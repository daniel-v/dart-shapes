// Generated by dart2js (mirrors), the Dart to JavaScript compiler version: 1.23.0.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
//
// dartDeferredLibraryLoader(uri, successCallback, errorCallback):
//    if this function is defined, it will be called when a deferred library
//    is loaded. It should load and eval the javascript of `uri`, and call
//    successCallback. If it fails to do so, it should call errorCallback with
//    an error.
//
// defaultPackagesBase:
//    Override the location where `package:` uris are resolved from. By default
//    they are resolved under "packages/" from the current window location.
(function() {
  // /* ::norenaming:: */
  var supportsDirectProtoAccess = function() {
    var cls = function() {
    };
    cls.prototype = {p: {}};
    var object = new cls();
    if (!(object.__proto__ && object.__proto__.p === cls.prototype.p))
      return false;
    try {
      if (typeof navigator != "undefined" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Chrome/") >= 0)
        return true;
      if (typeof version == "function" && version.length == 0) {
        var v = version();
        if (/^\d+\.\d+\.\d+\.\d+$/.test(v))
          return true;
      }
    } catch (_) {
    }
    return false;
  }();
  function map(x) {
    x = Object.create(null);
    x.x = 0;
    delete x.x;
    return x;
  }
  // The global objects start as so-called "slow objects". For V8, this
  // means that it won't try to make map transitions as we add properties
  // to these objects. Later on, we attempt to turn these objects into
  // fast objects by calling "convertToFastObject" (see
  // [emitConvertToFastObjectFunction]).
  var A = map();
  var B = map();
  var C = map();
  var D = map();
  var E = map();
  var F = map();
  var G = map();
  var H = map();
  var J = map();
  var K = map();
  var L = map();
  var M = map();
  var N = map();
  var O = map();
  var P = map();
  var Q = map();
  var R = map();
  var S = map();
  var T = map();
  var U = map();
  var V = map();
  var W = map();
  var X = map();
  var Y = map();
  var Z = map();
  function Isolate() {
  }
  init();
  init.mangledNames = {get$$arguments: "arguments", get$$function: "function", get$__serviceId: "__serviceId", get$_accumulated: "_accumulated", get$_active: "_active", get$_activeConnections: "_activeConnections", get$_addStreamState: "_addStreamState", get$_allowInvalid: "_allowInvalid", get$_allowMalformed: "_allowMalformed", get$_alphabet: "_alphabet", get$_async$_controller: "_async$_controller", get$_async$_equals: "_async$_equals", get$_async$_iterator: "_async$_iterator", get$_async$_map: "_async$_map", get$_async$_next: "_async$_next", get$_async$_previous: "_async$_previous", get$_async$_sink: "_async$_sink", get$_async$_target: "_async$_target", get$_asyncDispatched: "_asyncDispatched", get$_atEnd: "_atEnd", get$_authenticate: "_authenticate", get$_authenticateProxy: "_authenticateProxy", get$_badCertificateCallback: "_badCertificateCallback", get$_bigEndianWords: "_bigEndianWords", get$_bodyController: "_bodyController", get$_bodyPaused: "_bodyPaused", get$_buffer: "_buffer", get$_bufferIndex: "_bufferIndex", get$_bufferOutput: "_bufferOutput", get$_bufferSize: "_bufferSize", get$_bufferedData: "_bufferedData", get$_bufferedDataIndex: "_bufferedDataIndex", get$_bytesWritten: "_bytesWritten", get$_callback: "_callback", get$_cancelFuture: "_cancelFuture", get$_carry: "_carry", get$_chunkSizeInWords: "_chunkSizeInWords", get$_chunked: "_chunked", get$_chunkedSink: "_chunkedSink", get$_chunkedTransferEncoding: "_chunkedTransferEncoding", get$_chunks: "_chunks", get$_classMirrors: "_classMirrors", get$_className: "_className", get$_closeCode: "_closeCode", get$_closeCompleter: "_closeCompleter", get$_closeFuture: "_closeFuture", get$_closeReason: "_closeReason", get$_closeServer: "_closeServer", get$_closeTimer: "_closeTimer", get$_closed: "_closed", get$_closedRead: "_closedRead", get$_closedWrite: "_closedWrite", get$_closing: "_closing", get$_closingForcefully: "_closingForcefully", get$_codec: "_codec", get$_collection$_count: "_collection$_count", get$_collection$_current: "_collection$_current", get$_collection$_first: "_collection$_first", get$_collection$_iterator: "_collection$_iterator", get$_collection$_length: "_collection$_length", get$_collection$_map: "_collection$_map", get$_collection$_next: "_collection$_next", get$_collection$_previous: "_collection$_previous", get$_collection$_source: "_collection$_source", get$_collection$_state: "_collection$_state", get$_commands: "_commands", get$_comparator: "_comparator", get$_completer: "_completer", get$_compressed: "_compressed", get$_compression: "_compression", get$_connectPending: "_connectPending", get$_connecting: "_connecting", get$_connectionTargets: "_connectionTargets", get$_connectionUpgrade: "_connectionUpgrade", get$_consume: "_consume", get$_consumer: "_consumer", get$_contentLength: "_contentLength", get$_contents: "_contents", get$_context: "_context", get$_controllerCompleter: "_controllerCompleter", get$_controllerInstance: "_controllerInstance", get$_convert$_eventSink: "_convert$_eventSink", get$_convert$_first: "_convert$_first", get$_convert$_name: "_convert$_name", get$_convert$_sink: "_convert$_sink", get$_convert$_state: "_convert$_state", get$_convert$_value: "_convert$_value", get$_cookies: "_cookies", get$_core$_arguments: "_core$_arguments", get$_core$_data: "_core$_data", get$_core$_position: "_core$_position", get$_core$_receiver: "_core$_receiver", get$_core$_start: "_core$_start", get$_core$_value: "_core$_value", get$_count: "_count", get$_createPeriodicTimer: "_createPeriodicTimer", get$_createTimer: "_createTimer", get$_credentials: "_credentials", get$_currentChunk: "_currentChunk", get$_currentCodePoint: "_currentCodePoint", get$_currentMessageType: "_currentMessageType", get$_currentNode: "_currentNode", get$_currentUri: "_currentUri", get$_data: "_data", get$_dataCompleter: "_dataCompleter", get$_deadline: "_deadline", get$_deadlineTimer: "_deadlineTimer", get$_decoder: "_decoder", get$_defaultPortForScheme: "_defaultPortForScheme", get$_deflate: "_deflate", get$_deflateHelper: "_deflateHelper", get$_delegateCache: "_delegateCache", get$_delegationTarget: "_delegationTarget", get$_description: "_description", get$_destroyed: "_destroyed", get$_developer$_arguments: "_developer$_arguments", get$_developer$_start: "_developer$_start", get$_digestCalled: "_digestCalled", get$_digestSizeInWords: "_digestSizeInWords", get$_dispose: "_dispose", get$_doneCompleter: "_doneCompleter", get$_doneFuture: "_doneFuture", get$_dummy: "_dummy", get$_duration: "_duration", get$_elementCount: "_elementCount", get$_empty: "_empty", get$_emptySymbol: "_emptySymbol", get$_encoder: "_encoder", get$_encoding: "_encoding", get$_encodingMutable: "_encodingMutable", get$_encodingSet: "_encodingSet", get$_end: "_end", get$_errorCallback: "_errorCallback", get$_errorCode: "_errorCode", get$_errorDetail: "_errorDetail", get$_escape: "_escape", get$_eventSink: "_eventSink", get$_eventState: "_eventState", get$_existingArgumentNames: "_existingArgumentNames", get$_expand: "_expand", get$_expectedUnits: "_expectedUnits", get$_extraUnits: "_extraUnits", get$_fd: "_fd", get$_file: "_file", get$_fileService: "_fileService", get$_filename: "_filename", get$_filter: "_filter", get$_filterActive: "_filterActive", get$_filterPending: "_filterPending", get$_filterStatus: "_filterStatus", get$_fin: "_fin", get$_findProxy: "_findProxy", get$_firstSubscription: "_firstSubscription", get$_followRedirects: "_followRedirects", get$_fork: "_fork", get$_fragment: "_fragment", get$_fragmentStart: "_fragmentStart", get$_generator: "_generator", get$_gzip: "_gzip", get$_gzipAdd: "_gzipAdd", get$_gzipBuffer: "_gzipBuffer", get$_gzipBufferLength: "_gzipBufferLength", get$_gzipSink: "_gzipSink", get$_h: "_h", get$_handleData: "_handleData", get$_handleDone: "_handleDone", get$_handleError: "_handleError", get$_handleUncaughtError: "_handleUncaughtError", get$_handshakeComplete: "_handshakeComplete", get$_hasValue: "_hasValue", get$_hashCodeCache: "_hashCodeCache", get$_head: "_head", get$_headerField: "_headerField", get$_headerValue: "_headerValue", get$_headers: "_headers", get$_height: "_height", get$_host: "_host", get$_hostStart: "_hostStart", get$_httpClient: "_httpClient", get$_httpClientConnection: "_httpClientConnection", get$_httpConnection: "_httpConnection", get$_httpParser: "_httpParser", get$_httpRequest: "_httpRequest", get$_httpServer: "_httpServer", get$_httpVersion: "_httpVersion", get$_httpVersionIndex: "_httpVersionIndex", get$_idle: "_idle", get$_idleConnections: "_idleConnections", get$_idleMark: "_idleMark", get$_idleTimeout: "_idleTimeout", get$_idleTimer: "_idleTimer", get$_incoming: "_incoming", get$_indent: "_indent", get$_indentLevel: "_indentLevel", get$_injectData: "_injectData", get$_io$_buffer: "_io$_buffer", get$_io$_controller: "_io$_controller", get$_io$_end: "_io$_end", get$_io$_hasError: "_io$_hasError", get$_io$_head: "_io$_head", get$_io$_host: "_io$_host", get$_io$_index: "_io$_index", get$_io$_isClosed: "_io$_isClosed", get$_io$_length: "_io$_length", get$_io$_map: "_io$_map", get$_io$_method: "_io$_method", get$_io$_name: "_io$_name", get$_io$_next: "_io$_next", get$_io$_parameters: "_io$_parameters", get$_io$_pending: "_io$_pending", get$_io$_port: "_io$_port", get$_io$_position: "_io$_position", get$_io$_state: "_io$_state", get$_io$_stream: "_io$_stream", get$_io$_subscription: "_io$_subscription", get$_io$_tail: "_io$_tail", get$_io$_target: "_io$_target", get$_io$_type: "_io$_type", get$_io$_uri: "_io$_uri", get$_io$_value: "_io$_value", get$_isBound: "_isBound", get$_isCanceled: "_isCanceled", get$_isDone: "_isDone", get$_isFirstCharacter: "_isFirstCharacter", get$_isNew: "_isNew", get$_isPaused: "_isPaused", get$_isTranslatable: "_isTranslatable", get$_isUsed: "_isUsed", get$_issuedPause: "_issuedPause", get$_jsWeakMapOrKey: "_jsWeakMapOrKey", get$_keys: "_keys", get$_lastSeen: "_lastSeen", get$_lastSubscription: "_lastSubscription", get$_len: "_len", get$_lengthInBytes: "_lengthInBytes", get$_lineParser: "_lineParser", get$_list: "_list", get$_littleEndian: "_littleEndian", get$_masked: "_masked", get$_maskingBytes: "_maskingBytes", get$_maxRedirects: "_maxRedirects", get$_memberName: "_memberName", get$_messageType: "_messageType", get$_mode: "_mode", get$_modificationCount: "_modificationCount", get$_mutable: "_mutable", get$_namedArguments: "_namedArguments", get$_nextEntry: "_nextEntry", get$_nextLink: "_nextLink", get$_nextListener: "_nextListener", get$_nextPosition: "_nextPosition", get$_nextResponseCompleter: "_nextResponseCompleter", get$_noFoldingHeaders: "_noFoldingHeaders", get$_noMessageBody: "_noMessageBody", get$_nonBlocking: "_nonBlocking", get$_onCancelHandler: "_onCancelHandler", get$_onData: "_onData", get$_onDone: "_onDone", get$_onError: "_onError", get$_onListenHandler: "_onListenHandler", get$_opcode: "_opcode", get$_openFuture: "_openFuture", get$_openedFile: "_openedFile", get$_ops: "_ops", get$_options: "_options", get$_optionsAndSeparators: "_optionsAndSeparators", get$_outCloseCode: "_outCloseCode", get$_outCloseReason: "_outCloseReason", get$_outgoing: "_outgoing", get$_parsed: "_parsed", get$_parser: "_parser", get$_parserCalled: "_parserCalled", get$_path: "_path", get$_pathSegments: "_pathSegments", get$_pathStart: "_pathStart", get$_pauseCount: "_pauseCount", get$_paused: "_paused", get$_payload: "_payload", get$_pending: "_pending", get$_pendingChunkedFooter: "_pendingChunkedFooter", get$_pendingData: "_pendingData", get$_pendingReadEvent: "_pendingReadEvent", get$_persistentConnection: "_persistentConnection", get$_pingInterval: "_pingInterval", get$_pingTimer: "_pingTimer", get$_port: "_port", get$_portStart: "_portStart", get$_position: "_position", get$_prev: "_prev", get$_previousLink: "_previousLink", get$_primaryType: "_primaryType", get$_print: "_print", get$_protocolSelector: "_protocolSelector", get$_proxy: "_proxy", get$_proxyCredentials: "_proxyCredentials", get$_proxyTunnel: "_proxyTunnel", get$_query: "_query", get$_queryParameterLists: "_queryParameterLists", get$_queryParameters: "_queryParameters", get$_queryStart: "_queryStart", get$_queue: "_queue", get$_r: "_r", get$_readEventsEnabled: "_readEventsEnabled", get$_readInProgress: "_readInProgress", get$_readyState: "_readyState", get$_reasonPhrase: "_reasonPhrase", get$_registerBinaryCallback: "_registerBinaryCallback", get$_registerCallback: "_registerCallback", get$_registerUnaryCallback: "_registerUnaryCallback", get$_remainingContent: "_remainingContent", get$_remainingLenBytes: "_remainingLenBytes", get$_remainingMaskingKeyBytes: "_remainingMaskingKeyBytes", get$_remainingPayloadBytes: "_remainingPayloadBytes", get$_requestParser: "_requestParser", get$_requestedUri: "_requestedUri", get$_resourceInfo: "_resourceInfo", get$_response: "_response", get$_responseCompleter: "_responseCompleter", get$_responseRedirects: "_responseRedirects", get$_result: "_result", get$_resultOrListeners: "_resultOrListeners", get$_reviver: "_reviver", get$_root: "_root", get$_run: "_run", get$_runBinary: "_runBinary", get$_runUnary: "_runUnary", get$_s: "_s", get$_scheduleMicrotask: "_scheduleMicrotask", get$_scheduled: "_scheduled", get$_scheme: "_scheme", get$_schemeCache: "_schemeCache", get$_schemeEnd: "_schemeEnd", get$_second: "_second", get$_secureFilter: "_secureFilter", get$_seen: "_seen", get$_selectedProtocol: "_selectedProtocol", get$_sentinel: "_sentinel", get$_separatorIndices: "_separatorIndices", get$_serverSide: "_serverSide", get$_serverSocket: "_serverSocket", get$_session: "_session", get$_sessionManager: "_sessionManager", get$_sessionManagerInstance: "_sessionManagerInstance", get$_sessionTimeout: "_sessionTimeout", get$_sessions: "_sessions", get$_sharedState: "_sharedState", get$_signalNumber: "_signalNumber", get$_sink: "_sink", get$_sinkMapper: "_sinkMapper", get$_skipLeadingLF: "_skipLeadingLF", get$_socket: "_socket", get$_socketClosedRead: "_socketClosedRead", get$_socketClosedWrite: "_socketClosedWrite", get$_socketError: "_socketError", get$_socketSubscription: "_socketSubscription", get$_source: "_source", get$_splayCount: "_splayCount", get$_stack: "_stack", get$_stackTrace: "_stackTrace", get$_startCpu: "_startCpu", get$_state: "_state", get$_stateData: "_stateData", get$_status: "_status", get$_statusCode: "_statusCode", get$_statusCodeLength: "_statusCodeLength", get$_stop: "_stop", get$_stream: "_stream", get$_streamFuture: "_streamFuture", get$_stringSink: "_stringSink", get$_subType: "_subType", get$_subscription: "_subscription", get$_subsetMask: "_subsetMask", get$_symbolCache: "_symbolCache", get$_table: "_table", get$_tail: "_tail", get$_taskId: "_taskId", get$_test: "_test", get$_text: "_text", get$_timeoutCallback: "_timeoutCallback", get$_timer: "_timer", get$_toEncodable: "_toEncodable", get$_transferLength: "_transferLength", get$_transform: "_transform", get$_transformer: "_transformer", get$_transformerSink: "_transformerSink", get$_tree: "_tree", get$_unmaskingIndex: "_unmaskingIndex", get$_unmodifiableParameters: "_unmodifiableParameters", get$_unsubscribed: "_unsubscribed", get$_uri: "_uri", get$_uriCache: "_uriCache", get$_uri_or_reason_phrase: "_uri_or_reason_phrase", get$_urlSafe: "_urlSafe", get$_userInfo: "_userInfo", get$_userOnData: "_userOnData", get$_utf8Sink: "_utf8Sink", get$_validKey: "_validKey", get$_value: "_value", get$_varData: "_varData", get$_visitedFirst: "_visitedFirst", get$_w: "_w", get$_width: "_width", get$_workList: "_workList", get$_writeClosed: "_writeClosed", get$_writeEventsEnabled: "_writeEventsEnabled", get$_x: "_x", get$_y: "_y", get$_zone: "_zone", get$abbreviation: "abbreviation", get$accessed: "accessed", get$active: "active", get$addChunk: "addChunk", get$addStreamFuture: "addStreamFuture", get$addSubscription: "addSubscription", get$address: "address", get$algorithm: "algorithm", get$allowTrailingOptions: "allowTrailingOptions", get$allowed: "allowed", get$allowedHelp: "allowedHelp", get$args: "args", get$autoCompress: "autoCompress", get$autoUncompress: "autoUncompress", get$broadcastEnabled: "broadcastEnabled", get$buffer: "buffer", get$bufferCache: "bufferCache", get$bufferOutput: "bufferOutput", get$bufferSize: "bufferSize", get$bufferedData: "bufferedData", get$builder: "builder", get$bytes: "bytes", get$callback: "callback", get$canceled: "canceled", get$category: "category", get$cause: "cause", get$changed: "changed", get$chunked: "chunked", get$chunkedTransferEncoding: "chunkedTransferEncoding", get$clientMaxWindowBits: "clientMaxWindowBits", get$clientNoContextTakeover: "clientNoContextTakeover", get$closeCode: "closeCode", get$closeCompleter: "closeCompleter", get$closeReason: "closeReason", get$closed: "closed", get$closing: "closing", get$columnWidths: "columnWidths", get$command: "command", get$commandName: "commandName", get$commands: "commands", get$connection: "connection", get$contentChanged: "contentChanged", get$contentLength: "contentLength", get$contentType: "contentType", get$context: "context", get$controlPort: "controlPort", get$controller: "controller", get$cookies: "cookies", get$createPeriodicTimer: "createPeriodicTimer", get$createTimer: "createTimer", get$credentials: "credentials", get$currentColumn: "currentColumn", get$data: "data", get$date: "date", get$deadline: "deadline", get$decoder: "decoder", get$defaultResponseHeaders: "defaultResponseHeaders", get$defaultValue: "defaultValue", get$description: "description", get$destination: "destination", get$dictionary: "dictionary", get$domain: "domain", get$duration: "duration", get$element: "element", get$elementSizeInBytes: "elementSizeInBytes", get$enabled: "enabled", get$encoder: "encoder", get$encoding: "encoding", get$end: "end", get$error: "error", get$errorCallback: "errorCallback", get$errorCode: "errorCode", get$escapeApos: "escapeApos", get$escapeLtGt: "escapeLtGt", get$escapeQuot: "escapeQuot", get$escapeSlash: "escapeSlash", get$executable: "executable", get$exitCode: "exitCode", get$expires: "expires", get$file: "file", get$firstPendingEvent: "firstPendingEvent", get$followLinks: "followLinks", get$followRedirects: "followRedirects", get$fork: "fork", get$fullBodyRead: "fullBodyRead", get$future: "future", get$grammar: "grammar", get$gzip: "gzip", get$ha1: "ha1", get$handleUncaughtError: "handleUncaughtError", get$hasSubscriber: "hasSubscriber", get$headerValue: "headerValue", get$headers: "headers", get$headersWritten: "headersWritten", get$height: "height", get$help: "help", get$hide: "hide", get$host: "host", get$httpOnly: "httpOnly", get$id: "id", get$idle: "idle", get$idleTimeout: "idleTimeout", get$ifModifiedSince: "ifModifiedSince", get$ignoreBody: "ignoreBody", get$indent: "indent", get$index: "index", get$indexable: "indexable", get$input: "input", get$invalidValue: "invalidValue", get$isConstructor: "isConstructor", get$isDirect: "isDirect", get$isDirectory: "isDirectory", get$isDocComment: "isDocComment", get$isFinal: "isFinal", get$isGetter: "isGetter", get$isNamed: "isNamed", get$isOperator: "isOperator", get$isOptional: "isOptional", get$isSecure: "isSecure", get$isSetter: "isSetter", get$isStatic: "isStatic", get$isTopLevel: "isTopLevel", get$isUtc: "isUtc", get$is_server: "is_server", get$isolate: "isolate", get$key: "key", get$label: "label", get$lastPendingEvent: "lastPendingEvent", get$lastRead: "lastRead", get$lastWrite: "lastWrite", get$left: "left", get$length: "length", get$lengthInBytes: "lengthInBytes", get$level: "level", get$libraryName: "libraryName", get$localPort: "localPort", get$location: "location", get$majorVersion: "majorVersion", get$max: "max", get$maxAge: "maxAge", get$maxConnectionsPerHost: "maxConnectionsPerHost", get$maxRedirects: "maxRedirects", get$maxWindowBits: "maxWindowBits", get$memLevel: "memLevel", get$message: "message", get$metaTargets: "metaTargets", get$method: "method", get$min: "min", get$minorVersion: "minorVersion", get$mixin: "mixin", get$mode: "mode", get$modified: "modified", get$modifiedObject: "modifiedObject", get$multicastHops: "multicastHops", get$multicastInterface: "multicastInterface", get$multicastLoopback: "multicastLoopback", get$name: "name", get$negatable: "negatable", get$newlinesNeeded: "newlinesNeeded", get$next: "next", get$nextRunning: "nextRunning", get$nonce: "nonce", get$nonceCount: "nonceCount", get$numHelpLines: "numHelpLines", get$offset: "offset", get$offsetInBytes: "offsetInBytes", get$onBadCertificate: "onBadCertificate", get$onCancel: "onCancel", get$onListen: "onListen", get$onPause: "onPause", get$onResume: "onResume", get$options: "options", get$optionsAndSeparators: "optionsAndSeparators", get$osError: "osError", get$outbound: "outbound", get$override: "override", get$owner: "owner", get$parent: "parent", get$password: "password", get$path: "path", get$pattern: "pattern", get$pauseCapability: "pauseCapability", get$payload: "payload", get$persistentConnection: "persistentConnection", get$pid: "pid", get$pingInterval: "pingInterval", get$port: "port", get$print: "print", get$process: "process", get$progress: "progress", get$protocol: "protocol", get$protocolVersion: "protocolVersion", get$proxies: "proxies", get$proxy: "proxy", get$qop: "qop", get$raw: "raw", get$readCount: "readCount", get$readEmpty: "readEmpty", get$readEncryptedNoLongerFull: "readEncryptedNoLongerFull", get$readEventsEnabled: "readEventsEnabled", get$readPlaintextNoLongerEmpty: "readPlaintextNoLongerEmpty", get$realm: "realm", get$reasonPhrase: "reasonPhrase", get$recursive: "recursive", get$redirects: "redirects", get$referent: "referent", get$reflectee: "reflectee", get$registerBinaryCallback: "registerBinaryCallback", get$registerCallback: "registerCallback", get$registerUnaryCallback: "registerUnaryCallback", get$remoteAddress: "remoteAddress", get$remotePort: "remotePort", get$requestClientCertificate: "requestClientCertificate", get$requireClientCertificate: "requireClientCertificate", get$response: "response", get$rest: "rest", get$result: "result", get$results: "results", get$right: "right", get$run: "run", get$runBinary: "runBinary", get$runUnary: "runUnary", get$scheduleMicrotask: "scheduleMicrotask", get$scheme: "scheme", get$secure: "secure", get$serverHeader: "serverHeader", get$serverMaxWindowBits: "serverMaxWindowBits", get$serverNoContextTakeover: "serverNoContextTakeover", get$serverSide: "serverSide", get$serverUri: "serverUri", get$shapes: "shapes", get$simpleName: "simpleName", get$size: "size", get$socket: "socket", get$source: "source", get$splitCommas: "splitCommas", get$stackTrace: "stackTrace", get$start: "start", get$startedAt: "startedAt", get$state: "state", get$statusCode: "statusCode", get$stderr: "stderr", get$stdout: "stdout", get$strategy: "strategy", get$string: "string", get$subscription: "subscription", get$superclass: "superclass", get$supportedProtocols: "supportedProtocols", get$symbols: "symbols", get$targets: "targets", get$terminateCapability: "terminateCapability", get$text: "text", get$top: "top", get$total: "total", get$totalRead: "totalRead", get$totalWritten: "totalWritten", get$trimmedText: "trimmedText", get$type: "type", get$unsupportedObject: "unsupportedObject", get$upgraded: "upgraded", get$uri: "uri", get$used: "used", get$userAgent: "userAgent", get$username: "username", get$value: "value", get$valueHelp: "valueHelp", get$varData: "varData", get$variableName: "variableName", get$w: "w", get$webSocket: "webSocket", get$width: "width", get$windowBits: "windowBits", get$writeCount: "writeCount", get$writeEmpty: "writeEmpty", get$writeEncryptedNoLongerEmpty: "writeEncryptedNoLongerEmpty", get$writeEventsEnabled: "writeEventsEnabled", get$writePlaintextNoLongerFull: "writePlaintextNoLongerFull", get$x: "x", get$y: "y", get$z: "z", get$zone: "zone"};
  init.mangledGlobalNames = {APPEND: "APPEND", ASCII: "ASCII", BASE64: "BASE64", BASE64URL: "BASE64URL", CompressionOptions_DEFAULT: "DEFAULT", CompressionOptions_OFF: "OFF", ContentType_BINARY: "BINARY", ContentType_HTML: "HTML", ContentType_JSON: "JSON", ContentType_TEXT: "TEXT", DateTime_APRIL: "APRIL", DateTime_AUGUST: "AUGUST", DateTime_DAYS_PER_WEEK: "DAYS_PER_WEEK", DateTime_DECEMBER: "DECEMBER", DateTime_FEBRUARY: "FEBRUARY", DateTime_FRIDAY: "FRIDAY", DateTime_JANUARY: "JANUARY", DateTime_JULY: "JULY", DateTime_JUNE: "JUNE", DateTime_MARCH: "MARCH", DateTime_MAY: "MAY", DateTime_MONDAY: "MONDAY", DateTime_MONTHS_PER_YEAR: "MONTHS_PER_YEAR", DateTime_NOVEMBER: "NOVEMBER", DateTime_OCTOBER: "OCTOBER", DateTime_SATURDAY: "SATURDAY", DateTime_SEPTEMBER: "SEPTEMBER", DateTime_SUNDAY: "SUNDAY", DateTime_THURSDAY: "THURSDAY", DateTime_TUESDAY: "TUESDAY", DateTime_WEDNESDAY: "WEDNESDAY", DateTime__MAX_MILLISECONDS_SINCE_EPOCH: "_MAX_MILLISECONDS_SINCE_EPOCH", Duration_HOURS_PER_DAY: "HOURS_PER_DAY", Duration_MICROSECONDS_PER_DAY: "MICROSECONDS_PER_DAY", Duration_MICROSECONDS_PER_HOUR: "MICROSECONDS_PER_HOUR", Duration_MICROSECONDS_PER_MILLISECOND: "MICROSECONDS_PER_MILLISECOND", Duration_MICROSECONDS_PER_MINUTE: "MICROSECONDS_PER_MINUTE", Duration_MICROSECONDS_PER_SECOND: "MICROSECONDS_PER_SECOND", Duration_MILLISECONDS_PER_DAY: "MILLISECONDS_PER_DAY", Duration_MILLISECONDS_PER_HOUR: "MILLISECONDS_PER_HOUR", Duration_MILLISECONDS_PER_MINUTE: "MILLISECONDS_PER_MINUTE", Duration_MILLISECONDS_PER_SECOND: "MILLISECONDS_PER_SECOND", Duration_MINUTES_PER_DAY: "MINUTES_PER_DAY", Duration_MINUTES_PER_HOUR: "MINUTES_PER_HOUR", Duration_SECONDS_PER_DAY: "SECONDS_PER_DAY", Duration_SECONDS_PER_HOUR: "SECONDS_PER_HOUR", Duration_SECONDS_PER_MINUTE: "SECONDS_PER_MINUTE", Duration_ZERO: "ZERO", E: "E", Encoding__nameToEncoding: "_nameToEncoding", Endianness_BIG_ENDIAN: "BIG_ENDIAN", Endianness_HOST_ENDIAN: "HOST_ENDIAN", Endianness_LITTLE_ENDIAN: "LITTLE_ENDIAN", Expando__EXPANDO_PROPERTY_NAME: "_EXPANDO_PROPERTY_NAME", Expando__keyCount: "_keyCount", FileLock_BLOCKING_EXCLUSIVE: "BLOCKING_EXCLUSIVE", FileLock_BLOCKING_SHARED: "BLOCKING_SHARED", FileLock_EXCLUSIVE: "EXCLUSIVE", FileLock_SHARED: "SHARED", FileLock_values: "values", FileMode_APPEND: "APPEND", FileMode_READ: "READ", FileMode_WRITE: "WRITE", FileMode_WRITE_ONLY: "WRITE_ONLY", FileMode_WRITE_ONLY_APPEND: "WRITE_ONLY_APPEND", FileStat__ACCESSED_TIME: "_ACCESSED_TIME", FileStat__CHANGED_TIME: "_CHANGED_TIME", FileStat__MODE: "_MODE", FileStat__MODIFIED_TIME: "_MODIFIED_TIME", FileStat__SIZE: "_SIZE", FileStat__TYPE: "_TYPE", FileStat__notFound: "_notFound", FileSystemEntityType_DIRECTORY: "DIRECTORY", FileSystemEntityType_FILE: "FILE", FileSystemEntityType_LINK: "LINK", FileSystemEntityType_NOT_FOUND: "NOT_FOUND", FileSystemEntityType__typeList: "_typeList", FileSystemEntity__absoluteWindowsPathPattern: "_absoluteWindowsPathPattern", FileSystemEntity__parentRegExp: "_parentRegExp", FileSystemEvent_ALL: "ALL", FileSystemEvent_CREATE: "CREATE", FileSystemEvent_DELETE: "DELETE", FileSystemEvent_MODIFY: "MODIFY", FileSystemEvent_MOVE: "MOVE", FileSystemEvent__DELETE_SELF: "_DELETE_SELF", FileSystemEvent__IS_DIR: "_IS_DIR", FileSystemEvent__MODIFY_ATTRIBUTES: "_MODIFY_ATTRIBUTES", Float32List_BYTES_PER_ELEMENT: "BYTES_PER_ELEMENT", Float32x4List_BYTES_PER_ELEMENT: "BYTES_PER_ELEMENT", Float32x4_WWWW: "WWWW", Float32x4_WWWX: "WWWX", Float32x4_WWWY: "WWWY", Float32x4_WWWZ: "WWWZ", Float32x4_WWXW: "WWXW", Float32x4_WWXX: "WWXX", Float32x4_WWXY: "WWXY", Float32x4_WWXZ: "WWXZ", Float32x4_WWYW: "WWYW", Float32x4_WWYX: "WWYX", Float32x4_WWYY: "WWYY", Float32x4_WWYZ: "WWYZ", Float32x4_WWZW: "WWZW", Float32x4_WWZX: "WWZX", Float32x4_WWZY: "WWZY", Float32x4_WWZZ: "WWZZ", Float32x4_WXWW: "WXWW", Float32x4_WXWX: "WXWX", Float32x4_WXWY: "WXWY", Float32x4_WXWZ: "WXWZ", Float32x4_WXXW: "WXXW", Float32x4_WXXX: "WXXX", Float32x4_WXXY: "WXXY", Float32x4_WXXZ: "WXXZ", Float32x4_WXYW: "WXYW", Float32x4_WXYX: "WXYX", Float32x4_WXYY: "WXYY", Float32x4_WXYZ: "WXYZ", Float32x4_WXZW: "WXZW", Float32x4_WXZX: "WXZX", Float32x4_WXZY: "WXZY", Float32x4_WXZZ: "WXZZ", Float32x4_WYWW: "WYWW", Float32x4_WYWX: "WYWX", Float32x4_WYWY: "WYWY", Float32x4_WYWZ: "WYWZ", Float32x4_WYXW: "WYXW", Float32x4_WYXX: "WYXX", Float32x4_WYXY: "WYXY", Float32x4_WYXZ: "WYXZ", Float32x4_WYYW: "WYYW", Float32x4_WYYX: "WYYX", Float32x4_WYYY: "WYYY", Float32x4_WYYZ: "WYYZ", Float32x4_WYZW: "WYZW", Float32x4_WYZX: "WYZX", Float32x4_WYZY: "WYZY", Float32x4_WYZZ: "WYZZ", Float32x4_WZWW: "WZWW", Float32x4_WZWX: "WZWX", Float32x4_WZWY: "WZWY", Float32x4_WZWZ: "WZWZ", Float32x4_WZXW: "WZXW", Float32x4_WZXX: "WZXX", Float32x4_WZXY: "WZXY", Float32x4_WZXZ: "WZXZ", Float32x4_WZYW: "WZYW", Float32x4_WZYX: "WZYX", Float32x4_WZYY: "WZYY", Float32x4_WZYZ: "WZYZ", Float32x4_WZZW: "WZZW", Float32x4_WZZX: "WZZX", Float32x4_WZZY: "WZZY", Float32x4_WZZZ: "WZZZ", Float32x4_XWWW: "XWWW", Float32x4_XWWX: "XWWX", Float32x4_XWWY: "XWWY", Float32x4_XWWZ: "XWWZ", Float32x4_XWXW: "XWXW", Float32x4_XWXX: "XWXX", Float32x4_XWXY: "XWXY", Float32x4_XWXZ: "XWXZ", Float32x4_XWYW: "XWYW", Float32x4_XWYX: "XWYX", Float32x4_XWYY: "XWYY", Float32x4_XWYZ: "XWYZ", Float32x4_XWZW: "XWZW", Float32x4_XWZX: "XWZX", Float32x4_XWZY: "XWZY", Float32x4_XWZZ: "XWZZ", Float32x4_XXWW: "XXWW", Float32x4_XXWX: "XXWX", Float32x4_XXWY: "XXWY", Float32x4_XXWZ: "XXWZ", Float32x4_XXXW: "XXXW", Float32x4_XXXX: "XXXX", Float32x4_XXXY: "XXXY", Float32x4_XXXZ: "XXXZ", Float32x4_XXYW: "XXYW", Float32x4_XXYX: "XXYX", Float32x4_XXYY: "XXYY", Float32x4_XXYZ: "XXYZ", Float32x4_XXZW: "XXZW", Float32x4_XXZX: "XXZX", Float32x4_XXZY: "XXZY", Float32x4_XXZZ: "XXZZ", Float32x4_XYWW: "XYWW", Float32x4_XYWX: "XYWX", Float32x4_XYWY: "XYWY", Float32x4_XYWZ: "XYWZ", Float32x4_XYXW: "XYXW", Float32x4_XYXX: "XYXX", Float32x4_XYXY: "XYXY", Float32x4_XYXZ: "XYXZ", Float32x4_XYYW: "XYYW", Float32x4_XYYX: "XYYX", Float32x4_XYYY: "XYYY", Float32x4_XYYZ: "XYYZ", Float32x4_XYZW: "XYZW", Float32x4_XYZX: "XYZX", Float32x4_XYZY: "XYZY", Float32x4_XYZZ: "XYZZ", Float32x4_XZWW: "XZWW", Float32x4_XZWX: "XZWX", Float32x4_XZWY: "XZWY", Float32x4_XZWZ: "XZWZ", Float32x4_XZXW: "XZXW", Float32x4_XZXX: "XZXX", Float32x4_XZXY: "XZXY", Float32x4_XZXZ: "XZXZ", Float32x4_XZYW: "XZYW", Float32x4_XZYX: "XZYX", Float32x4_XZYY: "XZYY", Float32x4_XZYZ: "XZYZ", Float32x4_XZZW: "XZZW", Float32x4_XZZX: "XZZX", Float32x4_XZZY: "XZZY", Float32x4_XZZZ: "XZZZ", Float32x4_YWWW: "YWWW", Float32x4_YWWX: "YWWX", Float32x4_YWWY: "YWWY", Float32x4_YWWZ: "YWWZ", Float32x4_YWXW: "YWXW", Float32x4_YWXX: "YWXX", Float32x4_YWXY: "YWXY", Float32x4_YWXZ: "YWXZ", Float32x4_YWYW: "YWYW", Float32x4_YWYX: "YWYX", Float32x4_YWYY: "YWYY", Float32x4_YWYZ: "YWYZ", Float32x4_YWZW: "YWZW", Float32x4_YWZX: "YWZX", Float32x4_YWZY: "YWZY", Float32x4_YWZZ: "YWZZ", Float32x4_YXWW: "YXWW", Float32x4_YXWX: "YXWX", Float32x4_YXWY: "YXWY", Float32x4_YXWZ: "YXWZ", Float32x4_YXXW: "YXXW", Float32x4_YXXX: "YXXX", Float32x4_YXXY: "YXXY", Float32x4_YXXZ: "YXXZ", Float32x4_YXYW: "YXYW", Float32x4_YXYX: "YXYX", Float32x4_YXYY: "YXYY", Float32x4_YXYZ: "YXYZ", Float32x4_YXZW: "YXZW", Float32x4_YXZX: "YXZX", Float32x4_YXZY: "YXZY", Float32x4_YXZZ: "YXZZ", Float32x4_YYWW: "YYWW", Float32x4_YYWX: "YYWX", Float32x4_YYWY: "YYWY", Float32x4_YYWZ: "YYWZ", Float32x4_YYXW: "YYXW", Float32x4_YYXX: "YYXX", Float32x4_YYXY: "YYXY", Float32x4_YYXZ: "YYXZ", Float32x4_YYYW: "YYYW", Float32x4_YYYX: "YYYX", Float32x4_YYYY: "YYYY", Float32x4_YYYZ: "YYYZ", Float32x4_YYZW: "YYZW", Float32x4_YYZX: "YYZX", Float32x4_YYZY: "YYZY", Float32x4_YYZZ: "YYZZ", Float32x4_YZWW: "YZWW", Float32x4_YZWX: "YZWX", Float32x4_YZWY: "YZWY", Float32x4_YZWZ: "YZWZ", Float32x4_YZXW: "YZXW", Float32x4_YZXX: "YZXX", Float32x4_YZXY: "YZXY", Float32x4_YZXZ: "YZXZ", Float32x4_YZYW: "YZYW", Float32x4_YZYX: "YZYX", Float32x4_YZYY: "YZYY", Float32x4_YZYZ: "YZYZ", Float32x4_YZZW: "YZZW", Float32x4_YZZX: "YZZX", Float32x4_YZZY: "YZZY", Float32x4_YZZZ: "YZZZ", Float32x4_ZWWW: "ZWWW", Float32x4_ZWWX: "ZWWX", Float32x4_ZWWY: "ZWWY", Float32x4_ZWWZ: "ZWWZ", Float32x4_ZWXW: "ZWXW", Float32x4_ZWXX: "ZWXX", Float32x4_ZWXY: "ZWXY", Float32x4_ZWXZ: "ZWXZ", Float32x4_ZWYW: "ZWYW", Float32x4_ZWYX: "ZWYX", Float32x4_ZWYY: "ZWYY", Float32x4_ZWYZ: "ZWYZ", Float32x4_ZWZW: "ZWZW", Float32x4_ZWZX: "ZWZX", Float32x4_ZWZY: "ZWZY", Float32x4_ZWZZ: "ZWZZ", Float32x4_ZXWW: "ZXWW", Float32x4_ZXWX: "ZXWX", Float32x4_ZXWY: "ZXWY", Float32x4_ZXWZ: "ZXWZ", Float32x4_ZXXW: "ZXXW", Float32x4_ZXXX: "ZXXX", Float32x4_ZXXY: "ZXXY", Float32x4_ZXXZ: "ZXXZ", Float32x4_ZXYW: "ZXYW", Float32x4_ZXYX: "ZXYX", Float32x4_ZXYY: "ZXYY", Float32x4_ZXYZ: "ZXYZ", Float32x4_ZXZW: "ZXZW", Float32x4_ZXZX: "ZXZX", Float32x4_ZXZY: "ZXZY", Float32x4_ZXZZ: "ZXZZ", Float32x4_ZYWW: "ZYWW", Float32x4_ZYWX: "ZYWX", Float32x4_ZYWY: "ZYWY", Float32x4_ZYWZ: "ZYWZ", Float32x4_ZYXW: "ZYXW", Float32x4_ZYXX: "ZYXX", Float32x4_ZYXY: "ZYXY", Float32x4_ZYXZ: "ZYXZ", Float32x4_ZYYW: "ZYYW", Float32x4_ZYYX: "ZYYX", Float32x4_ZYYY: "ZYYY", Float32x4_ZYYZ: "ZYYZ", Float32x4_ZYZW: "ZYZW", Float32x4_ZYZX: "ZYZX", Float32x4_ZYZY: "ZYZY", Float32x4_ZYZZ: "ZYZZ", Float32x4_ZZWW: "ZZWW", Float32x4_ZZWX: "ZZWX", Float32x4_ZZWY: "ZZWY", Float32x4_ZZWZ: "ZZWZ", Float32x4_ZZXW: "ZZXW", Float32x4_ZZXX: "ZZXX", Float32x4_ZZXY: "ZZXY", Float32x4_ZZXZ: "ZZXZ", Float32x4_ZZYW: "ZZYW", Float32x4_ZZYX: "ZZYX", Float32x4_ZZYY: "ZZYY", Float32x4_ZZYZ: "ZZYZ", Float32x4_ZZZW: "ZZZW", Float32x4_ZZZX: "ZZZX", Float32x4_ZZZY: "ZZZY", Float32x4_ZZZZ: "ZZZZ", Float64List_BYTES_PER_ELEMENT: "BYTES_PER_ELEMENT", Float64x2List_BYTES_PER_ELEMENT: "BYTES_PER_ELEMENT", Future__nullFuture: "_nullFuture", GZIP: "GZIP", HTML_ESCAPE: "HTML_ESCAPE", HasNextIterator__HAS_NEXT_AND_NEXT_IN_CURRENT: "_HAS_NEXT_AND_NEXT_IN_CURRENT", HasNextIterator__NOT_MOVED_YET: "_NOT_MOVED_YET", HasNextIterator__NO_NEXT: "_NO_NEXT", HtmlEscapeMode_ATTRIBUTE: "ATTRIBUTE", HtmlEscapeMode_ELEMENT: "ELEMENT", HtmlEscapeMode_SQ_ATTRIBUTE: "SQ_ATTRIBUTE", HtmlEscapeMode_UNKNOWN: "UNKNOWN", HttpClient_DEFAULT_HTTPS_PORT: "DEFAULT_HTTPS_PORT", HttpClient_DEFAULT_HTTP_PORT: "DEFAULT_HTTP_PORT", HttpHeaders_ACCEPT: "ACCEPT", HttpHeaders_ACCEPT_CHARSET: "ACCEPT_CHARSET", HttpHeaders_ACCEPT_ENCODING: "ACCEPT_ENCODING", HttpHeaders_ACCEPT_LANGUAGE: "ACCEPT_LANGUAGE", HttpHeaders_ACCEPT_RANGES: "ACCEPT_RANGES", HttpHeaders_AGE: "AGE", HttpHeaders_ALLOW: "ALLOW", HttpHeaders_AUTHORIZATION: "AUTHORIZATION", HttpHeaders_CACHE_CONTROL: "CACHE_CONTROL", HttpHeaders_CONNECTION: "CONNECTION", HttpHeaders_CONTENT_ENCODING: "CONTENT_ENCODING", HttpHeaders_CONTENT_LANGUAGE: "CONTENT_LANGUAGE", HttpHeaders_CONTENT_LENGTH: "CONTENT_LENGTH", HttpHeaders_CONTENT_LOCATION: "CONTENT_LOCATION", HttpHeaders_CONTENT_MD5: "CONTENT_MD5", HttpHeaders_CONTENT_RANGE: "CONTENT_RANGE", HttpHeaders_CONTENT_TYPE: "CONTENT_TYPE", HttpHeaders_COOKIE: "COOKIE", HttpHeaders_DATE: "DATE", HttpHeaders_ENTITY_HEADERS: "ENTITY_HEADERS", HttpHeaders_ETAG: "ETAG", HttpHeaders_EXPECT: "EXPECT", HttpHeaders_EXPIRES: "EXPIRES", HttpHeaders_FROM: "FROM", HttpHeaders_GENERAL_HEADERS: "GENERAL_HEADERS", HttpHeaders_HOST: "HOST", HttpHeaders_IF_MATCH: "IF_MATCH", HttpHeaders_IF_MODIFIED_SINCE: "IF_MODIFIED_SINCE", HttpHeaders_IF_NONE_MATCH: "IF_NONE_MATCH", HttpHeaders_IF_RANGE: "IF_RANGE", HttpHeaders_IF_UNMODIFIED_SINCE: "IF_UNMODIFIED_SINCE", HttpHeaders_LAST_MODIFIED: "LAST_MODIFIED", HttpHeaders_LOCATION: "LOCATION", HttpHeaders_MAX_FORWARDS: "MAX_FORWARDS", HttpHeaders_PRAGMA: "PRAGMA", HttpHeaders_PROXY_AUTHENTICATE: "PROXY_AUTHENTICATE", HttpHeaders_PROXY_AUTHORIZATION: "PROXY_AUTHORIZATION", HttpHeaders_RANGE: "RANGE", HttpHeaders_REFERER: "REFERER", HttpHeaders_REQUEST_HEADERS: "REQUEST_HEADERS", HttpHeaders_RESPONSE_HEADERS: "RESPONSE_HEADERS", HttpHeaders_RETRY_AFTER: "RETRY_AFTER", HttpHeaders_SERVER: "SERVER", HttpHeaders_SET_COOKIE: "SET_COOKIE", HttpHeaders_TE: "TE", HttpHeaders_TRAILER: "TRAILER", HttpHeaders_TRANSFER_ENCODING: "TRANSFER_ENCODING", HttpHeaders_UPGRADE: "UPGRADE", HttpHeaders_USER_AGENT: "USER_AGENT", HttpHeaders_VARY: "VARY", HttpHeaders_VIA: "VIA", HttpHeaders_WARNING: "WARNING", HttpHeaders_WWW_AUTHENTICATE: "WWW_AUTHENTICATE", HttpStatus_ACCEPTED: "ACCEPTED", HttpStatus_BAD_GATEWAY: "BAD_GATEWAY", HttpStatus_BAD_REQUEST: "BAD_REQUEST", HttpStatus_CONFLICT: "CONFLICT", HttpStatus_CONTINUE: "CONTINUE", HttpStatus_CREATED: "CREATED", HttpStatus_EXPECTATION_FAILED: "EXPECTATION_FAILED", HttpStatus_FORBIDDEN: "FORBIDDEN", HttpStatus_FOUND: "FOUND", HttpStatus_GATEWAY_TIMEOUT: "GATEWAY_TIMEOUT", HttpStatus_GONE: "GONE", HttpStatus_HTTP_VERSION_NOT_SUPPORTED: "HTTP_VERSION_NOT_SUPPORTED", HttpStatus_INTERNAL_SERVER_ERROR: "INTERNAL_SERVER_ERROR", HttpStatus_LENGTH_REQUIRED: "LENGTH_REQUIRED", HttpStatus_METHOD_NOT_ALLOWED: "METHOD_NOT_ALLOWED", HttpStatus_MOVED_PERMANENTLY: "MOVED_PERMANENTLY", HttpStatus_MOVED_TEMPORARILY: "MOVED_TEMPORARILY", HttpStatus_MULTIPLE_CHOICES: "MULTIPLE_CHOICES", HttpStatus_NETWORK_CONNECT_TIMEOUT_ERROR: "NETWORK_CONNECT_TIMEOUT_ERROR", HttpStatus_NON_AUTHORITATIVE_INFORMATION: "NON_AUTHORITATIVE_INFORMATION", HttpStatus_NOT_ACCEPTABLE: "NOT_ACCEPTABLE", HttpStatus_NOT_FOUND: "NOT_FOUND", HttpStatus_NOT_IMPLEMENTED: "NOT_IMPLEMENTED", HttpStatus_NOT_MODIFIED: "NOT_MODIFIED", HttpStatus_NO_CONTENT: "NO_CONTENT", HttpStatus_OK: "OK", HttpStatus_PARTIAL_CONTENT: "PARTIAL_CONTENT", HttpStatus_PAYMENT_REQUIRED: "PAYMENT_REQUIRED", HttpStatus_PRECONDITION_FAILED: "PRECONDITION_FAILED", HttpStatus_PROXY_AUTHENTICATION_REQUIRED: "PROXY_AUTHENTICATION_REQUIRED", HttpStatus_REQUESTED_RANGE_NOT_SATISFIABLE: "REQUESTED_RANGE_NOT_SATISFIABLE", HttpStatus_REQUEST_ENTITY_TOO_LARGE: "REQUEST_ENTITY_TOO_LARGE", HttpStatus_REQUEST_TIMEOUT: "REQUEST_TIMEOUT", HttpStatus_REQUEST_URI_TOO_LONG: "REQUEST_URI_TOO_LONG", HttpStatus_RESET_CONTENT: "RESET_CONTENT", HttpStatus_SEE_OTHER: "SEE_OTHER", HttpStatus_SERVICE_UNAVAILABLE: "SERVICE_UNAVAILABLE", HttpStatus_SWITCHING_PROTOCOLS: "SWITCHING_PROTOCOLS", HttpStatus_TEMPORARY_REDIRECT: "TEMPORARY_REDIRECT", HttpStatus_UNAUTHORIZED: "UNAUTHORIZED", HttpStatus_UNSUPPORTED_MEDIA_TYPE: "UNSUPPORTED_MEDIA_TYPE", HttpStatus_USE_PROXY: "USE_PROXY", Int16List_BYTES_PER_ELEMENT: "BYTES_PER_ELEMENT", Int32List_BYTES_PER_ELEMENT: "BYTES_PER_ELEMENT", Int32x4List_BYTES_PER_ELEMENT: "BYTES_PER_ELEMENT", Int32x4_WWWW: "WWWW", Int32x4_WWWX: "WWWX", Int32x4_WWWY: "WWWY", Int32x4_WWWZ: "WWWZ", Int32x4_WWXW: "WWXW", Int32x4_WWXX: "WWXX", Int32x4_WWXY: "WWXY", Int32x4_WWXZ: "WWXZ", Int32x4_WWYW: "WWYW", Int32x4_WWYX: "WWYX", Int32x4_WWYY: "WWYY", Int32x4_WWYZ: "WWYZ", Int32x4_WWZW: "WWZW", Int32x4_WWZX: "WWZX", Int32x4_WWZY: "WWZY", Int32x4_WWZZ: "WWZZ", Int32x4_WXWW: "WXWW", Int32x4_WXWX: "WXWX", Int32x4_WXWY: "WXWY", Int32x4_WXWZ: "WXWZ", Int32x4_WXXW: "WXXW", Int32x4_WXXX: "WXXX", Int32x4_WXXY: "WXXY", Int32x4_WXXZ: "WXXZ", Int32x4_WXYW: "WXYW", Int32x4_WXYX: "WXYX", Int32x4_WXYY: "WXYY", Int32x4_WXYZ: "WXYZ", Int32x4_WXZW: "WXZW", Int32x4_WXZX: "WXZX", Int32x4_WXZY: "WXZY", Int32x4_WXZZ: "WXZZ", Int32x4_WYWW: "WYWW", Int32x4_WYWX: "WYWX", Int32x4_WYWY: "WYWY", Int32x4_WYWZ: "WYWZ", Int32x4_WYXW: "WYXW", Int32x4_WYXX: "WYXX", Int32x4_WYXY: "WYXY", Int32x4_WYXZ: "WYXZ", Int32x4_WYYW: "WYYW", Int32x4_WYYX: "WYYX", Int32x4_WYYY: "WYYY", Int32x4_WYYZ: "WYYZ", Int32x4_WYZW: "WYZW", Int32x4_WYZX: "WYZX", Int32x4_WYZY: "WYZY", Int32x4_WYZZ: "WYZZ", Int32x4_WZWW: "WZWW", Int32x4_WZWX: "WZWX", Int32x4_WZWY: "WZWY", Int32x4_WZWZ: "WZWZ", Int32x4_WZXW: "WZXW", Int32x4_WZXX: "WZXX", Int32x4_WZXY: "WZXY", Int32x4_WZXZ: "WZXZ", Int32x4_WZYW: "WZYW", Int32x4_WZYX: "WZYX", Int32x4_WZYY: "WZYY", Int32x4_WZYZ: "WZYZ", Int32x4_WZZW: "WZZW", Int32x4_WZZX: "WZZX", Int32x4_WZZY: "WZZY", Int32x4_WZZZ: "WZZZ", Int32x4_XWWW: "XWWW", Int32x4_XWWX: "XWWX", Int32x4_XWWY: "XWWY", Int32x4_XWWZ: "XWWZ", Int32x4_XWXW: "XWXW", Int32x4_XWXX: "XWXX", Int32x4_XWXY: "XWXY", Int32x4_XWXZ: "XWXZ", Int32x4_XWYW: "XWYW", Int32x4_XWYX: "XWYX", Int32x4_XWYY: "XWYY", Int32x4_XWYZ: "XWYZ", Int32x4_XWZW: "XWZW", Int32x4_XWZX: "XWZX", Int32x4_XWZY: "XWZY", Int32x4_XWZZ: "XWZZ", Int32x4_XXWW: "XXWW", Int32x4_XXWX: "XXWX", Int32x4_XXWY: "XXWY", Int32x4_XXWZ: "XXWZ", Int32x4_XXXW: "XXXW", Int32x4_XXXX: "XXXX", Int32x4_XXXY: "XXXY", Int32x4_XXXZ: "XXXZ", Int32x4_XXYW: "XXYW", Int32x4_XXYX: "XXYX", Int32x4_XXYY: "XXYY", Int32x4_XXYZ: "XXYZ", Int32x4_XXZW: "XXZW", Int32x4_XXZX: "XXZX", Int32x4_XXZY: "XXZY", Int32x4_XXZZ: "XXZZ", Int32x4_XYWW: "XYWW", Int32x4_XYWX: "XYWX", Int32x4_XYWY: "XYWY", Int32x4_XYWZ: "XYWZ", Int32x4_XYXW: "XYXW", Int32x4_XYXX: "XYXX", Int32x4_XYXY: "XYXY", Int32x4_XYXZ: "XYXZ", Int32x4_XYYW: "XYYW", Int32x4_XYYX: "XYYX", Int32x4_XYYY: "XYYY", Int32x4_XYYZ: "XYYZ", Int32x4_XYZW: "XYZW", Int32x4_XYZX: "XYZX", Int32x4_XYZY: "XYZY", Int32x4_XYZZ: "XYZZ", Int32x4_XZWW: "XZWW", Int32x4_XZWX: "XZWX", Int32x4_XZWY: "XZWY", Int32x4_XZWZ: "XZWZ", Int32x4_XZXW: "XZXW", Int32x4_XZXX: "XZXX", Int32x4_XZXY: "XZXY", Int32x4_XZXZ: "XZXZ", Int32x4_XZYW: "XZYW", Int32x4_XZYX: "XZYX", Int32x4_XZYY: "XZYY", Int32x4_XZYZ: "XZYZ", Int32x4_XZZW: "XZZW", Int32x4_XZZX: "XZZX", Int32x4_XZZY: "XZZY", Int32x4_XZZZ: "XZZZ", Int32x4_YWWW: "YWWW", Int32x4_YWWX: "YWWX", Int32x4_YWWY: "YWWY", Int32x4_YWWZ: "YWWZ", Int32x4_YWXW: "YWXW", Int32x4_YWXX: "YWXX", Int32x4_YWXY: "YWXY", Int32x4_YWXZ: "YWXZ", Int32x4_YWYW: "YWYW", Int32x4_YWYX: "YWYX", Int32x4_YWYY: "YWYY", Int32x4_YWYZ: "YWYZ", Int32x4_YWZW: "YWZW", Int32x4_YWZX: "YWZX", Int32x4_YWZY: "YWZY", Int32x4_YWZZ: "YWZZ", Int32x4_YXWW: "YXWW", Int32x4_YXWX: "YXWX", Int32x4_YXWY: "YXWY", Int32x4_YXWZ: "YXWZ", Int32x4_YXXW: "YXXW", Int32x4_YXXX: "YXXX", Int32x4_YXXY: "YXXY", Int32x4_YXXZ: "YXXZ", Int32x4_YXYW: "YXYW", Int32x4_YXYX: "YXYX", Int32x4_YXYY: "YXYY", Int32x4_YXYZ: "YXYZ", Int32x4_YXZW: "YXZW", Int32x4_YXZX: "YXZX", Int32x4_YXZY: "YXZY", Int32x4_YXZZ: "YXZZ", Int32x4_YYWW: "YYWW", Int32x4_YYWX: "YYWX", Int32x4_YYWY: "YYWY", Int32x4_YYWZ: "YYWZ", Int32x4_YYXW: "YYXW", Int32x4_YYXX: "YYXX", Int32x4_YYXY: "YYXY", Int32x4_YYXZ: "YYXZ", Int32x4_YYYW: "YYYW", Int32x4_YYYX: "YYYX", Int32x4_YYYY: "YYYY", Int32x4_YYYZ: "YYYZ", Int32x4_YYZW: "YYZW", Int32x4_YYZX: "YYZX", Int32x4_YYZY: "YYZY", Int32x4_YYZZ: "YYZZ", Int32x4_YZWW: "YZWW", Int32x4_YZWX: "YZWX", Int32x4_YZWY: "YZWY", Int32x4_YZWZ: "YZWZ", Int32x4_YZXW: "YZXW", Int32x4_YZXX: "YZXX", Int32x4_YZXY: "YZXY", Int32x4_YZXZ: "YZXZ", Int32x4_YZYW: "YZYW", Int32x4_YZYX: "YZYX", Int32x4_YZYY: "YZYY", Int32x4_YZYZ: "YZYZ", Int32x4_YZZW: "YZZW", Int32x4_YZZX: "YZZX", Int32x4_YZZY: "YZZY", Int32x4_YZZZ: "YZZZ", Int32x4_ZWWW: "ZWWW", Int32x4_ZWWX: "ZWWX", Int32x4_ZWWY: "ZWWY", Int32x4_ZWWZ: "ZWWZ", Int32x4_ZWXW: "ZWXW", Int32x4_ZWXX: "ZWXX", Int32x4_ZWXY: "ZWXY", Int32x4_ZWXZ: "ZWXZ", Int32x4_ZWYW: "ZWYW", Int32x4_ZWYX: "ZWYX", Int32x4_ZWYY: "ZWYY", Int32x4_ZWYZ: "ZWYZ", Int32x4_ZWZW: "ZWZW", Int32x4_ZWZX: "ZWZX", Int32x4_ZWZY: "ZWZY", Int32x4_ZWZZ: "ZWZZ", Int32x4_ZXWW: "ZXWW", Int32x4_ZXWX: "ZXWX", Int32x4_ZXWY: "ZXWY", Int32x4_ZXWZ: "ZXWZ", Int32x4_ZXXW: "ZXXW", Int32x4_ZXXX: "ZXXX", Int32x4_ZXXY: "ZXXY", Int32x4_ZXXZ: "ZXXZ", Int32x4_ZXYW: "ZXYW", Int32x4_ZXYX: "ZXYX", Int32x4_ZXYY: "ZXYY", Int32x4_ZXYZ: "ZXYZ", Int32x4_ZXZW: "ZXZW", Int32x4_ZXZX: "ZXZX", Int32x4_ZXZY: "ZXZY", Int32x4_ZXZZ: "ZXZZ", Int32x4_ZYWW: "ZYWW", Int32x4_ZYWX: "ZYWX", Int32x4_ZYWY: "ZYWY", Int32x4_ZYWZ: "ZYWZ", Int32x4_ZYXW: "ZYXW", Int32x4_ZYXX: "ZYXX", Int32x4_ZYXY: "ZYXY", Int32x4_ZYXZ: "ZYXZ", Int32x4_ZYYW: "ZYYW", Int32x4_ZYYX: "ZYYX", Int32x4_ZYYY: "ZYYY", Int32x4_ZYYZ: "ZYYZ", Int32x4_ZYZW: "ZYZW", Int32x4_ZYZX: "ZYZX", Int32x4_ZYZY: "ZYZY", Int32x4_ZYZZ: "ZYZZ", Int32x4_ZZWW: "ZZWW", Int32x4_ZZWX: "ZZWX", Int32x4_ZZWY: "ZZWY", Int32x4_ZZWZ: "ZZWZ", Int32x4_ZZXW: "ZZXW", Int32x4_ZZXX: "ZZXX", Int32x4_ZZXY: "ZZXY", Int32x4_ZZXZ: "ZZXZ", Int32x4_ZZYW: "ZZYW", Int32x4_ZZYX: "ZZYX", Int32x4_ZZYY: "ZZYY", Int32x4_ZZYZ: "ZZYZ", Int32x4_ZZZW: "ZZZW", Int32x4_ZZZX: "ZZZX", Int32x4_ZZZY: "ZZZY", Int32x4_ZZZZ: "ZZZZ", Int64List_BYTES_PER_ELEMENT: "BYTES_PER_ELEMENT", Int8List_BYTES_PER_ELEMENT: "BYTES_PER_ELEMENT", InternetAddressType_ANY: "ANY", InternetAddressType_IP_V4: "IP_V4", InternetAddressType_IP_V6: "IP_V6", Isolate_BEFORE_NEXT_EVENT: "BEFORE_NEXT_EVENT", Isolate_IMMEDIATE: "IMMEDIATE", Isolate__currentIsolateCache: "_currentIsolateCache", Isolate__packageBase: "_packageBase", JSON: "JSON", JsonUtf8Encoder_DEFAULT_BUFFER_SIZE: "DEFAULT_BUFFER_SIZE", LATIN1: "LATIN1", LN10: "LN10", LN2: "LN2", LOG10E: "LOG10E", LOG2E: "LOG2E", ListQueue__INITIAL_CAPACITY: "_INITIAL_CAPACITY", Metrics__metrics: "_metrics", OSError_noErrorCode: "noErrorCode", OptionType_FLAG: "FLAG", OptionType_MULTIPLE: "MULTIPLE", OptionType_SINGLE: "SINGLE", Option__invalidChars: "_invalidChars", PI: "PI", Platform__localHostname: "_localHostname", Platform__numberOfProcessors: "_numberOfProcessors", Platform__operatingSystem: "_operatingSystem", Platform__pathSeparator: "_pathSeparator", Platform__version: "_version", Platform_isAndroid: "isAndroid", Platform_isFuchsia: "isFuchsia", Platform_isIOS: "isIOS", Platform_isLinux: "isLinux", Platform_isMacOS: "isMacOS", Platform_isWindows: "isWindows", ProcessSignal_SIGABRT: "SIGABRT", ProcessSignal_SIGALRM: "SIGALRM", ProcessSignal_SIGBUS: "SIGBUS", ProcessSignal_SIGCHLD: "SIGCHLD", ProcessSignal_SIGCONT: "SIGCONT", ProcessSignal_SIGFPE: "SIGFPE", ProcessSignal_SIGHUP: "SIGHUP", ProcessSignal_SIGILL: "SIGILL", ProcessSignal_SIGINT: "SIGINT", ProcessSignal_SIGKILL: "SIGKILL", ProcessSignal_SIGPIPE: "SIGPIPE", ProcessSignal_SIGPOLL: "SIGPOLL", ProcessSignal_SIGPROF: "SIGPROF", ProcessSignal_SIGQUIT: "SIGQUIT", ProcessSignal_SIGSEGV: "SIGSEGV", ProcessSignal_SIGSTOP: "SIGSTOP", ProcessSignal_SIGSYS: "SIGSYS", ProcessSignal_SIGTERM: "SIGTERM", ProcessSignal_SIGTRAP: "SIGTRAP", ProcessSignal_SIGTSTP: "SIGTSTP", ProcessSignal_SIGTTIN: "SIGTTIN", ProcessSignal_SIGTTOU: "SIGTTOU", ProcessSignal_SIGURG: "SIGURG", ProcessSignal_SIGUSR1: "SIGUSR1", ProcessSignal_SIGUSR2: "SIGUSR2", ProcessSignal_SIGVTALRM: "SIGVTALRM", ProcessSignal_SIGWINCH: "SIGWINCH", ProcessSignal_SIGXCPU: "SIGXCPU", ProcessSignal_SIGXFSZ: "SIGXFSZ", ProcessStartMode_DETACHED: "DETACHED", ProcessStartMode_DETACHED_WITH_STDIO: "DETACHED_WITH_STDIO", ProcessStartMode_NORMAL: "NORMAL", ProcessStartMode_values: "values", READ: "READ", Random__secureRandom: "_secureRandom", RawSocketEvent_CLOSED: "CLOSED", RawSocketEvent_READ: "READ", RawSocketEvent_READ_CLOSED: "READ_CLOSED", RawSocketEvent_WRITE: "WRITE", SQRT1_2: "SQRT1_2", SQRT2: "SQRT2", SYSTEM_ENCODING: "SYSTEM_ENCODING", ServiceExtensionResponse_extensionError: "extensionError", ServiceExtensionResponse_extensionErrorMax: "extensionErrorMax", ServiceExtensionResponse_extensionErrorMin: "extensionErrorMin", ServiceExtensionResponse_invalidParams: "invalidParams", ServiceExtensionResponse_kExtensionError: "kExtensionError", ServiceExtensionResponse_kExtensionErrorMax: "kExtensionErrorMax", ServiceExtensionResponse_kExtensionErrorMin: "kExtensionErrorMin", ServiceExtensionResponse_kInvalidParams: "kInvalidParams", SocketDirection_BOTH: "BOTH", SocketDirection_RECEIVE: "RECEIVE", SocketDirection_SEND: "SEND", SocketOption_TCP_NODELAY: "TCP_NODELAY", SocketOption__IP_BROADCAST: "_IP_BROADCAST", SocketOption__IP_MULTICAST_HOPS: "_IP_MULTICAST_HOPS", SocketOption__IP_MULTICAST_IF: "_IP_MULTICAST_IF", SocketOption__IP_MULTICAST_LOOP: "_IP_MULTICAST_LOOP", StdioType_FILE: "FILE", StdioType_OTHER: "OTHER", StdioType_PIPE: "PIPE", StdioType_TERMINAL: "TERMINAL", Stopwatch__frequency: "_frequency", Timeline__isolateId: "_developer$_isolateId", Timeline__isolateIdString: "_isolateIdString", Timeline__stack: "_stack", UNICODE_BOM_CHARACTER_RUNE: "UNICODE_BOM_CHARACTER_RUNE", UNICODE_REPLACEMENT_CHARACTER_RUNE: "UNICODE_REPLACEMENT_CHARACTER_RUNE", UTF8: "UTF8", Uint16List_BYTES_PER_ELEMENT: "BYTES_PER_ELEMENT", Uint32List_BYTES_PER_ELEMENT: "BYTES_PER_ELEMENT", Uint64List_BYTES_PER_ELEMENT: "BYTES_PER_ELEMENT", Uint8ClampedList_BYTES_PER_ELEMENT: "BYTES_PER_ELEMENT", Uint8List_BYTES_PER_ELEMENT: "BYTES_PER_ELEMENT", UriData__base64Table: "_base64Table", UriData__noScheme: "_noScheme", UriData__tokenCharTable: "_tokenCharTable", UriData__uricTable: "_uricTable", Usage_NUM_COLUMNS: "NUM_COLUMNS", UserTag_MAX_USER_TAGS: "MAX_USER_TAGS", WRITE: "WRITE", WRITE_ONLY: "WRITE_ONLY", WRITE_ONLY_APPEND: "WRITE_ONLY_APPEND", WebSocketStatus_ABNORMAL_CLOSURE: "ABNORMAL_CLOSURE", WebSocketStatus_GOING_AWAY: "GOING_AWAY", WebSocketStatus_INTERNAL_SERVER_ERROR: "INTERNAL_SERVER_ERROR", WebSocketStatus_INVALID_FRAME_PAYLOAD_DATA: "INVALID_FRAME_PAYLOAD_DATA", WebSocketStatus_MESSAGE_TOO_BIG: "MESSAGE_TOO_BIG", WebSocketStatus_MISSING_MANDATORY_EXTENSION: "MISSING_MANDATORY_EXTENSION", WebSocketStatus_NORMAL_CLOSURE: "NORMAL_CLOSURE", WebSocketStatus_NO_STATUS_RECEIVED: "NO_STATUS_RECEIVED", WebSocketStatus_POLICY_VIOLATION: "POLICY_VIOLATION", WebSocketStatus_PROTOCOL_ERROR: "PROTOCOL_ERROR", WebSocketStatus_RESERVED_1004: "RESERVED_1004", WebSocketStatus_RESERVED_1015: "RESERVED_1015", WebSocketStatus_UNSUPPORTED_DATA: "UNSUPPORTED_DATA", WebSocket_CLOSED: "CLOSED", WebSocket_CLOSING: "CLOSING", WebSocket_CONNECTING: "CONNECTING", WebSocket_OPEN: "OPEN", ZLIB: "ZLIB", ZLibOption_DEFAULT_LEVEL: "DEFAULT_LEVEL", ZLibOption_DEFAULT_MEM_LEVEL: "DEFAULT_MEM_LEVEL", ZLibOption_DEFAULT_WINDOW_BITS: "DEFAULT_WINDOW_BITS", ZLibOption_MAX_LEVEL: "MAX_LEVEL", ZLibOption_MAX_MEM_LEVEL: "MAX_MEM_LEVEL", ZLibOption_MAX_WINDOW_BITS: "MAX_WINDOW_BITS", ZLibOption_MIN_LEVEL: "MIN_LEVEL", ZLibOption_MIN_MEM_LEVEL: "MIN_MEM_LEVEL", ZLibOption_MIN_WINDOW_BITS: "MIN_WINDOW_BITS", ZLibOption_STRATEGY_DEFAULT: "STRATEGY_DEFAULT", ZLibOption_STRATEGY_FILTERED: "STRATEGY_FILTERED", ZLibOption_STRATEGY_FIXED: "STRATEGY_FIXED", ZLibOption_STRATEGY_HUFFMAN_ONLY: "STRATEGY_HUFFMAN_ONLY", ZLibOption_STRATEGY_RLE: "STRATEGY_RLE", Zone_ROOT: "ROOT", Zone__current: "_async$_current", _ABBR_OPT: "_ABBR_OPT", _AMPERSAND: "_AMPERSAND", _ASCII_MASK: "_ASCII_MASK", _AsyncDirectoryLister_LIST_DIRECTORY: "LIST_DIRECTORY", _AsyncDirectoryLister_LIST_DONE: "LIST_DONE", _AsyncDirectoryLister_LIST_ERROR: "LIST_ERROR", _AsyncDirectoryLister_LIST_FILE: "LIST_FILE", _AsyncDirectoryLister_LIST_LINK: "LIST_LINK", _AsyncDirectoryLister_RESPONSE_COMPLETE: "RESPONSE_COMPLETE", _AsyncDirectoryLister_RESPONSE_ERROR: "RESPONSE_ERROR", _AsyncDirectoryLister_RESPONSE_PATH: "RESPONSE_PATH", _AsyncDirectoryLister_RESPONSE_TYPE: "RESPONSE_TYPE", _AsyncRun__scheduleImmediateClosure: "_scheduleImmediateClosure", _AuthenticationScheme_BASIC: "BASIC", _AuthenticationScheme_DIGEST: "DIGEST", _AuthenticationScheme_UNKNOWN: "UNKNOWN", _BACKSLASH: "_BACKSLASH", _BITS_PER_BYTE: "_BITS_PER_BYTE", _BLOCK_SIZE: "_BLOCK_SIZE", _BYTES_PER_WORD: "_BYTES_PER_WORD", _Base64Decoder___: "__", _Base64Decoder__char_3: "_char_3", _Base64Decoder__char_d: "_char_d", _Base64Decoder__char_percent: "_char_percent", _Base64Decoder__countMask: "_countMask", _Base64Decoder__invalid: "_invalid", _Base64Decoder__inverseAlphabet: "_inverseAlphabet", _Base64Decoder__p: "_p", _Base64Decoder__padding: "_padding", _Base64Decoder__valueShift: "_valueShift", _Base64Encoder__base64Alphabet: "_base64Alphabet", _Base64Encoder__base64urlAlphabet: "_base64urlAlphabet", _Base64Encoder__countMask: "_countMask", _Base64Encoder__sixBitMask: "_sixBitMask", _Base64Encoder__valueShift: "_valueShift", _BroadcastStreamController__STATE_ADDSTREAM: "_STATE_ADDSTREAM", _BroadcastStreamController__STATE_CLOSED: "_STATE_CLOSED", _BroadcastStreamController__STATE_EVENT_ID: "_STATE_EVENT_ID", _BroadcastStreamController__STATE_FIRING: "_STATE_FIRING", _BroadcastStreamController__STATE_INITIAL: "_STATE_INITIAL", _BroadcastSubscription__STATE_EVENT_ID: "_STATE_EVENT_ID", _BroadcastSubscription__STATE_FIRING: "_STATE_FIRING", _BroadcastSubscription__STATE_REMOVE_AFTER_FIRING: "_STATE_REMOVE_AFTER_FIRING", _BufferingStreamSubscription__STATE_CANCELED: "_STATE_CANCELED", _BufferingStreamSubscription__STATE_CANCEL_ON_ERROR: "_STATE_CANCEL_ON_ERROR", _BufferingStreamSubscription__STATE_CLOSED: "_STATE_CLOSED", _BufferingStreamSubscription__STATE_HAS_PENDING: "_STATE_HAS_PENDING", _BufferingStreamSubscription__STATE_INPUT_PAUSED: "_STATE_INPUT_PAUSED", _BufferingStreamSubscription__STATE_IN_CALLBACK: "_STATE_IN_CALLBACK", _BufferingStreamSubscription__STATE_PAUSE_COUNT: "_STATE_PAUSE_COUNT", _BufferingStreamSubscription__STATE_WAIT_FOR_CANCEL: "_STATE_WAIT_FOR_CANCEL", _ByteCallbackSink__INITIAL_BUFFER_SIZE: "_INITIAL_BUFFER_SIZE", _COLON: "_COLON", _CR: "_CR", _CharCode_AMPERSAND: "AMPERSAND", _CharCode_COLON: "COLON", _CharCode_COMMA: "COMMA", _CharCode_CR: "CR", _CharCode_DASH: "DASH", _CharCode_EQUAL: "EQUAL", _CharCode_HT: "HT", _CharCode_LF: "LF", _CharCode_ONE: "ONE", _CharCode_SEMI_COLON: "SEMI_COLON", _CharCode_SLASH: "SLASH", _CharCode_SP: "SP", _CharCode_ZERO: "ZERO", _Const_F: "F", _Const_HTTP: "HTTP", _Const_HTTP10: "HTTP10", _Const_HTTP11: "HTTP11", _Const_HTTP1DOT: "HTTP1DOT", _Const_SEPARATOR_MAP: "SEPARATOR_MAP", _Const_T: "T", _CopyingBytesBuilder__INIT_SIZE: "_INIT_SIZE", _CopyingBytesBuilder__emptyList: "_emptyList", _CryptoUtils_CR: "CR", _CryptoUtils_LF: "LF", _CryptoUtils_LINE_LENGTH: "LINE_LENGTH", _CryptoUtils_PAD: "PAD", _CryptoUtils__decodeTable: "_decodeTable", _CryptoUtils__encodeTable: "_encodeTable", _CryptoUtils__encodeTableUrlSafe: "_encodeTableUrlSafe", _DART_SESSION_ID: "_DART_SESSION_ID", _DIRECTORY_CREATE: "_DIRECTORY_CREATE", _DIRECTORY_CREATE_TEMP: "_DIRECTORY_CREATE_TEMP", _DIRECTORY_DELETE: "_DIRECTORY_DELETE", _DIRECTORY_EXISTS: "_DIRECTORY_EXISTS", _DIRECTORY_LIST_NEXT: "_DIRECTORY_LIST_NEXT", _DIRECTORY_LIST_START: "_DIRECTORY_LIST_START", _DIRECTORY_LIST_STOP: "_DIRECTORY_LIST_STOP", _DIRECTORY_RENAME: "_DIRECTORY_RENAME", _DOT: "_DOT", _DistinctStream__SENTINEL: "_SENTINEL", _DoneStreamSubscription__DONE_SENT: "_DONE_SENT", _DoneStreamSubscription__PAUSED: "_PAUSED", _DoneStreamSubscription__SCHEDULED: "_SCHEDULED", _EQUALS: "_EQUALS", _ERROR_RESPONSE_ERROR_TYPE: "_ERROR_RESPONSE_ERROR_TYPE", _FILE_CLOSE: "_FILE_CLOSE", _FILE_CLOSED_RESPONSE: "_FILE_CLOSED_RESPONSE", _FILE_COPY: "_FILE_COPY", _FILE_CREATE: "_FILE_CREATE", _FILE_CREATE_LINK: "_FILE_CREATE_LINK", _FILE_DELETE: "_FILE_DELETE", _FILE_DELETE_LINK: "_FILE_DELETE_LINK", _FILE_EXISTS: "_FILE_EXISTS", _FILE_FLUSH: "_FILE_FLUSH", _FILE_IDENTICAL: "_FILE_IDENTICAL", _FILE_LAST_ACCESSED: "_FILE_LAST_ACCESSED", _FILE_LAST_MODIFIED: "_FILE_LAST_MODIFIED", _FILE_LENGTH: "_FILE_LENGTH", _FILE_LENGTH_FROM_PATH: "_FILE_LENGTH_FROM_PATH", _FILE_LINK_TARGET: "_FILE_LINK_TARGET", _FILE_LOCK: "_FILE_LOCK", _FILE_OPEN: "_FILE_OPEN", _FILE_POSITION: "_FILE_POSITION", _FILE_READ: "_FILE_READ", _FILE_READ_BYTE: "_FILE_READ_BYTE", _FILE_READ_INTO: "_FILE_READ_INTO", _FILE_RENAME: "_FILE_RENAME", _FILE_RENAME_LINK: "_FILE_RENAME_LINK", _FILE_RESOLVE_SYMBOLIC_LINKS: "_FILE_RESOLVE_SYMBOLIC_LINKS", _FILE_SET_LAST_ACCESSED: "_FILE_SET_LAST_ACCESSED", _FILE_SET_LAST_MODIFIED: "_FILE_SET_LAST_MODIFIED", _FILE_SET_POSITION: "_FILE_SET_POSITION", _FILE_STAT: "_FILE_STAT", _FILE_TRUNCATE: "_FILE_TRUNCATE", _FILE_TYPE: "_FILE_TYPE", _FILE_WRITE_BYTE: "_FILE_WRITE_BYTE", _FILE_WRITE_FROM: "_FILE_WRITE_FROM", _FOUR_BYTE_LIMIT: "_FOUR_BYTE_LIMIT", _FileResourceInfo_TYPE: "TYPE", _FileResourceInfo_openFiles: "openFiles", _FutureListener_MASK_ERROR: "MASK_ERROR", _FutureListener_MASK_TEST_ERROR: "MASK_TEST_ERROR", _FutureListener_MASK_VALUE: "MASK_VALUE", _FutureListener_MASK_WHENCOMPLETE: "MASK_WHENCOMPLETE", _FutureListener_STATE_CATCHERROR: "STATE_CATCHERROR", _FutureListener_STATE_CATCHERROR_TEST: "STATE_CATCHERROR_TEST", _FutureListener_STATE_CHAIN: "STATE_CHAIN", _FutureListener_STATE_THEN: "STATE_THEN", _FutureListener_STATE_THEN_ONERROR: "STATE_THEN_ONERROR", _FutureListener_STATE_WHENCOMPLETE: "STATE_WHENCOMPLETE", _Future__CHAINED: "_CHAINED", _Future__ERROR: "_ERROR", _Future__INCOMPLETE: "_INCOMPLETE", _Future__PENDING_COMPLETE: "_PENDING_COMPLETE", _Future__VALUE: "_VALUE", _HttpClient__platformEnvironmentCache: "_platformEnvironmentCache", _HttpConnection__ACTIVE: "_ACTIVE", _HttpConnection__CLOSING: "_CLOSING", _HttpConnection__DETACHED: "_DETACHED", _HttpConnection__IDLE: "_IDLE", _HttpConnection__connections: "_connections", _HttpOutgoing__chunk0Length: "_chunk0Length", _HttpOutgoing__footerAndChunk0Length: "_footerAndChunk0Length", _HttpServer__servers: "_servers", _HttpVersion_HTTP10: "HTTP10", _HttpVersion_HTTP11: "HTTP11", _HttpVersion_UNDETERMINED: "UNDETERMINED", _ILLEGAL_ARGUMENT_RESPONSE: "_ILLEGAL_ARGUMENT_RESPONSE", _IOResourceInfo__count: "_io$_count", _IOResourceInfo__startTime: "_startTime", _IOResourceInfo__sw: "_sw", _JsonStringifier_BACKSLASH: "BACKSLASH", _JsonStringifier_BACKSPACE: "BACKSPACE", _JsonStringifier_CARRIAGE_RETURN: "CARRIAGE_RETURN", _JsonStringifier_CHAR_0: "CHAR_0", _JsonStringifier_CHAR_b: "CHAR_b", _JsonStringifier_CHAR_f: "CHAR_f", _JsonStringifier_CHAR_n: "CHAR_n", _JsonStringifier_CHAR_r: "CHAR_r", _JsonStringifier_CHAR_t: "CHAR_t", _JsonStringifier_CHAR_u: "CHAR_u", _JsonStringifier_FORM_FEED: "FORM_FEED", _JsonStringifier_NEWLINE: "NEWLINE", _JsonStringifier_QUOTE: "QUOTE", _JsonStringifier_TAB: "TAB", _LATIN1_MASK: "_LATIN1_MASK", _LEAD_SURROGATE_MIN: "_LEAD_SURROGATE_MIN", _LEFT_BRACKET: "_LEFT_BRACKET", _LF: "_LF", _LONG_OPT: "_LONG_OPT", _LOWER_CASE_A: "_LOWER_CASE_A", _LOWER_CASE_F: "_LOWER_CASE_F", _LOWER_CASE_Z: "_LOWER_CASE_Z", _MASK_32: "_MASK_32", _MASK_8: "_MASK_8", _MD5__k: "_k", _MD5__r: "_io$_r", _MessageType_REQUEST: "REQUEST", _MessageType_RESPONSE: "RESPONSE", _MessageType_UNDETERMINED: "UNDETERMINED", _ONE_BYTE_LIMIT: "_ONE_BYTE_LIMIT", _OSERROR_RESPONSE: "_OSERROR_RESPONSE", _OSERROR_RESPONSE_ERROR_CODE: "_OSERROR_RESPONSE_ERROR_CODE", _OSERROR_RESPONSE_MESSAGE: "_OSERROR_RESPONSE_MESSAGE", _OUTGOING_BUFFER_SIZE: "_OUTGOING_BUFFER_SIZE", _PERCENT: "_PERCENT", _PLUS: "_PLUS", _PendingEvents__STATE_CANCELED: "_STATE_CANCELED", _PendingEvents__STATE_SCHEDULED: "_STATE_SCHEDULED", _PendingEvents__STATE_UNSCHEDULED: "_STATE_UNSCHEDULED", _Platform__environmentCache: "_environmentCache", _Platform_executable: "executable", _Platform_packageConfig: "packageConfig", _Platform_packageRoot: "packageRoot", _Platform_resolvedExecutable: "resolvedExecutable", _Platform_script: "script", _ProcessResourceInfo_TYPE: "TYPE", _ProcessResourceInfo_startedProcesses: "startedProcesses", _ProxyConfiguration_DIRECT_PREFIX: "DIRECT_PREFIX", _ProxyConfiguration_PROXY_PREFIX: "PROXY_PREFIX", _RIGHT_BRACKET: "_RIGHT_BRACKET", _ROOT_ZONE: "_ROOT_ZONE", _RandomAccessFile_LOCK_BLOCKING_EXCLUSIVE: "LOCK_BLOCKING_EXCLUSIVE", _RandomAccessFile_LOCK_BLOCKING_SHARED: "LOCK_BLOCKING_SHARED", _RandomAccessFile_LOCK_EXCLUSIVE: "LOCK_EXCLUSIVE", _RandomAccessFile_LOCK_SHARED: "LOCK_SHARED", _RandomAccessFile_LOCK_UNLOCK: "LOCK_UNLOCK", _RandomAccessFile__connectedResourceHandler: "_connectedResourceHandler", _RawSecureSocket_CLOSED: "CLOSED", _RawSecureSocket_CONNECTED: "CONNECTED", _RawSecureSocket_HANDSHAKE: "HANDSHAKE", _RawSecureSocket_NUM_BUFFERS: "NUM_BUFFERS", _RawSecureSocket_READ_ENCRYPTED: "READ_ENCRYPTED", _RawSecureSocket_READ_PLAINTEXT: "READ_PLAINTEXT", _RawSecureSocket_WRITE_ENCRYPTED: "WRITE_ENCRYPTED", _RawSecureSocket_WRITE_PLAINTEXT: "WRITE_PLAINTEXT", _RootZone__rootDelegate: "_rootDelegate", _RootZone__rootMap: "_rootMap", _SLASH: "_SLASH", _SOCKET_LIST_INTERFACES: "_SOCKET_LIST_INTERFACES", _SOCKET_LOOKUP: "_SOCKET_LOOKUP", _SOCKET_REVERSE_LOOKUP: "_SOCKET_REVERSE_LOOKUP", _SOLO_OPT: "_SOLO_OPT", _SPACE: "_SPACE", _SSL_PROCESS_FILTER: "_SSL_PROCESS_FILTER", _STDIO_HANDLE_TYPE_FILE: "_STDIO_HANDLE_TYPE_FILE", _STDIO_HANDLE_TYPE_OTHER: "_STDIO_HANDLE_TYPE_OTHER", _STDIO_HANDLE_TYPE_PIPE: "_STDIO_HANDLE_TYPE_PIPE", _STDIO_HANDLE_TYPE_SOCKET: "_STDIO_HANDLE_TYPE_SOCKET", _STDIO_HANDLE_TYPE_TERMINAL: "_STDIO_HANDLE_TYPE_TERMINAL", _SUCCESS_RESPONSE: "_SUCCESS_RESPONSE", _SURROGATE_MASK: "_SURROGATE_MASK", _SURROGATE_TAG_MASK: "_SURROGATE_TAG_MASK", _SURROGATE_VALUE_MASK: "_SURROGATE_VALUE_MASK", _SocketResourceInfo_TCP_STRING: "TCP_STRING", _SocketResourceInfo_TYPE: "TYPE", _SocketResourceInfo_UDP_STRING: "UDP_STRING", _SocketResourceInfo_openSockets: "openSockets", _State_BODY: "BODY", _State_CHUNKED_BODY_DONE_CR: "CHUNKED_BODY_DONE_CR", _State_CHUNKED_BODY_DONE_LF: "CHUNKED_BODY_DONE_LF", _State_CHUNK_SIZE: "CHUNK_SIZE", _State_CHUNK_SIZE_ENDING: "CHUNK_SIZE_ENDING", _State_CHUNK_SIZE_EXTENSION: "CHUNK_SIZE_EXTENSION", _State_CHUNK_SIZE_STARTING_CR: "CHUNK_SIZE_STARTING_CR", _State_CHUNK_SIZE_STARTING_LF: "CHUNK_SIZE_STARTING_LF", _State_CLOSED: "CLOSED", _State_FAILURE: "FAILURE", _State_FIRST_BODY_STATE: "FIRST_BODY_STATE", _State_HEADER_ENDING: "HEADER_ENDING", _State_HEADER_FIELD: "HEADER_FIELD", _State_HEADER_START: "HEADER_START", _State_HEADER_VALUE: "HEADER_VALUE", _State_HEADER_VALUE_FOLDING_OR_ENDING: "HEADER_VALUE_FOLDING_OR_ENDING", _State_HEADER_VALUE_FOLD_OR_END: "HEADER_VALUE_FOLD_OR_END", _State_HEADER_VALUE_START: "HEADER_VALUE_START", _State_METHOD_OR_RESPONSE_HTTP_VERSION: "METHOD_OR_RESPONSE_HTTP_VERSION", _State_REQUEST_LINE_ENDING: "REQUEST_LINE_ENDING", _State_REQUEST_LINE_HTTP_VERSION: "REQUEST_LINE_HTTP_VERSION", _State_REQUEST_LINE_METHOD: "REQUEST_LINE_METHOD", _State_REQUEST_LINE_URI: "REQUEST_LINE_URI", _State_RESPONSE_HTTP_VERSION: "RESPONSE_HTTP_VERSION", _State_RESPONSE_LINE_ENDING: "RESPONSE_LINE_ENDING", _State_RESPONSE_LINE_REASON_PHRASE: "RESPONSE_LINE_REASON_PHRASE", _State_RESPONSE_LINE_STATUS_CODE: "RESPONSE_LINE_STATUS_CODE", _State_START: "START", _State_UPGRADED: "UPGRADED", _StreamController__STATE_ADDSTREAM: "_STATE_ADDSTREAM", _StreamController__STATE_CANCELED: "_STATE_CANCELED", _StreamController__STATE_CLOSED: "_STATE_CLOSED", _StreamController__STATE_INITIAL: "_STATE_INITIAL", _StreamController__STATE_SUBSCRIBED: "_STATE_SUBSCRIBED", _StreamController__STATE_SUBSCRIPTION_MASK: "_STATE_SUBSCRIPTION_MASK", _StringConversionSinkAsStringSinkAdapter__MIN_STRING_SIZE: "_MIN_STRING_SIZE", _TAIL_SURROGATE_MIN: "_TAIL_SURROGATE_MIN", _THREE_BYTE_LIMIT: "_THREE_BYTE_LIMIT", _TWO_BYTE_LIMIT: "_TWO_BYTE_LIMIT", _UPPER_CASE_A: "_UPPER_CASE_A", _UPPER_CASE_Z: "_UPPER_CASE_Z", _Uri__encodeFullTable: "_encodeFullTable", _Uri__genDelimitersTable: "_genDelimitersTable", _Uri__needsNoEncoding: "_needsNoEncoding", _Uri__pathCharOrSlashTable: "_pathCharOrSlashTable", _Uri__pathCharTable: "_pathCharTable", _Uri__queryCharTable: "_queryCharTable", _Uri__regNameTable: "_regNameTable", _Uri__schemeLowerTable: "_schemeLowerTable", _Uri__schemeTable: "_schemeTable", _Uri__subDelimitersTable: "_subDelimitersTable", _Uri__unreserved2396Table: "_unreserved2396Table", _Uri__unreservedTable: "_unreservedTable", _Uri__userinfoTable: "_userinfoTable", _Utf8Decoder__LIMITS: "_LIMITS", _Utf8Encoder__DEFAULT_BYTE_BUFFER_SIZE: "_DEFAULT_BYTE_BUFFER_SIZE", _WebSocketImpl_DEFAULT_WINDOW_BITS: "DEFAULT_WINDOW_BITS", _WebSocketImpl_PER_MESSAGE_DEFLATE: "PER_MESSAGE_DEFLATE", _WebSocketImpl__httpClient: "_httpClient", _WebSocketImpl__webSockets: "_webSockets", _WebSocketMessageType_BINARY: "BINARY", _WebSocketMessageType_NONE: "NONE", _WebSocketMessageType_TEXT: "TEXT", _WebSocketOpcode_BINARY: "BINARY", _WebSocketOpcode_CLOSE: "CLOSE", _WebSocketOpcode_CONTINUATION: "CONTINUATION", _WebSocketOpcode_PING: "PING", _WebSocketOpcode_PONG: "PONG", _WebSocketOpcode_RESERVED_3: "RESERVED_3", _WebSocketOpcode_RESERVED_4: "RESERVED_4", _WebSocketOpcode_RESERVED_5: "RESERVED_5", _WebSocketOpcode_RESERVED_6: "RESERVED_6", _WebSocketOpcode_RESERVED_7: "RESERVED_7", _WebSocketOpcode_RESERVED_B: "RESERVED_B", _WebSocketOpcode_RESERVED_C: "RESERVED_C", _WebSocketOpcode_RESERVED_D: "RESERVED_D", _WebSocketOpcode_RESERVED_E: "RESERVED_E", _WebSocketOpcode_RESERVED_F: "RESERVED_F", _WebSocketOpcode_TEXT: "TEXT", _WebSocketProtocolTransformer_CLOSED: "CLOSED", _WebSocketProtocolTransformer_FAILURE: "FAILURE", _WebSocketProtocolTransformer_FIN: "FIN", _WebSocketProtocolTransformer_LEN_FIRST: "LEN_FIRST", _WebSocketProtocolTransformer_LEN_REST: "LEN_REST", _WebSocketProtocolTransformer_MASK: "MASK", _WebSocketProtocolTransformer_OPCODE: "OPCODE", _WebSocketProtocolTransformer_PAYLOAD: "PAYLOAD", _WebSocketProtocolTransformer_RSV1: "RSV1", _WebSocketProtocolTransformer_RSV2: "RSV2", _WebSocketProtocolTransformer_RSV3: "RSV3", _WebSocketProtocolTransformer_START: "START", _clientMaxWindowBits: "_clientMaxWindowBits", _clientNoContextTakeover: "_clientNoContextTakeover", _fastPathArguments: "_fastPathArguments", _fragmentStartIndex: "_fragmentStartIndex", _hexDigits: "_hexDigits", _hostStartIndex: "_hostStartIndex", _isInCallbackLoop: "_isInCallbackLoop", _isProduct: "_isProduct", _lastCallback: "_lastCallback", _lastPriorityCallback: "_lastPriorityCallback", _nextCallback: "_nextCallback", _nextServiceId: "_nextServiceId", _nonSimpleEndStates: "_nonSimpleEndStates", _notSimpleIndex: "_notSimpleIndex", _paddingChar: "_paddingChar", _pathStartIndex: "_pathStartIndex", _portStartIndex: "_portStartIndex", _queryStartIndex: "_queryStartIndex", _scannerTables: "_scannerTables", _schemeEndIndex: "_schemeEndIndex", _schemeStart: "_schemeStart", _serverMaxWindowBits: "_serverMaxWindowBits", _serverNoContextTakeover: "_serverNoContextTakeover", _stderr: "_stderr", _stdin: "_stdin", _stdout: "_stdout", _toStringVisiting: "_toStringVisiting", _uriStart: "_uriStart", _webSocketGUID: "_webSocketGUID", argResults: "argResults", deprecated: "deprecated", double_INFINITY: "INFINITY", double_MAX_FINITE: "MAX_FINITE", double_MIN_POSITIVE: "MIN_POSITIVE", double_NAN: "NAN", double_NEGATIVE_INFINITY: "NEGATIVE_INFINITY", override: "override", proxy: "proxy", shapeDef: "shapeDef"};
  // Constructors are generated at runtime.
  function setupProgram(programData, typesOffset) {
    "use strict";
    function generateAccessor(fieldDescriptor, accessors, cls) {
      var fieldInformation = fieldDescriptor.split("-");
      var field = fieldInformation[0];
      var len = field.length;
      var code = field.charCodeAt(len - 1);
      var reflectable;
      if (fieldInformation.length > 1)
        reflectable = true;
      else
        reflectable = false;
      code = code >= 60 && code <= 64 ? code - 59 : code >= 123 && code <= 126 ? code - 117 : code >= 37 && code <= 43 ? code - 27 : 0;
      if (code) {
        var getterCode = code & 3;
        var setterCode = code >> 2;
        var accessorName = field = field.substring(0, len - 1);
        var divider = field.indexOf(":");
        if (divider > 0) {
          accessorName = field.substring(0, divider);
          field = field.substring(divider + 1);
        }
        if (getterCode) {
          var args = getterCode & 2 ? "receiver" : "";
          var receiver = getterCode & 1 ? "this" : "receiver";
          var body = "return " + receiver + "." + field;
          var property = cls + ".prototype.get$" + accessorName + "=";
          var fn = "function(" + args + "){" + body + "}";
          if (reflectable)
            accessors.push(property + "$reflectable(" + fn + ");\n");
          else
            accessors.push(property + fn + ";\n");
        }
        if (setterCode) {
          var args = setterCode & 2 ? "receiver, value" : "value";
          var receiver = setterCode & 1 ? "this" : "receiver";
          var body = receiver + "." + field + " = value";
          var property = cls + ".prototype.set$" + accessorName + "=";
          var fn = "function(" + args + "){" + body + "}";
          if (reflectable)
            accessors.push(property + "$reflectable(" + fn + ");\n");
          else
            accessors.push(property + fn + ";\n");
        }
      }
      return field;
    }
    function defineClass(name, fields) {
      var accessors = [];
      var str = "function " + name + "(";
      var body = "";
      var fieldNames = "";
      for (var i = 0; i < fields.length; i++) {
        if (i != 0)
          str += ", ";
        var field = generateAccessor(fields[i], accessors, name);
        fieldNames += "'" + field + "',";
        var parameter = "p_" + field;
        str += parameter;
        body += "this." + field + " = " + parameter + ";\n";
      }
      if (supportsDirectProtoAccess)
        body += "this." + "$deferredAction" + "();";
      str += ") {\n" + body + "}\n";
      str += name + ".builtin$cls=\"" + name + "\";\n";
      str += "$desc=$collectedClasses." + name + "[1];\n";
      str += name + ".prototype = $desc;\n";
      if (typeof defineClass.name != "string")
        str += name + ".name=\"" + name + "\";\n";
      str += name + "." + "$__fields__" + "=[" + fieldNames + "];\n";
      str += accessors.join("");
      return str;
    }
    init.createNewIsolate = function() {
      return new Isolate();
    };
    init.classIdExtractor = function(o) {
      return o.constructor.name;
    };
    init.classFieldsExtractor = function(o) {
      var fieldNames = o.constructor.$__fields__;
      if (!fieldNames)
        return [];
      var result = [];
      result.length = fieldNames.length;
      for (var i = 0; i < fieldNames.length; i++)
        result[i] = o[fieldNames[i]];
      return result;
    };
    init.instanceFromClassId = function(name) {
      return new init.allClasses[name]();
    };
    init.initializeEmptyInstance = function(name, o, fields) {
      init.allClasses[name].apply(o, fields);
      return o;
    };
    var inheritFrom = supportsDirectProtoAccess ? function(constructor, superConstructor) {
      var prototype = constructor.prototype;
      prototype.__proto__ = superConstructor.prototype;
      prototype.constructor = constructor;
      prototype["$is" + constructor.name] = constructor;
      return convertToFastObject(prototype);
    } : function() {
      function tmp() {
      }
      return function(constructor, superConstructor) {
        tmp.prototype = superConstructor.prototype;
        var object = new tmp();
        convertToSlowObject(object);
        var properties = constructor.prototype;
        var members = Object.keys(properties);
        for (var i = 0; i < members.length; i++) {
          var member = members[i];
          object[member] = properties[member];
        }
        object["$is" + constructor.name] = constructor;
        object.constructor = constructor;
        constructor.prototype = object;
        return object;
      };
    }();
    function finishClasses(processedClasses) {
      var allClasses = init.allClasses;
      processedClasses.combinedConstructorFunction += "return [\n" + processedClasses.constructorsList.join(",\n  ") + "\n]";
      var constructors = new Function("$collectedClasses", processedClasses.combinedConstructorFunction)(processedClasses.collected);
      processedClasses.combinedConstructorFunction = null;
      for (var i = 0; i < constructors.length; i++) {
        var constructor = constructors[i];
        var cls = constructor.name;
        var desc = processedClasses.collected[cls];
        var globalObject = desc[0];
        desc = desc[1];
        constructor["@"] = desc;
        allClasses[cls] = constructor;
        globalObject[cls] = constructor;
      }
      constructors = null;
      var finishedClasses = init.finishedClasses;
      function finishClass(cls) {
        if (finishedClasses[cls])
          return;
        finishedClasses[cls] = true;
        var superclass = processedClasses.pending[cls];
        if (superclass && superclass.indexOf("+") > 0) {
          var s = superclass.split("+");
          superclass = s[0];
          var mixinClass = s[1];
          finishClass(mixinClass);
          var mixin = allClasses[mixinClass];
          var mixinPrototype = mixin.prototype;
          var clsPrototype = allClasses[cls].prototype;
          var properties = Object.keys(mixinPrototype);
          for (var i = 0; i < properties.length; i++) {
            var d = properties[i];
            if (!hasOwnProperty.call(clsPrototype, d))
              clsPrototype[d] = mixinPrototype[d];
          }
        }
        if (!superclass || typeof superclass != "string") {
          var constructor = allClasses[cls];
          var prototype = constructor.prototype;
          prototype.constructor = constructor;
          prototype.$isObject = constructor;
          prototype.$deferredAction = function() {
          };
          return;
        }
        finishClass(superclass);
        var superConstructor = allClasses[superclass];
        if (!superConstructor)
          superConstructor = existingIsolateProperties[superclass];
        var constructor = allClasses[cls];
        var prototype = inheritFrom(constructor, superConstructor);
        if (mixinPrototype)
          prototype.$deferredAction = mixinDeferredActionHelper(mixinPrototype, prototype);
        if (Object.prototype.hasOwnProperty.call(prototype, "%")) {
          var nativeSpec = prototype["%"].split(";");
          if (nativeSpec[0]) {
            var tags = nativeSpec[0].split("|");
            for (var i = 0; i < tags.length; i++) {
              init.interceptorsByTag[tags[i]] = constructor;
              init.leafTags[tags[i]] = true;
            }
          }
          if (nativeSpec[1]) {
            tags = nativeSpec[1].split("|");
            if (nativeSpec[2]) {
              var subclasses = nativeSpec[2].split("|");
              for (var i = 0; i < subclasses.length; i++) {
                var subclass = allClasses[subclasses[i]];
                subclass.$nativeSuperclassTag = tags[0];
              }
            }
            for (i = 0; i < tags.length; i++) {
              init.interceptorsByTag[tags[i]] = constructor;
              init.leafTags[tags[i]] = false;
            }
          }
          prototype.$deferredAction();
        }
        if (prototype.$isInterceptor)
          prototype.$deferredAction();
      }
      var properties = Object.keys(processedClasses.pending);
      for (var i = 0; i < properties.length; i++)
        finishClass(properties[i]);
    }
    function finishAddStubsHelper() {
      var prototype = this;
      while (!prototype.hasOwnProperty("$deferredAction"))
        prototype = prototype.__proto__;
      delete prototype.$deferredAction;
      var properties = Object.keys(prototype);
      for (var index = 0; index < properties.length; index++) {
        var property = properties[index];
        var firstChar = property.charCodeAt(0);
        var elem;
        if (property !== "^" && property !== "$reflectable" && firstChar !== 43 && firstChar !== 42 && (elem = prototype[property]) != null && elem.constructor === Array && property !== "<>")
          addStubs(prototype, elem, property, false, []);
      }
      convertToFastObject(prototype);
      prototype = prototype.__proto__;
      prototype.$deferredAction();
    }
    function mixinDeferredActionHelper(mixinPrototype, targetPrototype) {
      var chain;
      if (targetPrototype.hasOwnProperty("$deferredAction"))
        chain = targetPrototype.$deferredAction;
      return function foo() {
        if (!supportsDirectProtoAccess)
          return;
        var prototype = this;
        while (!prototype.hasOwnProperty("$deferredAction"))
          prototype = prototype.__proto__;
        if (chain)
          prototype.$deferredAction = chain;
        else {
          delete prototype.$deferredAction;
          convertToFastObject(prototype);
        }
        mixinPrototype.$deferredAction();
        prototype.$deferredAction();
      };
    }
    function processClassData(cls, descriptor, processedClasses) {
      descriptor = convertToSlowObject(descriptor);
      var previousProperty;
      var properties = Object.keys(descriptor);
      var hasDeferredWork = false;
      var shouldDeferWork = supportsDirectProtoAccess && cls != "Object";
      for (var i = 0; i < properties.length; i++) {
        var property = properties[i];
        var firstChar = property.charCodeAt(0);
        if (property === "static") {
          processStatics(init.statics[cls] = descriptor.static, processedClasses);
          delete descriptor.static;
        } else if (firstChar === 43) {
          mangledNames[previousProperty] = property.substring(1);
          var flag = descriptor[property];
          if (flag > 0)
            descriptor[previousProperty].$reflectable = flag;
        } else if (firstChar === 42) {
          descriptor[previousProperty].$defaultValues = descriptor[property];
          var optionalMethods = descriptor.$methodsWithOptionalArguments;
          if (!optionalMethods)
            descriptor.$methodsWithOptionalArguments = optionalMethods = {};
          optionalMethods[property] = previousProperty;
        } else {
          var elem = descriptor[property];
          if (property !== "^" && elem != null && elem.constructor === Array && property !== "<>")
            if (shouldDeferWork)
              hasDeferredWork = true;
            else
              addStubs(descriptor, elem, property, false, []);
          else
            previousProperty = property;
        }
      }
      if (hasDeferredWork)
        descriptor.$deferredAction = finishAddStubsHelper;
      var classData = descriptor["^"], split, supr, fields = classData;
      if (typeof classData == "object" && classData instanceof Array)
        classData = fields = classData[0];
      var s = fields.split(";");
      fields = s[1] ? s[1].split(",") : [];
      supr = s[0];
      split = supr.split(":");
      if (split.length == 2) {
        supr = split[0];
        var functionSignature = split[1];
        if (functionSignature)
          descriptor.$signature = function(s) {
            return function() {
              return init.types[s];
            };
          }(functionSignature);
      }
      if (supr)
        processedClasses.pending[cls] = supr;
      processedClasses.combinedConstructorFunction += defineClass(cls, fields);
      processedClasses.constructorsList.push(cls);
      processedClasses.collected[cls] = [globalObject, descriptor];
      classes.push(cls);
    }
    function processStatics(descriptor, processedClasses) {
      var properties = Object.keys(descriptor);
      for (var i = 0; i < properties.length; i++) {
        var property = properties[i];
        if (property === "^")
          continue;
        var element = descriptor[property];
        var firstChar = property.charCodeAt(0);
        var previousProperty;
        if (firstChar === 43) {
          mangledGlobalNames[previousProperty] = property.substring(1);
          var flag = descriptor[property];
          if (flag > 0)
            descriptor[previousProperty].$reflectable = flag;
          if (element && element.length)
            init.typeInformation[previousProperty] = element;
        } else if (firstChar === 42) {
          globalObject[previousProperty].$defaultValues = element;
          var optionalMethods = descriptor.$methodsWithOptionalArguments;
          if (!optionalMethods)
            descriptor.$methodsWithOptionalArguments = optionalMethods = {};
          optionalMethods[property] = previousProperty;
        } else if (typeof element === "function") {
          globalObject[previousProperty = property] = element;
          functions.push(property);
          init.globalFunctions[property] = element;
        } else if (element.constructor === Array)
          addStubs(globalObject, element, property, true, functions);
        else {
          previousProperty = property;
          processClassData(property, element, processedClasses);
        }
      }
    }
    function addStubs(prototype, array, name, isStatic, functions) {
      var index = 0, alias = array[index], f;
      if (typeof alias == "string")
        f = array[++index];
      else {
        f = alias;
        alias = name;
      }
      var funcs = [prototype[name] = prototype[alias] = f];
      f.$stubName = name;
      functions.push(name);
      for (index++; index < array.length; index++) {
        f = array[index];
        if (typeof f != "function")
          break;
        if (!isStatic)
          f.$stubName = array[++index];
        funcs.push(f);
        if (f.$stubName) {
          prototype[f.$stubName] = f;
          functions.push(f.$stubName);
        }
      }
      for (var i = 0; i < funcs.length; index++, i++)
        funcs[i].$callName = array[index];
      var getterStubName = array[index];
      array = array.slice(++index);
      var requiredParameterInfo = array[0];
      var requiredParameterCount = requiredParameterInfo >> 1;
      var isAccessor = (requiredParameterInfo & 1) === 1;
      var isSetter = requiredParameterInfo === 3;
      var isGetter = requiredParameterInfo === 1;
      var optionalParameterInfo = array[1];
      var optionalParameterCount = optionalParameterInfo >> 1;
      var optionalParametersAreNamed = (optionalParameterInfo & 1) === 1;
      var isIntercepted = requiredParameterCount + optionalParameterCount != funcs[0].length;
      var functionTypeIndex = array[2];
      if (typeof functionTypeIndex == "number")
        array[2] = functionTypeIndex + typesOffset;
      var unmangledNameIndex = 3 * optionalParameterCount + 2 * requiredParameterCount + 3;
      if (getterStubName) {
        f = tearOff(funcs, array, isStatic, name, isIntercepted);
        prototype[name].$getter = f;
        f.$getterStub = true;
        if (isStatic) {
          init.globalFunctions[name] = f;
          functions.push(getterStubName);
        }
        prototype[getterStubName] = f;
        funcs.push(f);
        f.$stubName = getterStubName;
        f.$callName = null;
        if (isIntercepted)
          init.interceptedNames[getterStubName] = 1;
      }
      var isReflectable = array.length > unmangledNameIndex;
      if (isReflectable) {
        funcs[0].$reflectable = 1;
        funcs[0].$reflectionInfo = array;
        for (var i = 1; i < funcs.length; i++) {
          funcs[i].$reflectable = 2;
          funcs[i].$reflectionInfo = array;
        }
        var mangledNames = isStatic ? init.mangledGlobalNames : init.mangledNames;
        var unmangledName = array[unmangledNameIndex];
        var reflectionName = unmangledName;
        if (getterStubName)
          mangledNames[getterStubName] = reflectionName;
        if (isSetter)
          reflectionName += "=";
        else if (!isGetter)
          reflectionName += ":" + (requiredParameterCount + optionalParameterCount);
        mangledNames[name] = reflectionName;
        funcs[0].$reflectionName = reflectionName;
        funcs[0].$metadataIndex = unmangledNameIndex + 1;
        if (optionalParameterCount)
          prototype[unmangledName + "*"] = funcs[0];
      }
    }
    function tearOffGetter(funcs, reflectionInfo, name, isIntercepted) {
      return isIntercepted ? new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "(x) {" + "if (c === null) c = " + "H.closureFromTearOff" + "(" + "this, funcs, reflectionInfo, false, [x], name);" + "return new c(this, funcs[0], x, name);" + "}")(funcs, reflectionInfo, name, H, null) : new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "() {" + "if (c === null) c = " + "H.closureFromTearOff" + "(" + "this, funcs, reflectionInfo, false, [], name);" + "return new c(this, funcs[0], null, name);" + "}")(funcs, reflectionInfo, name, H, null);
    }
    function tearOff(funcs, reflectionInfo, isStatic, name, isIntercepted) {
      var cache;
      return isStatic ? function() {
        if (cache === void 0)
          cache = H.closureFromTearOff(this, funcs, reflectionInfo, true, [], name).prototype;
        return cache;
      } : tearOffGetter(funcs, reflectionInfo, name, isIntercepted);
    }
    var functionCounter = 0;
    if (!init.libraries)
      init.libraries = [];
    if (!init.mangledNames)
      init.mangledNames = map();
    if (!init.mangledGlobalNames)
      init.mangledGlobalNames = map();
    if (!init.statics)
      init.statics = map();
    if (!init.typeInformation)
      init.typeInformation = map();
    if (!init.globalFunctions)
      init.globalFunctions = map();
    if (!init.interceptedNames)
      init.interceptedNames = {set$_filter: 1, set$buffer: 1, set$elementSizeInBytes: 1, set$length: 1, set$lengthInBytes: 1, set$offsetInBytes: 1, get$_filter: 1, get$bitLength: 1, get$buffer: 1, get$codeUnits: 1, get$elementSizeInBytes: 1, get$first: 1, get$hashCode: 1, get$isEmpty: 1, get$isEven: 1, get$isFinite: 1, get$isInfinite: 1, get$isNaN: 1, get$isNegative: 1, get$isNotEmpty: 1, get$isOdd: 1, get$iterator: 1, get$last: 1, get$length: 1, get$lengthInBytes: 1, get$list: 1, get$offsetInBytes: 1, get$reversed: 1, get$runes: 1, get$runtimeType: 1, get$sign: 1, get$single: 1, $add: 1, $and: 1, $div: 1, $eq: 1, $ge: 1, $gt: 1, $index: 1, $indexSet: 1, $le: 1, $lt: 1, $mod: 1, $mul: 1, $negate: 1, $not: 1, $or: 1, $shl: 1, $shr: 1, $sub: 1, $tdiv: 1, $xor: 1, _checkPosition$3: 1, _codeUnitAt$1: 1, _collection$_filter$2: 1, _defaultSplit$1: 1, _invalidPosition$3: 1, _removeWhere$2: 1, _setRangeFast$4: 1, _shlPositive$1: 1, _shrOtherPositive$1: 1, _tdivFast$1: 1, _tdivSlow$1: 1, abs$0: 1, add$1: 1, add$2: 1, addAll$1: 1, allMatches$1: 1, allMatches$2: 1, any$1: 1, asByteData$0: 1, asByteData$1: 1, asByteData$2: 1, asFloat32List$0: 1, asFloat32List$1: 1, asFloat32List$2: 1, asFloat32x4List$0: 1, asFloat32x4List$1: 1, asFloat32x4List$2: 1, asFloat64List$0: 1, asFloat64List$1: 1, asFloat64List$2: 1, asFloat64x2List$0: 1, asFloat64x2List$1: 1, asFloat64x2List$2: 1, asInt16List$0: 1, asInt16List$1: 1, asInt16List$2: 1, asInt32List$0: 1, asInt32List$1: 1, asInt32List$2: 1, asInt32x4List$0: 1, asInt32x4List$1: 1, asInt32x4List$2: 1, asInt64List$0: 1, asInt64List$1: 1, asInt64List$2: 1, asInt8List$0: 1, asInt8List$1: 1, asInt8List$2: 1, asMap$0: 1, asUint16List$0: 1, asUint16List$1: 1, asUint16List$2: 1, asUint32List$0: 1, asUint32List$1: 1, asUint32List$2: 1, asUint64List$0: 1, asUint64List$1: 1, asUint64List$2: 1, asUint8ClampedList$0: 1, asUint8ClampedList$1: 1, asUint8ClampedList$2: 1, asUint8List$0: 1, asUint8List$1: 1, asUint8List$2: 1, ceil$0: 1, ceilToDouble$0: 1, checkGrowable$1: 1, checkMutable$1: 1, clamp$2: 1, clear$0: 1, codeUnitAt$1: 1, compareTo$1: 1, contains$1: 1, contains$2: 1, elementAt$1: 1, endsWith$1: 1, every$1: 1, expand$1: 1, fillRange$2: 1, fillRange$3: 1, firstWhere$1: 1, firstWhere$2$defaultValue: 1, firstWhere$2$orElse: 1, floor$0: 1, floorToDouble$0: 1, fold$2: 1, forEach$1: 1, gcd$1: 1, getFloat32$1: 1, getFloat32$2: 1, getFloat64$1: 1, getFloat64$2: 1, getInt16$1: 1, getInt16$2: 1, getInt32$1: 1, getInt32$2: 1, getInt64$1: 1, getInt64$2: 1, getInt8$1: 1, getRange$2: 1, getUint16$1: 1, getUint16$2: 1, getUint32$1: 1, getUint32$2: 1, getUint64$1: 1, getUint64$2: 1, getUint8$1: 1, indexOf$1: 1, indexOf$2: 1, insert$2: 1, insertAll$2: 1, join$0: 1, join$1: 1, lastIndexOf$1: 1, lastIndexOf$2: 1, lastWhere$1: 1, lastWhere$2$defaultValue: 1, lastWhere$2$orElse: 1, length$0: 1, list$0: 1, list$1$recursive: 1, list$2$followLinks$recursive: 1, map$1: 1, matchAsPrefix$1: 1, matchAsPrefix$2: 1, modInverse$1: 1, modPow$2: 1, noSuchMethod$1: 1, padLeft$1: 1, padLeft$2: 1, padRight$1: 1, padRight$2: 1, reduce$1: 1, remainder$1: 1, remove$0: 1, remove$1: 1, remove$2: 1, removeAt$1: 1, removeLast$0: 1, removeRange$2: 1, removeWhere$1: 1, replaceAll$2: 1, replaceAllMapped$2: 1, replaceFirst$2: 1, replaceFirst$3: 1, replaceFirstMapped$2: 1, replaceFirstMapped$3: 1, replaceRange$3: 1, retainWhere$1: 1, round$0: 1, roundToDouble$0: 1, setAll$2: 1, setFloat32$2: 1, setFloat32$3: 1, setFloat64$2: 1, setFloat64$3: 1, setInt16$2: 1, setInt16$3: 1, setInt32$2: 1, setInt32$3: 1, setInt64$2: 1, setInt64$3: 1, setInt8$2: 1, setRange$3: 1, setRange$4: 1, setUint16$2: 1, setUint16$3: 1, setUint32$2: 1, setUint32$3: 1, setUint64$2: 1, setUint64$3: 1, setUint8$2: 1, shuffle$0: 1, shuffle$1: 1, singleWhere$1: 1, singleWhere$2$orElse: 1, skip$1: 1, skipWhile$1: 1, sort$0: 1, sort$1: 1, split$1: 1, splitMapJoin$1: 1, splitMapJoin$3$onMatch$onNonMatch: 1, startsWith$1: 1, startsWith$2: 1, sublist$1: 1, sublist$2: 1, substring$1: 1, substring$2: 1, take$1: 1, takeWhile$1: 1, toDouble$0: 1, toInt$0: 1, toList$0: 1, toList$1$growable: 1, toLowerCase$0: 1, toRadixString$1: 1, toSet$0: 1, toSigned$1: 1, toString$0: 1, toStringAsExponential$0: 1, toStringAsExponential$1: 1, toStringAsFixed$1: 1, toStringAsPrecision$1: 1, toUnsigned$1: 1, toUpperCase$0: 1, trim$0: 1, trimLeft$0: 1, trimRight$0: 1, truncate$0: 1, truncate$1: 1, truncateToDouble$0: 1, where$1: 1};
    var libraries = init.libraries;
    var mangledNames = init.mangledNames;
    var mangledGlobalNames = init.mangledGlobalNames;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var length = programData.length;
    var processedClasses = map();
    processedClasses.collected = map();
    processedClasses.pending = map();
    processedClasses.constructorsList = [];
    processedClasses.combinedConstructorFunction = "function $reflectable(fn){fn.$reflectable=1;return fn};\n" + "var $desc;\n";
    for (var i = 0; i < length; i++) {
      var data = programData[i];
      var name = data[0];
      var uri = data[1];
      var metadata = data[2];
      var globalObject = data[3];
      var descriptor = data[4];
      var isRoot = !!data[5];
      var fields = descriptor && descriptor["^"];
      if (fields instanceof Array)
        fields = fields[0];
      var classes = [];
      var functions = [];
      processStatics(descriptor, processedClasses);
      libraries.push([name, uri, classes, functions, metadata, fields, isRoot, globalObject]);
    }
    finishClasses(processedClasses);
  }
  Isolate.functionThatReturnsNull = function() {
  };
  var dart = [["_foreign_helper", "dart:_foreign_helper",, H, {
    "^": "",
    JS_CONST: {
      "^": "Object;code"
    },
    "+JS_CONST": 0
  }], ["_interceptors", "dart:_interceptors",, J, {
    "^": "",
    _symbolToString: function(symbol) {
      return symbol.get$__internal$_name();
    },
    _symbolMapToStringMap: function(map) {
      var result = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [P.String, null]);
      map.forEach$1(0, new J._symbolMapToStringMap_closure(result));
      return result;
    },
    getInterceptor: function(object) {
      return void 0;
    },
    getDispatchProperty: function(object) {
      return object[init.dispatchPropertyName];
    },
    setDispatchProperty: function(object, value) {
      Object.defineProperty(object, init.dispatchPropertyName, {value: value, enumerable: false, writable: true, configurable: true});
    },
    makeDispatchRecord: function(interceptor, proto, extension, indexability) {
      return {i: interceptor, p: proto, e: extension, x: indexability};
    },
    dispatchRecordInterceptor: function(record) {
      return record.i;
    },
    dispatchRecordProto: function(record) {
      return record.p;
    },
    dispatchRecordExtension: function(record) {
      return record.e;
    },
    dispatchRecordIndexability: function(record) {
      return record.x;
    },
    getNativeInterceptor: function(object) {
      var record, proto, objectProto, $constructor, interceptor;
      record = object[init.dispatchPropertyName];
      if (record == null)
        if ($.initNativeDispatchFlag == null) {
          H.initNativeDispatch();
          record = object[init.dispatchPropertyName];
        }
      if (record != null) {
        proto = record.p;
        if (false === proto)
          return record.i;
        if (true === proto)
          return object;
        objectProto = Object.getPrototypeOf(object);
        if (proto === objectProto)
          return record.i;
        if (record.e === objectProto)
          throw H.wrapException(new P.UnimplementedError("Return interceptor for " + H.S(proto(object, record))));
      }
      $constructor = object.constructor;
      interceptor = $constructor == null ? null : $constructor[$.$get$JS_INTEROP_INTERCEPTOR_TAG()];
      if (interceptor != null)
        return interceptor;
      interceptor = H.lookupAndCacheInterceptor(object);
      if (interceptor != null)
        return interceptor;
      if (typeof object == "function")
        return C.JavaScriptFunction_methods;
      proto = Object.getPrototypeOf(object);
      if (proto == null)
        return C.PlainJavaScriptObject_methods;
      if (proto === Object.prototype)
        return C.PlainJavaScriptObject_methods;
      if (typeof $constructor == "function") {
        Object.defineProperty($constructor, $.$get$JS_INTEROP_INTERCEPTOR_TAG(), {value: C.UnknownJavaScriptObject_methods, enumerable: false, writable: true, configurable: true});
        return C.UnknownJavaScriptObject_methods;
      }
      return C.UnknownJavaScriptObject_methods;
    },
    lookupInterceptorByConstructor: function($constructor) {
      return $constructor == null ? null : $constructor[$.$get$JS_INTEROP_INTERCEPTOR_TAG()];
    },
    cacheInterceptorOnConstructor: function($constructor, interceptor) {
      Object.defineProperty($constructor, $.$get$JS_INTEROP_INTERCEPTOR_TAG(), {value: interceptor, enumerable: false, writable: true, configurable: true});
    },
    XlookupInterceptorByConstructor: function($constructor) {
      return $.$get$constructorToInterceptor().get($constructor);
    },
    XcacheInterceptorOnConstructor: function($constructor, interceptor) {
      $.$get$constructorToInterceptor().set($constructor, interceptor);
    },
    typeToInterceptorMap: function() {
      return init.typeToInterceptorMap;
    },
    findIndexForNativeSubclassType: function(type) {
      var map, t1, i;
      if (init.typeToInterceptorMap == null)
        return;
      map = init.typeToInterceptorMap;
      for (t1 = map.length, i = 0; i + 1 < t1; i += 3)
        if (i >= t1)
          return H.ioore(map, i);
      return;
    },
    findInterceptorConstructorForType: function(type) {
      var index, map, t1;
      index = J.findIndexForNativeSubclassType(type);
      if (index == null)
        return;
      map = init.typeToInterceptorMap;
      t1 = index + 1;
      if (t1 >= map.length)
        return H.ioore(map, t1);
      return map[t1];
    },
    findConstructorForNativeSubclassType: function(type, $name) {
      var index, map, t1;
      index = J.findIndexForNativeSubclassType(type);
      if (index == null)
        return;
      map = init.typeToInterceptorMap;
      t1 = index + 2;
      if (t1 >= map.length)
        return H.ioore(map, t1);
      return map[t1][$name];
    },
    findInterceptorForType: function(type) {
      var $constructor = J.findInterceptorConstructorForType(type);
      if ($constructor == null)
        return;
      return $constructor.prototype;
    },
    _symbolMapToStringMap_closure: {
      "^": "Closure:150;result",
      call$2: [function(key, value) {
        this.result.$indexSet(0, key.get$__internal$_name(), value);
      }, null, null, 4, 0, 150, 6, [], 1, [], "call"]
    },
    "+ _symbolMapToStringMap_closure": [2],
    Interceptor: {
      "^": "Object;",
      $eq: [function(receiver, other) {
        return receiver === other;
      }, null, "get$==", 2, 0, 24, 2, [], "=="],
      get$hashCode: [function(receiver) {
        return H.Primitives_objectHashCode(receiver);
      }, null, null, 1, 0, 11, "hashCode"],
      toString$0: [function(receiver) {
        return H.Primitives_objectToHumanReadableString(receiver);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      noSuchMethod$1: ["super$Interceptor$noSuchMethod", function(receiver, invocation) {
        throw H.wrapException(P.NoSuchMethodError$(receiver, invocation.get$memberName(), invocation.get$positionalArguments(), invocation.get$namedArguments(), null));
      }, "call$1", "get$noSuchMethod", 2, 0, 77, 118, [], "noSuchMethod"],
      get$runtimeType: [function(receiver) {
        return new H.TypeImpl(H.getRuntimeTypeString(receiver), null);
      }, null, null, 1, 0, 20, "runtimeType"]
    },
    "+Interceptor": 0,
    JSBool: {
      "^": "Interceptor;",
      toString$0: [function(receiver) {
        return String(receiver);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      get$hashCode: [function(receiver) {
        return receiver ? 519018 : 218159;
      }, null, null, 1, 0, 11, "hashCode"],
      get$runtimeType: [function(receiver) {
        return C.Type_bool_lhE;
      }, null, null, 1, 0, 20, "runtimeType"],
      $isbool: 1
    },
    "+JSBool": [151, 8],
    JSNull: {
      "^": "Interceptor;",
      $eq: [function(receiver, other) {
        return null == other;
      }, null, "get$==", 2, 0, 24, 2, [], "=="],
      toString$0: [function(receiver) {
        return "null";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      get$hashCode: [function(receiver) {
        return 0;
      }, null, null, 1, 0, 11, "hashCode"],
      get$runtimeType: [function(receiver) {
        return C.Type_Null_Yyn;
      }, null, null, 1, 0, 20, "runtimeType"],
      noSuchMethod$1: [function(receiver, invocation) {
        return this.super$Interceptor$noSuchMethod(receiver, invocation);
      }, "call$1", "get$noSuchMethod", 2, 0, 77, 118, [], "noSuchMethod"],
      $isNull: 1
    },
    "+JSNull": [151, 1120],
    JSIndexable: {
      "^": "Object;$ti",
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $asJSIndexable: null
    },
    "+JSIndexable": 0,
    JavaScriptObject: {
      "^": "Interceptor;",
      get$hashCode: [function(receiver) {
        return 0;
      }, null, null, 1, 0, 11, "hashCode"],
      get$runtimeType: [function(receiver) {
        return C.Type_JSObject_8k0;
      }, null, null, 1, 0, 20, "runtimeType"],
      toString$0: ["super$JavaScriptObject$toString", function(receiver) {
        return String(receiver);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isJSObject: 1
    },
    "+JavaScriptObject": 0,
    PlainJavaScriptObject: {
      "^": "JavaScriptObject;"
    },
    "+PlainJavaScriptObject": 0,
    UnknownJavaScriptObject: {
      "^": "JavaScriptObject;"
    },
    "+UnknownJavaScriptObject": 0,
    JavaScriptFunction: {
      "^": "JavaScriptObject;",
      toString$0: [function(receiver) {
        var dartClosure = receiver[$.$get$DART_CLOSURE_PROPERTY_NAME()];
        return dartClosure == null ? this.super$JavaScriptObject$toString(receiver) : J.toString$0$(dartClosure);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isFunction: 1,
      $signature: function() {
        return {func: 1, opt: [,,,,,,,,,,,,,,,,]};
      }
    },
    "+JavaScriptFunction": 0,
    _Growable: {
      "^": "Object;"
    },
    "+_Growable": 0,
    JSArray: {
      "^": "Interceptor;$ti",
      checkMutable$1: function(receiver, reason) {
        if (!!receiver.immutable$list)
          throw H.wrapException(new P.UnsupportedError(reason));
      },
      checkGrowable$1: function(receiver, reason) {
        if (!!receiver.fixed$length)
          throw H.wrapException(new P.UnsupportedError(reason));
      },
      add$1: [function(receiver, value) {
        if (!!receiver.fixed$length)
          H.throwExpression(new P.UnsupportedError("add"));
        receiver.push(value);
      }, "call$1", "get$add", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [E]};
        }, this.$receiver, "JSArray");
      }, 1, [], "add"],
      removeAt$1: [function(receiver, index) {
        this.checkGrowable$1(receiver, "removeAt");
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(H.argumentErrorValue(index));
        if (index < 0 || index >= receiver.length)
          throw H.wrapException(P.RangeError$value(index, null, null));
        return receiver.splice(index, 1)[0];
      }, "call$1", "get$removeAt", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [P.int]};
        }, this.$receiver, "JSArray");
      }, 14, [], "removeAt"],
      insert$2: [function(receiver, index, value) {
        this.checkGrowable$1(receiver, "insert");
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(H.argumentErrorValue(index));
        if (index < 0 || index > receiver.length)
          throw H.wrapException(P.RangeError$value(index, null, null));
        receiver.splice(index, 0, value);
      }, "call$2", "get$insert", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [P.int, E]};
        }, this.$receiver, "JSArray");
      }, 14, [], 1, [], "insert"],
      insertAll$2: [function(receiver, index, iterable) {
        var t1, insertionLength, end;
        this.checkGrowable$1(receiver, "insertAll");
        P.RangeError_checkValueInInterval(index, 0, receiver.length, "index", null);
        t1 = J.getInterceptor(iterable);
        if (!t1.$isEfficientLengthIterable)
          iterable = t1.toList$0(iterable);
        insertionLength = J.get$length$asx(iterable);
        t1 = receiver.length;
        if (typeof insertionLength !== "number")
          return H.iae(insertionLength);
        this.set$length(receiver, t1 + insertionLength);
        end = J.$add$ns(index, insertionLength);
        this.setRange$4(receiver, end, receiver.length, receiver, index);
        this.setRange$3(receiver, index, end, iterable);
      }, "call$2", "get$insertAll", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [P.int, [P.Iterable, E]]};
        }, this.$receiver, "JSArray");
      }, 14, [], 42, [], "insertAll"],
      setAll$2: [function(receiver, index, iterable) {
        var t1, element, index0;
        this.checkMutable$1(receiver, "setAll");
        P.RangeError_checkValueInInterval(index, 0, receiver.length, "index", null);
        for (t1 = J.get$iterator$ax(iterable); t1.moveNext$0(); index = index0) {
          element = t1.get$current();
          index0 = J.$add$ns(index, 1);
          this.$indexSet(receiver, index, element);
        }
      }, "call$2", "get$setAll", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [P.int, [P.Iterable, E]]};
        }, this.$receiver, "JSArray");
      }, 14, [], 42, [], "setAll"],
      removeLast$0: [function(receiver) {
        this.checkGrowable$1(receiver, "removeLast");
        if (receiver.length === 0)
          throw H.wrapException(H.diagnoseIndexError(receiver, -1));
        return receiver.pop();
      }, "call$0", "get$removeLast", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "JSArray");
      }, "removeLast"],
      remove$1: [function(receiver, element) {
        var i;
        if (!!receiver.fixed$length)
          H.throwExpression(new P.UnsupportedError("remove"));
        for (i = 0; i < receiver.length; ++i)
          if (J.$eq$(receiver[i], element)) {
            receiver.splice(i, 1);
            return true;
          }
        return false;
      }, "call$1", "get$remove", 2, 0, 15, 31, [], "remove"],
      removeWhere$1: [function(receiver, test) {
        this.checkGrowable$1(receiver, "removeWhere");
        this._removeWhere$2(receiver, test, true);
      }, "call$1", "get$removeWhere", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "JSArray");
      }, 11, [], "removeWhere"],
      retainWhere$1: [function(receiver, test) {
        this.checkGrowable$1(receiver, "retainWhere");
        this._removeWhere$2(receiver, test, false);
      }, "call$1", "get$retainWhere", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "JSArray");
      }, 11, [], "retainWhere"],
      _removeWhere$2: function(receiver, test, removeMatching) {
        var retained, end, i, element, t1;
        retained = [];
        end = receiver.length;
        for (i = 0; i < end; ++i) {
          element = receiver[i];
          if (test.call$1(element) !== true === removeMatching)
            retained.push(element);
          if (receiver.length !== end)
            throw H.wrapException(new P.ConcurrentModificationError(receiver));
        }
        t1 = retained.length;
        if (t1 === end)
          return;
        this.set$length(receiver, t1);
        for (i = 0; i < retained.length; ++i)
          this.$indexSet(receiver, i, retained[i]);
      },
      where$1: [function(receiver, f) {
        return new H.WhereIterable(receiver, f, [H.getTypeArgumentByIndex(receiver, 0)]);
      }, "call$1", "get$where", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "JSArray");
      }, 9, [], "where"],
      expand$1: [function(receiver, f) {
        return new H.ExpandIterable(receiver, f, [H.getTypeArgumentByIndex(receiver, 0), null]);
      }, "call$1", "get$expand", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.Iterable, args: [{func: 1, ret: P.Iterable, args: [E]}]};
        }, this.$receiver, "JSArray");
      }, 9, [], "expand"],
      addAll$1: [function(receiver, collection) {
        var t1;
        this.checkGrowable$1(receiver, "addAll");
        for (t1 = J.get$iterator$ax(collection); t1.moveNext$0();)
          receiver.push(t1.get$current());
      }, "call$1", "get$addAll", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [[P.Iterable, E]]};
        }, this.$receiver, "JSArray");
      }, 905, [], "addAll"],
      clear$0: [function(receiver) {
        this.set$length(receiver, 0);
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      forEach$1: [function(receiver, f) {
        var end, i;
        end = receiver.length;
        for (i = 0; i < end; ++i) {
          f.call$1(receiver[i]);
          if (receiver.length !== end)
            throw H.wrapException(new P.ConcurrentModificationError(receiver));
        }
      }, "call$1", "get$forEach", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, v: true, args: [E]}]};
        }, this.$receiver, "JSArray");
      }, 9, [], "forEach"],
      map$1: [function(receiver, f) {
        return new H.MappedListIterable(receiver, f, [null, null]);
      }, "call$1", "get$map", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.Iterable, args: [{func: 1, args: [E]}]};
        }, this.$receiver, "JSArray");
      }, 9, [], "map"],
      join$1: [function(receiver, separator) {
        var t1, list, i, t2;
        t1 = receiver.length;
        list = new Array(t1);
        list.fixed$length = Array;
        for (i = 0; i < receiver.length; ++i) {
          t2 = H.S(receiver[i]);
          if (i >= t1)
            return H.ioore(list, i);
          list[i] = t2;
        }
        return list.join(separator);
      }, function($receiver) {
        return this.join$1($receiver, "");
      }, "join$0", "call$1", "call$0", "get$join", 0, 2, 92, 32, 63, [], "join"],
      take$1: [function(receiver, n) {
        return H.SubListIterable$(receiver, 0, n, H.getTypeArgumentByIndex(receiver, 0));
      }, "call$1", "get$take", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [P.int]};
        }, this.$receiver, "JSArray");
      }, 89, [], "take"],
      takeWhile$1: [function(receiver, test) {
        return new H.TakeWhileIterable(receiver, test, [H.getTypeArgumentByIndex(receiver, 0)]);
      }, "call$1", "get$takeWhile", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "JSArray");
      }, 11, [], "takeWhile"],
      skip$1: [function(receiver, n) {
        return H.SubListIterable$(receiver, n, null, H.getTypeArgumentByIndex(receiver, 0));
      }, "call$1", "get$skip", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [P.int]};
        }, this.$receiver, "JSArray");
      }, 89, [], "skip"],
      skipWhile$1: [function(receiver, test) {
        return new H.SkipWhileIterable(receiver, test, [H.getTypeArgumentByIndex(receiver, 0)]);
      }, "call$1", "get$skipWhile", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "JSArray");
      }, 11, [], "skipWhile"],
      reduce$1: [function(receiver, combine) {
        var $length, value, i;
        $length = receiver.length;
        if ($length === 0)
          throw H.wrapException(H.IterableElementError_noElement());
        if (0 >= $length)
          return H.ioore(receiver, 0);
        value = receiver[0];
        for (i = 1; i < $length; ++i) {
          value = combine.call$2(value, receiver[i]);
          if ($length !== receiver.length)
            throw H.wrapException(new P.ConcurrentModificationError(receiver));
        }
        return value;
      }, "call$1", "get$reduce", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: E, args: [E, E]}]};
        }, this.$receiver, "JSArray");
      }, 61, [], "reduce"],
      fold$2: [function(receiver, initialValue, combine) {
        var $length, value, i;
        $length = receiver.length;
        for (value = initialValue, i = 0; i < $length; ++i) {
          value = combine.call$2(value, receiver[i]);
          if (receiver.length !== $length)
            throw H.wrapException(new P.ConcurrentModificationError(receiver));
        }
        return value;
      }, "call$2", "get$fold", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, args: [, {func: 1, args: [, E]}]};
        }, this.$receiver, "JSArray");
      }, 123, [], 61, [], "fold"],
      firstWhere$2$orElse: [function(receiver, test, orElse) {
        var end, i, element;
        end = receiver.length;
        for (i = 0; i < end; ++i) {
          element = receiver[i];
          if (test.call$1(element) === true)
            return element;
          if (receiver.length !== end)
            throw H.wrapException(new P.ConcurrentModificationError(receiver));
        }
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      }, function($receiver, test) {
        return this.firstWhere$2$orElse($receiver, test, null);
      }, "firstWhere$1", "call$2$orElse", "call$1", "get$firstWhere", 2, 3, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: P.bool, args: [E]}], named: {orElse: {func: 1, ret: E}}};
        }, this.$receiver, "JSArray");
      }, 0, 11, [], 67, [], "firstWhere"],
      lastWhere$2$orElse: [function(receiver, test, orElse) {
        var $length, i, element;
        $length = receiver.length;
        for (i = $length - 1; i >= 0; --i) {
          element = receiver[i];
          if (test.call$1(element) === true)
            return element;
          if ($length !== receiver.length)
            throw H.wrapException(new P.ConcurrentModificationError(receiver));
        }
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      }, function($receiver, test) {
        return this.lastWhere$2$orElse($receiver, test, null);
      }, "lastWhere$1", "call$2$orElse", "call$1", "get$lastWhere", 2, 3, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: P.bool, args: [E]}], named: {orElse: {func: 1, ret: E}}};
        }, this.$receiver, "JSArray");
      }, 0, 11, [], 67, [], "lastWhere"],
      singleWhere$1: [function(receiver, test) {
        var $length, match, matchFound, i, element;
        $length = receiver.length;
        for (match = null, matchFound = false, i = 0; i < $length; ++i) {
          element = receiver[i];
          if (test.call$1(element) === true) {
            if (matchFound)
              throw H.wrapException(H.IterableElementError_tooMany());
            match = element;
            matchFound = true;
          }
          if ($length !== receiver.length)
            throw H.wrapException(new P.ConcurrentModificationError(receiver));
        }
        if (matchFound)
          return match;
        throw H.wrapException(H.IterableElementError_noElement());
      }, "call$1", "get$singleWhere", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "JSArray");
      }, 11, [], "singleWhere"],
      elementAt$1: [function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          return H.ioore(receiver, index);
        return receiver[index];
      }, "call$1", "get$elementAt", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [P.int]};
        }, this.$receiver, "JSArray");
      }, 14, [], "elementAt"],
      sublist$2: [function(receiver, start, end) {
        if (start == null)
          H.throwExpression(H.argumentErrorValue(start));
        if (typeof start !== "number" || Math.floor(start) !== start)
          throw H.wrapException(H.argumentErrorValue(start));
        if (start < 0 || start > receiver.length)
          throw H.wrapException(P.RangeError$range(start, 0, receiver.length, "start", null));
        if (end == null)
          end = receiver.length;
        else {
          if (typeof end !== "number" || Math.floor(end) !== end)
            throw H.wrapException(H.argumentErrorValue(end));
          if (end < start || end > receiver.length)
            throw H.wrapException(P.RangeError$range(end, start, receiver.length, "end", null));
        }
        if (start === end)
          return H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(receiver, 0)]);
        return H.setRuntimeTypeInfo(receiver.slice(start, end), [H.getTypeArgumentByIndex(receiver, 0)]);
      }, function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      }, "sublist$1", "call$2", "call$1", "get$sublist", 2, 2, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.List, E], args: [P.int], opt: [P.int]};
        }, this.$receiver, "JSArray");
      }, 0, 3, [], 5, [], "sublist"],
      getRange$2: [function(receiver, start, end) {
        P.RangeError_checkValidRange(start, end, receiver.length, null, null, null);
        return H.SubListIterable$(receiver, start, end, H.getTypeArgumentByIndex(receiver, 0));
      }, "call$2", "get$getRange", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [P.int, P.int]};
        }, this.$receiver, "JSArray");
      }, 3, [], 5, [], "getRange"],
      get$first: [function(receiver) {
        if (receiver.length > 0)
          return receiver[0];
        throw H.wrapException(H.IterableElementError_noElement());
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "JSArray");
      }, "first"],
      get$last: [function(receiver) {
        var t1 = receiver.length;
        if (t1 > 0)
          return receiver[t1 - 1];
        throw H.wrapException(H.IterableElementError_noElement());
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "JSArray");
      }, "last"],
      get$single: [function(receiver) {
        var t1 = receiver.length;
        if (t1 === 1) {
          if (0 >= t1)
            return H.ioore(receiver, 0);
          return receiver[0];
        }
        if (t1 === 0)
          throw H.wrapException(H.IterableElementError_noElement());
        throw H.wrapException(H.IterableElementError_tooMany());
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "JSArray");
      }, "single"],
      removeRange$2: [function(receiver, start, end) {
        this.checkGrowable$1(receiver, "removeRange");
        P.RangeError_checkValidRange(start, end, receiver.length, null, null, null);
        receiver.splice(start, J.$sub$n(end, start));
      }, "call$2", "get$removeRange", 4, 0, 76, 3, [], 5, [], "removeRange"],
      setRange$4: [function(receiver, start, end, iterable, skipCount) {
        var $length, t1, t2, otherStart, otherList, t3, i, t4, element;
        this.checkMutable$1(receiver, "set range");
        P.RangeError_checkValidRange(start, end, receiver.length, null, null, null);
        $length = J.$sub$n(end, start);
        t1 = J.getInterceptor($length);
        if (t1.$eq($length, 0))
          return;
        if (J.$lt$n(skipCount, 0))
          H.throwExpression(P.RangeError$range(skipCount, 0, null, "skipCount", null));
        t2 = J.getInterceptor(iterable);
        if (!!t2.$isList) {
          otherStart = skipCount;
          otherList = iterable;
        } else {
          otherList = t2.skip$1(iterable, skipCount).toList$1$growable(0, false);
          otherStart = 0;
        }
        t2 = J.getInterceptor$ns(otherStart);
        t3 = J.getInterceptor$asx(otherList);
        if (J.$gt$n(t2.$add(otherStart, $length), t3.get$length(otherList)))
          throw H.wrapException(H.IterableElementError_tooFew());
        if (t2.$lt(otherStart, start))
          for (i = t1.$sub($length, 1), t1 = J.getInterceptor$ns(start); t4 = J.getInterceptor$n(i), t4.$ge(i, 0); i = t4.$sub(i, 1)) {
            element = t3.$index(otherList, t2.$add(otherStart, i));
            receiver[t1.$add(start, i)] = element;
          }
        else {
          if (typeof $length !== "number")
            return H.iae($length);
          t1 = J.getInterceptor$ns(start);
          i = 0;
          for (; i < $length; ++i) {
            element = t3.$index(otherList, t2.$add(otherStart, i));
            receiver[t1.$add(start, i)] = element;
          }
        }
      }, function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      }, "setRange$3", "call$4", "call$3", "get$setRange", 6, 2, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [P.int, P.int, [P.Iterable, E]], opt: [P.int]};
        }, this.$receiver, "JSArray");
      }, 7, 3, [], 5, [], 42, [], 197, [], "setRange"],
      fillRange$3: [function(receiver, start, end, fillValue) {
        var i, t1;
        this.checkMutable$1(receiver, "fill range");
        P.RangeError_checkValidRange(start, end, receiver.length, null, null, null);
        for (i = start; t1 = J.getInterceptor$n(i), t1.$lt(i, end); i = t1.$add(i, 1))
          receiver[i] = fillValue;
      }, function($receiver, start, end) {
        return this.fillRange$3($receiver, start, end, null);
      }, "fillRange$2", "call$3", "call$2", "get$fillRange", 4, 2, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [P.int, P.int], opt: [E]};
        }, this.$receiver, "JSArray");
      }, 0, 3, [], 5, [], 588, [], "fillRange"],
      replaceRange$3: [function(receiver, start, end, replacement) {
        var t1, removeLength, insertLength, t2, delta, insertEnd, newLength;
        this.checkGrowable$1(receiver, "replace range");
        P.RangeError_checkValidRange(start, end, receiver.length, null, null, null);
        t1 = J.getInterceptor(replacement);
        if (!t1.$isEfficientLengthIterable)
          replacement = t1.toList$0(replacement);
        removeLength = J.$sub$n(end, start);
        insertLength = J.get$length$asx(replacement);
        t1 = J.getInterceptor$n(removeLength);
        t2 = J.getInterceptor$ns(start);
        if (t1.$ge(removeLength, insertLength)) {
          delta = t1.$sub(removeLength, insertLength);
          insertEnd = t2.$add(start, insertLength);
          t1 = receiver.length;
          if (typeof delta !== "number")
            return H.iae(delta);
          newLength = t1 - delta;
          this.setRange$3(receiver, start, insertEnd, replacement);
          if (delta !== 0) {
            this.setRange$4(receiver, insertEnd, newLength, receiver, end);
            this.set$length(receiver, newLength);
          }
        } else {
          delta = J.$sub$n(insertLength, removeLength);
          t1 = receiver.length;
          if (typeof delta !== "number")
            return H.iae(delta);
          newLength = t1 + delta;
          insertEnd = t2.$add(start, insertLength);
          this.set$length(receiver, newLength);
          this.setRange$4(receiver, insertEnd, newLength, receiver, end);
          this.setRange$3(receiver, start, insertEnd, replacement);
        }
      }, "call$3", "get$replaceRange", 6, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [P.int, P.int, [P.Iterable, E]]};
        }, this.$receiver, "JSArray");
      }, 3, [], 5, [], 589, [], "replaceRange"],
      any$1: [function(receiver, test) {
        var end, i;
        end = receiver.length;
        for (i = 0; i < end; ++i) {
          if (test.call$1(receiver[i]) === true)
            return true;
          if (receiver.length !== end)
            throw H.wrapException(new P.ConcurrentModificationError(receiver));
        }
        return false;
      }, "call$1", "get$any", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.bool, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "JSArray");
      }, 11, [], "any"],
      every$1: [function(receiver, test) {
        var end, i;
        end = receiver.length;
        for (i = 0; i < end; ++i) {
          if (test.call$1(receiver[i]) !== true)
            return false;
          if (receiver.length !== end)
            throw H.wrapException(new P.ConcurrentModificationError(receiver));
        }
        return true;
      }, "call$1", "get$every", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.bool, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "JSArray");
      }, 11, [], "every"],
      get$reversed: [function(receiver) {
        return new H.ReversedListIterable(receiver, [H.getTypeArgumentByIndex(receiver, 0)]);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E]};
        }, this.$receiver, "JSArray");
      }, "reversed"],
      sort$1: [function(receiver, compare) {
        var t1;
        this.checkMutable$1(receiver, "sort");
        t1 = compare == null ? P.core_Comparable_compare$closure() : compare;
        H.Sort__doSort(receiver, 0, receiver.length - 1, t1);
      }, function($receiver) {
        return this.sort$1($receiver, null);
      }, "sort$0", "call$1", "call$0", "get$sort", 0, 2, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, opt: [{func: 1, ret: P.int, args: [E, E]}]};
        }, this.$receiver, "JSArray");
      }, 0, 116, [], "sort"],
      shuffle$1: [function(receiver, random) {
        var $length, pos, t1, tmp;
        this.checkMutable$1(receiver, "shuffle");
        if (random == null)
          random = C.C__JSRandom;
        $length = receiver.length;
        for (; $length > 1;) {
          pos = random.nextInt$1($length);
          --$length;
          t1 = receiver.length;
          if ($length >= t1)
            return H.ioore(receiver, $length);
          tmp = receiver[$length];
          if (pos >>> 0 !== pos || pos >= t1)
            return H.ioore(receiver, pos);
          this.$indexSet(receiver, $length, receiver[pos]);
          this.$indexSet(receiver, pos, tmp);
        }
      }, function($receiver) {
        return this.shuffle$1($receiver, null);
      }, "shuffle$0", "call$1", "call$0", "get$shuffle", 0, 2, 304, 0, 390, [], "shuffle"],
      indexOf$2: [function(receiver, element, start) {
        var t1, i;
        t1 = J.getInterceptor$n(start);
        if (t1.$ge(start, receiver.length))
          return -1;
        if (t1.$lt(start, 0))
          start = 0;
        for (i = start; J.$lt$n(i, receiver.length); ++i) {
          if (i >>> 0 !== i || i >= receiver.length)
            return H.ioore(receiver, i);
          if (J.$eq$(receiver[i], element))
            return i;
        }
        return -1;
      }, function($receiver, element) {
        return this.indexOf$2($receiver, element, 0);
      }, "indexOf$1", "call$2", "call$1", "get$indexOf", 2, 2, 222, 7, 31, [], 3, [], "indexOf"],
      lastIndexOf$2: [function(receiver, element, startIndex) {
        var t1, i;
        if (startIndex == null)
          startIndex = receiver.length - 1;
        else {
          t1 = J.getInterceptor$n(startIndex);
          if (t1.$lt(startIndex, 0))
            return -1;
          if (t1.$ge(startIndex, receiver.length))
            startIndex = receiver.length - 1;
        }
        for (i = startIndex; J.$ge$n(i, 0); --i) {
          if (i >>> 0 !== i || i >= receiver.length)
            return H.ioore(receiver, i);
          if (J.$eq$(receiver[i], element))
            return i;
        }
        return -1;
      }, function($receiver, element) {
        return this.lastIndexOf$2($receiver, element, null);
      }, "lastIndexOf$1", "call$2", "call$1", "get$lastIndexOf", 2, 2, 222, 0, 31, [], 102, [], "lastIndexOf"],
      contains$1: [function(receiver, other) {
        var i;
        for (i = 0; i < receiver.length; ++i)
          if (J.$eq$(receiver[i], other))
            return true;
        return false;
      }, "call$1", "get$contains", 2, 0, 15, 2, [], "contains"],
      get$isEmpty: [function(receiver) {
        return receiver.length === 0;
      }, null, null, 1, 0, 5, "isEmpty"],
      get$isNotEmpty: [function(receiver) {
        return receiver.length !== 0;
      }, null, null, 1, 0, 5, "isNotEmpty"],
      toString$0: [function(receiver) {
        return P.IterableBase_iterableToFullString(receiver, "[", "]");
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      toList$1$growable: [function(receiver, growable) {
        var t1 = [H.getTypeArgumentByIndex(receiver, 0)];
        if (growable === true)
          t1 = H.setRuntimeTypeInfo(receiver.slice(), t1);
        else {
          t1 = H.setRuntimeTypeInfo(receiver.slice(), t1);
          t1.fixed$length = Array;
          t1 = t1;
        }
        return t1;
      }, function($receiver) {
        return this.toList$1$growable($receiver, true);
      }, "toList$0", "call$1$growable", "call$0", "get$toList", 0, 3, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.List, E], named: {growable: P.bool}};
        }, this.$receiver, "JSArray");
      }, 25, 88, [], "toList"],
      toSet$0: [function(receiver) {
        return P.LinkedHashSet_LinkedHashSet$from(receiver, H.getTypeArgumentByIndex(receiver, 0));
      }, "call$0", "get$toSet", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Set, E]};
        }, this.$receiver, "JSArray");
      }, "toSet"],
      get$iterator: [function(receiver) {
        return new J.ArrayIterator(receiver, receiver.length, 0, null, [H.getTypeArgumentByIndex(receiver, 0)]);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterator, E]};
        }, this.$receiver, "JSArray");
      }, "iterator"],
      get$hashCode: [function(receiver) {
        return H.Primitives_objectHashCode(receiver);
      }, null, null, 1, 0, 11, "hashCode"],
      get$length: [function(receiver) {
        return receiver.length;
      }, null, null, 1, 0, 11, "length"],
      set$length: [function(receiver, newLength) {
        if (!!receiver.fixed$length)
          H.throwExpression(new P.UnsupportedError("set length"));
        if (typeof newLength !== "number" || Math.floor(newLength) !== newLength)
          throw H.wrapException(P.ArgumentError$value(newLength, "newLength", null));
        if (newLength < 0)
          throw H.wrapException(P.RangeError$range(newLength, 0, null, "newLength", null));
        receiver.length = newLength;
      }, null, null, 3, 0, 22, 382, [], "length"],
      $index: [function(receiver, index) {
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        if (index >= receiver.length || index < 0)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        return receiver[index];
      }, null, "get$[]", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [P.int]};
        }, this.$receiver, "JSArray");
      }, 14, [], "[]"],
      $indexSet: [function(receiver, index, value) {
        if (!!receiver.immutable$list)
          H.throwExpression(new P.UnsupportedError("indexed set"));
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        if (index >= receiver.length || index < 0)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        receiver[index] = value;
      }, null, "get$[]=", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [P.int, E]};
        }, this.$receiver, "JSArray");
      }, 14, [], 1, [], "[]="],
      asMap$0: [function(receiver) {
        return new H.ListMapView(receiver, [H.getTypeArgumentByIndex(receiver, 0)]);
      }, "call$0", "get$asMap", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Map, P.int, E]};
        }, this.$receiver, "JSArray");
      }, "asMap"],
      length$0: function($receiver) {
        return this.get$length($receiver).call$0();
      },
      $isJSIndexable: 1,
      $asJSIndexable: Isolate.functionThatReturnsNull,
      $isList: 1,
      $asList: null,
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: null,
      $isIterable: 1,
      $asIterable: null,
      "<>": [545],
      static: {
        JSArray_JSArray$list: function($length, $E) {
          if (C.C__Growable === $length)
            return H.setRuntimeTypeInfo([], [$E]);
          return J.JSArray_JSArray$fixed($length, $E);
        },
        JSArray_JSArray$fixed: function($length, $E) {
          var t1;
          if (typeof $length !== "number" || Math.floor($length) !== $length)
            throw H.wrapException(P.ArgumentError$value($length, "length", "is not an integer"));
          if ($length < 0 || $length > 4294967295)
            throw H.wrapException(P.RangeError$range($length, 0, 4294967295, "length", null));
          t1 = H.setRuntimeTypeInfo(new Array($length), [$E]);
          t1.fixed$length = Array;
          return t1;
        },
        JSArray_markUnmodifiableList: function(list) {
          list.fixed$length = Array;
          list.immutable$list = Array;
          return list;
        }
      }
    },
    "+JSArray": [151, 438, 1122],
    JSMutableArray: {
      "^": "JSArray;$ti",
      $isJSIndexable: 1,
      $asJSIndexable: Isolate.functionThatReturnsNull
    },
    "+JSMutableArray": 0,
    JSFixedArray: {
      "^": "JSMutableArray;$ti"
    },
    "+JSFixedArray": 0,
    JSExtendableArray: {
      "^": "JSMutableArray;$ti"
    },
    "+JSExtendableArray": 0,
    JSUnmodifiableArray: {
      "^": "JSArray;$ti"
    },
    "+JSUnmodifiableArray": 0,
    ArrayIterator: {
      "^": "Object;__interceptors$_iterable,__interceptors$_length,__interceptors$_index,__interceptors$_current,$ti",
      get$current: [function() {
        return this.__interceptors$_current;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "ArrayIterator");
      }, "current"],
      moveNext$0: [function() {
        var t1, $length, t2;
        t1 = this.__interceptors$_iterable;
        $length = t1.length;
        if (this.__interceptors$_length !== $length)
          throw H.wrapException(H.throwConcurrentModificationError(t1));
        t2 = this.__interceptors$_index;
        if (t2 >= $length) {
          this.__interceptors$_current = null;
          return false;
        }
        this.__interceptors$_current = t1[t2];
        this.__interceptors$_index = t2 + 1;
        return true;
      }, "call$0", "get$moveNext", 0, 0, 5, "moveNext"]
    },
    "+ArrayIterator": 0,
    JSNumber: {
      "^": "Interceptor;",
      compareTo$1: [function(receiver, b) {
        var bIsNegative;
        if (typeof b !== "number")
          throw H.wrapException(H.argumentErrorValue(b));
        if (receiver < b)
          return -1;
        else if (receiver > b)
          return 1;
        else if (receiver === b) {
          if (receiver === 0) {
            bIsNegative = this.get$isNegative(b);
            if (this.get$isNegative(receiver) === bIsNegative)
              return 0;
            if (this.get$isNegative(receiver))
              return -1;
            return 1;
          }
          return 0;
        } else if (isNaN(receiver)) {
          if (this.get$isNaN(b))
            return 0;
          return 1;
        } else
          return -1;
      }, "call$1", "get$compareTo", 2, 0, 437, 78, [], "compareTo"],
      get$isNegative: [function(receiver) {
        return receiver === 0 ? 1 / receiver < 0 : receiver < 0;
      }, null, null, 1, 0, 5, "isNegative"],
      get$isNaN: [function(receiver) {
        return isNaN(receiver);
      }, null, null, 1, 0, 5, "isNaN"],
      get$isInfinite: [function(receiver) {
        return receiver == 1 / 0 || receiver == -1 / 0;
      }, null, null, 1, 0, 5, "isInfinite"],
      get$isFinite: [function(receiver) {
        return isFinite(receiver);
      }, null, null, 1, 0, 5, "isFinite"],
      remainder$1: [function(receiver, b) {
        if (typeof b !== "number")
          throw H.wrapException(H.argumentErrorValue(b));
        return receiver % b;
      }, "call$1", "get$remainder", 2, 0, 58, 78, [], "remainder"],
      abs$0: [function(receiver) {
        return Math.abs(receiver);
      }, "call$0", "get$abs", 0, 0, 155, "abs"],
      get$sign: [function(receiver) {
        var t1;
        if (receiver > 0)
          t1 = 1;
        else
          t1 = receiver < 0 ? -1 : receiver;
        return t1;
      }, null, null, 1, 0, 155, "sign"],
      toInt$0: [function(receiver) {
        var t1;
        if (receiver >= -2147483648 && receiver <= 2147483647)
          return receiver | 0;
        if (isFinite(receiver)) {
          t1 = receiver < 0 ? Math.ceil(receiver) : Math.floor(receiver);
          return t1 + 0;
        }
        throw H.wrapException(new P.UnsupportedError("" + receiver + ".toInt()"));
      }, "call$0", "get$toInt", 0, 0, 11, "toInt"],
      truncate$0: [function(receiver) {
        return this.toInt$0(receiver);
      }, "call$0", "get$truncate", 0, 0, 11, "truncate"],
      ceil$0: [function(receiver) {
        var truncated, d;
        if (receiver >= 0) {
          if (receiver <= 2147483647) {
            truncated = receiver | 0;
            return receiver === truncated ? truncated : truncated + 1;
          }
        } else if (receiver >= -2147483648)
          return receiver | 0;
        d = Math.ceil(receiver);
        if (isFinite(d))
          return d;
        throw H.wrapException(new P.UnsupportedError("" + receiver + ".ceil()"));
      }, "call$0", "get$ceil", 0, 0, 11, "ceil"],
      floor$0: [function(receiver) {
        var truncated, d;
        if (receiver >= 0) {
          if (receiver <= 2147483647)
            return receiver | 0;
        } else if (receiver >= -2147483648) {
          truncated = receiver | 0;
          return receiver === truncated ? truncated : truncated - 1;
        }
        d = Math.floor(receiver);
        if (isFinite(d))
          return d;
        throw H.wrapException(new P.UnsupportedError("" + receiver + ".floor()"));
      }, "call$0", "get$floor", 0, 0, 11, "floor"],
      round$0: [function(receiver) {
        if (receiver > 0) {
          if (receiver !== 1 / 0)
            return Math.round(receiver);
        } else if (receiver > -1 / 0)
          return 0 - Math.round(0 - receiver);
        throw H.wrapException(new P.UnsupportedError("" + receiver + ".round()"));
      }, "call$0", "get$round", 0, 0, 11, "round"],
      ceilToDouble$0: [function(receiver) {
        return Math.ceil(receiver);
      }, "call$0", "get$ceilToDouble", 0, 0, 52, "ceilToDouble"],
      floorToDouble$0: [function(receiver) {
        return Math.floor(receiver);
      }, "call$0", "get$floorToDouble", 0, 0, 52, "floorToDouble"],
      roundToDouble$0: [function(receiver) {
        if (receiver < 0)
          return -Math.round(-receiver);
        else
          return Math.round(receiver);
      }, "call$0", "get$roundToDouble", 0, 0, 52, "roundToDouble"],
      truncateToDouble$0: [function(receiver) {
        return receiver < 0 ? Math.ceil(receiver) : Math.floor(receiver);
      }, "call$0", "get$truncateToDouble", 0, 0, 52, "truncateToDouble"],
      clamp$2: [function(receiver, lowerLimit, upperLimit) {
        if (typeof lowerLimit !== "number")
          throw H.wrapException(H.argumentErrorValue(lowerLimit));
        if (typeof upperLimit !== "number")
          throw H.wrapException(H.argumentErrorValue(upperLimit));
        if (this.compareTo$1(lowerLimit, upperLimit) > 0)
          throw H.wrapException(H.argumentErrorValue(lowerLimit));
        if (this.compareTo$1(receiver, lowerLimit) < 0)
          return lowerLimit;
        if (this.compareTo$1(receiver, upperLimit) > 0)
          return upperLimit;
        return receiver;
      }, "call$2", "get$clamp", 4, 0, 1499, 379, [], 374, [], "clamp"],
      toDouble$0: [function(receiver) {
        return receiver;
      }, "call$0", "get$toDouble", 0, 0, 4, "toDouble"],
      toStringAsFixed$1: [function(receiver, fractionDigits) {
        var t1, result;
        H.checkInt(fractionDigits);
        t1 = J.getInterceptor$n(fractionDigits);
        if (t1.$lt(fractionDigits, 0) || t1.$gt(fractionDigits, 20))
          throw H.wrapException(P.RangeError$range(fractionDigits, 0, 20, "fractionDigits", null));
        result = receiver.toFixed(fractionDigits);
        if (receiver === 0 && this.get$isNegative(receiver))
          return "-" + result;
        return result;
      }, "call$1", "get$toStringAsFixed", 2, 0, 25, 599, [], "toStringAsFixed"],
      toStringAsExponential$1: [function(receiver, fractionDigits) {
        var t1, result;
        if (fractionDigits != null) {
          H.checkInt(fractionDigits);
          t1 = J.getInterceptor$n(fractionDigits);
          if (t1.$lt(fractionDigits, 0) || t1.$gt(fractionDigits, 20))
            throw H.wrapException(P.RangeError$range(fractionDigits, 0, 20, "fractionDigits", null));
          result = receiver.toExponential(fractionDigits);
        } else
          result = receiver.toExponential();
        if (receiver === 0 && this.get$isNegative(receiver))
          return "-" + result;
        return result;
      }, function($receiver) {
        return this.toStringAsExponential$1($receiver, null);
      }, "toStringAsExponential$0", "call$1", "call$0", "get$toStringAsExponential", 0, 2, 839, 0, 599, [], "toStringAsExponential"],
      toStringAsPrecision$1: [function(receiver, precision) {
        var t1, result;
        H.checkInt(precision);
        t1 = J.getInterceptor$n(precision);
        if (t1.$lt(precision, 1) || t1.$gt(precision, 21))
          throw H.wrapException(P.RangeError$range(precision, 1, 21, "precision", null));
        result = receiver.toPrecision(precision);
        if (receiver === 0 && this.get$isNegative(receiver))
          return "-" + result;
        return result;
      }, "call$1", "get$toStringAsPrecision", 2, 0, 25, 904, [], "toStringAsPrecision"],
      toRadixString$1: [function(receiver, radix) {
        var t1, result, match, exponent;
        H.checkInt(radix);
        t1 = J.getInterceptor$n(radix);
        if (t1.$lt(radix, 2) || t1.$gt(radix, 36))
          throw H.wrapException(P.RangeError$range(radix, 2, 36, "radix", null));
        result = receiver.toString(radix);
        if (C.JSString_methods.codeUnitAt$1(result, result.length - 1) !== 41)
          return result;
        match = /^([\da-z]+)(?:\.([\da-z]+))?\(e\+(\d+)\)$/.exec(result);
        if (match == null)
          H.throwExpression(new P.UnsupportedError("Unexpected toString result: " + result));
        t1 = J.getInterceptor$asx(match);
        result = t1.$index(match, 1);
        exponent = +t1.$index(match, 3);
        if (t1.$index(match, 2) != null) {
          result += t1.$index(match, 2);
          exponent -= t1.$index(match, 2).length;
        }
        return result + C.JSString_methods.$mul("0", exponent);
      }, "call$1", "get$toRadixString", 2, 0, 25, 605, [], "toRadixString"],
      toString$0: [function(receiver) {
        if (receiver === 0 && 1 / receiver < 0)
          return "-0.0";
        else
          return "" + receiver;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      get$hashCode: [function(receiver) {
        return receiver & 0x1FFFFFFF;
      }, null, null, 1, 0, 11, "hashCode"],
      $negate: [function(receiver) {
        return -receiver;
      }, null, "get$unary-", 0, 0, 155, "unary-"],
      $add: [function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver + other;
      }, null, "get$+", 2, 0, 58, 2, [], "+"],
      $sub: [function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver - other;
      }, null, "get$-", 2, 0, 58, 2, [], "-"],
      $div: [function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver / other;
      }, null, "get$/", 2, 0, 58, 2, [], "/"],
      $mul: [function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver * other;
      }, null, "get$*", 2, 0, 58, 2, [], "*"],
      $mod: [function(receiver, other) {
        var result;
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        result = receiver % other;
        if (result === 0)
          return 0;
        if (result > 0)
          return result;
        if (other < 0)
          return result - other;
        else
          return result + other;
      }, null, "get$%", 2, 0, 58, 2, [], "%"],
      $tdiv: [function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        if ((receiver | 0) === receiver)
          if (other >= 1 || other < -1)
            return receiver / other | 0;
        return this._tdivSlow$1(receiver, other);
      }, null, "get$~/", 2, 0, 437, 2, [], "~/"],
      _tdivFast$1: function(receiver, other) {
        return (receiver | 0) === receiver ? receiver / other | 0 : this._tdivSlow$1(receiver, other);
      },
      _tdivSlow$1: function(receiver, other) {
        var quotient = receiver / other;
        if (quotient >= -2147483648 && quotient <= 2147483647)
          return quotient | 0;
        if (quotient > 0) {
          if (quotient !== 1 / 0)
            return Math.floor(quotient);
        } else if (quotient > -1 / 0)
          return Math.ceil(quotient);
        throw H.wrapException(new P.UnsupportedError("Result of truncating division is " + H.S(quotient) + ": " + H.S(receiver) + " ~/ " + H.S(other)));
      },
      $shl: [function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        if (other < 0)
          throw H.wrapException(H.argumentErrorValue(other));
        return other > 31 ? 0 : receiver << other >>> 0;
      }, null, "get$<<", 2, 0, 58, 2, [], "<<"],
      _shlPositive$1: function(receiver, other) {
        return other > 31 ? 0 : receiver << other >>> 0;
      },
      $shr: [function(receiver, other) {
        var t1;
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        if (other < 0)
          throw H.wrapException(H.argumentErrorValue(other));
        if (receiver > 0)
          t1 = other > 31 ? 0 : receiver >>> other;
        else {
          t1 = other > 31 ? 31 : other;
          t1 = receiver >> t1 >>> 0;
        }
        return t1;
      }, null, "get$>>", 2, 0, 58, 2, [], ">>"],
      _shrOtherPositive$1: function(receiver, other) {
        var t1;
        if (receiver > 0)
          t1 = other > 31 ? 0 : receiver >>> other;
        else {
          t1 = other > 31 ? 31 : other;
          t1 = receiver >> t1 >>> 0;
        }
        return t1;
      },
      $and: [function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return (receiver & other) >>> 0;
      }, null, "get$&", 2, 0, 58, 2, [], "&"],
      $or: [function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return (receiver | other) >>> 0;
      }, null, "get$|", 2, 0, 58, 2, [], "|"],
      $xor: [function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return (receiver ^ other) >>> 0;
      }, null, "get$^", 2, 0, 58, 2, [], "^"],
      $lt: [function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver < other;
      }, null, "get$<", 2, 0, 199, 2, [], "<"],
      $gt: [function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver > other;
      }, null, "get$>", 2, 0, 199, 2, [], ">"],
      $le: [function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver <= other;
      }, null, "get$<=", 2, 0, 199, 2, [], "<="],
      $ge: [function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver >= other;
      }, null, "get$>=", 2, 0, 199, 2, [], ">="],
      get$runtimeType: [function(receiver) {
        return C.Type_num_cv7;
      }, null, null, 1, 0, 20, "runtimeType"],
      $isnum: 1
    },
    "+JSNumber": [151, 46],
    JSInt: {
      "^": "JSNumber;",
      get$isEven: [function(receiver) {
        return (receiver & 1) === 0;
      }, null, null, 1, 0, 5, "isEven"],
      get$isOdd: [function(receiver) {
        return (receiver & 1) === 1;
      }, null, null, 1, 0, 5, "isOdd"],
      toUnsigned$1: [function(receiver, width) {
        if (typeof width !== "number")
          return H.iae(width);
        return (receiver & this.$shl(1, width) - 1) >>> 0;
      }, "call$1", "get$toUnsigned", 2, 0, 16, 139, [], "toUnsigned"],
      toSigned$1: [function(receiver, width) {
        var t1, signMask;
        t1 = J.$sub$n(width, 1);
        if (typeof t1 !== "number")
          return H.iae(t1);
        signMask = this.$shl(1, t1);
        return ((receiver & signMask - 1) >>> 0) - ((receiver & signMask) >>> 0);
      }, "call$1", "get$toSigned", 2, 0, 16, 139, [], "toSigned"],
      get$bitLength: [function(receiver) {
        var nonneg = receiver < 0 ? -receiver - 1 : receiver;
        if (nonneg >= 4294967296)
          return J.JSInt__bitCount(J.JSInt__spread(this._tdivFast$1(nonneg, 4294967296))) + 32;
        return J.JSInt__bitCount(J.JSInt__spread(nonneg));
      }, null, null, 1, 0, 11, "bitLength"],
      modPow$2: [function(receiver, e, m) {
        var b, r;
        if (typeof e !== "number" || Math.floor(e) !== e)
          throw H.wrapException(P.ArgumentError$value(e, "exponent", "not an integer"));
        if (typeof m !== "number" || Math.floor(m) !== m)
          throw H.wrapException(P.ArgumentError$value(m, "modulus", "not an integer"));
        if (e < 0)
          throw H.wrapException(P.RangeError$range(e, 0, null, "exponent", null));
        if (m <= 0)
          throw H.wrapException(P.RangeError$range(m, 1, null, "modulus", null));
        if (e === 0)
          return 1;
        b = receiver < 0 || receiver > m ? this.$mod(receiver, m) : receiver;
        for (r = 1; e > 0;) {
          if (this.get$isOdd(e))
            r = this.$mod(r * b, m);
          e = this._tdivFast$1(e, 2);
          b = this.$mod(b * b, m);
        }
        return r;
      }, "call$2", "get$modPow", 4, 0, 70, 47, [], 173, [], "modPow"],
      modInverse$1: [function(receiver, m) {
        var t, t1;
        if (typeof m !== "number" || Math.floor(m) !== m)
          throw H.wrapException(P.ArgumentError$value(m, "modulus", "not an integer"));
        if (m <= 0)
          throw H.wrapException(P.RangeError$range(m, 1, null, "modulus", null));
        if (m === 1)
          return 0;
        t = receiver < 0 || receiver >= m ? this.$mod(receiver, m) : receiver;
        if (t === 1)
          return 1;
        if (t !== 0)
          t1 = (t & 1) === 0 && this.get$isEven(m);
        else
          t1 = true;
        if (t1)
          throw H.wrapException(P.Exception_Exception("Not coprime"));
        return J.JSInt__binaryGcd(m, t, true);
      }, "call$1", "get$modInverse", 2, 0, 16, 173, [], "modInverse"],
      gcd$1: [function(receiver, other) {
        var x, y;
        if (typeof other !== "number" || Math.floor(other) !== other)
          throw H.wrapException(P.ArgumentError$value(other, "other", "not an integer"));
        x = Math.abs(receiver);
        y = this.abs$0(other);
        if (x === 0)
          return y;
        if (y === 0)
          return x;
        if (x === 1 || y === 1)
          return 1;
        return J.JSInt__binaryGcd(x, y, false);
      }, "call$1", "get$gcd", 2, 0, 16, 2, [], "gcd"],
      get$runtimeType: [function(receiver) {
        return C.Type_int_tHn;
      }, null, null, 1, 0, 20, "runtimeType"],
      $not: [function(receiver) {
        return ~receiver >>> 0;
      }, null, "get$~", 0, 0, 11, "~"],
      $isdouble: 1,
      $isnum: 1,
      $isint: 1,
      static: {
        JSInt__binaryGcd: function(x, y, inv) {
          var s, t0, ac, v, u, a, b, c, d;
          if (!inv) {
            s = 1;
            while (true) {
              if (!(C.JSInt_methods.get$isEven(x) && (y & 1) === 0))
                break;
              x = C.JSInt_methods._tdivFast$1(x, 2);
              y = C.JSInt_methods._tdivFast$1(y, 2);
              s *= 2;
            }
            if ((y & 1) === 1) {
              t0 = y;
              y = x;
              x = t0;
            }
            inv = false;
          } else
            s = 1;
          ac = C.JSInt_methods.get$isEven(x);
          v = y;
          u = x;
          a = 1;
          b = 0;
          c = 0;
          d = 1;
          do {
            for (; C.JSInt_methods.get$isEven(u);) {
              u = C.JSInt_methods._tdivFast$1(u, 2);
              if (ac) {
                if ((a & 1) !== 0 || (b & 1) !== 0) {
                  a += y;
                  b -= x;
                }
                a = C.JSInt_methods._tdivFast$1(a, 2);
              } else if ((b & 1) !== 0)
                b -= x;
              b = C.JSInt_methods._tdivFast$1(b, 2);
            }
            for (; C.JSInt_methods.get$isEven(v);) {
              v = C.JSInt_methods._tdivFast$1(v, 2);
              if (ac) {
                if ((c & 1) !== 0 || (d & 1) !== 0) {
                  c += y;
                  d -= x;
                }
                c = C.JSInt_methods._tdivFast$1(c, 2);
              } else if ((d & 1) !== 0)
                d -= x;
              d = C.JSInt_methods._tdivFast$1(d, 2);
            }
            if (u >= v) {
              u -= v;
              if (ac)
                a -= c;
              b -= d;
            } else {
              v -= u;
              if (ac)
                c -= a;
              d -= b;
            }
          } while (u !== 0);
          if (!inv)
            return s * v;
          if (v !== 1)
            throw H.wrapException(P.Exception_Exception("Not coprime"));
          if (d < 0) {
            d += x;
            if (d < 0)
              d += x;
          } else if (d > x) {
            d -= x;
            if (d > x)
              d -= x;
          }
          return d;
        },
        JSInt__bitCount: function(i) {
          i = (i >>> 0) - (i >>> 1 & 1431655765);
          i = (i & 858993459) + (i >>> 2 & 858993459);
          i = 252645135 & i + (i >>> 4);
          i += i >>> 8;
          return i + (i >>> 16) & 63;
        },
        JSInt__spread: function(i) {
          i |= i >> 1;
          i |= i >> 2;
          i |= i >> 4;
          i |= i >> 8;
          return (i | i >> 16) >>> 0;
        }
      }
    },
    "+JSInt": [439, 23, 0],
    JSDouble: {
      "^": "JSNumber;",
      get$runtimeType: [function(receiver) {
        return C.Type_double_K1J;
      }, null, null, 1, 0, 20, "runtimeType"],
      $isdouble: 1,
      $isnum: 1
    },
    "+JSDouble": [439, 23],
    JSPositiveInt: {
      "^": "JSInt;"
    },
    "+JSPositiveInt": 0,
    JSUInt32: {
      "^": "JSPositiveInt;"
    },
    "+JSUInt32": 0,
    JSUInt31: {
      "^": "JSUInt32;"
    },
    "+JSUInt31": 0,
    JSString: {
      "^": "Interceptor;",
      codeUnitAt$1: [function(receiver, index) {
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        if (index < 0)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        if (index >= receiver.length)
          H.throwExpression(H.diagnoseIndexError(receiver, index));
        return receiver.charCodeAt(index);
      }, "call$1", "get$codeUnitAt", 2, 0, 16, 14, [], "codeUnitAt", 362],
      _codeUnitAt$1: function(receiver, index) {
        if (index >= receiver.length)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        return receiver.charCodeAt(index);
      },
      allMatches$2: [function(receiver, string, start) {
        var t1;
        H.checkString(string);
        H.checkInt(start);
        if (typeof start !== "number")
          return H.iae(start);
        if (!(0 > start)) {
          t1 = J.get$length$asx(string);
          if (typeof t1 !== "number")
            return H.iae(t1);
          t1 = start > t1;
        } else
          t1 = true;
        if (t1)
          throw H.wrapException(P.RangeError$range(start, 0, J.get$length$asx(string), null, null));
        return new H._StringAllMatchesIterable(string, receiver, start);
      }, function($receiver, string) {
        return this.allMatches$2($receiver, string, 0);
      }, "allMatches$1", "call$2", "call$1", "get$allMatches", 2, 2, 452, 7, 39, [], 3, [], "allMatches"],
      matchAsPrefix$2: [function(receiver, string, start) {
        var t1, t2, t3, i;
        t1 = J.getInterceptor$n(start);
        if (t1.$lt(start, 0) || t1.$gt(start, J.get$length$asx(string)))
          throw H.wrapException(P.RangeError$range(start, 0, J.get$length$asx(string), null, null));
        t2 = receiver.length;
        t3 = J.getInterceptor$asx(string);
        if (J.$gt$n(t1.$add(start, t2), t3.get$length(string)))
          return;
        for (i = 0; i < t2; ++i)
          if (t3.codeUnitAt$1(string, t1.$add(start, i)) !== this._codeUnitAt$1(receiver, i))
            return;
        return new H.StringMatch(start, string, receiver);
      }, function($receiver, string) {
        return this.matchAsPrefix$2($receiver, string, 0);
      }, "matchAsPrefix$1", "call$2", "call$1", "get$matchAsPrefix", 2, 2, 492, 7, 39, [], 3, [], "matchAsPrefix"],
      $add: [function(receiver, other) {
        if (typeof other !== "string")
          throw H.wrapException(P.ArgumentError$value(other, null, null));
        return receiver + other;
      }, null, "get$+", 2, 0, 28, 2, [], "+"],
      endsWith$1: [function(receiver, other) {
        var t1, otherLength, t2;
        H.checkString(other);
        t1 = J.getInterceptor$asx(other);
        otherLength = t1.get$length(other);
        t2 = receiver.length;
        if (J.$gt$n(otherLength, t2))
          return false;
        if (typeof otherLength !== "number")
          return H.iae(otherLength);
        return t1.$eq(other, this.substring$1(receiver, t2 - otherLength));
      }, "call$1", "get$endsWith", 2, 0, 30, 2, [], "endsWith"],
      replaceAll$2: [function(receiver, from, to) {
        H.checkString(to);
        return H.stringReplaceAllUnchecked(receiver, from, to);
      }, "call$2", "get$replaceAll", 4, 0, 726, 144, [], 347, [], "replaceAll"],
      replaceAllMapped$2: [function(receiver, from, convert) {
        return H.stringReplaceAllFuncUnchecked(receiver, from, convert, null);
      }, "call$2", "get$replaceAllMapped", 4, 0, 740, 144, [], 192, [], "replaceAllMapped"],
      splitMapJoin$3$onMatch$onNonMatch: [function(receiver, from, onMatch, onNonMatch) {
        return H.stringReplaceAllFuncUnchecked(receiver, from, onMatch, onNonMatch);
      }, function($receiver, from) {
        return this.splitMapJoin$3$onMatch$onNonMatch($receiver, from, null, null);
      }, "splitMapJoin$1", "call$3$onMatch$onNonMatch", "call$1", "get$splitMapJoin", 2, 5, 744, 0, 0, 144, [], 903, [], 902, [], "splitMapJoin"],
      replaceFirst$3: [function(receiver, from, to, startIndex) {
        H.checkString(to);
        H.checkInt(startIndex);
        P.RangeError_checkValueInInterval(startIndex, 0, receiver.length, "startIndex", null);
        return H.stringReplaceFirstUnchecked(receiver, from, to, startIndex);
      }, function($receiver, from, to) {
        return this.replaceFirst$3($receiver, from, to, 0);
      }, "replaceFirst$2", "call$3", "call$2", "get$replaceFirst", 4, 2, 785, 7, 144, [], 347, [], 102, [], "replaceFirst"],
      replaceFirstMapped$3: [function(receiver, from, replace, startIndex) {
        if (replace == null)
          H.throwExpression(H.argumentErrorValue(replace));
        H.checkInt(startIndex);
        P.RangeError_checkValueInInterval(startIndex, 0, receiver.length, "startIndex", null);
        return H.stringReplaceFirstMappedUnchecked(receiver, from, replace, startIndex);
      }, function($receiver, from, replace) {
        return this.replaceFirstMapped$3($receiver, from, replace, 0);
      }, "replaceFirstMapped$2", "call$3", "call$2", "get$replaceFirstMapped", 4, 2, 842, 7, 144, [], 899, [], 102, [], "replaceFirstMapped"],
      split$1: [function(receiver, pattern) {
        if (pattern == null)
          H.throwExpression(H.argumentErrorValue(pattern));
        if (typeof pattern === "string")
          return receiver.split(pattern);
        else if (pattern instanceof H.JSSyntaxRegExp && pattern.get$_nativeAnchoredVersion().exec("").length - 2 === 0)
          return receiver.split(pattern.get$_nativeRegExp());
        else
          return this._defaultSplit$1(receiver, pattern);
      }, "call$1", "get$split", 2, 0, 959, 230, [], "split"],
      replaceRange$3: [function(receiver, start, end, replacement) {
        H.checkString(replacement);
        H.checkInt(start);
        end = P.RangeError_checkValidRange(start, end, receiver.length, null, null, null);
        H.checkInt(end);
        return H.stringReplaceRangeUnchecked(receiver, start, end, replacement);
      }, "call$3", "get$replaceRange", 6, 0, 980, 3, [], 5, [], 589, [], "replaceRange"],
      _defaultSplit$1: function(receiver, pattern) {
        var result, t1, start, $length, match, matchStart, matchEnd;
        result = H.setRuntimeTypeInfo([], [P.String]);
        for (t1 = J.allMatches$1$s(pattern, receiver), t1 = t1.get$iterator(t1), start = 0, $length = 1; t1.moveNext$0();) {
          match = t1.get$current();
          matchStart = match.get$start();
          matchEnd = match.get$end();
          $length = J.$sub$n(matchEnd, matchStart);
          if (J.$eq$($length, 0) && J.$eq$(start, matchStart))
            continue;
          result.push(this.substring$2(receiver, start, matchStart));
          start = matchEnd;
        }
        if (J.$lt$n(start, receiver.length) || J.$gt$n($length, 0))
          result.push(this.substring$1(receiver, start));
        return result;
      },
      startsWith$2: [function(receiver, pattern, index) {
        var t1, endIndex;
        if (typeof index !== "number" || Math.floor(index) !== index)
          H.throwExpression(H.argumentErrorValue(index));
        t1 = J.getInterceptor$n(index);
        if (t1.$lt(index, 0) || t1.$gt(index, receiver.length))
          throw H.wrapException(P.RangeError$range(index, 0, receiver.length, null, null));
        if (typeof pattern === "string") {
          endIndex = t1.$add(index, pattern.length);
          if (J.$gt$n(endIndex, receiver.length))
            return false;
          return pattern === receiver.substring(index, endIndex);
        }
        return J.matchAsPrefix$2$s(pattern, receiver, index) != null;
      }, function($receiver, pattern) {
        return this.startsWith$2($receiver, pattern, 0);
      }, "startsWith$1", "call$2", "call$1", "get$startsWith", 2, 2, 352, 7, 230, [], 14, [], "startsWith"],
      substring$2: [function(receiver, startIndex, endIndex) {
        var t1;
        if (typeof startIndex !== "number" || Math.floor(startIndex) !== startIndex)
          H.throwExpression(H.argumentErrorValue(startIndex));
        if (endIndex == null)
          endIndex = receiver.length;
        if (typeof endIndex !== "number" || Math.floor(endIndex) !== endIndex)
          H.throwExpression(H.argumentErrorValue(endIndex));
        t1 = J.getInterceptor$n(startIndex);
        if (t1.$lt(startIndex, 0))
          throw H.wrapException(P.RangeError$value(startIndex, null, null));
        if (t1.$gt(startIndex, endIndex))
          throw H.wrapException(P.RangeError$value(startIndex, null, null));
        if (J.$gt$n(endIndex, receiver.length))
          throw H.wrapException(P.RangeError$value(endIndex, null, null));
        return receiver.substring(startIndex, endIndex);
      }, function($receiver, startIndex) {
        return this.substring$2($receiver, startIndex, null);
      }, "substring$1", "call$2", "call$1", "get$substring", 2, 2, 1013, 0, 102, [], 231, [], "substring"],
      toLowerCase$0: [function(receiver) {
        return receiver.toLowerCase();
      }, "call$0", "get$toLowerCase", 0, 0, 7, "toLowerCase"],
      toUpperCase$0: [function(receiver) {
        return receiver.toUpperCase();
      }, "call$0", "get$toUpperCase", 0, 0, 7, "toUpperCase"],
      trim$0: [function(receiver) {
        var result, endIndex, startIndex, t1, endIndex0;
        result = receiver.trim();
        endIndex = result.length;
        if (endIndex === 0)
          return result;
        if (this._codeUnitAt$1(result, 0) === 133) {
          startIndex = J.JSString__skipLeadingWhitespace(result, 1);
          if (startIndex === endIndex)
            return "";
        } else
          startIndex = 0;
        t1 = endIndex - 1;
        endIndex0 = this.codeUnitAt$1(result, t1) === 133 ? J.JSString__skipTrailingWhitespace(result, t1) : endIndex;
        if (startIndex === 0 && endIndex0 === endIndex)
          return result;
        return result.substring(startIndex, endIndex0);
      }, "call$0", "get$trim", 0, 0, 7, "trim"],
      trimLeft$0: [function(receiver) {
        var result, startIndex;
        if (typeof receiver.trimLeft != "undefined") {
          result = receiver.trimLeft();
          if (result.length === 0)
            return result;
          startIndex = this._codeUnitAt$1(result, 0) === 133 ? J.JSString__skipLeadingWhitespace(result, 1) : 0;
        } else {
          startIndex = J.JSString__skipLeadingWhitespace(receiver, 0);
          result = receiver;
        }
        if (startIndex === 0)
          return result;
        if (startIndex === result.length)
          return "";
        return result.substring(startIndex);
      }, "call$0", "get$trimLeft", 0, 0, 7, "trimLeft"],
      trimRight$0: [function(receiver) {
        var result, endIndex, t1;
        if (typeof receiver.trimRight != "undefined") {
          result = receiver.trimRight();
          endIndex = result.length;
          if (endIndex === 0)
            return result;
          t1 = endIndex - 1;
          if (this.codeUnitAt$1(result, t1) === 133)
            endIndex = J.JSString__skipTrailingWhitespace(result, t1);
        } else {
          endIndex = J.JSString__skipTrailingWhitespace(receiver, receiver.length);
          result = receiver;
        }
        if (endIndex === result.length)
          return result;
        if (endIndex === 0)
          return "";
        return result.substring(0, endIndex);
      }, "call$0", "get$trimRight", 0, 0, 7, "trimRight"],
      $mul: [function(receiver, times) {
        var s, result;
        if (typeof times !== "number")
          return H.iae(times);
        if (0 >= times)
          return "";
        if (times === 1 || receiver.length === 0)
          return receiver;
        if (times !== times >>> 0)
          throw H.wrapException(C.C_OutOfMemoryError);
        for (s = receiver, result = ""; true;) {
          if ((times & 1) === 1)
            result = s + result;
          times = times >>> 1;
          if (times === 0)
            break;
          s += s;
        }
        return result;
      }, null, "get$*", 2, 0, 25, 897, [], "*"],
      padLeft$2: [function(receiver, width, padding) {
        var delta = J.$sub$n(width, receiver.length);
        if (J.$le$n(delta, 0))
          return receiver;
        return J.$add$ns(J.$mul$ns(padding, delta), receiver);
      }, function($receiver, width) {
        return this.padLeft$2($receiver, width, " ");
      }, "padLeft$1", "call$2", "call$1", "get$padLeft", 2, 2, 353, 487, 139, [], 548, [], "padLeft"],
      padRight$2: [function(receiver, width, padding) {
        var delta = J.$sub$n(width, receiver.length);
        if (J.$le$n(delta, 0))
          return receiver;
        return this.$add(receiver, J.$mul$ns(padding, delta));
      }, function($receiver, width) {
        return this.padRight$2($receiver, width, " ");
      }, "padRight$1", "call$2", "call$1", "get$padRight", 2, 2, 353, 487, 139, [], 548, [], "padRight"],
      get$codeUnits: [function(receiver) {
        return new H.CodeUnits(receiver);
      }, null, null, 1, 0, 69, "codeUnits"],
      get$runes: [function(receiver) {
        return new P.Runes(receiver);
      }, null, null, 1, 0, 632, "runes"],
      indexOf$2: [function(receiver, pattern, start) {
        var t1, match, t2, i;
        if (pattern == null)
          H.throwExpression(H.argumentErrorValue(pattern));
        if (typeof start !== "number" || Math.floor(start) !== start)
          throw H.wrapException(H.argumentErrorValue(start));
        if (start < 0 || start > receiver.length)
          throw H.wrapException(P.RangeError$range(start, 0, receiver.length, null, null));
        if (typeof pattern === "string")
          return receiver.indexOf(pattern, start);
        t1 = J.getInterceptor(pattern);
        if (!!t1.$isJSSyntaxRegExp) {
          match = pattern._execGlobal$2(receiver, start);
          return match == null ? -1 : match._match.index;
        }
        for (t2 = receiver.length, i = start; i <= t2; ++i)
          if (t1.matchAsPrefix$2(pattern, receiver, i) != null)
            return i;
        return -1;
      }, function($receiver, pattern) {
        return this.indexOf$2($receiver, pattern, 0);
      }, "indexOf$1", "call$2", "call$1", "get$indexOf", 2, 2, 405, 7, 230, [], 3, [], "indexOf"],
      lastIndexOf$2: [function(receiver, pattern, start) {
        var t1, t2, i;
        if (pattern == null)
          H.throwExpression(H.argumentErrorValue(pattern));
        if (start == null)
          start = receiver.length;
        else if (typeof start !== "number" || Math.floor(start) !== start)
          throw H.wrapException(H.argumentErrorValue(start));
        else if (start < 0 || start > receiver.length)
          throw H.wrapException(P.RangeError$range(start, 0, receiver.length, null, null));
        if (typeof pattern === "string") {
          t1 = pattern.length;
          t2 = receiver.length;
          if (J.$add$ns(start, t1) > t2)
            start = t2 - t1;
          return receiver.lastIndexOf(pattern, start);
        }
        for (t1 = J.getInterceptor$s(pattern), i = start; t2 = J.getInterceptor$n(i), t2.$ge(i, 0); i = t2.$sub(i, 1))
          if (t1.matchAsPrefix$2(pattern, receiver, i) != null)
            return i;
        return -1;
      }, function($receiver, pattern) {
        return this.lastIndexOf$2($receiver, pattern, null);
      }, "lastIndexOf$1", "call$2", "call$1", "get$lastIndexOf", 2, 2, 405, 0, 230, [], 3, [], "lastIndexOf"],
      contains$2: [function(receiver, other, startIndex) {
        var t1;
        if (other == null)
          H.throwExpression(H.argumentErrorValue(other));
        t1 = J.getInterceptor$n(startIndex);
        if (t1.$lt(startIndex, 0) || t1.$gt(startIndex, receiver.length))
          throw H.wrapException(P.RangeError$range(startIndex, 0, receiver.length, null, null));
        return H.stringContainsUnchecked(receiver, other, startIndex);
      }, function($receiver, other) {
        return this.contains$2($receiver, other, 0);
      }, "contains$1", "call$2", "call$1", "get$contains", 2, 2, 352, 7, 2, [], 102, [], "contains"],
      get$isEmpty: [function(receiver) {
        return receiver.length === 0;
      }, null, null, 1, 0, 5, "isEmpty"],
      get$isNotEmpty: [function(receiver) {
        return receiver.length !== 0;
      }, null, null, 1, 0, 5, "isNotEmpty"],
      compareTo$1: [function(receiver, other) {
        var t1;
        if (typeof other !== "string")
          throw H.wrapException(H.argumentErrorValue(other));
        if (receiver === other)
          t1 = 0;
        else
          t1 = receiver < other ? -1 : 1;
        return t1;
      }, "call$1", "get$compareTo", 2, 0, 31, 2, [], "compareTo"],
      toString$0: [function(receiver) {
        return receiver;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      get$hashCode: [function(receiver) {
        var t1, hash, i;
        for (t1 = receiver.length, hash = 0, i = 0; i < t1; ++i) {
          hash = 536870911 & hash + receiver.charCodeAt(i);
          hash = 536870911 & hash + ((524287 & hash) << 10);
          hash ^= hash >> 6;
        }
        hash = 536870911 & hash + ((67108863 & hash) << 3);
        hash ^= hash >> 11;
        return 536870911 & hash + ((16383 & hash) << 15);
      }, null, null, 1, 0, 11, "hashCode"],
      get$runtimeType: [function(receiver) {
        return C.Type_String_k8F;
      }, null, null, 1, 0, 20, "runtimeType"],
      get$length: [function(receiver) {
        return receiver.length;
      }, null, null, 1, 0, 11, "length"],
      $index: [function(receiver, index) {
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        if (index >= receiver.length || index < 0)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        return receiver[index];
      }, null, "get$[]", 2, 0, 25, 14, [], "[]"],
      length$0: function($receiver) {
        return this.get$length($receiver).call$0();
      },
      $isJSIndexable: 1,
      $asJSIndexable: Isolate.functionThatReturnsNull,
      $isString: 1,
      $isPattern: 1,
      static: {
        JSString__isWhitespace: function(codeUnit) {
          if (codeUnit < 256)
            switch (codeUnit) {
              case 9:
              case 10:
              case 11:
              case 12:
              case 13:
              case 32:
              case 133:
              case 160:
                return true;
              default:
                return false;
            }
          switch (codeUnit) {
            case 5760:
            case 8192:
            case 8193:
            case 8194:
            case 8195:
            case 8196:
            case 8197:
            case 8198:
            case 8199:
            case 8200:
            case 8201:
            case 8202:
            case 8232:
            case 8233:
            case 8239:
            case 8287:
            case 12288:
            case 65279:
              return true;
            default:
              return false;
          }
        },
        JSString__skipLeadingWhitespace: function(string, index) {
          var t1, codeUnit;
          for (t1 = string.length; index < t1;) {
            codeUnit = C.JSString_methods._codeUnitAt$1(string, index);
            if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
              break;
            ++index;
          }
          return index;
        },
        JSString__skipTrailingWhitespace: function(string, index) {
          var index0, codeUnit;
          for (; index > 0; index = index0) {
            index0 = index - 1;
            codeUnit = C.JSString_methods.codeUnitAt$1(string, index0);
            if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
              break;
          }
          return index;
        }
      }
    },
    "+JSString": [151, 438, 9]
  }], ["dart._internal", "dart:_internal",, H, {
    "^": "",
    hexDigitValue: function(char) {
      var digit, letter;
      digit = char ^ 48;
      if (digit <= 9)
        return digit;
      letter = char | 32;
      if (97 <= letter && letter <= 102)
        return letter - 87;
      return -1;
    },
    parseHexByte: function(source, index) {
      var t1, digit1, digit2;
      t1 = J.getInterceptor$s(source);
      digit1 = H.hexDigitValue(t1.codeUnitAt$1(source, index));
      digit2 = H.hexDigitValue(t1.codeUnitAt$1(source, J.$add$ns(index, 1)));
      return digit1 * 16 + digit2 - (digit2 & 256);
    },
    IterableElementError_noElement: function() {
      return new P.StateError("No element");
    },
    IterableElementError_tooMany: function() {
      return new P.StateError("Too many elements");
    },
    IterableElementError_tooFew: function() {
      return new P.StateError("Too few elements");
    },
    makeListFixedLength: function(growableList) {
      growableList.fixed$length = Array;
      return growableList;
    },
    makeFixedListUnmodifiable: function(fixedLengthList) {
      return J.JSArray_markUnmodifiableList(fixedLengthList);
    },
    printToConsole: function(line) {
      H.printString(H.S(line));
    },
    Sort__doSort: function(a, left, right, compare) {
      if (J.$le$n(J.$sub$n(right, left), 32))
        H.Sort__insertionSort(a, left, right, compare);
      else
        H.Sort__dualPivotQuicksort(a, left, right, compare);
    },
    Sort__insertionSort: function(a, left, right, compare) {
      var i, t1, t2, el, j, t3;
      for (i = J.$add$ns(left, 1), t1 = J.getInterceptor$asx(a); t2 = J.getInterceptor$n(i), t2.$le(i, right); i = t2.$add(i, 1)) {
        el = t1.$index(a, i);
        j = i;
        while (true) {
          t3 = J.getInterceptor$n(j);
          if (!(t3.$gt(j, left) && J.$gt$n(compare.call$2(t1.$index(a, t3.$sub(j, 1)), el), 0)))
            break;
          t1.$indexSet(a, j, t1.$index(a, t3.$sub(j, 1)));
          j = t3.$sub(j, 1);
        }
        t1.$indexSet(a, j, el);
      }
    },
    Sort__dualPivotQuicksort: function(a, left, right, compare) {
      var t1, sixth, t2, index1, index5, index3, t3, index2, index4, el1, el2, el3, el4, el5, t0, less, great, k, ak, comp, t4, less0, great0, pivots_are_equal;
      t1 = J.getInterceptor$n(right);
      sixth = J.$tdiv$n(J.$add$ns(t1.$sub(right, left), 1), 6);
      t2 = J.getInterceptor$ns(left);
      index1 = t2.$add(left, sixth);
      index5 = t1.$sub(right, sixth);
      index3 = J.$tdiv$n(t2.$add(left, right), 2);
      t3 = J.getInterceptor$n(index3);
      index2 = t3.$sub(index3, sixth);
      index4 = t3.$add(index3, sixth);
      t3 = J.getInterceptor$asx(a);
      el1 = t3.$index(a, index1);
      el2 = t3.$index(a, index2);
      el3 = t3.$index(a, index3);
      el4 = t3.$index(a, index4);
      el5 = t3.$index(a, index5);
      if (J.$gt$n(compare.call$2(el1, el2), 0)) {
        t0 = el2;
        el2 = el1;
        el1 = t0;
      }
      if (J.$gt$n(compare.call$2(el4, el5), 0)) {
        t0 = el5;
        el5 = el4;
        el4 = t0;
      }
      if (J.$gt$n(compare.call$2(el1, el3), 0)) {
        t0 = el3;
        el3 = el1;
        el1 = t0;
      }
      if (J.$gt$n(compare.call$2(el2, el3), 0)) {
        t0 = el3;
        el3 = el2;
        el2 = t0;
      }
      if (J.$gt$n(compare.call$2(el1, el4), 0)) {
        t0 = el4;
        el4 = el1;
        el1 = t0;
      }
      if (J.$gt$n(compare.call$2(el3, el4), 0)) {
        t0 = el4;
        el4 = el3;
        el3 = t0;
      }
      if (J.$gt$n(compare.call$2(el2, el5), 0)) {
        t0 = el5;
        el5 = el2;
        el2 = t0;
      }
      if (J.$gt$n(compare.call$2(el2, el3), 0)) {
        t0 = el3;
        el3 = el2;
        el2 = t0;
      }
      if (J.$gt$n(compare.call$2(el4, el5), 0)) {
        t0 = el5;
        el5 = el4;
        el4 = t0;
      }
      t3.$indexSet(a, index1, el1);
      t3.$indexSet(a, index3, el3);
      t3.$indexSet(a, index5, el5);
      t3.$indexSet(a, index2, t3.$index(a, left));
      t3.$indexSet(a, index4, t3.$index(a, right));
      less = t2.$add(left, 1);
      great = t1.$sub(right, 1);
      if (J.$eq$(compare.call$2(el2, el4), 0)) {
        for (k = less; t1 = J.getInterceptor$n(k), t1.$le(k, great); k = t1.$add(k, 1)) {
          ak = t3.$index(a, k);
          comp = compare.call$2(ak, el2);
          t2 = J.getInterceptor(comp);
          if (t2.$eq(comp, 0))
            continue;
          if (t2.$lt(comp, 0)) {
            if (!t1.$eq(k, less)) {
              t3.$indexSet(a, k, t3.$index(a, less));
              t3.$indexSet(a, less, ak);
            }
            less = J.$add$ns(less, 1);
          } else
            for (; true;) {
              comp = compare.call$2(t3.$index(a, great), el2);
              t2 = J.getInterceptor$n(comp);
              if (t2.$gt(comp, 0)) {
                great = J.$sub$n(great, 1);
                continue;
              } else {
                t4 = J.getInterceptor$n(great);
                if (t2.$lt(comp, 0)) {
                  t3.$indexSet(a, k, t3.$index(a, less));
                  less0 = J.$add$ns(less, 1);
                  t3.$indexSet(a, less, t3.$index(a, great));
                  great0 = t4.$sub(great, 1);
                  t3.$indexSet(a, great, ak);
                  great = great0;
                  less = less0;
                  break;
                } else {
                  t3.$indexSet(a, k, t3.$index(a, great));
                  great0 = t4.$sub(great, 1);
                  t3.$indexSet(a, great, ak);
                  great = great0;
                  break;
                }
              }
            }
        }
        pivots_are_equal = true;
      } else {
        for (k = less; t1 = J.getInterceptor$n(k), t1.$le(k, great); k = t1.$add(k, 1)) {
          ak = t3.$index(a, k);
          if (J.$lt$n(compare.call$2(ak, el2), 0)) {
            if (!t1.$eq(k, less)) {
              t3.$indexSet(a, k, t3.$index(a, less));
              t3.$indexSet(a, less, ak);
            }
            less = J.$add$ns(less, 1);
          } else if (J.$gt$n(compare.call$2(ak, el4), 0))
            for (; true;)
              if (J.$gt$n(compare.call$2(t3.$index(a, great), el4), 0)) {
                great = J.$sub$n(great, 1);
                if (J.$lt$n(great, k))
                  break;
                continue;
              } else {
                t2 = J.getInterceptor$n(great);
                if (J.$lt$n(compare.call$2(t3.$index(a, great), el2), 0)) {
                  t3.$indexSet(a, k, t3.$index(a, less));
                  less0 = J.$add$ns(less, 1);
                  t3.$indexSet(a, less, t3.$index(a, great));
                  great0 = t2.$sub(great, 1);
                  t3.$indexSet(a, great, ak);
                  great = great0;
                  less = less0;
                } else {
                  t3.$indexSet(a, k, t3.$index(a, great));
                  great0 = t2.$sub(great, 1);
                  t3.$indexSet(a, great, ak);
                  great = great0;
                }
                break;
              }
        }
        pivots_are_equal = false;
      }
      t1 = J.getInterceptor$n(less);
      t3.$indexSet(a, left, t3.$index(a, t1.$sub(less, 1)));
      t3.$indexSet(a, t1.$sub(less, 1), el2);
      t2 = J.getInterceptor$ns(great);
      t3.$indexSet(a, right, t3.$index(a, t2.$add(great, 1)));
      t3.$indexSet(a, t2.$add(great, 1), el4);
      H.Sort__doSort(a, left, t1.$sub(less, 2), compare);
      H.Sort__doSort(a, t2.$add(great, 2), right, compare);
      if (pivots_are_equal)
        return;
      if (t1.$lt(less, index1) && t2.$gt(great, index5)) {
        for (; J.$eq$(compare.call$2(t3.$index(a, less), el2), 0);)
          less = J.$add$ns(less, 1);
        for (; J.$eq$(compare.call$2(t3.$index(a, great), el4), 0);)
          great = J.$sub$n(great, 1);
        for (k = less; t1 = J.getInterceptor$n(k), t1.$le(k, great); k = t1.$add(k, 1)) {
          ak = t3.$index(a, k);
          if (J.$eq$(compare.call$2(ak, el2), 0)) {
            if (!t1.$eq(k, less)) {
              t3.$indexSet(a, k, t3.$index(a, less));
              t3.$indexSet(a, less, ak);
            }
            less = J.$add$ns(less, 1);
          } else if (J.$eq$(compare.call$2(ak, el4), 0))
            for (; true;)
              if (J.$eq$(compare.call$2(t3.$index(a, great), el4), 0)) {
                great = J.$sub$n(great, 1);
                if (J.$lt$n(great, k))
                  break;
                continue;
              } else {
                t2 = J.getInterceptor$n(great);
                if (J.$lt$n(compare.call$2(t3.$index(a, great), el2), 0)) {
                  t3.$indexSet(a, k, t3.$index(a, less));
                  less0 = J.$add$ns(less, 1);
                  t3.$indexSet(a, less, t3.$index(a, great));
                  great0 = t2.$sub(great, 1);
                  t3.$indexSet(a, great, ak);
                  great = great0;
                  less = less0;
                } else {
                  t3.$indexSet(a, k, t3.$index(a, great));
                  great0 = t2.$sub(great, 1);
                  t3.$indexSet(a, great, ak);
                  great = great0;
                }
                break;
              }
        }
        H.Sort__doSort(a, less, great, compare);
      } else
        H.Sort__doSort(a, less, great, compare);
    },
    CodeUnits: {
      "^": "UnmodifiableListBase;__internal$_string",
      get$length: [function(_) {
        return this.__internal$_string.length;
      }, null, null, 1, 0, 11, "length"],
      $index: [function(_, i) {
        return C.JSString_methods.codeUnitAt$1(this.__internal$_string, i);
      }, null, "get$[]", 2, 0, 16, 127, [], "[]"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $asUnmodifiableListBase: function() {
        return [P.int];
      },
      $asListBase: function() {
        return [P.int];
      },
      $asObject_ListMixin: function() {
        return [P.int];
      },
      $asList: function() {
        return [P.int];
      },
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      }
    },
    "+CodeUnits": 0,
    EfficientLengthIterable: {
      "^": "Iterable;$ti",
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $asEfficientLengthIterable: null
    },
    "+EfficientLengthIterable": 0,
    ListIterable: {
      "^": "EfficientLengthIterable;$ti",
      get$iterator: [function(_) {
        return new H.ListIterator(this, this.get$length(this), 0, null, [H.getRuntimeTypeArgument(this, "ListIterable", 0)]);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterator, E]};
        }, this.$receiver, "ListIterable");
      }, "iterator"],
      forEach$1: [function(_, action) {
        var $length, i;
        $length = this.get$length(this);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          action.call$1(this.elementAt$1(0, i));
          if ($length !== this.get$length(this))
            throw H.wrapException(new P.ConcurrentModificationError(this));
        }
      }, "call$1", "get$forEach", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, v: true, args: [E]}]};
        }, this.$receiver, "ListIterable");
      }, 71, [], "forEach"],
      get$isEmpty: [function(_) {
        return J.$eq$(this.get$length(this), 0);
      }, null, null, 1, 0, 5, "isEmpty"],
      get$first: [function(_) {
        if (J.$eq$(this.get$length(this), 0))
          throw H.wrapException(H.IterableElementError_noElement());
        return this.elementAt$1(0, 0);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "ListIterable");
      }, "first"],
      get$last: [function(_) {
        if (J.$eq$(this.get$length(this), 0))
          throw H.wrapException(H.IterableElementError_noElement());
        return this.elementAt$1(0, J.$sub$n(this.get$length(this), 1));
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "ListIterable");
      }, "last"],
      get$single: [function(_) {
        if (J.$eq$(this.get$length(this), 0))
          throw H.wrapException(H.IterableElementError_noElement());
        if (J.$gt$n(this.get$length(this), 1))
          throw H.wrapException(H.IterableElementError_tooMany());
        return this.elementAt$1(0, 0);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "ListIterable");
      }, "single"],
      contains$1: [function(_, element) {
        var $length, i;
        $length = this.get$length(this);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          if (J.$eq$(this.elementAt$1(0, i), element))
            return true;
          if ($length !== this.get$length(this))
            throw H.wrapException(new P.ConcurrentModificationError(this));
        }
        return false;
      }, "call$1", "get$contains", 2, 0, 15, 31, [], "contains"],
      every$1: [function(_, test) {
        var $length, i;
        $length = this.get$length(this);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          if (test.call$1(this.elementAt$1(0, i)) !== true)
            return false;
          if ($length !== this.get$length(this))
            throw H.wrapException(new P.ConcurrentModificationError(this));
        }
        return true;
      }, "call$1", "get$every", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.bool, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "ListIterable");
      }, 11, [], "every"],
      any$1: [function(_, test) {
        var $length, i;
        $length = this.get$length(this);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          if (test.call$1(this.elementAt$1(0, i)) === true)
            return true;
          if ($length !== this.get$length(this))
            throw H.wrapException(new P.ConcurrentModificationError(this));
        }
        return false;
      }, "call$1", "get$any", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.bool, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "ListIterable");
      }, 11, [], "any"],
      firstWhere$2$orElse: [function(_, test, orElse) {
        var $length, i, element;
        $length = this.get$length(this);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          element = this.elementAt$1(0, i);
          if (test.call$1(element) === true)
            return element;
          if ($length !== this.get$length(this))
            throw H.wrapException(new P.ConcurrentModificationError(this));
        }
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      }, function($receiver, test) {
        return this.firstWhere$2$orElse($receiver, test, null);
      }, "firstWhere$1", "call$2$orElse", "call$1", "get$firstWhere", 2, 3, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: P.bool, args: [E]}], named: {orElse: {func: 1, ret: E}}};
        }, this.$receiver, "ListIterable");
      }, 0, 11, [], 67, [], "firstWhere"],
      lastWhere$2$orElse: [function(_, test, orElse) {
        var $length, t1, i, t2, element;
        $length = this.get$length(this);
        for (t1 = J.getInterceptor$n($length), i = t1.$sub($length, 1); t2 = J.getInterceptor$n(i), t2.$ge(i, 0); i = t2.$sub(i, 1)) {
          element = this.elementAt$1(0, i);
          if (test.call$1(element) === true)
            return element;
          if (!t1.$eq($length, this.get$length(this)))
            throw H.wrapException(new P.ConcurrentModificationError(this));
        }
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      }, function($receiver, test) {
        return this.lastWhere$2$orElse($receiver, test, null);
      }, "lastWhere$1", "call$2$orElse", "call$1", "get$lastWhere", 2, 3, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: P.bool, args: [E]}], named: {orElse: {func: 1, ret: E}}};
        }, this.$receiver, "ListIterable");
      }, 0, 11, [], 67, [], "lastWhere"],
      singleWhere$1: [function(_, test) {
        var $length, match, matchFound, i, element;
        $length = this.get$length(this);
        if (typeof $length !== "number")
          return H.iae($length);
        match = null;
        matchFound = false;
        i = 0;
        for (; i < $length; ++i) {
          element = this.elementAt$1(0, i);
          if (test.call$1(element) === true) {
            if (matchFound)
              throw H.wrapException(H.IterableElementError_tooMany());
            match = element;
            matchFound = true;
          }
          if ($length !== this.get$length(this))
            throw H.wrapException(new P.ConcurrentModificationError(this));
        }
        if (matchFound)
          return match;
        throw H.wrapException(H.IterableElementError_noElement());
      }, "call$1", "get$singleWhere", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "ListIterable");
      }, 11, [], "singleWhere"],
      join$1: [function(_, separator) {
        var $length, t1, first, i;
        $length = this.get$length(this);
        if (J.get$isEmpty$asx(separator) !== true) {
          t1 = J.getInterceptor($length);
          if (t1.$eq($length, 0))
            return "";
          first = H.S(this.elementAt$1(0, 0));
          if (!t1.$eq($length, this.get$length(this)))
            throw H.wrapException(new P.ConcurrentModificationError(this));
          if (typeof $length !== "number")
            return H.iae($length);
          t1 = first;
          i = 1;
          for (; i < $length; ++i) {
            t1 = t1 + H.S(separator) + H.S(this.elementAt$1(0, i));
            if ($length !== this.get$length(this))
              throw H.wrapException(new P.ConcurrentModificationError(this));
          }
          return t1.charCodeAt(0) == 0 ? t1 : t1;
        } else {
          if (typeof $length !== "number")
            return H.iae($length);
          i = 0;
          t1 = "";
          for (; i < $length; ++i) {
            t1 += H.S(this.elementAt$1(0, i));
            if ($length !== this.get$length(this))
              throw H.wrapException(new P.ConcurrentModificationError(this));
          }
          return t1.charCodeAt(0) == 0 ? t1 : t1;
        }
      }, function($receiver) {
        return this.join$1($receiver, "");
      }, "join$0", "call$1", "call$0", "get$join", 0, 2, 92, 32, 63, [], "join"],
      where$1: [function(_, test) {
        return this.super$Iterable$where(0, test);
      }, "call$1", "get$where", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "ListIterable");
      }, 11, [], "where"],
      map$1: [function(_, f) {
        return new H.MappedListIterable(this, f, [H.getRuntimeTypeArgument(this, "ListIterable", 0), null]);
      }, "call$1", "get$map", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.Iterable, args: [{func: 1, args: [E]}]};
        }, this.$receiver, "ListIterable");
      }, 9, [], "map"],
      reduce$1: [function(_, combine) {
        var $length, value, i;
        $length = this.get$length(this);
        if (J.$eq$($length, 0))
          throw H.wrapException(H.IterableElementError_noElement());
        value = this.elementAt$1(0, 0);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 1;
        for (; i < $length; ++i) {
          value = combine.call$2(value, this.elementAt$1(0, i));
          if ($length !== this.get$length(this))
            throw H.wrapException(new P.ConcurrentModificationError(this));
        }
        return value;
      }, "call$1", "get$reduce", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: E, args: [, E]}]};
        }, this.$receiver, "ListIterable");
      }, 61, [], "reduce"],
      fold$2: [function(_, initialValue, combine) {
        var $length, value, i;
        $length = this.get$length(this);
        if (typeof $length !== "number")
          return H.iae($length);
        value = initialValue;
        i = 0;
        for (; i < $length; ++i) {
          value = combine.call$2(value, this.elementAt$1(0, i));
          if ($length !== this.get$length(this))
            throw H.wrapException(new P.ConcurrentModificationError(this));
        }
        return value;
      }, "call$2", "get$fold", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, args: [, {func: 1, args: [, E]}]};
        }, this.$receiver, "ListIterable");
      }, 123, [], 61, [], "fold"],
      skip$1: [function(_, count) {
        return H.SubListIterable$(this, count, null, H.getRuntimeTypeArgument(this, "ListIterable", 0));
      }, "call$1", "get$skip", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [P.int]};
        }, this.$receiver, "ListIterable");
      }, 43, [], "skip"],
      skipWhile$1: [function(_, test) {
        return this.super$Iterable$skipWhile(0, test);
      }, "call$1", "get$skipWhile", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "ListIterable");
      }, 11, [], "skipWhile"],
      take$1: [function(_, count) {
        return H.SubListIterable$(this, 0, count, H.getRuntimeTypeArgument(this, "ListIterable", 0));
      }, "call$1", "get$take", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [P.int]};
        }, this.$receiver, "ListIterable");
      }, 43, [], "take"],
      takeWhile$1: [function(_, test) {
        return this.super$Iterable$takeWhile(0, test);
      }, "call$1", "get$takeWhile", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "ListIterable");
      }, 11, [], "takeWhile"],
      toList$1$growable: [function(_, growable) {
        var t1, result, t2, i;
        t1 = [H.getRuntimeTypeArgument(this, "ListIterable", 0)];
        if (growable === true) {
          result = H.setRuntimeTypeInfo([], t1);
          C.JSArray_methods.set$length(result, this.get$length(this));
        } else {
          t2 = this.get$length(this);
          if (typeof t2 !== "number")
            return H.iae(t2);
          t2 = new Array(t2);
          t2.fixed$length = Array;
          result = H.setRuntimeTypeInfo(t2, t1);
        }
        i = 0;
        while (true) {
          t1 = this.get$length(this);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          t1 = this.elementAt$1(0, i);
          if (i >= result.length)
            return H.ioore(result, i);
          result[i] = t1;
          ++i;
        }
        return result;
      }, function($receiver) {
        return this.toList$1$growable($receiver, true);
      }, "toList$0", "call$1$growable", "call$0", "get$toList", 0, 3, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.List, E], named: {growable: P.bool}};
        }, this.$receiver, "ListIterable");
      }, 25, 88, [], "toList"],
      toSet$0: [function(_) {
        var result, i, t1;
        result = P.LinkedHashSet_LinkedHashSet(null, null, null, H.getRuntimeTypeArgument(this, "ListIterable", 0));
        i = 0;
        while (true) {
          t1 = this.get$length(this);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          result.add$1(0, this.elementAt$1(0, i));
          ++i;
        }
        return result;
      }, "call$0", "get$toSet", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Set, E]};
        }, this.$receiver, "ListIterable");
      }, "toSet"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      }
    },
    "+ListIterable": 0,
    SubListIterable: {
      "^": "ListIterable;_iterable,_start,_endOrLength,$ti",
      get$_endIndex: function() {
        var $length, t1;
        $length = J.get$length$asx(this._iterable);
        t1 = this._endOrLength;
        if (t1 == null || J.$gt$n(t1, $length))
          return $length;
        return t1;
      },
      get$_startIndex: function() {
        var $length, t1;
        $length = J.get$length$asx(this._iterable);
        t1 = this._start;
        if (J.$gt$n(t1, $length))
          return $length;
        return t1;
      },
      get$length: [function(_) {
        var $length, t1, t2;
        $length = J.get$length$asx(this._iterable);
        t1 = this._start;
        if (J.$ge$n(t1, $length))
          return 0;
        t2 = this._endOrLength;
        if (t2 == null || J.$ge$n(t2, $length))
          return J.$sub$n($length, t1);
        return J.$sub$n(t2, t1);
      }, null, null, 1, 0, 11, "length"],
      elementAt$1: [function(_, index) {
        var realIndex = J.$add$ns(this.get$_startIndex(), index);
        if (J.$lt$n(index, 0) || J.$ge$n(realIndex, this.get$_endIndex()))
          throw H.wrapException(P.IndexError$(index, this, "index", null, null));
        return J.elementAt$1$ax(this._iterable, realIndex);
      }, "call$1", "get$elementAt", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [P.int]};
        }, this.$receiver, "SubListIterable");
      }, 14, [], "elementAt"],
      skip$1: [function(_, count) {
        var newStart, t1;
        if (J.$lt$n(count, 0))
          H.throwExpression(P.RangeError$range(count, 0, null, "count", null));
        newStart = J.$add$ns(this._start, count);
        t1 = this._endOrLength;
        if (t1 != null && J.$ge$n(newStart, t1))
          return new H.EmptyIterable(this.$ti);
        return H.SubListIterable$(this._iterable, newStart, t1, H.getTypeArgumentByIndex(this, 0));
      }, "call$1", "get$skip", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [P.int]};
        }, this.$receiver, "SubListIterable");
      }, 43, [], "skip"],
      take$1: [function(_, count) {
        var t1, t2, newEnd;
        if (J.$lt$n(count, 0))
          H.throwExpression(P.RangeError$range(count, 0, null, "count", null));
        t1 = this._endOrLength;
        t2 = this._start;
        if (t1 == null)
          return H.SubListIterable$(this._iterable, t2, J.$add$ns(t2, count), H.getTypeArgumentByIndex(this, 0));
        else {
          newEnd = J.$add$ns(t2, count);
          if (J.$lt$n(t1, newEnd))
            return this;
          return H.SubListIterable$(this._iterable, t2, newEnd, H.getTypeArgumentByIndex(this, 0));
        }
      }, "call$1", "get$take", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [P.int]};
        }, this.$receiver, "SubListIterable");
      }, 43, [], "take"],
      toList$1$growable: [function(_, growable) {
        var start, t1, t2, end, end0, $length, t3, result, t4, i;
        start = this._start;
        t1 = this._iterable;
        t2 = J.getInterceptor$asx(t1);
        end = t2.get$length(t1);
        end0 = this._endOrLength;
        if (end0 != null && J.$lt$n(end0, end))
          end = end0;
        $length = J.$sub$n(end, start);
        if (J.$lt$n($length, 0))
          $length = 0;
        t3 = this.$ti;
        if (growable === true) {
          result = H.setRuntimeTypeInfo([], t3);
          C.JSArray_methods.set$length(result, $length);
        } else {
          if (typeof $length !== "number")
            return H.iae($length);
          t4 = new Array($length);
          t4.fixed$length = Array;
          result = H.setRuntimeTypeInfo(t4, t3);
        }
        if (typeof $length !== "number")
          return H.iae($length);
        t3 = J.getInterceptor$ns(start);
        i = 0;
        for (; i < $length; ++i) {
          t4 = t2.elementAt$1(t1, t3.$add(start, i));
          if (i >= result.length)
            return H.ioore(result, i);
          result[i] = t4;
          if (J.$lt$n(t2.get$length(t1), end))
            throw H.wrapException(new P.ConcurrentModificationError(this));
        }
        return result;
      }, function($receiver) {
        return this.toList$1$growable($receiver, true);
      }, "toList$0", "call$1$growable", "call$0", "get$toList", 0, 3, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.List, E], named: {growable: P.bool}};
        }, this.$receiver, "SubListIterable");
      }, 25, 88, [], "toList"],
      SubListIterable$3: function(_iterable, _start, _endOrLength, $E) {
        var t1, t2, t3;
        t1 = this._start;
        t2 = J.getInterceptor$n(t1);
        if (t2.$lt(t1, 0))
          H.throwExpression(P.RangeError$range(t1, 0, null, "start", null));
        t3 = this._endOrLength;
        if (t3 != null) {
          if (J.$lt$n(t3, 0))
            H.throwExpression(P.RangeError$range(t3, 0, null, "end", null));
          if (t2.$gt(t1, t3))
            throw H.wrapException(P.RangeError$range(t1, 0, t3, "start", null));
        }
      },
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      static: {
        SubListIterable$: function(_iterable, _start, _endOrLength, $E) {
          var t1 = new H.SubListIterable(_iterable, _start, _endOrLength, [$E]);
          t1.SubListIterable$3(_iterable, _start, _endOrLength, $E);
          return t1;
        }
      }
    },
    "+SubListIterable": 0,
    ListIterator: {
      "^": "Object;_iterable,__internal$_length,_index,__internal$_current,$ti",
      get$current: [function() {
        return this.__internal$_current;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "ListIterator");
      }, "current"],
      moveNext$0: [function() {
        var t1, t2, $length, t3;
        t1 = this._iterable;
        t2 = J.getInterceptor$asx(t1);
        $length = t2.get$length(t1);
        if (!J.$eq$(this.__internal$_length, $length))
          throw H.wrapException(new P.ConcurrentModificationError(t1));
        t3 = this._index;
        if (typeof $length !== "number")
          return H.iae($length);
        if (t3 >= $length) {
          this.__internal$_current = null;
          return false;
        }
        this.__internal$_current = t2.elementAt$1(t1, t3);
        ++this._index;
        return true;
      }, "call$0", "get$moveNext", 0, 0, 5, "moveNext"]
    },
    "+ListIterator": 0,
    MappedIterable: {
      "^": "Iterable;_iterable,_f,$ti",
      get$iterator: [function(_) {
        return new H.MappedIterator(null, J.get$iterator$ax(this._iterable), this._f, this.$ti);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, ret: [P.Iterator, T]};
        }, this.$receiver, "MappedIterable");
      }, "iterator"],
      get$length: [function(_) {
        return J.get$length$asx(this._iterable);
      }, null, null, 1, 0, 11, "length"],
      get$isEmpty: [function(_) {
        return J.get$isEmpty$asx(this._iterable);
      }, null, null, 1, 0, 5, "isEmpty"],
      get$first: [function(_) {
        return this._f.call$1(J.get$first$ax(this._iterable));
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, ret: T};
        }, this.$receiver, "MappedIterable");
      }, "first"],
      get$last: [function(_) {
        return this._f.call$1(J.get$last$ax(this._iterable));
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, ret: T};
        }, this.$receiver, "MappedIterable");
      }, "last"],
      get$single: [function(_) {
        return this._f.call$1(J.get$single$ax(this._iterable));
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, ret: T};
        }, this.$receiver, "MappedIterable");
      }, "single"],
      elementAt$1: [function(_, index) {
        return this._f.call$1(J.elementAt$1$ax(this._iterable, index));
      }, "call$1", "get$elementAt", 2, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, ret: T, args: [P.int]};
        }, this.$receiver, "MappedIterable");
      }, 14, [], "elementAt"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $asIterable: function($S, $T) {
        return [$T];
      },
      static: {
        MappedIterable_MappedIterable: function(iterable, $function, $S, $T) {
          if (!!J.getInterceptor(iterable).$isEfficientLengthIterable)
            return new H.EfficientLengthMappedIterable(iterable, $function, [$S, $T]);
          return new H.MappedIterable(iterable, $function, [$S, $T]);
        }
      }
    },
    "+MappedIterable": 0,
    EfficientLengthMappedIterable: {
      "^": "MappedIterable;_iterable,_f,$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function($S, $T) {
        return [$T];
      },
      $asIterable: function($S, $T) {
        return [$T];
      }
    },
    "+EfficientLengthMappedIterable": 0,
    MappedIterator: {
      "^": "Iterator;__internal$_current,_iterator,_f,$ti",
      moveNext$0: [function() {
        var t1 = this._iterator;
        if (t1.moveNext$0()) {
          this.__internal$_current = this._f.call$1(t1.get$current());
          return true;
        }
        this.__internal$_current = null;
        return false;
      }, "call$0", "get$moveNext", 0, 0, 5, "moveNext"],
      get$current: [function() {
        return this.__internal$_current;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, ret: T};
        }, this.$receiver, "MappedIterator");
      }, "current"],
      $asIterator: function($S, $T) {
        return [$T];
      }
    },
    "+MappedIterator": 0,
    MappedListIterable: {
      "^": "ListIterable;__internal$_source,_f,$ti",
      get$length: [function(_) {
        return J.get$length$asx(this.__internal$_source);
      }, null, null, 1, 0, 11, "length"],
      elementAt$1: [function(_, index) {
        return this._f.call$1(J.elementAt$1$ax(this.__internal$_source, index));
      }, "call$1", "get$elementAt", 2, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, ret: T, args: [P.int]};
        }, this.$receiver, "MappedListIterable");
      }, 14, [], "elementAt"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $asListIterable: function($S, $T) {
        return [$T];
      },
      $asEfficientLengthIterable: function($S, $T) {
        return [$T];
      },
      $asIterable: function($S, $T) {
        return [$T];
      }
    },
    "+MappedListIterable": 0,
    WhereIterable: {
      "^": "Iterable;_iterable,_f,$ti",
      get$iterator: [function(_) {
        return new H.WhereIterator(J.get$iterator$ax(this._iterable), this._f, this.$ti);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterator, E]};
        }, this.$receiver, "WhereIterable");
      }, "iterator"],
      map$1: [function(_, f) {
        return new H.MappedIterable(this, f, [H.getTypeArgumentByIndex(this, 0), null]);
      }, "call$1", "get$map", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.Iterable, args: [{func: 1, args: [E]}]};
        }, this.$receiver, "WhereIterable");
      }, 9, [], "map"]
    },
    "+WhereIterable": 0,
    WhereIterator: {
      "^": "Iterator;_iterator,_f,$ti",
      moveNext$0: [function() {
        var t1, t2;
        for (t1 = this._iterator, t2 = this._f; t1.moveNext$0();)
          if (t2.call$1(t1.get$current()) === true)
            return true;
        return false;
      }, "call$0", "get$moveNext", 0, 0, 5, "moveNext"],
      get$current: [function() {
        return this._iterator.get$current();
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "WhereIterator");
      }, "current"]
    },
    "+WhereIterator": 0,
    ExpandIterable: {
      "^": "Iterable;_iterable,_f,$ti",
      get$iterator: [function(_) {
        return new H.ExpandIterator(J.get$iterator$ax(this._iterable), this._f, C.C_EmptyIterator, null, this.$ti);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, ret: [P.Iterator, T]};
        }, this.$receiver, "ExpandIterable");
      }, "iterator"],
      $asIterable: function($S, $T) {
        return [$T];
      }
    },
    "+ExpandIterable": 0,
    ExpandIterator: {
      "^": "Object;_iterator,_f,_currentExpansion,__internal$_current,$ti",
      get$current: [function() {
        return this.__internal$_current;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, ret: T};
        }, this.$receiver, "ExpandIterator");
      }, "current"],
      moveNext$0: [function() {
        var t1, t2, t3;
        t1 = this._currentExpansion;
        if (t1 == null)
          return false;
        for (t2 = this._iterator, t3 = this._f; !t1.moveNext$0();) {
          this.__internal$_current = null;
          if (t2.moveNext$0()) {
            this._currentExpansion = null;
            t1 = J.get$iterator$ax(t3.call$1(t2.get$current()));
            this._currentExpansion = t1;
          } else
            return false;
        }
        this.__internal$_current = this._currentExpansion.get$current();
        return true;
      }, "call$0", "get$moveNext", 0, 0, 5, "moveNext"]
    },
    "+ExpandIterator": 0,
    TakeIterable: {
      "^": "Iterable;_iterable,_takeCount,$ti",
      get$iterator: [function(_) {
        return new H.TakeIterator(J.get$iterator$ax(this._iterable), this._takeCount, this.$ti);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterator, E]};
        }, this.$receiver, "TakeIterable");
      }, "iterator"],
      static: {
        TakeIterable_TakeIterable: function(iterable, takeCount, $E) {
          if (typeof takeCount !== "number" || Math.floor(takeCount) !== takeCount || takeCount < 0)
            throw H.wrapException(P.ArgumentError$(takeCount));
          if (!!J.getInterceptor(iterable).$isEfficientLengthIterable)
            return new H.EfficientLengthTakeIterable(iterable, takeCount, [$E]);
          return new H.TakeIterable(iterable, takeCount, [$E]);
        }
      }
    },
    "+TakeIterable": 0,
    EfficientLengthTakeIterable: {
      "^": "TakeIterable;_iterable,_takeCount,$ti",
      get$length: [function(_) {
        var iterableLength, t1;
        iterableLength = J.get$length$asx(this._iterable);
        t1 = this._takeCount;
        if (J.$gt$n(iterableLength, t1))
          return t1;
        return iterableLength;
      }, null, null, 1, 0, 11, "length"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: null,
      $asIterable: null
    },
    "+EfficientLengthTakeIterable": 0,
    TakeIterator: {
      "^": "Iterator;_iterator,_remaining,$ti",
      moveNext$0: [function() {
        var t1 = J.$sub$n(this._remaining, 1);
        this._remaining = t1;
        if (J.$ge$n(t1, 0))
          return this._iterator.moveNext$0();
        this._remaining = -1;
        return false;
      }, "call$0", "get$moveNext", 0, 0, 5, "moveNext"],
      get$current: [function() {
        if (J.$lt$n(this._remaining, 0))
          return;
        return this._iterator.get$current();
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "TakeIterator");
      }, "current"]
    },
    "+TakeIterator": 0,
    TakeWhileIterable: {
      "^": "Iterable;_iterable,_f,$ti",
      get$iterator: [function(_) {
        return new H.TakeWhileIterator(J.get$iterator$ax(this._iterable), this._f, false, this.$ti);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterator, E]};
        }, this.$receiver, "TakeWhileIterable");
      }, "iterator"]
    },
    "+TakeWhileIterable": 0,
    TakeWhileIterator: {
      "^": "Iterator;_iterator,_f,_isFinished,$ti",
      moveNext$0: [function() {
        if (this._isFinished)
          return false;
        var t1 = this._iterator;
        if (!t1.moveNext$0() || this._f.call$1(t1.get$current()) !== true) {
          this._isFinished = true;
          return false;
        }
        return true;
      }, "call$0", "get$moveNext", 0, 0, 5, "moveNext"],
      get$current: [function() {
        if (this._isFinished)
          return;
        return this._iterator.get$current();
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "TakeWhileIterator");
      }, "current"]
    },
    "+TakeWhileIterator": 0,
    SkipIterable: {
      "^": "Iterable;_iterable,_skipCount,$ti",
      skip$1: [function(_, count) {
        var t1 = this._skipCount;
        if (typeof t1 !== "number" || Math.floor(t1) !== t1)
          throw H.wrapException(P.ArgumentError$value(t1, "count is not an integer", null));
        if (t1 < 0)
          H.throwExpression(P.RangeError$range(t1, 0, null, "count", null));
        if (typeof count !== "number")
          return H.iae(count);
        return H.SkipIterable$_(this._iterable, t1 + count, H.getTypeArgumentByIndex(this, 0));
      }, "call$1", "get$skip", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [P.int]};
        }, this.$receiver, "SkipIterable");
      }, 43, [], "skip"],
      get$iterator: [function(_) {
        return new H.SkipIterator(J.get$iterator$ax(this._iterable), this._skipCount, this.$ti);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterator, E]};
        }, this.$receiver, "SkipIterable");
      }, "iterator"],
      SkipIterable$_$2: function(_iterable, _skipCount, $E) {
        var t1 = this._skipCount;
        if (typeof t1 !== "number" || Math.floor(t1) !== t1)
          throw H.wrapException(P.ArgumentError$value(t1, "count is not an integer", null));
        if (t1 < 0)
          H.throwExpression(P.RangeError$range(t1, 0, null, "count", null));
      },
      static: {
        SkipIterable_SkipIterable: function(iterable, count, $E) {
          var t1;
          if (!!J.getInterceptor(iterable).$isEfficientLengthIterable) {
            t1 = new H.EfficientLengthSkipIterable(iterable, count, [$E]);
            t1.SkipIterable$_$2(iterable, count, $E);
            return t1;
          }
          return H.SkipIterable$_(iterable, count, $E);
        },
        SkipIterable$_: function(_iterable, _skipCount, $E) {
          var t1 = new H.SkipIterable(_iterable, _skipCount, [$E]);
          t1.SkipIterable$_$2(_iterable, _skipCount, $E);
          return t1;
        }
      }
    },
    "+SkipIterable": 0,
    EfficientLengthSkipIterable: {
      "^": "SkipIterable;_iterable,_skipCount,$ti",
      get$length: [function(_) {
        var $length = J.$sub$n(J.get$length$asx(this._iterable), this._skipCount);
        if (J.$ge$n($length, 0))
          return $length;
        return 0;
      }, null, null, 1, 0, 11, "length"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: null,
      $asIterable: null
    },
    "+EfficientLengthSkipIterable": 0,
    SkipIterator: {
      "^": "Iterator;_iterator,_skipCount,$ti",
      moveNext$0: [function() {
        var t1, i, t2;
        t1 = this._iterator;
        i = 0;
        while (true) {
          t2 = this._skipCount;
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          t1.moveNext$0();
          ++i;
        }
        this._skipCount = 0;
        return t1.moveNext$0();
      }, "call$0", "get$moveNext", 0, 0, 5, "moveNext"],
      get$current: [function() {
        return this._iterator.get$current();
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "SkipIterator");
      }, "current"]
    },
    "+SkipIterator": 0,
    SkipWhileIterable: {
      "^": "Iterable;_iterable,_f,$ti",
      get$iterator: [function(_) {
        return new H.SkipWhileIterator(J.get$iterator$ax(this._iterable), this._f, false, this.$ti);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterator, E]};
        }, this.$receiver, "SkipWhileIterable");
      }, "iterator"]
    },
    "+SkipWhileIterable": 0,
    SkipWhileIterator: {
      "^": "Iterator;_iterator,_f,_hasSkipped,$ti",
      moveNext$0: [function() {
        var t1, t2;
        if (!this._hasSkipped) {
          this._hasSkipped = true;
          for (t1 = this._iterator, t2 = this._f; t1.moveNext$0();)
            if (t2.call$1(t1.get$current()) !== true)
              return true;
        }
        return this._iterator.moveNext$0();
      }, "call$0", "get$moveNext", 0, 0, 5, "moveNext"],
      get$current: [function() {
        return this._iterator.get$current();
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "SkipWhileIterator");
      }, "current"]
    },
    "+SkipWhileIterator": 0,
    EmptyIterable: {
      "^": "EfficientLengthIterable;$ti",
      get$iterator: [function(_) {
        return C.C_EmptyIterator;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterator, E]};
        }, this.$receiver, "EmptyIterable");
      }, "iterator"],
      forEach$1: [function(_, action) {
      }, "call$1", "get$forEach", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, v: true, args: [E]}]};
        }, this.$receiver, "EmptyIterable");
      }, 71, [], "forEach"],
      get$isEmpty: [function(_) {
        return true;
      }, null, null, 1, 0, 5, "isEmpty"],
      get$length: [function(_) {
        return 0;
      }, null, null, 1, 0, 11, "length"],
      get$first: [function(_) {
        throw H.wrapException(H.IterableElementError_noElement());
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "EmptyIterable");
      }, "first"],
      get$last: [function(_) {
        throw H.wrapException(H.IterableElementError_noElement());
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "EmptyIterable");
      }, "last"],
      get$single: [function(_) {
        throw H.wrapException(H.IterableElementError_noElement());
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "EmptyIterable");
      }, "single"],
      elementAt$1: [function(_, index) {
        throw H.wrapException(P.RangeError$range(index, 0, 0, "index", null));
      }, "call$1", "get$elementAt", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [P.int]};
        }, this.$receiver, "EmptyIterable");
      }, 14, [], "elementAt"],
      contains$1: [function(_, element) {
        return false;
      }, "call$1", "get$contains", 2, 0, 15, 31, [], "contains"],
      every$1: [function(_, test) {
        return true;
      }, "call$1", "get$every", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.bool, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "EmptyIterable");
      }, 11, [], "every"],
      any$1: [function(_, test) {
        return false;
      }, "call$1", "get$any", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.bool, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "EmptyIterable");
      }, 11, [], "any"],
      firstWhere$2$orElse: [function(_, test, orElse) {
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      }, function($receiver, test) {
        return this.firstWhere$2$orElse($receiver, test, null);
      }, "firstWhere$1", "call$2$orElse", "call$1", "get$firstWhere", 2, 3, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: P.bool, args: [E]}], named: {orElse: {func: 1, ret: E}}};
        }, this.$receiver, "EmptyIterable");
      }, 0, 11, [], 67, [], "firstWhere"],
      lastWhere$2$orElse: [function(_, test, orElse) {
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      }, function($receiver, test) {
        return this.lastWhere$2$orElse($receiver, test, null);
      }, "lastWhere$1", "call$2$orElse", "call$1", "get$lastWhere", 2, 3, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: P.bool, args: [E]}], named: {orElse: {func: 1, ret: E}}};
        }, this.$receiver, "EmptyIterable");
      }, 0, 11, [], 67, [], "lastWhere"],
      singleWhere$2$orElse: [function(_, test, orElse) {
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      }, function($receiver, test) {
        return this.singleWhere$2$orElse($receiver, test, null);
      }, "singleWhere$1", "call$2$orElse", "call$1", "get$singleWhere", 2, 3, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: P.bool, args: [E]}], named: {orElse: {func: 1, ret: E}}};
        }, this.$receiver, "EmptyIterable");
      }, 0, 11, [], 67, [], "singleWhere"],
      join$1: [function(_, separator) {
        return "";
      }, function($receiver) {
        return this.join$1($receiver, "");
      }, "join$0", "call$1", "call$0", "get$join", 0, 2, 92, 32, 63, [], "join"],
      where$1: [function(_, test) {
        return this;
      }, "call$1", "get$where", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "EmptyIterable");
      }, 11, [], "where"],
      map$1: [function(_, f) {
        return C.C_EmptyIterable;
      }, "call$1", "get$map", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.Iterable, args: [{func: 1, args: [E]}]};
        }, this.$receiver, "EmptyIterable");
      }, 9, [], "map"],
      reduce$1: [function(_, combine) {
        throw H.wrapException(H.IterableElementError_noElement());
      }, "call$1", "get$reduce", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: E, args: [E, E]}]};
        }, this.$receiver, "EmptyIterable");
      }, 61, [], "reduce"],
      fold$2: [function(_, initialValue, combine) {
        return initialValue;
      }, "call$2", "get$fold", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, args: [, {func: 1, args: [, E]}]};
        }, this.$receiver, "EmptyIterable");
      }, 123, [], 61, [], "fold"],
      skip$1: [function(_, count) {
        if (J.$lt$n(count, 0))
          H.throwExpression(P.RangeError$range(count, 0, null, "count", null));
        return this;
      }, "call$1", "get$skip", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [P.int]};
        }, this.$receiver, "EmptyIterable");
      }, 43, [], "skip"],
      skipWhile$1: [function(_, test) {
        return this;
      }, "call$1", "get$skipWhile", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "EmptyIterable");
      }, 11, [], "skipWhile"],
      take$1: [function(_, count) {
        if (J.$lt$n(count, 0))
          H.throwExpression(P.RangeError$range(count, 0, null, "count", null));
        return this;
      }, "call$1", "get$take", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [P.int]};
        }, this.$receiver, "EmptyIterable");
      }, 43, [], "take"],
      takeWhile$1: [function(_, test) {
        return this;
      }, "call$1", "get$takeWhile", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "EmptyIterable");
      }, 11, [], "takeWhile"],
      toList$1$growable: [function(_, growable) {
        var t1, t2;
        t1 = this.$ti;
        if (growable === true)
          t1 = H.setRuntimeTypeInfo([], t1);
        else {
          t2 = new Array(0);
          t2.fixed$length = Array;
          t1 = H.setRuntimeTypeInfo(t2, t1);
        }
        return t1;
      }, function($receiver) {
        return this.toList$1$growable($receiver, true);
      }, "toList$0", "call$1$growable", "call$0", "get$toList", 0, 3, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.List, E], named: {growable: P.bool}};
        }, this.$receiver, "EmptyIterable");
      }, 25, 88, [], "toList"],
      toSet$0: [function(_) {
        return P.LinkedHashSet_LinkedHashSet(null, null, null, H.getTypeArgumentByIndex(this, 0));
      }, "call$0", "get$toSet", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Set, E]};
        }, this.$receiver, "EmptyIterable");
      }, "toSet"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      }
    },
    "+EmptyIterable": 0,
    EmptyIterator: {
      "^": "Object;$ti",
      moveNext$0: [function() {
        return false;
      }, "call$0", "get$moveNext", 0, 0, 5, "moveNext"],
      get$current: [function() {
        return;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "EmptyIterator");
      }, "current"]
    },
    "+EmptyIterator": 0,
    FixedLengthListMixin: {
      "^": "Object;$ti",
      set$length: [function(receiver, newLength) {
        throw H.wrapException(new P.UnsupportedError("Cannot change the length of a fixed-length list"));
      }, null, null, 3, 0, 22, 382, [], "length"],
      add$1: [function(receiver, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot add to a fixed-length list"));
      }, "call$1", "get$add", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [E]};
        }, this.$receiver, "FixedLengthListMixin");
      }, 1, [], "add"],
      insert$2: [function(receiver, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot add to a fixed-length list"));
      }, "call$2", "get$insert", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [P.int, E]};
        }, this.$receiver, "FixedLengthListMixin");
      }, 14, [], 1, [], "insert"],
      insertAll$2: [function(receiver, at, iterable) {
        throw H.wrapException(new P.UnsupportedError("Cannot add to a fixed-length list"));
      }, "call$2", "get$insertAll", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [P.int, [P.Iterable, E]]};
        }, this.$receiver, "FixedLengthListMixin");
      }, 376, [], 42, [], "insertAll"],
      addAll$1: [function(receiver, iterable) {
        throw H.wrapException(new P.UnsupportedError("Cannot add to a fixed-length list"));
      }, "call$1", "get$addAll", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [[P.Iterable, E]]};
        }, this.$receiver, "FixedLengthListMixin");
      }, 42, [], "addAll"],
      remove$1: [function(receiver, element) {
        throw H.wrapException(new P.UnsupportedError("Cannot remove from a fixed-length list"));
      }, "call$1", "get$remove", 2, 0, 15, 31, [], "remove"],
      removeWhere$1: [function(receiver, test) {
        throw H.wrapException(new P.UnsupportedError("Cannot remove from a fixed-length list"));
      }, "call$1", "get$removeWhere", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "FixedLengthListMixin");
      }, 11, [], "removeWhere"],
      retainWhere$1: [function(receiver, test) {
        throw H.wrapException(new P.UnsupportedError("Cannot remove from a fixed-length list"));
      }, "call$1", "get$retainWhere", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "FixedLengthListMixin");
      }, 11, [], "retainWhere"],
      clear$0: [function(receiver) {
        throw H.wrapException(new P.UnsupportedError("Cannot clear a fixed-length list"));
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      removeAt$1: [function(receiver, index) {
        throw H.wrapException(new P.UnsupportedError("Cannot remove from a fixed-length list"));
      }, "call$1", "get$removeAt", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [P.int]};
        }, this.$receiver, "FixedLengthListMixin");
      }, 14, [], "removeAt"],
      removeLast$0: [function(receiver) {
        throw H.wrapException(new P.UnsupportedError("Cannot remove from a fixed-length list"));
      }, "call$0", "get$removeLast", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "FixedLengthListMixin");
      }, "removeLast"],
      removeRange$2: [function(receiver, start, end) {
        throw H.wrapException(new P.UnsupportedError("Cannot remove from a fixed-length list"));
      }, "call$2", "get$removeRange", 4, 0, 76, 3, [], 5, [], "removeRange"],
      replaceRange$3: [function(receiver, start, end, iterable) {
        throw H.wrapException(new P.UnsupportedError("Cannot remove from a fixed-length list"));
      }, "call$3", "get$replaceRange", 6, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [P.int, P.int, [P.Iterable, E]]};
        }, this.$receiver, "FixedLengthListMixin");
      }, 3, [], 5, [], 42, [], "replaceRange"]
    },
    "+FixedLengthListMixin": 0,
    UnmodifiableListMixin: {
      "^": "Object;$ti",
      $indexSet: [function(_, index, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot modify an unmodifiable list"));
      }, null, "get$[]=", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [P.int, E]};
        }, this.$receiver, "UnmodifiableListMixin");
      }, 14, [], 1, [], "[]="],
      set$length: [function(_, newLength) {
        throw H.wrapException(new P.UnsupportedError("Cannot change the length of an unmodifiable list"));
      }, null, null, 3, 0, 22, 382, [], "length"],
      setAll$2: [function(_, at, iterable) {
        throw H.wrapException(new P.UnsupportedError("Cannot modify an unmodifiable list"));
      }, "call$2", "get$setAll", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [P.int, [P.Iterable, E]]};
        }, this.$receiver, "UnmodifiableListMixin");
      }, 376, [], 42, [], "setAll"],
      add$1: [function(_, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot add to an unmodifiable list"));
      }, "call$1", "get$add", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [E]};
        }, this.$receiver, "UnmodifiableListMixin");
      }, 1, [], "add"],
      insert$2: [function(_, index, element) {
        throw H.wrapException(new P.UnsupportedError("Cannot add to an unmodifiable list"));
      }, "call$2", "get$insert", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [P.int, E]};
        }, this.$receiver, "UnmodifiableListMixin");
      }, 14, [], 31, [], "insert"],
      insertAll$2: [function(_, at, iterable) {
        throw H.wrapException(new P.UnsupportedError("Cannot add to an unmodifiable list"));
      }, "call$2", "get$insertAll", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [P.int, [P.Iterable, E]]};
        }, this.$receiver, "UnmodifiableListMixin");
      }, 376, [], 42, [], "insertAll"],
      addAll$1: [function(_, iterable) {
        throw H.wrapException(new P.UnsupportedError("Cannot add to an unmodifiable list"));
      }, "call$1", "get$addAll", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [[P.Iterable, E]]};
        }, this.$receiver, "UnmodifiableListMixin");
      }, 42, [], "addAll"],
      remove$1: [function(_, element) {
        throw H.wrapException(new P.UnsupportedError("Cannot remove from an unmodifiable list"));
      }, "call$1", "get$remove", 2, 0, 15, 31, [], "remove"],
      removeWhere$1: [function(_, test) {
        throw H.wrapException(new P.UnsupportedError("Cannot remove from an unmodifiable list"));
      }, "call$1", "get$removeWhere", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "UnmodifiableListMixin");
      }, 11, [], "removeWhere"],
      retainWhere$1: [function(_, test) {
        throw H.wrapException(new P.UnsupportedError("Cannot remove from an unmodifiable list"));
      }, "call$1", "get$retainWhere", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "UnmodifiableListMixin");
      }, 11, [], "retainWhere"],
      sort$1: [function(_, compare) {
        throw H.wrapException(new P.UnsupportedError("Cannot modify an unmodifiable list"));
      }, function($receiver) {
        return this.sort$1($receiver, null);
      }, "sort$0", "call$1", "call$0", "get$sort", 0, 2, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, opt: [{func: 1, ret: P.int, args: [E, E]}]};
        }, this.$receiver, "UnmodifiableListMixin");
      }, 0, 116, [], "sort"],
      shuffle$1: [function(_, random) {
        throw H.wrapException(new P.UnsupportedError("Cannot modify an unmodifiable list"));
      }, function($receiver) {
        return this.shuffle$1($receiver, null);
      }, "shuffle$0", "call$1", "call$0", "get$shuffle", 0, 2, 304, 0, 390, [], "shuffle"],
      clear$0: [function(_) {
        throw H.wrapException(new P.UnsupportedError("Cannot clear an unmodifiable list"));
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      removeAt$1: [function(_, index) {
        throw H.wrapException(new P.UnsupportedError("Cannot remove from an unmodifiable list"));
      }, "call$1", "get$removeAt", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [P.int]};
        }, this.$receiver, "UnmodifiableListMixin");
      }, 14, [], "removeAt"],
      removeLast$0: [function(_) {
        throw H.wrapException(new P.UnsupportedError("Cannot remove from an unmodifiable list"));
      }, "call$0", "get$removeLast", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "UnmodifiableListMixin");
      }, "removeLast"],
      setRange$4: [function(_, start, end, iterable, skipCount) {
        throw H.wrapException(new P.UnsupportedError("Cannot modify an unmodifiable list"));
      }, function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      }, "setRange$3", "call$4", "call$3", "get$setRange", 6, 2, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [P.int, P.int, [P.Iterable, E]], opt: [P.int]};
        }, this.$receiver, "UnmodifiableListMixin");
      }, 7, 3, [], 5, [], 42, [], 197, [], "setRange"],
      removeRange$2: [function(_, start, end) {
        throw H.wrapException(new P.UnsupportedError("Cannot remove from an unmodifiable list"));
      }, "call$2", "get$removeRange", 4, 0, 76, 3, [], 5, [], "removeRange"],
      replaceRange$3: [function(_, start, end, iterable) {
        throw H.wrapException(new P.UnsupportedError("Cannot remove from an unmodifiable list"));
      }, "call$3", "get$replaceRange", 6, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [P.int, P.int, [P.Iterable, E]]};
        }, this.$receiver, "UnmodifiableListMixin");
      }, 3, [], 5, [], 42, [], "replaceRange"],
      fillRange$3: [function(_, start, end, fillValue) {
        throw H.wrapException(new P.UnsupportedError("Cannot modify an unmodifiable list"));
      }, function($receiver, start, end) {
        return this.fillRange$3($receiver, start, end, null);
      }, "fillRange$2", "call$3", "call$2", "get$fillRange", 4, 2, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [P.int, P.int], opt: [E]};
        }, this.$receiver, "UnmodifiableListMixin");
      }, 0, 3, [], 5, [], 588, [], "fillRange"],
      $isList: 1,
      $asList: null,
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: null,
      $isIterable: 1,
      $asIterable: null
    },
    "+UnmodifiableListMixin": 0,
    UnmodifiableListBase: {
      "^": "ListBase+UnmodifiableListMixin;$ti",
      $asList: null,
      $asEfficientLengthIterable: null,
      $asIterable: null,
      $isList: 1,
      $isEfficientLengthIterable: 1,
      $isIterable: 1
    },
    "+UnmodifiableListBase": 0,
    _ListIndicesIterable: {
      "^": "ListIterable;_backedList",
      get$length: [function(_) {
        return J.get$length$asx(this._backedList);
      }, null, null, 1, 0, 11, "length"],
      elementAt$1: [function(_, index) {
        P.RangeError_checkValidIndex(index, this, null, null, null);
        return index;
      }, "call$1", "get$elementAt", 2, 0, 16, 14, [], "elementAt"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $asListIterable: function() {
        return [P.int];
      },
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      }
    },
    "+_ListIndicesIterable": 0,
    ListMapView: {
      "^": "Object;_values,$ti",
      $index: [function(_, key) {
        var t1;
        if (typeof key === "number" && Math.floor(key) === key)
          if (key >= 0) {
            t1 = J.get$length$asx(this._values);
            if (typeof t1 !== "number")
              return H.iae(t1);
            t1 = key < t1;
          } else
            t1 = false;
        else
          t1 = false;
        return t1 ? J.$index$asx(this._values, key) : null;
      }, null, "get$[]", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [P.Object]};
        }, this.$receiver, "ListMapView");
      }, 6, [], "[]"],
      get$length: [function(_) {
        return J.get$length$asx(this._values);
      }, null, null, 1, 0, 11, "length"],
      get$values: [function() {
        return H.SubListIterable$(this._values, 0, null, H.getTypeArgumentByIndex(this, 0));
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E]};
        }, this.$receiver, "ListMapView");
      }, "values"],
      get$keys: [function() {
        return new H._ListIndicesIterable(this._values);
      }, null, null, 1, 0, 809, "keys"],
      get$isEmpty: [function(_) {
        return J.get$isEmpty$asx(this._values);
      }, null, null, 1, 0, 5, "isEmpty"],
      get$isNotEmpty: [function(_) {
        return J.get$isNotEmpty$asx(this._values);
      }, null, null, 1, 0, 5, "isNotEmpty"],
      containsValue$1: [function(value) {
        return J.contains$1$asx(this._values, value);
      }, "call$1", "get$containsValue", 2, 0, 15, 1, [], "containsValue"],
      containsKey$1: [function(key) {
        var t1;
        if (typeof key === "number" && Math.floor(key) === key)
          if (key >= 0) {
            t1 = J.get$length$asx(this._values);
            if (typeof t1 !== "number")
              return H.iae(t1);
            t1 = key < t1;
          } else
            t1 = false;
        else
          t1 = false;
        return t1;
      }, "call$1", "get$containsKey", 2, 0, 15, 6, [], "containsKey"],
      forEach$1: [function(_, f) {
        var t1, t2, $length, i;
        t1 = this._values;
        t2 = J.getInterceptor$asx(t1);
        $length = t2.get$length(t1);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          f.call$2(i, t2.$index(t1, i));
          if ($length !== t2.get$length(t1))
            throw H.wrapException(new P.ConcurrentModificationError(t1));
        }
      }, "call$1", "get$forEach", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, v: true, args: [P.int, E]}]};
        }, this.$receiver, "ListMapView");
      }, 9, [], "forEach"],
      $indexSet: [function(_, key, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot modify an unmodifiable map"));
      }, null, "get$[]=", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [P.int, E]};
        }, this.$receiver, "ListMapView");
      }, 6, [], 1, [], "[]="],
      putIfAbsent$2: [function(key, ifAbsent) {
        throw H.wrapException(new P.UnsupportedError("Cannot modify an unmodifiable map"));
      }, "call$2", "get$putIfAbsent", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [P.int, {func: 1, ret: E}]};
        }, this.$receiver, "ListMapView");
      }, 6, [], 85, [], "putIfAbsent"],
      remove$1: [function(_, key) {
        throw H.wrapException(new P.UnsupportedError("Cannot modify an unmodifiable map"));
      }, "call$1", "get$remove", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [P.Object]};
        }, this.$receiver, "ListMapView");
      }, 6, [], "remove"],
      clear$0: [function(_) {
        throw H.wrapException(new P.UnsupportedError("Cannot modify an unmodifiable map"));
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      addAll$1: [function(_, other) {
        throw H.wrapException(new P.UnsupportedError("Cannot modify an unmodifiable map"));
      }, "call$1", "get$addAll", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [[P.Map, P.int, E]]};
        }, this.$receiver, "ListMapView");
      }, 2, [], "addAll"],
      toString$0: [function(_) {
        return P.Maps_mapToString(this);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $isMap: 1,
      $asMap: function($E) {
        return [P.int, $E];
      }
    },
    "+ListMapView": 0,
    ReversedListIterable: {
      "^": "ListIterable;__internal$_source,$ti",
      get$length: [function(_) {
        return J.get$length$asx(this.__internal$_source);
      }, null, null, 1, 0, 11, "length"],
      elementAt$1: [function(_, index) {
        var t1, t2;
        t1 = this.__internal$_source;
        t2 = J.getInterceptor$asx(t1);
        return t2.elementAt$1(t1, J.$sub$n(J.$sub$n(t2.get$length(t1), 1), index));
      }, "call$1", "get$elementAt", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [P.int]};
        }, this.$receiver, "ReversedListIterable");
      }, 14, [], "elementAt"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      }
    },
    "+ReversedListIterable": 0,
    Symbol0: {
      "^": "Object;__internal$_name<",
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof H.Symbol0 && J.$eq$(this.__internal$_name, other.__internal$_name);
      }, null, "get$==", 2, 0, 24, 2, [], "=="],
      get$hashCode: [function(_) {
        var hash, t1;
        hash = this._hashCode;
        if (hash != null)
          return hash;
        t1 = J.get$hashCode$(this.__internal$_name);
        if (typeof t1 !== "number")
          return H.iae(t1);
        hash = 536870911 & 664597 * t1;
        this._hashCode = hash;
        return hash;
      }, null, null, 1, 0, 11, "hashCode"],
      toString$0: [function(_) {
        return 'Symbol("' + H.S(this.__internal$_name) + '")';
      }, "call$0", "get$toString", 0, 0, 4, "toString"],
      $isSymbol: 1,
      static: {
        Symbol_validatePublicSymbol: function($name) {
          var t1 = J.getInterceptor$asx($name);
          if (t1.get$isEmpty($name) === true || $.$get$Symbol_publicSymbolPattern()._nativeRegExp.test(H.checkString($name)))
            return $name;
          if (t1.startsWith$1($name, "_"))
            throw H.wrapException(P.ArgumentError$('"' + H.S($name) + '" is a private identifier'));
          throw H.wrapException(P.ArgumentError$('"' + H.S($name) + '" is not a valid (qualified) symbol name'));
        }
      }
    },
    "+Symbol": 0,
    _Transformation0: {
      "^": "",
      $typedefType: 1672,
      $$isTypedef: true
    },
    "+_Transformation": "",
    _ElementPredicate: {
      "^": "",
      $typedefType: 1673,
      $$isTypedef: true
    },
    "+_ElementPredicate": "",
    _ExpandFunction: {
      "^": "",
      $typedefType: 1674,
      $$isTypedef: true
    },
    "+_ExpandFunction": ""
  }], ["_isolate_helper", "dart:_isolate_helper",, H, {
    "^": "",
    _callInIsolate: function(isolate, $function) {
      var result = isolate.eval$1($function);
      if (!init.globalState.currentContext._isExecutingEvent)
        init.globalState.topEventLoop.run$0();
      return result;
    },
    enterJsAsync: function() {
      ++init.globalState.topEventLoop._activeJsAsyncCount;
    },
    leaveJsAsync: function() {
      --init.globalState.topEventLoop._activeJsAsyncCount;
    },
    isWorker: function() {
      return init.globalState.isWorker;
    },
    _currentIsolate: function() {
      return init.globalState.currentContext;
    },
    startRootIsolate: function(entry, args) {
      var t1, t2, t3, t4, t5, rootContext;
      t1 = {};
      t1.args = args;
      if (args == null) {
        args = [];
        t1.args = args;
        t2 = args;
      } else
        t2 = args;
      if (!J.getInterceptor(t2).$isList)
        throw H.wrapException(P.ArgumentError$("Arguments to main must be a List: " + H.S(t2)));
      init.globalState = new H._Manager(0, 0, 1, null, null, null, null, null, null, null, null, null, entry);
      t2 = init.globalState;
      t3 = self.window == null;
      t4 = self.Worker;
      t5 = t3 && !!self.postMessage;
      t2.isWorker = t5;
      t5 = !t5;
      if (t5)
        t4 = t4 != null && $.$get$IsolateNatives_thisScript() != null;
      else
        t4 = true;
      t2.supportsWorkers = t4;
      t2.fromCommandLine = t3 && t5;
      t2.topEventLoop = new H._EventLoop(P.ListQueue$(null, H._IsolateEvent), 0);
      t3 = P.int;
      t2.isolates = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [t3, H._IsolateContext]);
      t2.managers = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [t3, null]);
      if (t2.isWorker === true) {
        t4 = new H._MainManagerStub();
        t2.mainManager = t4;
        self.onmessage = function(f, a) {
          return function(e) {
            f(a, e);
          };
        }(H.IsolateNatives__processWorkerMessage, t4);
        self.dartPrint = self.dartPrint || function(serialize) {
          return function(object) {
            if (self.console && self.console.log)
              self.console.log(object);
            else
              self.postMessage(serialize(object));
          };
        }(H._Manager__serializePrintMessage);
      }
      if (init.globalState.isWorker === true)
        return;
      t2 = init.globalState.nextIsolateId++;
      t4 = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [t3, H.RawReceivePortImpl]);
      t3 = P.LinkedHashSet_LinkedHashSet(null, null, null, t3);
      t5 = new H.RawReceivePortImpl(0, null, false);
      rootContext = new H._IsolateContext(t2, t4, t3, init.createNewIsolate(), t5, new H.CapabilityImpl(H.random64()), new H.CapabilityImpl(H.random64()), false, false, [], P.LinkedHashSet_LinkedHashSet(null, null, null, null), null, null, false, true, P.LinkedHashSet_LinkedHashSet(null, null, null, null));
      t3.add$1(0, 0);
      rootContext._addRegistration$2(0, t5);
      init.globalState.rootContext = rootContext;
      init.globalState.currentContext = rootContext;
      if (H.functionTypeTest(entry, {func: 1, args: [,]}))
        rootContext.eval$1(new H.startRootIsolate_closure(t1, entry));
      else if (H.functionTypeTest(entry, {func: 1, args: [,,]}))
        rootContext.eval$1(new H.startRootIsolate_closure0(t1, entry));
      else
        rootContext.eval$1(entry);
      init.globalState.topEventLoop.run$0();
    },
    _globalState: function() {
      return init.globalState;
    },
    _globalState0: function(val) {
      init.globalState = val;
    },
    globalWindow: function() {
      return self.window;
    },
    globalWorker: function() {
      return self.Worker;
    },
    globalPostMessageDefined: function() {
      return !!self.postMessage;
    },
    IsolateNatives_computeThisScript: function() {
      var currentScript = init.currentScript;
      if (currentScript != null)
        return String(currentScript.src);
      if (init.globalState.isWorker === true)
        return H.IsolateNatives_computeThisScriptFromTrace();
      return;
    },
    IsolateNatives_computeThisScriptFromTrace: function() {
      var stack, matches;
      stack = new Error().stack;
      if (stack == null) {
        stack = function() {
          try {
            throw new Error();
          } catch (e) {
            return e.stack;
          }
        }();
        if (stack == null)
          throw H.wrapException(new P.UnsupportedError("No stack trace"));
      }
      matches = stack.match(new RegExp("^ *at [^(]*\\((.*):[0-9]*:[0-9]*\\)$", "m"));
      if (matches != null)
        return matches[1];
      matches = stack.match(new RegExp("^[^@]*@(.*):[0-9]*$", "m"));
      if (matches != null)
        return matches[1];
      throw H.wrapException(new P.UnsupportedError('Cannot extract URI from "' + H.S(stack) + '"'));
    },
    IsolateNatives__processWorkerMessage: [function(sender, e) {
      var msg, t1, functionName, entryPoint, args, message, isSpawnUri, startPaused, replyTo, t2, t3, t4, context;
      msg = new H._Deserializer(true, []).deserialize$1(e.data);
      t1 = J.getInterceptor$asx(msg);
      switch (t1.$index(msg, "command")) {
        case "start":
          init.globalState.currentManagerId = t1.$index(msg, "id");
          functionName = t1.$index(msg, "functionName");
          entryPoint = functionName == null ? init.globalState.entry : init.globalFunctions[functionName]();
          args = t1.$index(msg, "args");
          message = new H._Deserializer(true, []).deserialize$1(t1.$index(msg, "msg"));
          isSpawnUri = t1.$index(msg, "isSpawnUri");
          startPaused = t1.$index(msg, "startPaused");
          replyTo = new H._Deserializer(true, []).deserialize$1(t1.$index(msg, "replyTo"));
          t1 = init.globalState.nextIsolateId++;
          t2 = P.int;
          t3 = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [t2, H.RawReceivePortImpl]);
          t2 = P.LinkedHashSet_LinkedHashSet(null, null, null, t2);
          t4 = new H.RawReceivePortImpl(0, null, false);
          context = new H._IsolateContext(t1, t3, t2, init.createNewIsolate(), t4, new H.CapabilityImpl(H.random64()), new H.CapabilityImpl(H.random64()), false, false, [], P.LinkedHashSet_LinkedHashSet(null, null, null, null), null, null, false, true, P.LinkedHashSet_LinkedHashSet(null, null, null, null));
          t2.add$1(0, 0);
          context._addRegistration$2(0, t4);
          init.globalState.topEventLoop.events._add$1(new H._IsolateEvent(context, new H.IsolateNatives__processWorkerMessage_closure(entryPoint, args, message, isSpawnUri, startPaused, replyTo), "worker-start"));
          init.globalState.currentContext = context;
          init.globalState.topEventLoop.run$0();
          break;
        case "spawn-worker":
          if ($.IsolateNatives_enableSpawnWorker != null)
            H.IsolateNatives_handleSpawnWorkerRequest(msg);
          break;
        case "message":
          if (t1.$index(msg, "port") != null)
            t1.$index(msg, "port").send$1(t1.$index(msg, "msg"));
          init.globalState.topEventLoop.run$0();
          break;
        case "close":
          init.globalState.managers.remove$1(0, $.$get$IsolateNatives_workerIds().$index(0, sender));
          sender.terminate();
          init.globalState.topEventLoop.run$0();
          break;
        case "log":
          H.IsolateNatives__log(t1.$index(msg, "msg"));
          break;
        case "print":
          if (init.globalState.isWorker === true) {
            t1 = init.globalState.mainManager;
            t2 = P.LinkedHashMap__makeLiteral(["command", "print", "msg", msg]);
            t2 = new H._Serializer(true, P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6(null, P.int)).serialize$1(t2);
            t1.toString;
            self.postMessage(t2);
          } else
            P.print(t1.$index(msg, "msg"));
          break;
        case "error":
          throw H.wrapException(t1.$index(msg, "msg"));
      }
    }, null, null, 4, 0, null, 583, [], 47, []],
    IsolateNatives_handleSpawnWorkerRequest: function(msg) {
      var t1, replyPort;
      t1 = J.getInterceptor$asx(msg);
      replyPort = t1.$index(msg, "replyPort");
      H.IsolateNatives_spawn(t1.$index(msg, "functionName"), t1.$index(msg, "uri"), t1.$index(msg, "args"), t1.$index(msg, "msg"), false, t1.$index(msg, "isSpawnUri"), t1.$index(msg, "startPaused")).then$2$onError(new H.IsolateNatives_handleSpawnWorkerRequest_closure(replyPort), new H.IsolateNatives_handleSpawnWorkerRequest_closure0(replyPort));
    },
    IsolateNatives__log: function(msg) {
      var trace, t1, t2, exception;
      if (init.globalState.isWorker === true) {
        t1 = init.globalState.mainManager;
        t2 = P.LinkedHashMap__makeLiteral(["command", "log", "msg", msg]);
        t2 = new H._Serializer(true, P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6(null, P.int)).serialize$1(t2);
        t1.toString;
        self.postMessage(t2);
      } else
        try {
          self.console.log(msg);
        } catch (exception) {
          H.unwrapException(exception);
          trace = H.getTraceFromException(exception);
          throw H.wrapException(P.Exception_Exception(trace));
        }
    },
    IsolateNatives_spawn: function(functionName, uri, args, message, isLight, isSpawnUri, startPaused) {
      var t1, t2, t3, port, completer, signalReply, worker;
      if (uri != null && J.endsWith$1$s(uri, ".dart"))
        uri = J.$add$ns(uri, ".js");
      t1 = $.RawReceivePortImpl__nextFreeId;
      $.RawReceivePortImpl__nextFreeId = t1 + 1;
      t2 = new H.RawReceivePortImpl(t1, null, false);
      t3 = init.globalState.currentContext;
      t3._addRegistration$2(t1, t2);
      t3._updateGlobalState$0();
      port = new H.ReceivePortImpl(t2, null);
      port.ReceivePortImpl$fromRawReceivePort$1(t2);
      t3 = new P._Future(0, $.Zone__current, null, [null]);
      completer = new P._AsyncCompleter(t3, [null]);
      port.get$first(port).then$1(new H.IsolateNatives_spawn_closure(completer));
      signalReply = t2.get$sendPort();
      if (init.globalState.supportsWorkers === true && true) {
        if (args != null)
          args = P.List_List$from(args, true, P.String);
        if (init.globalState.isWorker === true) {
          t1 = init.globalState.mainManager;
          t2 = P.LinkedHashMap__makeLiteral(["command", "spawn-worker", "functionName", functionName, "args", args, "msg", message, "uri", uri, "isSpawnUri", isSpawnUri, "startPaused", startPaused, "replyPort", signalReply]);
          t2 = new H._Serializer(true, P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6(null, P.int)).serialize$1(t2);
          t1.toString;
          self.postMessage(t2);
        } else {
          if (uri == null)
            uri = $.$get$IsolateNatives_thisScript();
          worker = new Worker(uri);
          worker.onerror = function(f, u, c) {
            return function(e) {
              return f(e, u, c);
            };
          }(H.IsolateNatives_workerOnError, uri, new H.IsolateNatives_spawn_closure0(completer));
          worker.onmessage = function(f, a) {
            return function(e) {
              e.onerror = null;
              return f(a, e);
            };
          }(H.IsolateNatives__processWorkerMessage, worker);
          t1 = init.globalState.nextManagerId++;
          $.$get$IsolateNatives_workerIds().$indexSet(0, worker, t1);
          init.globalState.managers.$indexSet(0, t1, worker);
          t2 = P.int;
          t1 = P.LinkedHashMap__makeLiteral(["command", "start", "id", t1, "replyTo", new H._Serializer(true, P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6(null, t2)).serialize$1(signalReply), "args", args, "msg", new H._Serializer(true, P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6(null, t2)).serialize$1(message), "isSpawnUri", isSpawnUri, "startPaused", startPaused, "functionName", functionName]);
          worker.postMessage(new H._Serializer(true, P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6(null, t2)).serialize$1(t1));
        }
      } else
        H.IsolateNatives__startNonWorker(functionName, uri, args, message, isSpawnUri, startPaused, signalReply);
      return t3;
    },
    IsolateNatives__startNonWorker: function(functionName, uri, args, message, isSpawnUri, startPaused, replyPort) {
      var t1, t2, t3, t4, t5, t6;
      t1 = {};
      t1.args = args;
      t1.message = message;
      if (uri != null)
        throw H.wrapException(new P.UnsupportedError("Currently spawnUri is not supported without web workers."));
      t1.message = H._clone(message);
      if (args != null)
        t1.args = P.List_List$from(args, true, P.String);
      t2 = init.globalState.topEventLoop;
      t3 = init.globalState.nextIsolateId++;
      t4 = P.int;
      t5 = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [t4, H.RawReceivePortImpl]);
      t4 = P.LinkedHashSet_LinkedHashSet(null, null, null, t4);
      t6 = new H.RawReceivePortImpl(0, null, false);
      t5 = new H._IsolateContext(t3, t5, t4, init.createNewIsolate(), t6, new H.CapabilityImpl(H.random64()), new H.CapabilityImpl(H.random64()), false, false, [], P.LinkedHashSet_LinkedHashSet(null, null, null, null), null, null, false, true, P.LinkedHashSet_LinkedHashSet(null, null, null, null));
      t4.add$1(0, 0);
      t5._addRegistration$2(0, t6);
      t2.events._add$1(new H._IsolateEvent(t5, new H.IsolateNatives__startNonWorker_closure(t1, functionName, isSpawnUri, startPaused, replyPort), "nonworker start"));
    },
    IsolateNatives__startIsolate: function(topLevel, args, message, isSpawnUri, startPaused, replyTo) {
      var context, t1, t2;
      context = init.globalState.currentContext;
      t1 = context.id;
      $.Primitives_mirrorFunctionCacheName = $.Primitives_mirrorFunctionCacheName + ("_" + t1);
      $.Primitives_mirrorInvokeCacheName = $.Primitives_mirrorInvokeCacheName + ("_" + t1);
      t1 = context.controlPort.get$sendPort();
      t2 = context.pauseCapability;
      replyTo.send$1(["spawned", t1, t2, context.terminateCapability]);
      t1 = new H.IsolateNatives__startIsolate_runStartFunction(topLevel, args, message, isSpawnUri, context);
      if (startPaused === true) {
        context.addPause$2(t2, t2);
        init.globalState.topEventLoop.events._add$1(new H._IsolateEvent(context, t1, "start isolate"));
      } else
        t1.call$0();
    },
    IsolateNatives_workerOnError: [function($event, uri, onError) {
      var message;
      $event.preventDefault();
      message = $event.message;
      onError.call$1(message == null ? "Error spawning worker for " + H.S(uri) : "Error spawning worker for " + H.S(uri) + " (" + message + ")");
      return true;
    }, null, null, 6, 0, null, 110, [], 40, [], 20, []],
    hasTimer: function() {
      return self.setTimeout != null;
    },
    _serializeMessage: function(message) {
      return new H._Serializer(true, P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6(null, P.int)).serialize$1(message);
    },
    _deserializeMessage: function(message) {
      return new H._Deserializer(true, []).deserialize$1(message);
    },
    _clone: function(message) {
      return new H._Deserializer(true, []).deserialize$1(new H._Serializer(false, P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6(null, P.int)).serialize$1(message));
    },
    startRootIsolate_closure: {
      "^": "Closure:4;_box_0,entry",
      call$0: [function() {
        this.entry.call$1(this._box_0.args);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ startRootIsolate_closure": [2],
    startRootIsolate_closure0: {
      "^": "Closure:4;_box_0,entry",
      call$0: [function() {
        this.entry.call$2(this._box_0.args, null);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ startRootIsolate_closure": [2],
    _Manager: {
      "^": "Object;nextIsolateId,currentManagerId,nextManagerId,currentContext,rootContext,topEventLoop,fromCommandLine,isWorker,supportsWorkers,isolates,mainManager,managers,entry",
      static: {
        _Manager__serializePrintMessage: [function(object) {
          var t1 = P.LinkedHashMap__makeLiteral(["command", "print", "msg", object]);
          return new H._Serializer(true, P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6(null, P.int)).serialize$1(t1);
        }, null, null, 2, 0, null, 23, []]
      }
    },
    "+_Manager": 0,
    _IsolateContext: {
      "^": "Object;id<,ports,weakPorts,isolateStatics<,controlPort<,pauseCapability<,terminateCapability<,initialized?,isPaused<,delayedEvents<,pauseTokens,doneHandlers,_scheduledControlEvents,_isExecutingEvent,errorsAreFatal,errorPorts",
      addPause$2: function(authentification, resume) {
        if (!this.pauseCapability.$eq(0, authentification))
          return;
        if (this.pauseTokens.add$1(0, resume) && !this.isPaused)
          this.isPaused = true;
        this._updateGlobalState$0();
      },
      removePause$1: function(resume) {
        var t1, t2, $event, t3;
        if (!this.isPaused)
          return;
        t1 = this.pauseTokens;
        t1.remove$1(0, resume);
        if (t1._collection$_length === 0) {
          for (t1 = this.delayedEvents; t2 = t1.length, t2 !== 0;) {
            if (0 >= t2)
              return H.ioore(t1, -1);
            $event = t1.pop();
            t2 = init.globalState.topEventLoop.events;
            t3 = J.$and$n(J.$sub$n(t2._head, 1), J.$sub$n(J.get$length$asx(t2._table), 1));
            t2._head = t3;
            J.$indexSet$ax(t2._table, t3, $event);
            if (J.$eq$(t2._head, t2._tail))
              t2._grow$0();
            t2._modificationCount = J.$add$ns(t2._modificationCount, 1);
          }
          this.isPaused = false;
        }
        this._updateGlobalState$0();
      },
      addDoneListener$2: function(responsePort, response) {
        var t1, i, t2;
        if (this.doneHandlers == null)
          this.doneHandlers = [];
        for (t1 = J.getInterceptor(responsePort), i = 0; t2 = this.doneHandlers, i < t2.length; i += 2)
          if (t1.$eq(responsePort, t2[i])) {
            t1 = this.doneHandlers;
            t2 = i + 1;
            if (t2 >= t1.length)
              return H.ioore(t1, t2);
            t1[t2] = response;
            return;
          }
        t2.push(responsePort);
        this.doneHandlers.push(response);
      },
      removeDoneListener$1: function(responsePort) {
        var t1, i, t2;
        if (this.doneHandlers == null)
          return;
        for (t1 = J.getInterceptor(responsePort), i = 0; t2 = this.doneHandlers, i < t2.length; i += 2)
          if (t1.$eq(responsePort, t2[i])) {
            t1 = this.doneHandlers;
            t2 = i + 2;
            t1.toString;
            if (typeof t1 !== "object" || t1 === null || !!t1.fixed$length)
              H.throwExpression(new P.UnsupportedError("removeRange"));
            P.RangeError_checkValidRange(i, t2, t1.length, null, null, null);
            t1.splice(i, t2 - i);
            return;
          }
      },
      setErrorsFatal$2: function(authentification, errorsAreFatal) {
        if (!this.terminateCapability.$eq(0, authentification))
          return;
        this.errorsAreFatal = errorsAreFatal;
      },
      handlePing$3: function(responsePort, pingType, response) {
        var t1 = J.getInterceptor(pingType);
        if (!t1.$eq(pingType, 0))
          t1 = t1.$eq(pingType, 1) && !this._isExecutingEvent;
        else
          t1 = true;
        if (t1) {
          responsePort.send$1(response);
          return;
        }
        t1 = this._scheduledControlEvents;
        if (t1 == null) {
          t1 = P.ListQueue$(null, null);
          this._scheduledControlEvents = t1;
        }
        t1._add$1(new H._IsolateContext_handlePing_respond(responsePort, response));
      },
      handleKill$2: function(authentification, priority) {
        var t1;
        if (!this.terminateCapability.$eq(0, authentification))
          return;
        t1 = J.getInterceptor(priority);
        if (!t1.$eq(priority, 0))
          t1 = t1.$eq(priority, 1) && !this._isExecutingEvent;
        else
          t1 = true;
        if (t1) {
          this.kill$0();
          return;
        }
        t1 = this._scheduledControlEvents;
        if (t1 == null) {
          t1 = P.ListQueue$(null, null);
          this._scheduledControlEvents = t1;
        }
        t1._add$1(this.get$kill());
      },
      addErrorListener$1: function(port) {
        this.errorPorts.add$1(0, port);
      },
      removeErrorListener$1: function(port) {
        this.errorPorts.remove$1(0, port);
      },
      handleUncaughtError$2: [function(error, stackTrace) {
        var t1, message, t2;
        t1 = this.errorPorts;
        if (t1._collection$_length === 0) {
          if (this.errorsAreFatal === true && this === init.globalState.rootContext)
            return;
          if (self.console && self.console.error)
            self.console.error(error, stackTrace);
          else {
            P.print(error);
            if (stackTrace != null)
              P.print(stackTrace);
          }
          return;
        }
        message = new Array(2);
        message.fixed$length = Array;
        message[0] = J.toString$0$(error);
        message[1] = stackTrace == null ? null : J.toString$0$(stackTrace);
        for (t2 = new P._LinkedHashSetIterator(t1, t1._collection$_modifications, null, null, [null]), t2._collection$_cell = t1._collection$_first; t2.moveNext$0();)
          t2._collection$_current.send$1(message);
      }, "call$2", "get$handleUncaughtError", 4, 0, 71, 8, [], 12, []],
      eval$1: function(code) {
        var old, result, oldIsExecutingEvent, e, s, exception, t1;
        old = init.globalState.currentContext;
        init.globalState.currentContext = this;
        $ = this.isolateStatics;
        result = null;
        oldIsExecutingEvent = this._isExecutingEvent;
        this._isExecutingEvent = true;
        try {
          result = code.call$0();
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          this.handleUncaughtError$2(e, s);
          if (this.errorsAreFatal === true) {
            this.kill$0();
            if (this === init.globalState.rootContext)
              throw exception;
          }
        } finally {
          this._isExecutingEvent = oldIsExecutingEvent;
          init.globalState.currentContext = old;
          if (old != null)
            $ = old.get$isolateStatics();
          if (this._scheduledControlEvents != null)
            for (; t1 = this._scheduledControlEvents, !t1.get$isEmpty(t1);)
              this._scheduledControlEvents.removeFirst$0().call$0();
        }
        return result;
      },
      handleControlMessage$1: function(message) {
        var t1 = J.getInterceptor$asx(message);
        switch (t1.$index(message, 0)) {
          case "pause":
            this.addPause$2(t1.$index(message, 1), t1.$index(message, 2));
            break;
          case "resume":
            this.removePause$1(t1.$index(message, 1));
            break;
          case "add-ondone":
            this.addDoneListener$2(t1.$index(message, 1), t1.$index(message, 2));
            break;
          case "remove-ondone":
            this.removeDoneListener$1(t1.$index(message, 1));
            break;
          case "set-errors-fatal":
            this.setErrorsFatal$2(t1.$index(message, 1), t1.$index(message, 2));
            break;
          case "ping":
            this.handlePing$3(t1.$index(message, 1), t1.$index(message, 2), t1.$index(message, 3));
            break;
          case "kill":
            this.handleKill$2(t1.$index(message, 1), t1.$index(message, 2));
            break;
          case "getErrors":
            this.errorPorts.add$1(0, t1.$index(message, 1));
            break;
          case "stopErrors":
            this.errorPorts.remove$1(0, t1.$index(message, 1));
            break;
        }
      },
      lookup$1: function(portId) {
        return this.ports.$index(0, portId);
      },
      _addRegistration$2: function(portId, port) {
        var t1 = this.ports;
        if (t1.containsKey$1(portId))
          throw H.wrapException(P.Exception_Exception("Registry: ports must be registered only once."));
        t1.$indexSet(0, portId, port);
      },
      _updateGlobalState$0: function() {
        var t1 = this.ports;
        if (t1.get$length(t1) - this.weakPorts._collection$_length > 0 || this.isPaused || !this.initialized)
          init.globalState.isolates.$indexSet(0, this.id, this);
        else
          this.kill$0();
      },
      kill$0: [function() {
        var t1, t2, i, responsePort, t3;
        t1 = this._scheduledControlEvents;
        if (t1 != null)
          t1.clear$0(0);
        for (t1 = this.ports, t2 = t1.get$values(), t2 = t2.get$iterator(t2); t2.moveNext$0();)
          t2.get$current()._close$0();
        t1.clear$0(0);
        this.weakPorts.clear$0(0);
        init.globalState.isolates.remove$1(0, this.id);
        this.errorPorts.clear$0(0);
        if (this.doneHandlers != null) {
          for (i = 0; t1 = this.doneHandlers, t2 = t1.length, i < t2; i += 2) {
            responsePort = t1[i];
            t3 = i + 1;
            if (t3 >= t2)
              return H.ioore(t1, t3);
            responsePort.send$1(t1[t3]);
          }
          this.doneHandlers = null;
        }
      }, "call$0", "get$kill", 0, 0, 6]
    },
    "+_IsolateContext": 0,
    _IsolateContext_handlePing_respond: {
      "^": "Closure:6;responsePort,response",
      call$0: [function() {
        this.responsePort.send$1(this.response);
      }, null, null, 0, 0, null, "call"]
    },
    "+ _IsolateContext_handlePing_respond": 0,
    _EventLoop: {
      "^": "Object;events,_activeJsAsyncCount",
      dequeue$0: function() {
        var t1 = this.events;
        if (J.$eq$(t1._head, t1._tail))
          return;
        return t1.removeFirst$0();
      },
      runIteration$0: function() {
        var $event, t1, t2;
        $event = this.dequeue$0();
        if ($event == null) {
          if (init.globalState.rootContext != null)
            if (init.globalState.isolates.containsKey$1(init.globalState.rootContext.id))
              if (init.globalState.fromCommandLine === true) {
                t1 = init.globalState.rootContext.ports;
                t1 = t1.get$isEmpty(t1);
              } else
                t1 = false;
            else
              t1 = false;
          else
            t1 = false;
          if (t1)
            H.throwExpression(P.Exception_Exception("Program exited with open ReceivePorts."));
          t1 = init.globalState;
          if (t1.isWorker === true) {
            t2 = t1.isolates;
            t2 = t2.get$isEmpty(t2) && t1.topEventLoop._activeJsAsyncCount === 0;
          } else
            t2 = false;
          if (t2) {
            t1 = t1.mainManager;
            t2 = P.LinkedHashMap__makeLiteral(["command", "close"]);
            t2 = new H._Serializer(true, new P._LinkedIdentityHashMap(0, null, null, null, null, null, 0, [null, P.int])).serialize$1(t2);
            t1.toString;
            self.postMessage(t2);
          }
          return false;
        }
        $event.process$0();
        return true;
      },
      _runHelper$0: function() {
        if (self.window != null)
          new H._EventLoop__runHelper_next(this).call$0();
        else
          for (; this.runIteration$0();)
            ;
      },
      run$0: [function() {
        var e, trace, exception, t1, t2;
        if (init.globalState.isWorker !== true)
          this._runHelper$0();
        else
          try {
            this._runHelper$0();
          } catch (exception) {
            t1 = H.unwrapException(exception);
            e = t1;
            trace = H.getTraceFromException(exception);
            t1 = init.globalState.mainManager;
            t2 = P.LinkedHashMap__makeLiteral(["command", "error", "msg", H.S(e) + "\n" + H.S(trace)]);
            t2 = new H._Serializer(true, P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6(null, P.int)).serialize$1(t2);
            t1.toString;
            self.postMessage(t2);
          }
      }, "call$0", "get$run", 0, 0, 6]
    },
    "+_EventLoop": 0,
    _EventLoop__runHelper_next: {
      "^": "Closure:6;$this",
      call$0: [function() {
        if (!this.$this.runIteration$0())
          return;
        P.Timer_Timer(C.Duration_0, this);
      }, null, null, 0, 0, null, "call"]
    },
    "+ _EventLoop__runHelper_next": 0,
    _IsolateEvent: {
      "^": "Object;isolate<,fn,message@",
      process$0: [function() {
        var t1 = this.isolate;
        if (t1.get$isPaused()) {
          t1.get$delayedEvents().push(this);
          return;
        }
        t1.eval$1(this.fn);
      }, "call$0", "get$process", 0, 0, 6]
    },
    "+_IsolateEvent": 0,
    _MainManagerStub: {
      "^": "Object;"
    },
    "+_MainManagerStub": 0,
    IsolateNatives__processWorkerMessage_closure: {
      "^": "Closure:4;entryPoint,args,message,isSpawnUri,startPaused,replyTo",
      call$0: function() {
        H.IsolateNatives__startIsolate(this.entryPoint, this.args, this.message, this.isSpawnUri, this.startPaused, this.replyTo);
      }
    },
    "+ IsolateNatives__processWorkerMessage_closure": 0,
    IsolateNatives_handleSpawnWorkerRequest_closure: {
      "^": "Closure:3;replyPort",
      call$1: [function(msg) {
        this.replyPort.send$1(msg);
      }, null, null, 2, 0, null, 92, [], "call"]
    },
    "+ IsolateNatives_handleSpawnWorkerRequest_closure": 0,
    IsolateNatives_handleSpawnWorkerRequest_closure0: {
      "^": "Closure:13;replyPort",
      call$1: [function(errorMessage) {
        this.replyPort.send$1(["spawn failed", errorMessage]);
      }, null, null, 2, 0, null, 895, [], "call"]
    },
    "+ IsolateNatives_handleSpawnWorkerRequest_closure": 0,
    IsolateNatives_spawn_closure: {
      "^": "Closure:3;completer",
      call$1: [function(msg) {
        var t1, t2;
        t1 = J.getInterceptor$asx(msg);
        t2 = this.completer;
        if (J.$eq$(t1.$index(msg, 0), "spawned"))
          t2.complete$1(msg);
        else
          t2.completeError$1(t1.$index(msg, 1));
      }, null, null, 2, 0, null, 92, [], "call"]
    },
    "+ IsolateNatives_spawn_closure": 0,
    IsolateNatives_spawn_closure0: {
      "^": "Closure:13;completer",
      call$1: [function(message) {
        return this.completer.completeError$1(message);
      }, null, null, 2, 0, null, 17, [], "call"]
    },
    "+ IsolateNatives_spawn_closure": 0,
    IsolateNatives__startNonWorker_closure: {
      "^": "Closure:4;_box_0,functionName,isSpawnUri,startPaused,replyPort",
      call$0: function() {
        var t1 = this._box_0;
        H.IsolateNatives__startIsolate(init.globalFunctions[this.functionName](), t1.args, t1.message, this.isSpawnUri, this.startPaused, this.replyPort);
      }
    },
    "+ IsolateNatives__startNonWorker_closure": 0,
    IsolateNatives__startIsolate_runStartFunction: {
      "^": "Closure:6;topLevel,args,message,isSpawnUri,context",
      call$0: function() {
        var t1, t2;
        t1 = this.context;
        t1.set$initialized(true);
        if (this.isSpawnUri !== true)
          this.topLevel.call$1(this.message);
        else {
          t2 = this.topLevel;
          if (H.functionTypeTest(t2, {func: 1, args: [,,]}))
            t2.call$2(this.args, this.message);
          else if (H.functionTypeTest(t2, {func: 1, args: [,]}))
            t2.call$1(this.args);
          else
            t2.call$0();
        }
        t1._updateGlobalState$0();
      }
    },
    "+ IsolateNatives__startIsolate_runStartFunction": 0,
    _BaseSendPort: {
      "^": "Object;"
    },
    "+_BaseSendPort": 0,
    _NativeJsSendPort: {
      "^": "_BaseSendPort;_receivePort,_isolateId",
      send$1: [function(message) {
        var isolate, t1, msg;
        isolate = init.globalState.isolates.$index(0, this._isolateId);
        if (isolate == null)
          return;
        t1 = this._receivePort;
        if (t1.get$_isClosed())
          return;
        msg = H._clone(message);
        if (J.$eq$(isolate.get$controlPort(), t1)) {
          isolate.handleControlMessage$1(msg);
          return;
        }
        init.globalState.topEventLoop.events._add$1(new H._IsolateEvent(isolate, new H._NativeJsSendPort_send_closure(this, msg), "receive"));
      }, "call$1", "get$send", 2, 0, 27, 17, [], "send"],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof H._NativeJsSendPort && J.$eq$(this._receivePort, other._receivePort);
      }, null, "get$==", 2, 0, 24, 2, [], "=="],
      get$hashCode: [function(_) {
        return this._receivePort.get$_id();
      }, null, null, 1, 0, 11, "hashCode"]
    },
    "+_NativeJsSendPort": 0,
    _NativeJsSendPort_send_closure: {
      "^": "Closure:4;$this,msg",
      call$0: function() {
        var t1 = this.$this._receivePort;
        if (!t1.get$_isClosed())
          t1.__isolate_helper$_add$1(this.msg);
      }
    },
    "+ _NativeJsSendPort_send_closure": 0,
    _WorkerSendPort: {
      "^": "_BaseSendPort;_workerId,_receivePortId,_isolateId",
      send$1: [function(message) {
        var t1, workerMessage, manager;
        t1 = P.LinkedHashMap__makeLiteral(["command", "message", "port", this, "msg", message]);
        workerMessage = new H._Serializer(true, P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6(null, P.int)).serialize$1(t1);
        if (init.globalState.isWorker === true) {
          init.globalState.mainManager.toString;
          self.postMessage(workerMessage);
        } else {
          manager = init.globalState.managers.$index(0, this._workerId);
          if (manager != null)
            manager.postMessage(workerMessage);
        }
      }, "call$1", "get$send", 2, 0, 27, 17, [], "send"],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof H._WorkerSendPort && J.$eq$(this._workerId, other._workerId) && J.$eq$(this._isolateId, other._isolateId) && J.$eq$(this._receivePortId, other._receivePortId);
      }, null, "get$==", 2, 0, 24, 2, [], "=="],
      get$hashCode: [function(_) {
        var t1, t2, t3;
        t1 = J.$shl$n(this._workerId, 16);
        t2 = J.$shl$n(this._isolateId, 8);
        t3 = this._receivePortId;
        if (typeof t3 !== "number")
          return H.iae(t3);
        return (t1 ^ t2 ^ t3) >>> 0;
      }, null, null, 1, 0, 11, "hashCode"]
    },
    "+_WorkerSendPort": 0,
    RawReceivePortImpl: {
      "^": "Object;_id<,_handler,_isClosed<",
      set$handler: [function(newHandler) {
        this._handler = newHandler;
      }, null, null, 3, 0, 164, 894, [], "handler"],
      _close$0: function() {
        this._isClosed = true;
        this._handler = null;
      },
      close$0: [function() {
        var t1, t2;
        if (this._isClosed)
          return;
        this._isClosed = true;
        this._handler = null;
        t1 = init.globalState.currentContext;
        t2 = this._id;
        t1.ports.remove$1(0, t2);
        t1.weakPorts.remove$1(0, t2);
        t1._updateGlobalState$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      __isolate_helper$_add$1: function(dataEvent) {
        if (this._isClosed)
          return;
        this._handler.call$1(dataEvent);
      },
      get$sendPort: [function() {
        return new H._NativeJsSendPort(this, init.globalState.currentContext.id);
      }, null, null, 1, 0, 302, "sendPort"],
      $isRawReceivePort: 1
    },
    "+RawReceivePortImpl": 0,
    ReceivePortImpl: {
      "^": "Stream;_rawPort,_controller",
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        var t1 = this._controller;
        t1.toString;
        return new P._ControllerStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, onError);
      }, "listen$2$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, null);
      }, "listen$2$onDone", function(onData, cancelOnError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, null, null);
      }, "listen$2$cancelOnError", "call$4$cancelOnError$onDone$onError", "call$1", "call$2$onError", "call$3$onDone$onError", "call$3$onDone$onError", "call$2$onDone", "call$2$cancelOnError", "get$listen", 2, 7, 502, 0, 0, 0, 27, [], 20, [], 28, [], 24, [], "listen"],
      close$0: [function() {
        this._rawPort.close$0();
        this._controller.close$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      get$sendPort: [function() {
        return this._rawPort.get$sendPort();
      }, null, null, 1, 0, 302, "sendPort"],
      ReceivePortImpl$fromRawReceivePort$1: function(_rawPort) {
        var t1 = new P._SyncStreamController(null, 0, null, null, null, null, this.get$close(), [null]);
        this._controller = t1;
        this._rawPort.set$handler(t1.get$add(t1));
      },
      $asStream: Isolate.functionThatReturnsNull,
      static: {
        ReceivePortImpl$fromRawReceivePort: function(_rawPort) {
          var t1 = new H.ReceivePortImpl(_rawPort, null);
          t1.ReceivePortImpl$fromRawReceivePort$1(_rawPort);
          return t1;
        }
      }
    },
    "+ReceivePortImpl": 0,
    TimerImpl: {
      "^": "Object;_once,_inEventLoop,_handle",
      cancel$0: [function() {
        if (self.setTimeout != null) {
          if (this._inEventLoop)
            throw H.wrapException(new P.UnsupportedError("Timer in event loop cannot be canceled."));
          var t1 = this._handle;
          if (t1 == null)
            return;
          --init.globalState.topEventLoop._activeJsAsyncCount;
          if (this._once)
            self.clearTimeout(t1);
          else
            self.clearInterval(t1);
          this._handle = null;
        } else
          throw H.wrapException(new P.UnsupportedError("Canceling a timer."));
      }, "call$0", "get$cancel", 0, 0, 6, "cancel"],
      get$isActive: [function() {
        return this._handle != null;
      }, null, null, 1, 0, 5, "isActive"],
      TimerImpl$periodic$2: function(milliseconds, callback) {
        if (self.setTimeout != null) {
          ++init.globalState.topEventLoop._activeJsAsyncCount;
          this._handle = self.setInterval(H.convertDartClosureToJS(new H.TimerImpl$periodic_closure(this, callback), 0), milliseconds);
        } else
          throw H.wrapException(new P.UnsupportedError("Periodic timer."));
      },
      TimerImpl$2: function(milliseconds, callback) {
        var t1, t2;
        if (J.$eq$(milliseconds, 0))
          t1 = self.setTimeout == null || init.globalState.isWorker === true;
        else
          t1 = false;
        if (t1) {
          this._handle = 1;
          t1 = init.globalState.topEventLoop;
          t2 = init.globalState.currentContext;
          t1.events._add$1(new H._IsolateEvent(t2, new H.TimerImpl_internalCallback(this, callback), "timer"));
          this._inEventLoop = true;
        } else if (self.setTimeout != null) {
          ++init.globalState.topEventLoop._activeJsAsyncCount;
          this._handle = self.setTimeout(H.convertDartClosureToJS(new H.TimerImpl_internalCallback0(this, callback), 0), milliseconds);
        } else
          throw H.wrapException(new P.UnsupportedError("Timer greater than 0."));
      },
      static: {
        TimerImpl$: function(milliseconds, callback) {
          var t1 = new H.TimerImpl(true, false, null);
          t1.TimerImpl$2(milliseconds, callback);
          return t1;
        },
        TimerImpl$periodic: function(milliseconds, callback) {
          var t1 = new H.TimerImpl(false, false, null);
          t1.TimerImpl$periodic$2(milliseconds, callback);
          return t1;
        }
      }
    },
    "+TimerImpl": 0,
    TimerImpl_internalCallback: {
      "^": "Closure:6;$this,callback",
      call$0: function() {
        this.$this._handle = null;
        this.callback.call$0();
      }
    },
    "+ TimerImpl_internalCallback": 0,
    TimerImpl_internalCallback0: {
      "^": "Closure:6;$this,callback",
      call$0: [function() {
        this.$this._handle = null;
        --init.globalState.topEventLoop._activeJsAsyncCount;
        this.callback.call$0();
      }, null, null, 0, 0, null, "call"]
    },
    "+ TimerImpl_internalCallback": 0,
    TimerImpl$periodic_closure: {
      "^": "Closure:4;$this,callback",
      call$0: [function() {
        this.callback.call$1(this.$this);
      }, null, null, 0, 0, null, "call"]
    },
    "+ TimerImpl$periodic_closure": 0,
    CapabilityImpl: {
      "^": "Object;_id<",
      get$hashCode: [function(_) {
        var hash, t1, t2;
        hash = this._id;
        t1 = J.getInterceptor$n(hash);
        t2 = t1.$shr(hash, 0);
        t1 = t1.$tdiv(hash, 4294967296);
        if (typeof t1 !== "number")
          return H.iae(t1);
        hash = t2 ^ t1;
        hash = (~hash >>> 0) + (hash << 15 >>> 0) & 4294967295;
        hash = ((hash ^ hash >>> 12) >>> 0) * 5 & 4294967295;
        hash = ((hash ^ hash >>> 4) >>> 0) * 2057 & 4294967295;
        return (hash ^ hash >>> 16) >>> 0;
      }, null, null, 1, 0, 11, "hashCode"],
      $eq: [function(_, other) {
        var t1, t2;
        if (other == null)
          return false;
        if (other === this)
          return true;
        if (other instanceof H.CapabilityImpl) {
          t1 = this._id;
          t2 = other._id;
          return t1 == null ? t2 == null : t1 === t2;
        }
        return false;
      }, null, "get$==", 2, 0, 15, 2, [], "=="]
    },
    "+CapabilityImpl": 0,
    _Serializer: {
      "^": "Object;_serializeSendPorts,serializedObjectIds",
      serialize$1: [function(x) {
        var t1, serializationId, serializeTearOff, t2, $name;
        if (x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean")
          return x;
        t1 = this.serializedObjectIds;
        serializationId = t1.$index(0, x);
        if (serializationId != null)
          return ["ref", serializationId];
        t1.$indexSet(0, x, t1.get$length(t1));
        t1 = J.getInterceptor(x);
        if (!!t1.$isNativeByteBuffer)
          return ["buffer", x];
        if (!!t1.$isNativeTypedData)
          return ["typed", x];
        if (!!t1.$isJSIndexable)
          return this.serializeJSIndexable$1(x);
        if (!!t1.$isInternalMap) {
          serializeTearOff = this.get$serialize();
          t1 = x.get$keys();
          t1 = H.MappedIterable_MappedIterable(t1, serializeTearOff, H.getRuntimeTypeArgument(t1, "Iterable", 0), null);
          t1 = P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "Iterable", 0));
          t2 = x.get$values();
          t2 = H.MappedIterable_MappedIterable(t2, serializeTearOff, H.getRuntimeTypeArgument(t2, "Iterable", 0), null);
          return ["map", t1, P.List_List$from(t2, true, H.getRuntimeTypeArgument(t2, "Iterable", 0))];
        }
        if (!!t1.$isJSObject)
          return this.serializeJSObject$1(x);
        if (!!t1.$isInterceptor)
          this.unsupported$1(x);
        if (!!t1.$isRawReceivePort)
          this.unsupported$2(x, "RawReceivePorts can't be transmitted:");
        if (!!t1.$is_NativeJsSendPort)
          return this.serializeJsSendPort$1(x);
        if (!!t1.$is_WorkerSendPort)
          return this.serializeWorkerSendPort$1(x);
        if (!!t1.$isClosure) {
          $name = x.$static_name;
          if ($name == null)
            this.unsupported$2(x, "Closures can't be transmitted:");
          return ["function", $name];
        }
        if (!!t1.$isCapabilityImpl)
          return ["capability", x._id];
        if (!(x instanceof P.Object))
          this.unsupported$1(x);
        return ["dart", init.classIdExtractor(x), this.serializeArrayInPlace$1(init.classFieldsExtractor(x))];
      }, "call$1", "get$serialize", 2, 0, 3, 38, []],
      unsupported$2: function(x, message) {
        throw H.wrapException(new P.UnsupportedError(H.S(message == null ? "Can't transmit:" : message) + " " + H.S(x)));
      },
      unsupported$1: function(x) {
        return this.unsupported$2(x, null);
      },
      serializeJSIndexable$1: function(indexable) {
        var serialized = this.serializeArray$1(indexable);
        if (!!indexable.fixed$length)
          return ["fixed", serialized];
        if (!indexable.fixed$length)
          return ["extendable", serialized];
        if (!indexable.immutable$list)
          return ["mutable", serialized];
        if (indexable.constructor === Array)
          return ["const", serialized];
        this.unsupported$2(indexable, "Can't serialize indexable: ");
      },
      serializeArray$1: function(x) {
        var serialized, i, t1;
        serialized = [];
        C.JSArray_methods.set$length(serialized, x.length);
        for (i = 0; i < x.length; ++i) {
          t1 = this.serialize$1(x[i]);
          if (i >= serialized.length)
            return H.ioore(serialized, i);
          serialized[i] = t1;
        }
        return serialized;
      },
      serializeArrayInPlace$1: function(x) {
        var i;
        for (i = 0; i < x.length; ++i)
          C.JSArray_methods.$indexSet(x, i, this.serialize$1(x[i]));
        return x;
      },
      serializeJSObject$1: function(x) {
        var keys, values, i, t1;
        if (!!x.constructor && x.constructor !== Object)
          this.unsupported$2(x, "Only plain JS Objects are supported:");
        keys = Object.keys(x);
        values = [];
        C.JSArray_methods.set$length(values, keys.length);
        for (i = 0; i < keys.length; ++i) {
          t1 = this.serialize$1(x[keys[i]]);
          if (i >= values.length)
            return H.ioore(values, i);
          values[i] = t1;
        }
        return ["js-object", keys, values];
      },
      serializeWorkerSendPort$1: function(x) {
        if (this._serializeSendPorts)
          return ["sendport", x._workerId, x._isolateId, x._receivePortId];
        return ["raw sendport", x];
      },
      serializeJsSendPort$1: function(x) {
        if (this._serializeSendPorts)
          return ["sendport", init.globalState.currentManagerId, x._isolateId, x._receivePort.get$_id()];
        return ["raw sendport", x];
      }
    },
    "+_Serializer": 0,
    _Deserializer: {
      "^": "Object;_adjustSendPorts,deserializedObjects",
      deserialize$1: [function(x) {
        var serializationId, t1, result, classId, fields, emptyInstance;
        if (x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean")
          return x;
        if (typeof x !== "object" || x === null || x.constructor !== Array)
          throw H.wrapException(P.ArgumentError$("Bad serialized message: " + H.S(x)));
        switch (C.JSArray_methods.get$first(x)) {
          case "ref":
            if (1 >= x.length)
              return H.ioore(x, 1);
            serializationId = x[1];
            t1 = this.deserializedObjects;
            if (serializationId >>> 0 !== serializationId || serializationId >= t1.length)
              return H.ioore(t1, serializationId);
            return t1[serializationId];
          case "buffer":
            if (1 >= x.length)
              return H.ioore(x, 1);
            result = x[1];
            this.deserializedObjects.push(result);
            return result;
          case "typed":
            if (1 >= x.length)
              return H.ioore(x, 1);
            result = x[1];
            this.deserializedObjects.push(result);
            return result;
          case "fixed":
            if (1 >= x.length)
              return H.ioore(x, 1);
            result = x[1];
            this.deserializedObjects.push(result);
            t1 = H.setRuntimeTypeInfo(this.deserializeArrayInPlace$1(result), [null]);
            t1.fixed$length = Array;
            return t1;
          case "extendable":
            if (1 >= x.length)
              return H.ioore(x, 1);
            result = x[1];
            this.deserializedObjects.push(result);
            return H.setRuntimeTypeInfo(this.deserializeArrayInPlace$1(result), [null]);
          case "mutable":
            if (1 >= x.length)
              return H.ioore(x, 1);
            result = x[1];
            this.deserializedObjects.push(result);
            return this.deserializeArrayInPlace$1(result);
          case "const":
            if (1 >= x.length)
              return H.ioore(x, 1);
            result = x[1];
            this.deserializedObjects.push(result);
            t1 = H.setRuntimeTypeInfo(this.deserializeArrayInPlace$1(result), [null]);
            t1.fixed$length = Array;
            return t1;
          case "map":
            return this.deserializeMap$1(x);
          case "sendport":
            return this.deserializeSendPort$1(x);
          case "raw sendport":
            if (1 >= x.length)
              return H.ioore(x, 1);
            result = x[1];
            this.deserializedObjects.push(result);
            return result;
          case "js-object":
            return this.deserializeJSObject$1(x);
          case "function":
            if (1 >= x.length)
              return H.ioore(x, 1);
            result = init.globalFunctions[x[1]]();
            this.deserializedObjects.push(result);
            return result;
          case "capability":
            if (1 >= x.length)
              return H.ioore(x, 1);
            return new H.CapabilityImpl(x[1]);
          case "dart":
            t1 = x.length;
            if (1 >= t1)
              return H.ioore(x, 1);
            classId = x[1];
            if (2 >= t1)
              return H.ioore(x, 2);
            fields = x[2];
            emptyInstance = init.instanceFromClassId(classId);
            this.deserializedObjects.push(emptyInstance);
            this.deserializeArrayInPlace$1(fields);
            return init.initializeEmptyInstance(classId, emptyInstance, fields);
          default:
            throw H.wrapException("couldn't deserialize: " + H.S(x));
        }
      }, "call$1", "get$deserialize", 2, 0, 3, 38, []],
      deserializeArrayInPlace$1: function(x) {
        var t1, i, t2;
        t1 = J.getInterceptor$asx(x);
        i = 0;
        while (true) {
          t2 = t1.get$length(x);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          t1.$indexSet(x, i, this.deserialize$1(t1.$index(x, i)));
          ++i;
        }
        return x;
      },
      deserializeMap$1: function(x) {
        var t1, keys, values, result, t2, i;
        t1 = x.length;
        if (1 >= t1)
          return H.ioore(x, 1);
        keys = x[1];
        if (2 >= t1)
          return H.ioore(x, 2);
        values = x[2];
        result = P.LinkedHashMap__makeEmpty();
        this.deserializedObjects.push(result);
        keys = J.map$1$ax(keys, this.get$deserialize()).toList$0(0);
        for (t1 = J.getInterceptor$asx(keys), t2 = J.getInterceptor$asx(values), i = 0; i < t1.get$length(keys); ++i)
          result.$indexSet(0, t1.$index(keys, i), this.deserialize$1(t2.$index(values, i)));
        return result;
      },
      deserializeSendPort$1: function(x) {
        var t1, managerId, isolateId, receivePortId, isolate, receivePort, result;
        t1 = x.length;
        if (1 >= t1)
          return H.ioore(x, 1);
        managerId = x[1];
        if (2 >= t1)
          return H.ioore(x, 2);
        isolateId = x[2];
        if (3 >= t1)
          return H.ioore(x, 3);
        receivePortId = x[3];
        if (J.$eq$(managerId, init.globalState.currentManagerId)) {
          isolate = init.globalState.isolates.$index(0, isolateId);
          if (isolate == null)
            return;
          receivePort = isolate.lookup$1(receivePortId);
          if (receivePort == null)
            return;
          result = new H._NativeJsSendPort(receivePort, isolateId);
        } else
          result = new H._WorkerSendPort(managerId, receivePortId, isolateId);
        this.deserializedObjects.push(result);
        return result;
      },
      deserializeJSObject$1: function(x) {
        var t1, keys, values, o, t2, i, t3;
        t1 = x.length;
        if (1 >= t1)
          return H.ioore(x, 1);
        keys = x[1];
        if (2 >= t1)
          return H.ioore(x, 2);
        values = x[2];
        o = {};
        this.deserializedObjects.push(o);
        t1 = J.getInterceptor$asx(keys);
        t2 = J.getInterceptor$asx(values);
        i = 0;
        while (true) {
          t3 = t1.get$length(keys);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          o[t1.$index(keys, i)] = this.deserialize$1(t2.$index(values, i));
          ++i;
        }
        return o;
      }
    },
    "+_Deserializer": 0,
    _MainFunction: {
      "^": "",
      $typedefType: 4,
      $$isTypedef: true
    },
    "+_MainFunction": "",
    _MainFunctionArgs: {
      "^": "",
      $typedefType: 3,
      $$isTypedef: true
    },
    "+_MainFunctionArgs": "",
    _MainFunctionArgsMessage: {
      "^": "",
      $typedefType: 12,
      $$isTypedef: true
    },
    "+_MainFunctionArgsMessage": ""
  }], ["_js_helper", "dart:_js_helper",, H, {
    "^": "",
    ConstantMap_ConstantMap$from: function(other, $K, $V) {
      var keys, allStrings, t1, _i, t2, k, object, containsProto, protoValue, $length, v;
      keys = other.get$keys().toList$0(0);
      t1 = keys.length;
      _i = 0;
      while (true) {
        t2 = keys.length;
        if (!(_i < t2)) {
          allStrings = true;
          break;
        }
        k = keys[_i];
        if (typeof k !== "string") {
          allStrings = false;
          break;
        }
        t2 === t1 || (0, H.throwConcurrentModificationError)(keys);
        ++_i;
      }
      if (allStrings) {
        object = {};
        for (t1 = J.getInterceptor$asx(other), containsProto = false, protoValue = null, $length = 0, _i = 0; _i < keys.length; keys.length === t2 || (0, H.throwConcurrentModificationError)(keys), ++_i) {
          k = keys[_i];
          v = t1.$index(other, k);
          if (!J.$eq$(k, "__proto__")) {
            if (!object.hasOwnProperty(k))
              ++$length;
            object[k] = v;
          } else {
            protoValue = v;
            containsProto = true;
          }
        }
        if (containsProto)
          return new H.ConstantProtoMap(protoValue, $length + 1, object, keys, [$K, $V]);
        return new H.ConstantStringMap($length, object, keys, [$K, $V]);
      }
      return new H.ConstantMapView(P.LinkedHashMap_LinkedHashMap$from(other, null, null), [$K, $V]);
    },
    ConstantMap__throwUnmodifiable: function() {
      throw H.wrapException(new P.UnsupportedError("Cannot modify unmodifiable Map"));
    },
    isCheckPropertyToJsConstructorName: function(isCheckProperty) {
      return isCheckProperty.substring(3);
    },
    isDartFunctionType: function(type) {
      return 'func' in type;
    },
    createDartFunctionTypeRti: function() {
      return {func: "dynafunc"};
    },
    rawRtiToJsConstructorName: function(rti) {
      return rti.builtin$cls;
    },
    jsConstructorNameToRti: function(constructorName) {
      return init.getTypeFromName(constructorName);
    },
    getRawRuntimeType: function(o) {
      return o.constructor;
    },
    builtinIsSubtype: function(type, other) {
      return '$is' + other in type.prototype;
    },
    isDartFunctionTypeRti: function(type) {
      return type.builtin$cls === "Function";
    },
    isNullType: function(type) {
      return type.builtin$cls === "Null";
    },
    isDartObjectTypeRti: function(type) {
      return type.builtin$cls === "Object";
    },
    isNullTypeRti: function(type) {
      return type.builtin$cls === "Null";
    },
    getMetadata: function(index) {
      return init.metadata[index];
    },
    getType: [function(index) {
      return init.types[index];
    }, null, null, 2, 0, null, 14, []],
    createDartClosureFromNameOfStaticFunction: function($name) {
      return init.globalFunctions[$name]();
    },
    requiresPreamble: function() {
    },
    isJsIndexable: function(object, record) {
      var result;
      if (record != null) {
        result = record.x;
        if (result != null)
          return result;
      }
      return !!J.getInterceptor(object).$isJavaScriptIndexingBehavior;
    },
    S: function(value) {
      var res;
      if (typeof value === "string")
        return value;
      if (typeof value === "number") {
        if (value !== 0)
          return "" + value;
      } else if (true === value)
        return "true";
      else if (false === value)
        return "false";
      else if (value == null)
        return "null";
      res = J.toString$0$(value);
      if (typeof res !== "string")
        throw H.wrapException(H.argumentErrorValue(value));
      return res;
    },
    createInvocationMirror: function($name, internalName, kind, $arguments, argumentNames) {
      return new H.JSInvocationMirror($name, internalName, kind, $arguments, argumentNames, null);
    },
    createUnmangledInvocationMirror: function(symbol, internalName, kind, $arguments, argumentNames) {
      return new H.JSInvocationMirror(symbol, internalName, kind, $arguments, argumentNames, null);
    },
    throwInvalidReflectionError: function(memberName) {
      throw H.wrapException(new P.UnsupportedError("Can't use '" + H.S(memberName) + "' in reflection because it is not included in a @MirrorsUsed annotation."));
    },
    consoleTraceHelper: function(method) {
      if (!this.cache)
        this.cache = Object.create(null);
      if (!this.cache[method]) {
        console.log(method);
        this.cache[method] = true;
      }
    },
    postTraceHelper: function(id, $name) {
      var t1 = $._traceBuffer;
      if (t1 == null) {
        t1 = [];
        $._traceBuffer = t1;
      }
      if (t1.length == 0)
        window.setTimeout(function(buffer) {
          return function() {
            var xhr = new XMLHttpRequest();
            xhr.open("POST", "/coverage_uri_to_amend_by_server");
            xhr.send(JSON.stringify(buffer));
            buffer.length = 0;
          };
        }(t1), 1000);
      $._traceBuffer.push([id, $name]);
    },
    Primitives_objectHashCode: function(object) {
      var hash = object.$identityHash;
      if (hash == null) {
        hash = Math.random() * 0x3fffffff | 0;
        object.$identityHash = hash;
      }
      return hash;
    },
    Primitives__parseIntError: function(source, handleError) {
      if (handleError == null)
        throw H.wrapException(new P.FormatException(source, null, null));
      return handleError.call$1(source);
    },
    Primitives_parseInt: function(source, radix, handleError) {
      var match, decimalMatch, maxCharCode, digitsPart, t1, i;
      H.checkString(source);
      match = /^\s*[+-]?((0x[a-f0-9]+)|(\d+)|([a-z0-9]+))\s*$/i.exec(source);
      if (match == null)
        return H.Primitives__parseIntError(source, handleError);
      if (3 >= match.length)
        return H.ioore(match, 3);
      decimalMatch = match[3];
      if (radix == null) {
        if (decimalMatch != null)
          return parseInt(source, 10);
        if (match[2] != null)
          return parseInt(source, 16);
        return H.Primitives__parseIntError(source, handleError);
      }
      if (typeof radix !== "number" || Math.floor(radix) !== radix)
        throw H.wrapException(P.ArgumentError$value(radix, "radix", "is not an integer"));
      if (radix < 2 || radix > 36)
        throw H.wrapException(P.RangeError$range(radix, 2, 36, "radix", null));
      if (radix === 10 && decimalMatch != null)
        return parseInt(source, 10);
      if (radix < 10 || decimalMatch == null) {
        maxCharCode = radix <= 10 ? 47 + radix : 86 + radix;
        digitsPart = match[1];
        for (t1 = digitsPart.length, i = 0; i < t1; ++i)
          if ((C.JSString_methods._codeUnitAt$1(digitsPart, i) | 32) > maxCharCode)
            return H.Primitives__parseIntError(source, handleError);
      }
      return parseInt(source, radix);
    },
    Primitives__parseDoubleError: function(source, handleError) {
      if (handleError == null)
        throw H.wrapException(new P.FormatException("Invalid double", source, null));
      return handleError.call$1(source);
    },
    Primitives_parseDouble: function(source, handleError) {
      var result, trimmed;
      H.checkString(source);
      if (!/^\s*[+-]?(?:Infinity|NaN|(?:\.\d+|\d+(?:\.\d*)?)(?:[eE][+-]?\d+)?)\s*$/.test(source))
        return H.Primitives__parseDoubleError(source, handleError);
      result = parseFloat(source);
      if (isNaN(result)) {
        trimmed = J.trim$0$s(source);
        if (trimmed === "NaN" || trimmed === "+NaN" || trimmed === "-NaN")
          return result;
        return H.Primitives__parseDoubleError(source, handleError);
      }
      return result;
    },
    Primitives_objectTypeName: function(object) {
      var interceptor, interceptorConstructor, interceptorConstructorName, $name, dispatchName, objectConstructor, match, decompiledName;
      interceptor = J.getInterceptor(object);
      interceptorConstructor = interceptor.constructor;
      if (typeof interceptorConstructor == "function") {
        interceptorConstructorName = interceptorConstructor.name;
        $name = typeof interceptorConstructorName === "string" ? interceptorConstructorName : null;
      } else
        $name = null;
      if ($name == null || interceptor === C.Interceptor_methods || !!J.getInterceptor(object).$isUnknownJavaScriptObject) {
        dispatchName = C.JS_CONST_TSE(object);
        if (dispatchName === "Object") {
          objectConstructor = object.constructor;
          if (typeof objectConstructor == "function") {
            match = String(objectConstructor).match(/^\s*function\s*([\w$]*)\s*\(/);
            decompiledName = match == null ? null : match[1];
            if (typeof decompiledName === "string" && /^\w+$/.test(decompiledName))
              $name = decompiledName;
          }
          if ($name == null)
            $name = dispatchName;
        } else
          $name = dispatchName;
      }
      $name = $name;
      if ($name.length > 1 && C.JSString_methods._codeUnitAt$1($name, 0) === 36)
        $name = C.JSString_methods.substring$1($name, 1);
      return function(str, names) {
        return str.replace(/[^<,> ]+/g, function(m) {
          return names[m] || m;
        });
      }($name + H.joinArguments(H.getRuntimeTypeInfo(object), 0, null), init.mangledGlobalNames);
    },
    Primitives_objectToHumanReadableString: function(object) {
      return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
    },
    Primitives_dateNow: [function() {
      return Date.now();
    }, "call$0", "_js_helper_Primitives_dateNow$closure", 0, 0, 155],
    Primitives_initTicker: function() {
      var $window, performance;
      if ($.Primitives_timerFrequency != null)
        return;
      $.Primitives_timerFrequency = 1000;
      $.Primitives_timerTicks = H._js_helper_Primitives_dateNow$closure();
      if (typeof window == "undefined")
        return;
      $window = window;
      if ($window == null)
        return;
      performance = $window.performance;
      if (performance == null)
        return;
      if (typeof performance.now != "function")
        return;
      $.Primitives_timerFrequency = 1000000;
      $.Primitives_timerTicks = new H.Primitives_initTicker_closure(performance);
    },
    Primitives_currentUri: function() {
      if (!!self.location)
        return self.location.href;
      return;
    },
    Primitives__fromCharCodeApply: function(array) {
      var end, result, i, i0, chunkEnd;
      end = J.get$length$asx(array);
      if (J.$le$n(end, 500))
        return String.fromCharCode.apply(null, array);
      if (typeof end !== "number")
        return H.iae(end);
      result = "";
      i = 0;
      for (; i < end; i = i0) {
        i0 = i + 500;
        if (i0 < end)
          chunkEnd = i0;
        else
          chunkEnd = end;
        result += String.fromCharCode.apply(null, array.slice(i, chunkEnd));
      }
      return result;
    },
    Primitives_stringFromCodePoints: function(codePoints) {
      var a, t1, i;
      a = H.setRuntimeTypeInfo([], [P.int]);
      for (t1 = J.get$iterator$ax(codePoints); t1.moveNext$0();) {
        i = t1.get$current();
        if (typeof i !== "number" || Math.floor(i) !== i)
          throw H.wrapException(H.argumentErrorValue(i));
        if (i <= 65535)
          a.push(i);
        else if (i <= 1114111) {
          a.push(55296 + (C.JSInt_methods._shrOtherPositive$1(i - 65536, 10) & 1023));
          a.push(56320 + (i & 1023));
        } else
          throw H.wrapException(H.argumentErrorValue(i));
      }
      return H.Primitives__fromCharCodeApply(a);
    },
    Primitives_stringFromCharCodes: function(charCodes) {
      var t1, i;
      for (t1 = J.get$iterator$ax(charCodes); t1.moveNext$0();) {
        i = t1.get$current();
        if (typeof i !== "number" || Math.floor(i) !== i)
          throw H.wrapException(H.argumentErrorValue(i));
        if (i < 0)
          throw H.wrapException(H.argumentErrorValue(i));
        if (i > 65535)
          return H.Primitives_stringFromCodePoints(charCodes);
      }
      return H.Primitives__fromCharCodeApply(charCodes);
    },
    Primitives_stringFromNativeUint8List: function(charCodes, start, end) {
      var t1, i, result, chunkEnd;
      t1 = J.getInterceptor$n(end);
      if (t1.$le(end, 500) && J.$eq$(start, 0) && t1.$eq(end, J.get$length$asx(charCodes)))
        return String.fromCharCode.apply(null, charCodes);
      for (i = start, result = ""; t1 = J.getInterceptor$n(i), t1.$lt(i, end); i = t1.$add(i, 500)) {
        chunkEnd = J.$lt$n(t1.$add(i, 500), end) ? t1.$add(i, 500) : end;
        result += String.fromCharCode.apply(null, charCodes.subarray(i, chunkEnd));
      }
      return result;
    },
    Primitives_stringFromCharCode: function(charCode) {
      var bits;
      if (typeof charCode !== "number")
        return H.iae(charCode);
      if (0 <= charCode) {
        if (charCode <= 65535)
          return String.fromCharCode(charCode);
        if (charCode <= 1114111) {
          bits = charCode - 65536;
          return String.fromCharCode((55296 | C.JSNumber_methods._shrOtherPositive$1(bits, 10)) >>> 0, 56320 | bits & 1023);
        }
      }
      throw H.wrapException(P.RangeError$range(charCode, 0, 1114111, null, null));
    },
    Primitives_getTimeZoneName: function(receiver) {
      var d, match;
      d = H.Primitives_lazyAsJsDate(receiver);
      match = /\((.*)\)/.exec(d.toString());
      if (match != null) {
        if (1 >= match.length)
          return H.ioore(match, 1);
        return match[1];
      }
      match = /^[A-Z,a-z]{3}\s[A-Z,a-z]{3}\s\d+\s\d{2}:\d{2}:\d{2}\s([A-Z]{3,5})\s\d{4}$/.exec(d.toString());
      if (match != null) {
        if (1 >= match.length)
          return H.ioore(match, 1);
        return match[1];
      }
      match = /(?:GMT|UTC)[+-]\d{4}/.exec(d.toString());
      if (match != null) {
        if (0 >= match.length)
          return H.ioore(match, 0);
        return match[0];
      }
      return "";
    },
    Primitives_valueFromDecomposedDate: function(years, month, day, hours, minutes, seconds, milliseconds, isUtc) {
      var jsMonth, t1, value, t2, date;
      H.checkInt(years);
      H.checkInt(month);
      H.checkInt(day);
      H.checkInt(hours);
      H.checkInt(minutes);
      H.checkInt(seconds);
      H.checkInt(milliseconds);
      if (typeof isUtc !== "boolean")
        H.throwExpression(H.argumentErrorValue(isUtc));
      jsMonth = J.$sub$n(month, 1);
      t1 = isUtc === true;
      value = t1 ? Date.UTC(years, jsMonth, day, hours, minutes, seconds, milliseconds) : new Date(years, jsMonth, day, hours, minutes, seconds, milliseconds).valueOf();
      if (isNaN(value) || value < -864e13 || value > 864e13)
        return;
      t2 = J.getInterceptor$n(years);
      if (t2.$le(years, 0) || t2.$lt(years, 100)) {
        date = new Date(value);
        if (t1)
          date.setUTCFullYear(years);
        else
          date.setFullYear(years);
        return date.valueOf();
      }
      return value;
    },
    Primitives_lazyAsJsDate: function(receiver) {
      if (receiver.date === void 0)
        receiver.date = new Date(receiver._core$_value);
      return receiver.date;
    },
    Primitives_getYear: function(receiver) {
      return receiver.isUtc === true ? H.Primitives_lazyAsJsDate(receiver).getUTCFullYear() + 0 : H.Primitives_lazyAsJsDate(receiver).getFullYear() + 0;
    },
    Primitives_getMonth: function(receiver) {
      return receiver.isUtc === true ? H.Primitives_lazyAsJsDate(receiver).getUTCMonth() + 1 : H.Primitives_lazyAsJsDate(receiver).getMonth() + 1;
    },
    Primitives_getDay: function(receiver) {
      return receiver.isUtc === true ? H.Primitives_lazyAsJsDate(receiver).getUTCDate() + 0 : H.Primitives_lazyAsJsDate(receiver).getDate() + 0;
    },
    Primitives_getHours: function(receiver) {
      return receiver.isUtc === true ? H.Primitives_lazyAsJsDate(receiver).getUTCHours() + 0 : H.Primitives_lazyAsJsDate(receiver).getHours() + 0;
    },
    Primitives_getMinutes: function(receiver) {
      return receiver.isUtc === true ? H.Primitives_lazyAsJsDate(receiver).getUTCMinutes() + 0 : H.Primitives_lazyAsJsDate(receiver).getMinutes() + 0;
    },
    Primitives_getSeconds: function(receiver) {
      return receiver.isUtc === true ? H.Primitives_lazyAsJsDate(receiver).getUTCSeconds() + 0 : H.Primitives_lazyAsJsDate(receiver).getSeconds() + 0;
    },
    Primitives_getMilliseconds: function(receiver) {
      return receiver.isUtc === true ? H.Primitives_lazyAsJsDate(receiver).getUTCMilliseconds() + 0 : H.Primitives_lazyAsJsDate(receiver).getMilliseconds() + 0;
    },
    Primitives_getProperty: function(object, key) {
      if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
        throw H.wrapException(H.argumentErrorValue(object));
      return object[key];
    },
    Primitives_setProperty: function(object, key, value) {
      if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
        throw H.wrapException(H.argumentErrorValue(object));
      object[key] = value;
    },
    Primitives_functionNoSuchMethod: function($function, positionalArguments, namedArguments) {
      var t1, $arguments, namedArgumentList, t2;
      t1 = {};
      t1.argumentCount = 0;
      $arguments = [];
      namedArgumentList = [];
      if (positionalArguments != null) {
        t2 = J.get$length$asx(positionalArguments);
        if (typeof t2 !== "number")
          return H.iae(t2);
        t1.argumentCount = 0 + t2;
        C.JSArray_methods.addAll$1($arguments, positionalArguments);
      }
      t1.names = "";
      if (namedArguments != null && !namedArguments.get$isEmpty(namedArguments))
        namedArguments.forEach$1(0, new H.Primitives_functionNoSuchMethod_closure(t1, $arguments, namedArgumentList));
      return J.noSuchMethod$1$($function, new H.JSInvocationMirror(C.Symbol_call, "call" + "$" + H.S(t1.argumentCount) + t1.names, 0, $arguments, namedArgumentList, null));
    },
    Primitives_applyFunctionWithPositionalArguments: function($function, positionalArguments) {
      var $arguments, t1;
      if (positionalArguments != null)
        $arguments = positionalArguments instanceof Array ? positionalArguments : P.List_List$from(positionalArguments, true, null);
      else
        $arguments = [];
      t1 = $arguments.length;
      if (t1 === 0) {
        if (!!$function.call$0)
          return $function.call$0();
      } else if (t1 === 1) {
        if (!!$function.call$1)
          return $function.call$1($arguments[0]);
      } else if (t1 === 2) {
        if (!!$function.call$2)
          return $function.call$2($arguments[0], $arguments[1]);
      } else if (t1 === 3) {
        if (!!$function.call$3)
          return $function.call$3($arguments[0], $arguments[1], $arguments[2]);
      } else if (t1 === 4) {
        if (!!$function.call$4)
          return $function.call$4($arguments[0], $arguments[1], $arguments[2], $arguments[3]);
      } else if (t1 === 5)
        if (!!$function.call$5)
          return $function.call$5($arguments[0], $arguments[1], $arguments[2], $arguments[3], $arguments[4]);
      return H.Primitives__genericApplyFunctionWithPositionalArguments($function, $arguments);
    },
    Primitives__genericApplyFunctionWithPositionalArguments: function($function, $arguments) {
      var argumentCount, jsFunction, info, requiredArgumentCount, maxArgumentCount, pos;
      argumentCount = $arguments.length;
      jsFunction = $function["call" + "$" + argumentCount];
      if (jsFunction == null) {
        jsFunction = J.getInterceptor($function)["call*"];
        if (jsFunction == null)
          return H.Primitives_functionNoSuchMethod($function, $arguments, null);
        info = H.ReflectionInfo_ReflectionInfo(jsFunction);
        requiredArgumentCount = info.requiredParameterCount;
        maxArgumentCount = requiredArgumentCount + info.optionalParameterCount;
        if (info.areOptionalParametersNamed || requiredArgumentCount > argumentCount || maxArgumentCount < argumentCount)
          return H.Primitives_functionNoSuchMethod($function, $arguments, null);
        $arguments = P.List_List$from($arguments, true, null);
        for (pos = argumentCount; pos < maxArgumentCount; ++pos)
          C.JSArray_methods.add$1($arguments, init.metadata[info.defaultValue$1(pos)]);
      }
      return jsFunction.apply($function, $arguments);
    },
    Primitives_applyFunctionWithNamedArguments: function($function, positionalArguments, namedArguments) {
      var t1, jsFunction, info, t2, defaultArguments, t3, i, index;
      t1 = {};
      if (namedArguments.get$isEmpty(namedArguments))
        return H.Primitives_applyFunctionWithPositionalArguments($function, positionalArguments);
      jsFunction = J.getInterceptor($function)["call*"];
      if (jsFunction == null)
        return H.Primitives_functionNoSuchMethod($function, positionalArguments, namedArguments);
      info = H.ReflectionInfo_ReflectionInfo(jsFunction);
      if (info == null || !info.areOptionalParametersNamed)
        return H.Primitives_functionNoSuchMethod($function, positionalArguments, namedArguments);
      positionalArguments = positionalArguments != null ? P.List_List$from(positionalArguments, true, null) : [];
      t2 = info.requiredParameterCount;
      if (t2 !== positionalArguments.length)
        return H.Primitives_functionNoSuchMethod($function, positionalArguments, namedArguments);
      defaultArguments = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [null, null]);
      for (t3 = info.optionalParameterCount, i = 0; i < t3; ++i) {
        index = i + t2;
        defaultArguments.$indexSet(0, info.parameterNameInOrder$1(index), init.metadata[info.defaultValueInOrder$1(index)]);
      }
      t1.bad = false;
      namedArguments.forEach$1(0, new H.Primitives_applyFunctionWithNamedArguments_closure(t1, defaultArguments));
      if (t1.bad)
        return H.Primitives_functionNoSuchMethod($function, positionalArguments, namedArguments);
      C.JSArray_methods.addAll$1(positionalArguments, defaultArguments.get$values());
      return jsFunction.apply($function, positionalArguments);
    },
    JsCache_allocate: function() {
      var result = Object.create(null);
      result.x = 0;
      delete result.x;
      return result;
    },
    iae: function(argument) {
      throw H.wrapException(H.argumentErrorValue(argument));
    },
    ioore: function(receiver, index) {
      if (receiver == null)
        J.get$length$asx(receiver);
      throw H.wrapException(H.diagnoseIndexError(receiver, index));
    },
    diagnoseIndexError: function(indexable, index) {
      var $length, t1;
      if (typeof index !== "number" || Math.floor(index) !== index)
        return new P.ArgumentError(true, index, "index", null);
      $length = J.get$length$asx(indexable);
      if (!(index < 0)) {
        if (typeof $length !== "number")
          return H.iae($length);
        t1 = index >= $length;
      } else
        t1 = true;
      if (t1)
        return P.IndexError$(index, indexable, "index", null, $length);
      return P.RangeError$value(index, "index", null);
    },
    diagnoseRangeError: function(start, end, $length) {
      if (typeof start !== "number" || Math.floor(start) !== start)
        return new P.ArgumentError(true, start, "start", null);
      if (start < 0 || start > $length)
        return new P.RangeError(0, $length, true, start, "start", "Invalid value");
      if (end != null) {
        if (typeof end !== "number" || Math.floor(end) !== end)
          return new P.ArgumentError(true, end, "end", null);
        if (end < start || end > $length)
          return new P.RangeError(start, $length, true, end, "end", "Invalid value");
      }
      return new P.ArgumentError(true, end, "end", null);
    },
    stringLastIndexOfUnchecked: function(receiver, element, start) {
      return receiver.lastIndexOf(element, start);
    },
    argumentErrorValue: function(object) {
      return new P.ArgumentError(true, object, null, null);
    },
    checkNull: function(object) {
      if (object == null)
        throw H.wrapException(H.argumentErrorValue(object));
      return object;
    },
    checkNum: function(value) {
      if (typeof value !== "number")
        throw H.wrapException(H.argumentErrorValue(value));
      return value;
    },
    checkInt: function(value) {
      if (typeof value !== "number" || Math.floor(value) !== value)
        throw H.wrapException(H.argumentErrorValue(value));
      return value;
    },
    checkBool: function(value) {
      if (typeof value !== "boolean")
        throw H.wrapException(H.argumentErrorValue(value));
      return value;
    },
    checkString: function(value) {
      if (typeof value !== "string")
        throw H.wrapException(H.argumentErrorValue(value));
      return value;
    },
    wrapException: function(ex) {
      var wrapper;
      if (ex == null)
        ex = new P.NullThrownError();
      wrapper = new Error();
      wrapper.dartException = ex;
      if ("defineProperty" in Object) {
        Object.defineProperty(wrapper, "message", {get: H.toStringWrapper});
        wrapper.name = "";
      } else
        wrapper.toString = H.toStringWrapper;
      return wrapper;
    },
    toStringWrapper: [function() {
      return J.toString$0$(this.dartException);
    }, null, null, 0, 0, null],
    throwExpression: function(ex) {
      throw H.wrapException(ex);
    },
    throwRuntimeError: function(message) {
      throw H.wrapException(new H.RuntimeError(message));
    },
    throwAbstractClassInstantiationError: function(className) {
      throw H.wrapException(new P.AbstractClassInstantiationError(className));
    },
    checkConcurrentModificationError: function(sameLength, collection) {
      if (true !== sameLength)
        H.throwConcurrentModificationError(collection);
    },
    throwConcurrentModificationError: function(collection) {
      throw H.wrapException(new P.ConcurrentModificationError(collection));
    },
    unwrapException: function(ex) {
      var t1, message, number, ieErrorCode, t2, nsme, notClosure, nullCall, nullLiteralCall, undefCall, undefLiteralCall, nullProperty, undefProperty, undefLiteralProperty, match;
      t1 = new H.unwrapException_saveStackTrace(ex);
      if (ex == null)
        return;
      if (ex instanceof H.ExceptionAndStackTrace)
        return t1.call$1(ex.dartException);
      if (typeof ex !== "object")
        return ex;
      if ("dartException" in ex)
        return t1.call$1(ex.dartException);
      else if (!("message" in ex))
        return ex;
      message = ex.message;
      if ("number" in ex && typeof ex.number == "number") {
        number = ex.number;
        ieErrorCode = number & 65535;
        if ((C.JSInt_methods._shrOtherPositive$1(number, 16) & 8191) === 10)
          switch (ieErrorCode) {
            case 438:
              return t1.call$1(H.JsNoSuchMethodError$(H.S(message) + " (Error " + ieErrorCode + ")", null));
            case 445:
            case 5007:
              t2 = H.S(message) + " (Error " + ieErrorCode + ")";
              return t1.call$1(new H.NullError(t2, null));
          }
      }
      if (ex instanceof TypeError) {
        nsme = $.$get$TypeErrorDecoder_noSuchMethodPattern();
        notClosure = $.$get$TypeErrorDecoder_notClosurePattern();
        nullCall = $.$get$TypeErrorDecoder_nullCallPattern();
        nullLiteralCall = $.$get$TypeErrorDecoder_nullLiteralCallPattern();
        undefCall = $.$get$TypeErrorDecoder_undefinedCallPattern();
        undefLiteralCall = $.$get$TypeErrorDecoder_undefinedLiteralCallPattern();
        nullProperty = $.$get$TypeErrorDecoder_nullPropertyPattern();
        $.$get$TypeErrorDecoder_nullLiteralPropertyPattern();
        undefProperty = $.$get$TypeErrorDecoder_undefinedPropertyPattern();
        undefLiteralProperty = $.$get$TypeErrorDecoder_undefinedLiteralPropertyPattern();
        match = nsme.matchTypeError$1(message);
        if (match != null)
          return t1.call$1(H.JsNoSuchMethodError$(message, match));
        else {
          match = notClosure.matchTypeError$1(message);
          if (match != null) {
            match.method = "call";
            return t1.call$1(H.JsNoSuchMethodError$(message, match));
          } else {
            match = nullCall.matchTypeError$1(message);
            if (match == null) {
              match = nullLiteralCall.matchTypeError$1(message);
              if (match == null) {
                match = undefCall.matchTypeError$1(message);
                if (match == null) {
                  match = undefLiteralCall.matchTypeError$1(message);
                  if (match == null) {
                    match = nullProperty.matchTypeError$1(message);
                    if (match == null) {
                      match = nullLiteralCall.matchTypeError$1(message);
                      if (match == null) {
                        match = undefProperty.matchTypeError$1(message);
                        if (match == null) {
                          match = undefLiteralProperty.matchTypeError$1(message);
                          t2 = match != null;
                        } else
                          t2 = true;
                      } else
                        t2 = true;
                    } else
                      t2 = true;
                  } else
                    t2 = true;
                } else
                  t2 = true;
              } else
                t2 = true;
            } else
              t2 = true;
            if (t2)
              return t1.call$1(new H.NullError(message, match == null ? null : match.method));
          }
        }
        return t1.call$1(new H.UnknownJsTypeError(typeof message === "string" ? message : ""));
      }
      if (ex instanceof RangeError) {
        if (typeof message === "string" && message.indexOf("call stack") !== -1)
          return new P.StackOverflowError();
        message = function(ex) {
          try {
            return String(ex);
          } catch (e) {
          }
          return null;
        }(ex);
        return t1.call$1(new P.ArgumentError(false, null, null, typeof message === "string" ? message.replace(/^RangeError:\s*/, "") : message));
      }
      if (typeof InternalError == "function" && ex instanceof InternalError)
        if (typeof message === "string" && message === "too much recursion")
          return new P.StackOverflowError();
      return ex;
    },
    tryStringifyException: function(ex) {
      return function(ex) {
        try {
          return String(ex);
        } catch (e) {
        }
        return null;
      }(ex);
    },
    getTraceFromException: function(exception) {
      var trace;
      if (exception instanceof H.ExceptionAndStackTrace)
        return exception.stackTrace;
      if (exception == null)
        return new H._StackTrace(exception, null);
      trace = exception.$cachedTrace;
      if (trace != null)
        return trace;
      return exception.$cachedTrace = new H._StackTrace(exception, null);
    },
    objectHashCode: function(object) {
      if (object == null || typeof object != 'object')
        return J.get$hashCode$(object);
      else
        return H.Primitives_objectHashCode(object);
    },
    fillLiteralMap: function(keyValuePairs, result) {
      var $length, index, index0, index1;
      $length = keyValuePairs.length;
      for (index = 0; index < $length; index = index1) {
        index0 = index + 1;
        index1 = index0 + 1;
        result.$indexSet(0, keyValuePairs[index], keyValuePairs[index0]);
      }
      return result;
    },
    invokeClosure: [function(closure, isolate, numberOfArguments, arg1, arg2, arg3, arg4) {
      switch (numberOfArguments) {
        case 0:
          return H._callInIsolate(isolate, new H.invokeClosure_closure(closure));
        case 1:
          return H._callInIsolate(isolate, new H.invokeClosure_closure0(closure, arg1));
        case 2:
          return H._callInIsolate(isolate, new H.invokeClosure_closure1(closure, arg1, arg2));
        case 3:
          return H._callInIsolate(isolate, new H.invokeClosure_closure2(closure, arg1, arg2, arg3));
        case 4:
          return H._callInIsolate(isolate, new H.invokeClosure_closure3(closure, arg1, arg2, arg3, arg4));
      }
      throw H.wrapException(P.Exception_Exception("Unsupported number of arguments for wrapped closure"));
    }, null, null, 14, 0, null, 893, [], 458, [], 891, [], 91, [], 90, [], 888, [], 879, []],
    convertDartClosureToJS: function(closure, arity) {
      var $function;
      if (closure == null)
        return;
      $function = closure.$identity;
      if (!!$function)
        return $function;
      $function = function(closure, arity, context, invoke) {
        return function(a1, a2, a3, a4) {
          return invoke(closure, context, arity, a1, a2, a3, a4);
        };
      }(closure, arity, init.globalState.currentContext, H.invokeClosure);
      closure.$identity = $function;
      return $function;
    },
    closureFromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, $name) {
      var t1;
      functions.fixed$length = Array;
      if (!!J.getInterceptor(reflectionInfo).$isList) {
        reflectionInfo.fixed$length = Array;
        t1 = reflectionInfo;
      } else
        t1 = reflectionInfo;
      return H.Closure_fromTearOff(receiver, functions, t1, !!isStatic, jsArguments, $name);
    },
    jsHasOwnProperty: function(jsObject, property) {
      return jsObject.hasOwnProperty(property);
    },
    jsPropertyAccess: function(jsObject, property) {
      return jsObject[property];
    },
    getFallThroughError: function() {
      return new H.FallThroughErrorImplementation();
    },
    boolConversionCheck: function(value) {
      return value;
    },
    stringTypeCheck: function(value) {
      if (value == null)
        return value;
      if (typeof value === "string")
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "String"));
    },
    stringTypeCast: function(value) {
      if (typeof value === "string" || value == null)
        return value;
      throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(value), "String"));
    },
    doubleTypeCheck: function(value) {
      if (value == null)
        return value;
      if (typeof value === "number")
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "double"));
    },
    doubleTypeCast: function(value) {
      if (typeof value === "number" || value == null)
        return value;
      throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(value), "double"));
    },
    numTypeCheck: function(value) {
      if (value == null)
        return value;
      if (typeof value === "number")
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "num"));
    },
    numTypeCast: function(value) {
      if (typeof value === "number" || value == null)
        return value;
      throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(value), "num"));
    },
    boolTypeCheck: function(value) {
      if (value == null)
        return value;
      if (typeof value === "boolean")
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "bool"));
    },
    boolTypeCast: function(value) {
      if (typeof value === "boolean" || value == null)
        return value;
      throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(value), "bool"));
    },
    intTypeCheck: function(value) {
      if (value == null)
        return value;
      if (typeof value === "number" && Math.floor(value) === value)
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "int"));
    },
    intTypeCast: function(value) {
      if (typeof value === "number" && Math.floor(value) === value || value == null)
        return value;
      throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(value), "int"));
    },
    propertyTypeError: function(value, property) {
      throw H.wrapException(H.TypeErrorImplementation$(value, property.substring(3)));
    },
    propertyTypeCastError: function(value, property) {
      var t1 = J.getInterceptor$asx(property);
      throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(value), t1.substring$2(property, 3, t1.get$length(property))));
    },
    propertyTypeCheck: function(value, property) {
      if (value == null)
        return value;
      if (!!value[property])
        return value;
      H.propertyTypeError(value, property);
    },
    propertyTypeCast: function(value, property) {
      if (value == null || !!value[property])
        return value;
      H.propertyTypeCastError(value, property);
    },
    interceptedTypeCheck: function(value, property) {
      if (value == null)
        return value;
      if ((typeof value === "object" || typeof value === "function") && J.getInterceptor(value)[property])
        return value;
      H.propertyTypeError(value, property);
    },
    interceptedTypeCast: function(value, property) {
      var t1;
      if (value != null)
        t1 = (typeof value === "object" || typeof value === "function") && J.getInterceptor(value)[property];
      else
        t1 = true;
      if (t1)
        return value;
      H.propertyTypeCastError(value, property);
    },
    numberOrStringSuperTypeCheck: function(value, property) {
      if (value == null)
        return value;
      if (typeof value === "string")
        return value;
      if (typeof value === "number")
        return value;
      if (!!value[property])
        return value;
      H.propertyTypeError(value, property);
    },
    numberOrStringSuperTypeCast: function(value, property) {
      if (typeof value === "string")
        return value;
      if (typeof value === "number")
        return value;
      return H.propertyTypeCast(value, property);
    },
    numberOrStringSuperNativeTypeCheck: function(value, property) {
      if (value == null)
        return value;
      if (typeof value === "string")
        return value;
      if (typeof value === "number")
        return value;
      if (J.getInterceptor(value)[property])
        return value;
      H.propertyTypeError(value, property);
    },
    numberOrStringSuperNativeTypeCast: function(value, property) {
      if (value == null)
        return value;
      if (typeof value === "string")
        return value;
      if (typeof value === "number")
        return value;
      if (J.getInterceptor(value)[property])
        return value;
      H.propertyTypeCastError(value, property);
    },
    stringSuperTypeCheck: function(value, property) {
      if (value == null)
        return value;
      if (typeof value === "string")
        return value;
      if (!!value[property])
        return value;
      H.propertyTypeError(value, property);
    },
    stringSuperTypeCast: function(value, property) {
      if (typeof value === "string")
        return value;
      return H.propertyTypeCast(value, property);
    },
    stringSuperNativeTypeCheck: function(value, property) {
      if (value == null)
        return value;
      if (typeof value === "string")
        return value;
      if (J.getInterceptor(value)[property])
        return value;
      H.propertyTypeError(value, property);
    },
    stringSuperNativeTypeCast: function(value, property) {
      if (typeof value === "string" || value == null)
        return value;
      if (J.getInterceptor(value)[property])
        return value;
      H.propertyTypeCastError(value, property);
    },
    listTypeCheck: function(value) {
      if (value == null)
        return value;
      if (!!J.getInterceptor(value).$isList)
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "List"));
    },
    listTypeCast: function(value) {
      if (!!J.getInterceptor(value).$isList || value == null)
        return value;
      throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(value), "List"));
    },
    listSuperTypeCheck: function(value, property) {
      if (value == null)
        return value;
      if (!!J.getInterceptor(value).$isList)
        return value;
      if (!!value[property])
        return value;
      H.propertyTypeError(value, property);
    },
    listSuperTypeCast: function(value, property) {
      if (!!J.getInterceptor(value).$isList)
        return value;
      return H.propertyTypeCast(value, property);
    },
    listSuperNativeTypeCheck: function(value, property) {
      if (value == null)
        return value;
      if (!!J.getInterceptor(value).$isList)
        return value;
      if (J.getInterceptor(value)[property])
        return value;
      H.propertyTypeError(value, property);
    },
    listSuperNativeTypeCast: function(value, property) {
      if (!!J.getInterceptor(value).$isList || value == null)
        return value;
      if (J.getInterceptor(value)[property])
        return value;
      H.propertyTypeCastError(value, property);
    },
    voidTypeCheck: function(value) {
      if (value == null)
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "void"));
    },
    extractFunctionTypeObjectFrom: function(o) {
      var interceptor = J.getInterceptor(o);
      return "$signature" in interceptor ? interceptor.$signature() : null;
    },
    functionTypeTest: function(value, functionTypeRti) {
      var functionTypeObject;
      if (value == null)
        return false;
      functionTypeObject = H.extractFunctionTypeObjectFrom(value);
      return functionTypeObject == null ? false : H.isFunctionSubtype(functionTypeObject, functionTypeRti);
    },
    functionTypeCheck: function(value, functionTypeRti) {
      var $self, t1;
      if (value == null)
        return value;
      if ($._inTypeAssertion)
        return value;
      $._inTypeAssertion = true;
      try {
        if (H.functionTypeTest(value, functionTypeRti))
          return value;
        $self = H.runtimeTypeToString(functionTypeRti, null);
        t1 = H.TypeErrorImplementation$(value, $self);
        throw H.wrapException(t1);
      } finally {
        $._inTypeAssertion = false;
      }
    },
    functionTypeCast: function(value, functionTypeRti) {
      var $self, functionTypeObject;
      if (value == null)
        return value;
      if (H.functionTypeTest(value, functionTypeRti))
        return value;
      $self = H.runtimeTypeToString(functionTypeRti, null);
      functionTypeObject = H.extractFunctionTypeObjectFrom(value);
      throw H.wrapException(H.CastErrorImplementation$(functionTypeObject != null ? H.runtimeTypeToString(functionTypeObject, null) : H.Primitives_objectTypeName(value), $self));
    },
    checkMalformedType: function(value, message) {
      if (value == null)
        return value;
      throw H.wrapException(new H.TypeErrorImplementation(message));
    },
    checkDeferredIsLoaded: function(loadId, uri) {
      if (!$.$get$_loadedLibraries().contains$1(0, loadId))
        throw H.wrapException(new H.DeferredNotLoadedError(uri));
    },
    assertTest: function(condition) {
      if (true === condition)
        return false;
      if (!!J.getInterceptor(condition).$isFunction)
        condition = condition.call$0();
      if (typeof condition === "boolean")
        return !condition;
      throw H.wrapException(H.TypeErrorImplementation$(condition, "bool"));
    },
    assertThrow: function(message) {
      throw H.wrapException(new H._AssertionError(message));
    },
    assertHelper: function(condition) {
      if (H.assertTest(condition))
        throw H.wrapException(new P.AssertionError(null));
    },
    throwNoSuchMethod: function(obj, $name, $arguments, expectedArgumentNames) {
      throw H.wrapException(P.NoSuchMethodError$(obj, new H.Symbol0($name), $arguments, H.JsLinkedHashMap_JsLinkedHashMap$es6(P.Symbol, null), expectedArgumentNames));
    },
    throwCyclicInit: function(staticName) {
      throw H.wrapException(new P.CyclicInitializationError(staticName));
    },
    random64: function() {
      return (Math.random() * 0x100000000 >>> 0) + (Math.random() * 0x100000000 >>> 0) * 4294967296;
    },
    jsonEncodeNative: function(string) {
      return JSON.stringify(string);
    },
    getIsolateAffinityTag: function($name) {
      return init.getIsolateTag($name);
    },
    _loadLibraryWrapper: function(loadId) {
      return new H._loadLibraryWrapper_closure(loadId);
    },
    loadDeferredLibrary: function(loadId) {
      var uris, hashes, t1, indices;
      uris = init.deferredLibraryUris[loadId];
      hashes = init.deferredLibraryHashes[loadId];
      if (uris == null) {
        t1 = new P._Future(0, $.Zone__current, null, [null]);
        t1._asyncComplete$1(null);
        return t1;
      }
      indices = P.List_List$generate(uris.length, new H.loadDeferredLibrary_closure(), true, null);
      t1 = H.getTypeArgumentByIndex(indices, 0);
      return P.Future_wait(new H.MappedListIterable(P.List_List$from(new H.WhereIterable(indices, new H.loadDeferredLibrary_closure0(hashes, init.isHunkLoaded), [t1]), true, t1), new H.loadDeferredLibrary_closure1(uris), [null, null]), null, false).then$1(new H.loadDeferredLibrary_closure2(loadId, hashes, indices, init.isHunkInitialized));
    },
    _loadHunk: function(hunkName) {
      var t1, deferredLibraryLoader, failure, jsSuccess, jsFailure, error, stackTrace, t2, future, uri, t3, t4, completer, exception, index, xhr, script;
      t1 = {};
      t2 = $.$get$_loadingLibraries();
      future = t2.$index(0, hunkName);
      if (future != null)
        return future.then$1(new H._loadHunk_closure());
      uri = $.$get$IsolateNatives_thisScript();
      t1.uri = uri;
      t1.uri = C.JSString_methods.substring$2(uri, 0, J.lastIndexOf$1$asx(uri, "/") + 1) + H.S(hunkName);
      deferredLibraryLoader = self.dartDeferredLibraryLoader;
      t3 = P.Null;
      t4 = new P._Future(0, $.Zone__current, null, [t3]);
      completer = new P._AsyncCompleter(t4, [t3]);
      t3 = new H._loadHunk_success(completer);
      failure = new H._loadHunk_failure(t1, hunkName, completer);
      jsSuccess = H.convertDartClosureToJS(t3, 0);
      jsFailure = H.convertDartClosureToJS(new H._loadHunk_closure0(failure), 1);
      if (typeof deferredLibraryLoader === "function")
        try {
          deferredLibraryLoader(t1.uri, jsSuccess, jsFailure);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          error = t1;
          stackTrace = H.getTraceFromException(exception);
          failure.call$2(error, stackTrace);
        }
      else if (init.globalState.isWorker === true) {
        ++init.globalState.topEventLoop._activeJsAsyncCount;
        t4.whenComplete$1(new H._loadHunk_closure1());
        index = J.lastIndexOf$1$asx(t1.uri, "/");
        t1.uri = J.substring$2$s(t1.uri, 0, index + 1) + H.S(hunkName);
        xhr = new XMLHttpRequest();
        xhr.open("GET", t1.uri);
        xhr.addEventListener("load", H.convertDartClosureToJS(new H._loadHunk_closure2(t3, failure, xhr), 1), false);
        xhr.addEventListener("error", failure, false);
        xhr.addEventListener("abort", failure, false);
        xhr.send();
      } else {
        script = document.createElement("script");
        script.type = "text/javascript";
        script.src = t1.uri;
        script.addEventListener("load", jsSuccess, false);
        script.addEventListener("error", jsFailure, false);
        document.body.appendChild(script);
      }
      t2.$indexSet(0, hunkName, t4);
      return t4;
    },
    missingMain: function() {
      throw H.wrapException(new H.MainError("No top-level function named 'main'."));
    },
    badMain: function() {
      throw H.wrapException(new H.MainError("'main' is not a function."));
    },
    mainHasTooManyParameters: function() {
      throw H.wrapException(new H.MainError("'main' expects too many parameters."));
    },
    assertUnreachable: function() {
      throw H.wrapException(new H._UnreachableError(null));
    },
    createRuntimeType: function($name) {
      return new H.TypeImpl($name, null);
    },
    getMangledTypeName: [function(type) {
      return type.get$_typeName();
    }, "call$1", "_js_helper__getMangledTypeName$closure", 2, 0, 557, 65, []],
    setRuntimeTypeInfo: function(target, rti) {
      target.$ti = rti;
      return target;
    },
    getRuntimeTypeInfo: function(target) {
      if (target == null)
        return;
      return target.$ti;
    },
    getRuntimeTypeArguments: function(target, substitutionName) {
      return H.substitute(target["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(target));
    },
    getRuntimeTypeArgument: function(target, substitutionName, index) {
      var $arguments = H.getRuntimeTypeArguments(target, substitutionName);
      return $arguments == null ? null : $arguments[index];
    },
    getTypeArgumentByIndex: function(target, index) {
      var rti = H.getRuntimeTypeInfo(target);
      return rti == null ? null : rti[index];
    },
    getClassName: function(object) {
      return J.getInterceptor(object).constructor.builtin$cls;
    },
    getRuntimeTypeAsString: function(rti, onTypeVariable) {
      return rti[0].builtin$cls + H.joinArguments(rti, 1, onTypeVariable);
    },
    runtimeTypeToString: function(rti, onTypeVariable) {
      var typedefInfo;
      if (rti == null)
        return "dynamic";
      if (typeof rti === "object" && rti !== null && rti.constructor === Array)
        return rti[0].builtin$cls + H.joinArguments(rti, 1, onTypeVariable);
      if (typeof rti == "function")
        return rti.builtin$cls;
      if (typeof rti === "number" && Math.floor(rti) === rti)
        return H.S(onTypeVariable == null ? rti : onTypeVariable.call$1(rti));
      if (typeof rti.func != "undefined") {
        typedefInfo = rti.typedef;
        if (typedefInfo != null)
          return H.runtimeTypeToString(typedefInfo, onTypeVariable);
        return H._functionRtiToString(rti, onTypeVariable);
      }
      return "unknown-reified-type";
    },
    _functionRtiToString: function(rti, onTypeVariable) {
      var returnTypeText, $arguments, t1, argumentsText, sep, _i, argument, optionalArguments, namedArguments, t2, $name;
      returnTypeText = !!rti.v ? "void" : H.runtimeTypeToString(rti.ret, onTypeVariable);
      if ("args" in rti) {
        $arguments = rti.args;
        for (t1 = $arguments.length, argumentsText = "", sep = "", _i = 0; _i < t1; ++_i, sep = ", ") {
          argument = $arguments[_i];
          argumentsText = argumentsText + sep + H.runtimeTypeToString(argument, onTypeVariable);
        }
      } else {
        argumentsText = "";
        sep = "";
      }
      if ("opt" in rti) {
        optionalArguments = rti.opt;
        argumentsText += sep + "[";
        for (t1 = optionalArguments.length, sep = "", _i = 0; _i < t1; ++_i, sep = ", ") {
          argument = optionalArguments[_i];
          argumentsText = argumentsText + sep + H.runtimeTypeToString(argument, onTypeVariable);
        }
        argumentsText += "]";
      }
      if ("named" in rti) {
        namedArguments = rti.named;
        argumentsText += sep + "{";
        for (t1 = H.extractKeys(namedArguments), t2 = t1.length, sep = "", _i = 0; _i < t2; ++_i, sep = ", ") {
          $name = t1[_i];
          argumentsText = argumentsText + sep + H.runtimeTypeToString(namedArguments[$name], onTypeVariable) + (" " + H.S($name));
        }
        argumentsText += "}";
      }
      return "(" + argumentsText + ") => " + returnTypeText;
    },
    joinArguments: function(types, startIndex, onTypeVariable) {
      var buffer, index, firstArgument, allDynamic, t1, argument;
      if (types == null)
        return "";
      buffer = new P.StringBuffer("");
      for (index = startIndex, firstArgument = true, allDynamic = true, t1 = ""; index < types.length; ++index) {
        if (firstArgument)
          firstArgument = false;
        else
          buffer._contents = t1 + ", ";
        argument = types[index];
        if (argument != null)
          allDynamic = false;
        t1 = buffer._contents += H.runtimeTypeToString(argument, onTypeVariable);
      }
      return allDynamic ? "" : "<" + buffer.toString$0(0) + ">";
    },
    getRuntimeTypeString: function(object) {
      var functionRti, className;
      if (object instanceof H.Closure) {
        functionRti = H.extractFunctionTypeObjectFrom(object);
        if (functionRti != null)
          return H.runtimeTypeToString(functionRti, null);
      }
      className = J.getInterceptor(object).constructor.builtin$cls;
      if (object == null)
        return className;
      return className + H.joinArguments(object.$ti, 0, null);
    },
    getRuntimeType: function(object) {
      return new H.TypeImpl(H.getRuntimeTypeString(object), null);
    },
    substitute: function(substitution, $arguments) {
      if (substitution == null)
        return $arguments;
      substitution = substitution.apply(null, $arguments);
      if (substitution == null)
        return;
      if (typeof substitution === "object" && substitution !== null && substitution.constructor === Array)
        return substitution;
      if (typeof substitution == "function")
        return substitution.apply(null, $arguments);
      return $arguments;
    },
    checkSubtype: function(object, isField, checks, asField) {
      var $arguments, interceptor;
      if (object == null)
        return false;
      $arguments = H.getRuntimeTypeInfo(object);
      interceptor = J.getInterceptor(object);
      if (interceptor[isField] == null)
        return false;
      return H.areSubtypes(H.substitute(interceptor[asField], $arguments), checks);
    },
    computeTypeName: function(isField, $arguments) {
      return function(str, names) {
        return str.replace(/[^<,> ]+/g, function(m) {
          return names[m] || m;
        });
      }(isField.substring(3) + H.joinArguments($arguments, 0, null), init.mangledGlobalNames);
    },
    subtypeCast: function(object, isField, checks, asField) {
      if (object == null)
        return object;
      if (H.checkSubtype(object, isField, checks, asField))
        return object;
      throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(object), function(str, names) {
        return str.replace(/[^<,> ]+/g, function(m) {
          return names[m] || m;
        });
      }(isField.substring(3) + H.joinArguments(checks, 0, null), init.mangledGlobalNames)));
    },
    assertSubtype: function(object, isField, checks, asField) {
      if (object == null)
        return object;
      if (H.checkSubtype(object, isField, checks, asField))
        return object;
      throw H.wrapException(H.TypeErrorImplementation$(object, function(str, names) {
        return str.replace(/[^<,> ]+/g, function(m) {
          return names[m] || m;
        });
      }(isField.substring(3) + H.joinArguments(checks, 0, null), init.mangledGlobalNames)));
    },
    assertIsSubtype: function(subtype, supertype, message) {
      if (!H.isSubtype(subtype, supertype))
        H.throwTypeError(message);
    },
    throwTypeError: function(message) {
      throw H.wrapException(new H.TypeErrorImplementation(message));
    },
    checkArguments: function(substitution, $arguments, checks) {
      return H.areSubtypes(H.substitute(substitution, $arguments), checks);
    },
    areSubtypes: function(s, t) {
      var len, i;
      if (s == null || t == null)
        return true;
      len = s.length;
      for (i = 0; i < len; ++i)
        if (!H.isSubtype(s[i], t[i]))
          return false;
      return true;
    },
    computeSignature: function(signature, context, contextName) {
      return signature.apply(context, H.getRuntimeTypeArguments(context, contextName));
    },
    isSupertypeOfNull: function(type) {
      return type == null || type.builtin$cls === "Object" || type.builtin$cls === "Null";
    },
    checkSubtypeOfRuntimeType: function(o, t) {
      var rti, type, targetSignatureFunction;
      if (o == null)
        return t == null || t.builtin$cls === "Object" || t.builtin$cls === "Null";
      if (t == null)
        return true;
      rti = H.getRuntimeTypeInfo(o);
      o = J.getInterceptor(o);
      type = o.constructor;
      if (rti != null) {
        rti = rti.slice();
        rti.splice(0, 0, type);
        type = rti;
      }
      if ('func' in t) {
        targetSignatureFunction = o.$signature;
        if (targetSignatureFunction == null)
          return false;
        return H.isFunctionSubtype(targetSignatureFunction.apply(o, null), t);
      }
      return H.isSubtype(type, t);
    },
    subtypeOfRuntimeTypeCast: function(object, type) {
      if (object != null && !H.checkSubtypeOfRuntimeType(object, type))
        throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(object), H.runtimeTypeToString(type, null)));
      return object;
    },
    assertSubtypeOfRuntimeType: function(object, type) {
      if (object != null && !H.checkSubtypeOfRuntimeType(object, type))
        throw H.wrapException(H.TypeErrorImplementation$(object, H.runtimeTypeToString(type, null)));
      return object;
    },
    getArguments: function(type) {
      return typeof type === "object" && type !== null && type.constructor === Array ? type.slice(1) : null;
    },
    isSubtype: function(s, t) {
      var t1, typeOfS, t2, typeOfT, typeOfTString, substitution;
      if (s === t)
        return true;
      if (s == null || t == null)
        return true;
      if (s.builtin$cls === "Null")
        return true;
      if ('func' in t)
        return H.isFunctionSubtype(s, t);
      if ('func' in s)
        return t.builtin$cls === "Function" || t.builtin$cls === "Object";
      t1 = typeof s === "object" && s !== null && s.constructor === Array;
      typeOfS = t1 ? s[0] : s;
      t2 = typeof t === "object" && t !== null && t.constructor === Array;
      typeOfT = t2 ? t[0] : t;
      if (typeOfT !== typeOfS) {
        typeOfTString = H.runtimeTypeToString(typeOfT, null);
        if (!('$is' + typeOfTString in typeOfS.prototype))
          return false;
        substitution = typeOfS.prototype["$as" + typeOfTString];
      } else
        substitution = null;
      if (!t1 && substitution == null || !t2)
        return true;
      t1 = t1 ? s.slice(1) : null;
      t2 = t.slice(1);
      return H.areSubtypes(H.substitute(substitution, t1), t2);
    },
    isAssignable: function(s, t) {
      return H.isSubtype(s, t) || H.isSubtype(t, s);
    },
    areAssignable: function(s, t, allowShorter) {
      var t1, sLength, tLength, i, t2;
      t1 = t == null;
      if (t1 && s == null)
        return true;
      if (t1)
        return allowShorter;
      if (s == null)
        return false;
      sLength = s.length;
      tLength = t.length;
      if (allowShorter) {
        if (sLength < tLength)
          return false;
      } else if (sLength !== tLength)
        return false;
      for (i = 0; i < tLength; ++i) {
        t1 = s[i];
        t2 = t[i];
        if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
          return false;
      }
      return true;
    },
    areAssignableMaps: function(s, t) {
      var t1, names, i, $name, tType, sType;
      if (t == null)
        return true;
      if (s == null)
        return false;
      t1 = Object.getOwnPropertyNames(t);
      t1.fixed$length = Array;
      names = t1;
      for (t1 = names.length, i = 0; i < t1; ++i) {
        $name = names[i];
        if (!Object.hasOwnProperty.call(s, $name))
          return false;
        tType = t[$name];
        sType = s[$name];
        if (!(H.isSubtype(tType, sType) || H.isSubtype(sType, tType)))
          return false;
      }
      return true;
    },
    isFunctionSubtype: function(s, t) {
      var sReturnType, tReturnType, sParameterTypes, tParameterTypes, sOptionalParameterTypes, tOptionalParameterTypes, sParametersLen, tParametersLen, sOptionalParametersLen, tOptionalParametersLen, pos, t1, t2, tPos, sPos;
      if (!('func' in s))
        return false;
      if ("v" in s) {
        if (!("v" in t) && "ret" in t)
          return false;
      } else if (!("v" in t)) {
        sReturnType = s.ret;
        tReturnType = t.ret;
        if (!(H.isSubtype(sReturnType, tReturnType) || H.isSubtype(tReturnType, sReturnType)))
          return false;
      }
      sParameterTypes = s.args;
      tParameterTypes = t.args;
      sOptionalParameterTypes = s.opt;
      tOptionalParameterTypes = t.opt;
      sParametersLen = sParameterTypes != null ? sParameterTypes.length : 0;
      tParametersLen = tParameterTypes != null ? tParameterTypes.length : 0;
      sOptionalParametersLen = sOptionalParameterTypes != null ? sOptionalParameterTypes.length : 0;
      tOptionalParametersLen = tOptionalParameterTypes != null ? tOptionalParameterTypes.length : 0;
      if (sParametersLen > tParametersLen)
        return false;
      if (sParametersLen + sOptionalParametersLen < tParametersLen + tOptionalParametersLen)
        return false;
      if (sParametersLen === tParametersLen) {
        if (!H.areAssignable(sParameterTypes, tParameterTypes, false))
          return false;
        if (!H.areAssignable(sOptionalParameterTypes, tOptionalParameterTypes, true))
          return false;
      } else {
        for (pos = 0; pos < sParametersLen; ++pos) {
          t1 = sParameterTypes[pos];
          t2 = tParameterTypes[pos];
          if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
            return false;
        }
        for (tPos = pos, sPos = 0; tPos < tParametersLen; ++sPos, ++tPos) {
          t1 = sOptionalParameterTypes[sPos];
          t2 = tParameterTypes[tPos];
          if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
            return false;
        }
        for (tPos = 0; tPos < tOptionalParametersLen; ++sPos, ++tPos) {
          t1 = sOptionalParameterTypes[sPos];
          t2 = tOptionalParameterTypes[tPos];
          if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
            return false;
        }
      }
      return H.areAssignableMaps(s.named, t.named);
    },
    invoke: function($function, $arguments) {
      return $function.apply(null, $arguments);
    },
    invokeOn: function($function, receiver, $arguments) {
      return $function.apply(receiver, $arguments);
    },
    $call: function(object, $name) {
      return object[$name]();
    },
    getField: function(object, $name) {
      return object[$name];
    },
    getIndex: function(array, index) {
      return array[index];
    },
    getLength: function(array) {
      return array.length;
    },
    isJsArray: function(value) {
      return typeof value === "object" && value !== null && value.constructor === Array;
    },
    hasField: function(object, $name) {
      return $name in object;
    },
    hasNoField: function(object, $name) {
      return !($name in object);
    },
    isJsFunction: function(o) {
      return typeof o == "function";
    },
    isJsObject: function(o) {
      return typeof o == 'object';
    },
    isIdentical: function(s, t) {
      return s === t;
    },
    isNotIdentical: function(s, t) {
      return s !== t;
    },
    contains: function(userAgent, $name) {
      return userAgent.indexOf($name) !== -1;
    },
    arrayLength: function(array) {
      return array.length;
    },
    arrayGet: function(array, index) {
      return array[index];
    },
    arraySet: function(array, index, value) {
      array[index] = value;
    },
    propertyGet: function(object, property) {
      return object[property];
    },
    callHasOwnProperty: function($function, object, property) {
      return $function.call(object, property);
    },
    propertySet: function(object, property, value) {
      object[property] = value;
    },
    getPropertyFromPrototype: function(object, $name) {
      return Object.getPrototypeOf(object)[$name];
    },
    toStringForNativeObject: function(obj) {
      var t1 = $.getTagFunction;
      return "Instance of " + (t1 == null ? "<Unknown>" : t1.call$1(obj));
    },
    hashCodeForNativeObject: function(object) {
      return H.Primitives_objectHashCode(object);
    },
    defineProperty: function(obj, property, value) {
      Object.defineProperty(obj, property, {value: value, enumerable: false, writable: true, configurable: true});
    },
    isDartObject: function(obj) {
      return obj instanceof P.Object;
    },
    interceptorsByTag: function() {
      return init.interceptorsByTag;
    },
    leafTags: function() {
      return init.leafTags;
    },
    findDispatchTagForInterceptorClass: function(interceptorClassConstructor) {
      return interceptorClassConstructor.$nativeSuperclassTag;
    },
    lookupInterceptor: function(tag) {
      return init.interceptorsByTag[tag];
    },
    lookupAndCacheInterceptor: function(obj) {
      var tag, record, interceptor, interceptorClass, mark, t1;
      tag = $.getTagFunction.call$1(obj);
      record = $.dispatchRecordsForInstanceTags[tag];
      if (record != null) {
        Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
        return record.i;
      }
      interceptor = $.interceptorsForUncacheableTags[tag];
      if (interceptor != null)
        return interceptor;
      interceptorClass = init.interceptorsByTag[tag];
      if (interceptorClass == null) {
        tag = $.alternateTagFunction.call$2(obj, tag);
        if (tag != null) {
          record = $.dispatchRecordsForInstanceTags[tag];
          if (record != null) {
            Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
            return record.i;
          }
          interceptor = $.interceptorsForUncacheableTags[tag];
          if (interceptor != null)
            return interceptor;
          interceptorClass = init.interceptorsByTag[tag];
        }
      }
      if (interceptorClass == null)
        return;
      interceptor = interceptorClass.prototype;
      mark = tag[0];
      if (mark === "!") {
        record = H.makeLeafDispatchRecord(interceptor);
        $.dispatchRecordsForInstanceTags[tag] = record;
        Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
        return record.i;
      }
      if (mark === "~") {
        $.interceptorsForUncacheableTags[tag] = interceptor;
        return interceptor;
      }
      if (mark === "-") {
        t1 = H.makeLeafDispatchRecord(interceptor);
        Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
        return t1.i;
      }
      if (mark === "+")
        return H.patchInteriorProto(obj, interceptor);
      if (mark === "*")
        throw H.wrapException(new P.UnimplementedError(tag));
      if (init.leafTags[tag] === true) {
        t1 = H.makeLeafDispatchRecord(interceptor);
        Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
        return t1.i;
      } else
        return H.patchInteriorProto(obj, interceptor);
    },
    patchInstance: function(obj, record) {
      Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
      return record.i;
    },
    patchProto: function(obj, record) {
      Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
      return record.i;
    },
    patchInteriorProto: function(obj, interceptor) {
      var proto = Object.getPrototypeOf(obj);
      Object.defineProperty(proto, init.dispatchPropertyName, {value: J.makeDispatchRecord(interceptor, proto, null, null), enumerable: false, writable: true, configurable: true});
      return interceptor;
    },
    makeLeafDispatchRecord: function(interceptor) {
      return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
    },
    makeDefaultDispatchRecord: function(tag, interceptorClass, proto) {
      var interceptor = interceptorClass.prototype;
      if (init.leafTags[tag] === true)
        return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
      else
        return J.makeDispatchRecord(interceptor, proto, null, null);
    },
    setNativeSubclassDispatchRecord: function(proto, interceptor) {
      Object.defineProperty(proto, init.dispatchPropertyName, {value: H.makeLeafDispatchRecord(interceptor), enumerable: false, writable: true, configurable: true});
    },
    constructorNameFallback: function(object) {
      return C.JS_CONST_TSE(object);
    },
    initNativeDispatch: function() {
      if (true === $.initNativeDispatchFlag)
        return;
      $.initNativeDispatchFlag = true;
      H.initNativeDispatchContinue();
    },
    initNativeDispatchContinue: function() {
      var map, tags, fun, i, tag, proto, record, interceptorClass;
      $.dispatchRecordsForInstanceTags = Object.create(null);
      $.interceptorsForUncacheableTags = Object.create(null);
      H.initHooks();
      map = init.interceptorsByTag;
      tags = Object.getOwnPropertyNames(map);
      if (typeof window != "undefined") {
        window;
        fun = function() {
        };
        for (i = 0; i < tags.length; ++i) {
          tag = tags[i];
          proto = $.prototypeForTagFunction.call$1(tag);
          if (proto != null) {
            record = H.makeDefaultDispatchRecord(tag, map[tag], proto);
            if (record != null) {
              Object.defineProperty(proto, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
              fun.prototype = proto;
            }
          }
        }
      }
      for (i = 0; i < tags.length; ++i) {
        tag = tags[i];
        if (/^[A-Za-z_]/.test(tag)) {
          interceptorClass = map[tag];
          map["!" + tag] = interceptorClass;
          map["~" + tag] = interceptorClass;
          map["-" + tag] = interceptorClass;
          map["+" + tag] = interceptorClass;
          map["*" + tag] = interceptorClass;
        }
      }
    },
    initHooks: function() {
      var hooks, transformers, i, transformer, getTag, getUnknownTag, prototypeForTag;
      hooks = C.JS_CONST_4IJ();
      hooks = H.applyHooksTransformer(C.JS_CONST_EKH, H.applyHooksTransformer(C.JS_CONST_EyN, H.applyHooksTransformer(C.JS_CONST_AgZ, H.applyHooksTransformer(C.JS_CONST_AgZ, H.applyHooksTransformer(C.JS_CONST_c0o, H.applyHooksTransformer(C.JS_CONST_LlX, H.applyHooksTransformer(C.JS_CONST_nuk(C.JS_CONST_TSE), hooks)))))));
      if (typeof dartNativeDispatchHooksTransformer != "undefined") {
        transformers = dartNativeDispatchHooksTransformer;
        if (typeof transformers == "function")
          transformers = [transformers];
        if (transformers.constructor == Array)
          for (i = 0; i < transformers.length; ++i) {
            transformer = transformers[i];
            if (typeof transformer == "function")
              hooks = transformer(hooks) || hooks;
          }
      }
      getTag = hooks.getTag;
      getUnknownTag = hooks.getUnknownTag;
      prototypeForTag = hooks.prototypeForTag;
      $.getTagFunction = new H.initHooks_closure(getTag);
      $.alternateTagFunction = new H.initHooks_closure0(getUnknownTag);
      $.prototypeForTagFunction = new H.initHooks_closure1(prototypeForTag);
    },
    applyHooksTransformer: function(transformer, hooks) {
      return transformer(hooks) || hooks;
    },
    regExpGetNative: function(regexp) {
      return regexp._nativeRegExp;
    },
    regExpGetGlobalNative: function(regexp) {
      var nativeRegexp = regexp.get$_nativeGlobalVersion();
      nativeRegexp.lastIndex = 0;
      return nativeRegexp;
    },
    regExpCaptureCount: function(regexp) {
      return regexp.get$_nativeAnchoredVersion().exec("").length - 2;
    },
    firstMatchAfter: function(regExp, string, start) {
      return regExp._execGlobal$2(string, start);
    },
    stringIndexOfStringUnchecked: function(receiver, other, startIndex) {
      return receiver.indexOf(other, startIndex);
    },
    substring1Unchecked: function(receiver, startIndex) {
      return receiver.substring(startIndex);
    },
    substring2Unchecked: function(receiver, startIndex, endIndex) {
      return receiver.substring(startIndex, endIndex);
    },
    stringContainsStringUnchecked: function(receiver, other, startIndex) {
      return receiver.indexOf(other, startIndex) >= 0;
    },
    allMatchesInStringUnchecked: function(pattern, string, startIndex) {
      return new H._StringAllMatchesIterable(string, pattern, startIndex);
    },
    stringContainsUnchecked: function(receiver, other, startIndex) {
      var t1;
      if (typeof other === "string")
        return receiver.indexOf(other, startIndex) >= 0;
      else {
        t1 = J.getInterceptor(other);
        if (!!t1.$isJSSyntaxRegExp) {
          t1 = C.JSString_methods.substring$1(receiver, startIndex);
          return other._nativeRegExp.test(t1);
        } else {
          t1 = t1.allMatches$1(other, C.JSString_methods.substring$1(receiver, startIndex));
          return !t1.get$isEmpty(t1);
        }
      }
    },
    stringReplaceJS: function(receiver, replacer, replacement) {
      return receiver.replace(replacer, replacement.replace(/\$/g, "$$$$"));
    },
    stringReplaceFirstRE: function(receiver, regexp, replacement, startIndex) {
      var match, t1, start;
      match = regexp._execGlobal$2(receiver, startIndex);
      if (match == null)
        return receiver;
      t1 = match._match;
      start = t1.index;
      return H.stringReplaceRangeUnchecked(receiver, start, start + t1[0].length, replacement);
    },
    quoteStringForRegExp: function(string) {
      return string.replace(/[[\]{}()*+?.\\^$|]/g, "\\$&");
    },
    stringReplaceAllUnchecked: function(receiver, pattern, replacement) {
      var $length, t1, i, nativeRegexp;
      H.checkString(replacement);
      if (typeof pattern === "string")
        if (pattern === "")
          if (receiver === "")
            return replacement;
          else {
            $length = receiver.length;
            t1 = H.S(replacement);
            for (i = 0; i < $length; ++i)
              t1 = t1 + receiver[i] + H.S(replacement);
            return t1.charCodeAt(0) == 0 ? t1 : t1;
          }
        else
          return receiver.replace(new RegExp(pattern.replace(/[[\]{}()*+?.\\^$|]/g, "\\$&"), 'g'), replacement.replace(/\$/g, "$$$$"));
      else if (pattern instanceof H.JSSyntaxRegExp) {
        nativeRegexp = pattern.get$_nativeGlobalVersion();
        nativeRegexp.lastIndex = 0;
        return receiver.replace(nativeRegexp, replacement.replace(/\$/g, "$$$$"));
      } else {
        if (pattern == null)
          H.throwExpression(H.argumentErrorValue(pattern));
        throw H.wrapException("String.replaceAll(Pattern) UNIMPLEMENTED");
      }
    },
    _matchString: [function(match) {
      return match.$index(0, 0);
    }, "call$1", "_js_helper___matchString$closure", 2, 0, 558],
    _stringIdentity: [function(string) {
      return string;
    }, "call$1", "_js_helper___stringIdentity$closure", 2, 0, 28],
    stringReplaceAllFuncUnchecked: function(receiver, pattern, onMatch, onNonMatch) {
      var t1, startIndex, t2, match;
      if (onMatch == null)
        onMatch = H._js_helper___matchString$closure();
      if (onNonMatch == null)
        onNonMatch = H._js_helper___stringIdentity$closure();
      if (typeof pattern === "string")
        return H.stringReplaceAllStringFuncUnchecked(receiver, pattern, onMatch, onNonMatch);
      t1 = J.getInterceptor(pattern);
      if (!t1.$isPattern)
        throw H.wrapException(P.ArgumentError$value(pattern, "pattern", "is not a Pattern"));
      for (t1 = t1.allMatches$1(pattern, receiver), t1 = t1.get$iterator(t1), startIndex = 0, t2 = ""; t1.moveNext$0();) {
        match = t1.get$current();
        t2 = t2 + H.S(onNonMatch.call$1(C.JSString_methods.substring$2(receiver, startIndex, match.get$start()))) + H.S(onMatch.call$1(match));
        startIndex = match.get$end();
      }
      t1 = t2 + H.S(onNonMatch.call$1(C.JSString_methods.substring$1(receiver, startIndex)));
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    stringReplaceAllEmptyFuncUnchecked: function(receiver, onMatch, onNonMatch) {
      var $length, t1, i, i0;
      $length = receiver.length;
      t1 = H.S(onNonMatch.call$1(""));
      for (i = 0; i < $length;) {
        t1 += H.S(onMatch.call$1(new H.StringMatch(i, receiver, "")));
        if ((C.JSString_methods._codeUnitAt$1(receiver, i) & 4294966272) === 55296 && $length > i + 1)
          if ((C.JSString_methods._codeUnitAt$1(receiver, i + 1) & 4294966272) === 56320) {
            i0 = i + 2;
            t1 += H.S(onNonMatch.call$1(C.JSString_methods.substring$2(receiver, i, i0)));
            i = i0;
            continue;
          }
        t1 += H.S(onNonMatch.call$1(receiver[i]));
        ++i;
      }
      t1 = t1 + H.S(onMatch.call$1(new H.StringMatch(i, receiver, ""))) + H.S(onNonMatch.call$1(""));
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    stringReplaceAllStringFuncUnchecked: function(receiver, pattern, onMatch, onNonMatch) {
      var patternLength, $length, startIndex, t1, position;
      patternLength = pattern.length;
      if (patternLength === 0)
        return H.stringReplaceAllEmptyFuncUnchecked(receiver, onMatch, onNonMatch);
      $length = receiver.length;
      for (startIndex = 0, t1 = ""; startIndex < $length;) {
        position = receiver.indexOf(pattern, startIndex);
        if (position === -1)
          break;
        t1 = t1 + H.S(onNonMatch.call$1(C.JSString_methods.substring$2(receiver, startIndex, position))) + H.S(onMatch.call$1(new H.StringMatch(position, receiver, pattern)));
        startIndex = position + patternLength;
      }
      t1 += H.S(onNonMatch.call$1(C.JSString_methods.substring$1(receiver, startIndex)));
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    stringReplaceFirstUnchecked: function(receiver, pattern, replacement, startIndex) {
      var index, t1, matches, match;
      if (typeof pattern === "string") {
        index = receiver.indexOf(pattern, startIndex);
        if (index < 0)
          return receiver;
        return H.stringReplaceRangeUnchecked(receiver, index, index + pattern.length, replacement);
      }
      t1 = J.getInterceptor(pattern);
      if (!!t1.$isJSSyntaxRegExp)
        return J.$eq$(startIndex, 0) ? receiver.replace(pattern._nativeRegExp, replacement.replace(/\$/g, "$$$$")) : H.stringReplaceFirstRE(receiver, pattern, replacement, startIndex);
      if (pattern == null)
        H.throwExpression(H.argumentErrorValue(pattern));
      t1 = t1.allMatches$2(pattern, receiver, startIndex);
      matches = t1.get$iterator(t1);
      if (!matches.moveNext$0())
        return receiver;
      match = matches.get$current();
      return C.JSString_methods.replaceRange$3(receiver, match.get$start(), match.get$end(), replacement);
    },
    stringReplaceFirstMappedUnchecked: function(receiver, pattern, replace, startIndex) {
      var t1, matches, match, replacement;
      t1 = J.allMatches$2$s(pattern, receiver, startIndex);
      matches = t1.get$iterator(t1);
      if (!matches.moveNext$0())
        return receiver;
      match = matches.get$current();
      replacement = H.S(replace.call$1(match));
      return C.JSString_methods.replaceRange$3(receiver, match.get$start(), match.get$end(), replacement);
    },
    stringJoinUnchecked: function(array, separator) {
      return array.join(separator);
    },
    stringReplaceRangeUnchecked: function(receiver, start, end, replacement) {
      var prefix, suffix;
      prefix = receiver.substring(0, start);
      suffix = receiver.substring(end);
      return prefix + H.S(replacement) + suffix;
    },
    NoSideEffects: {
      "^": "Object;"
    },
    "+NoSideEffects": 0,
    NoThrows: {
      "^": "Object;"
    },
    "+NoThrows": 0,
    NoInline: {
      "^": "Object;"
    },
    "+NoInline": 0,
    ForceInline: {
      "^": "Object;"
    },
    "+ForceInline": 0,
    Native: {
      "^": "Object;name<"
    },
    "+Native": 0,
    _Patch: {
      "^": "Object;version<"
    },
    "+_Patch": 0,
    ConstantMapView: {
      "^": "UnmodifiableMapView;_collection$_map-202,$ti",
      $asUnmodifiableMapView: Isolate.functionThatReturnsNull,
      $asMapView: Isolate.functionThatReturnsNull,
      $asMap: Isolate.functionThatReturnsNull,
      $isMap: 1
    },
    "+ConstantMapView": 0,
    ConstantMap: {
      "^": "Object;$ti",
      get$isEmpty: [function(_) {
        return this.get$length(this) === 0;
      }, null, null, 1, 0, 5, "isEmpty"],
      get$isNotEmpty: [function(_) {
        return this.get$length(this) !== 0;
      }, null, null, 1, 0, 5, "isNotEmpty"],
      toString$0: [function(_) {
        return P.Maps_mapToString(this);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $indexSet: [function(_, key, val) {
        return H.ConstantMap__throwUnmodifiable();
      }, null, "get$[]=", 4, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, v: true, args: [K, V]};
        }, this.$receiver, "ConstantMap");
      }, 6, [], 422, [], "[]="],
      putIfAbsent$2: [function(key, ifAbsent) {
        return H.ConstantMap__throwUnmodifiable();
      }, "call$2", "get$putIfAbsent", 4, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V, args: [K, {func: 1, ret: V}]};
        }, this.$receiver, "ConstantMap");
      }, 6, [], 85, [], "putIfAbsent"],
      remove$1: [function(_, key) {
        return H.ConstantMap__throwUnmodifiable();
      }, "call$1", "get$remove", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V, args: [K]};
        }, this.$receiver, "ConstantMap");
      }, 6, [], "remove"],
      clear$0: [function(_) {
        return H.ConstantMap__throwUnmodifiable();
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      addAll$1: [function(_, other) {
        return H.ConstantMap__throwUnmodifiable();
      }, "call$1", "get$addAll", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, v: true, args: [[P.Map, K, V]]};
        }, this.$receiver, "ConstantMap");
      }, 2, [], "addAll"],
      $isMap: 1
    },
    "+ConstantMap": 0,
    ConstantStringMap: {
      "^": "ConstantMap;_length,_jsObject,__js_helper$_keys,$ti",
      get$length: [function(_) {
        return this._length;
      }, null, null, 1, 0, 11, "length"],
      containsValue$1: [function(needle) {
        return this.get$values().any$1(0, new H.ConstantStringMap_containsValue_closure(this, needle));
      }, "call$1", "get$containsValue", 2, 0, 15, 439, [], "containsValue"],
      containsKey$1: [function(key) {
        if (typeof key !== "string")
          return false;
        if ("__proto__" === key)
          return false;
        return this._jsObject.hasOwnProperty(key);
      }, "call$1", "get$containsKey", 2, 0, 15, 6, [], "containsKey"],
      $index: [function(_, key) {
        if (!this.containsKey$1(key))
          return;
        return this._fetch$1(key);
      }, null, "get$[]", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V, args: [P.Object]};
        }, this.$receiver, "ConstantStringMap");
      }, 6, [], "[]"],
      _fetch$1: function(key) {
        return this._jsObject[key];
      },
      forEach$1: [function(_, f) {
        var keys, t1, i, key;
        keys = this.__js_helper$_keys;
        for (t1 = keys.length, i = 0; i < t1; ++i) {
          key = keys[i];
          f.call$2(key, this._fetch$1(key));
        }
      }, "call$1", "get$forEach", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, v: true, args: [{func: 1, v: true, args: [K, V]}]};
        }, this.$receiver, "ConstantStringMap");
      }, 9, [], "forEach"],
      get$keys: [function() {
        return new H._ConstantMapKeyIterable(this, [H.getTypeArgumentByIndex(this, 0)]);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: [P.Iterable, K]};
        }, this.$receiver, "ConstantStringMap");
      }, "keys"],
      get$values: [function() {
        return H.MappedIterable_MappedIterable(this.__js_helper$_keys, new H.ConstantStringMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: [P.Iterable, V]};
        }, this.$receiver, "ConstantStringMap");
      }, "values"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      }
    },
    "+ConstantStringMap": 0,
    ConstantStringMap_containsValue_closure: {
      "^": "Closure;$this,needle",
      call$1: [function(value) {
        return J.$eq$(value, this.needle);
      }, null, null, 2, 0, null, 1, [], "call"],
      $signature: function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, args: [V]};
        }, this.$this, "ConstantStringMap");
      }
    },
    "+ ConstantStringMap_containsValue_closure": 0,
    ConstantStringMap_values_closure: {
      "^": "Closure:3;$this",
      call$1: [function(key) {
        return this.$this._fetch$1(key);
      }, null, null, 2, 0, null, 6, [], "call"]
    },
    "+ ConstantStringMap_values_closure": 0,
    ConstantProtoMap: {
      "^": "ConstantStringMap;_protoValue,_length,_jsObject,__js_helper$_keys,$ti",
      containsKey$1: [function(key) {
        if (typeof key !== "string")
          return false;
        if ("__proto__" === key)
          return true;
        return this._jsObject.hasOwnProperty(key);
      }, "call$1", "get$containsKey", 2, 0, 15, 6, [], "containsKey"],
      _fetch$1: function(key) {
        return "__proto__" === key ? this._protoValue : this._jsObject[key];
      }
    },
    "+ConstantProtoMap": 0,
    _ConstantMapKeyIterable: {
      "^": "Iterable;_map,$ti",
      get$iterator: [function(_) {
        var t1 = this._map.__js_helper$_keys;
        return new J.ArrayIterator(t1, t1.length, 0, null, [H.getTypeArgumentByIndex(t1, 0)]);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(K) {
          return {func: 1, ret: [P.Iterator, K]};
        }, this.$receiver, "_ConstantMapKeyIterable");
      }, "iterator"],
      get$length: [function(_) {
        return this._map.__js_helper$_keys.length;
      }, null, null, 1, 0, 11, "length"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      }
    },
    "+_ConstantMapKeyIterable": 0,
    JSInvocationMirror: {
      "^": "Object;__js_helper$_memberName,_internalName,__js_helper$_kind,_arguments<,_namedArgumentNames,_namedIndices",
      get$memberName: [function() {
        var $name, t1, unmangledName;
        $name = this.__js_helper$_memberName;
        if (!!J.getInterceptor($name).$isSymbol)
          return $name;
        t1 = $.$get$mangledNames();
        unmangledName = t1.$index(0, $name);
        if (unmangledName != null) {
          t1 = unmangledName.split(":");
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          $name = t1[0];
        } else if (t1.$index(0, this._internalName) == null)
          P.print("Warning: '" + H.S($name) + "' is used reflectively but not in MirrorsUsed. This will break minified code.");
        t1 = new H.Symbol0($name);
        this.__js_helper$_memberName = t1;
        return t1;
      }, null, null, 1, 0, 45, "memberName"],
      get$isMethod: [function() {
        return this.__js_helper$_kind === 0;
      }, null, null, 1, 0, 5, "isMethod"],
      get$isGetter: [function() {
        return this.__js_helper$_kind === 1;
      }, null, null, 1, 0, 5, "isGetter"],
      get$isSetter: [function() {
        return this.__js_helper$_kind === 2;
      }, null, null, 1, 0, 5, "isSetter"],
      get$isAccessor: [function() {
        return this.__js_helper$_kind !== 0;
      }, null, null, 1, 0, 5, "isAccessor"],
      get$positionalArguments: [function() {
        var t1, t2, argumentCount, list, index;
        if (this.__js_helper$_kind === 1)
          return C.List_empty;
        t1 = this._arguments;
        t2 = J.getInterceptor$asx(t1);
        argumentCount = J.$sub$n(t2.get$length(t1), this._namedArgumentNames.length);
        if (J.$eq$(argumentCount, 0))
          return C.List_empty;
        list = [];
        if (typeof argumentCount !== "number")
          return H.iae(argumentCount);
        index = 0;
        for (; index < argumentCount; ++index)
          list.push(t2.$index(t1, index));
        return J.JSArray_markUnmodifiableList(list);
      }, null, null, 1, 0, 530, "positionalArguments"],
      get$namedArguments: [function() {
        var t1, namedArgumentCount, t2, t3, namedArgumentsStartIndex, t4, map, t5, i;
        if (this.__js_helper$_kind !== 0)
          return C.Map_empty1;
        t1 = this._namedArgumentNames;
        namedArgumentCount = t1.length;
        t2 = this._arguments;
        t3 = J.getInterceptor$asx(t2);
        namedArgumentsStartIndex = J.$sub$n(t3.get$length(t2), namedArgumentCount);
        if (namedArgumentCount === 0)
          return C.Map_empty1;
        t4 = P.Symbol;
        map = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [t4, null]);
        for (t5 = J.getInterceptor$ns(namedArgumentsStartIndex), i = 0; i < namedArgumentCount; ++i) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          map.$indexSet(0, new H.Symbol0(t1[i]), t3.$index(t2, t5.$add(namedArgumentsStartIndex, i)));
        }
        return new H.ConstantMapView(map, [t4, null]);
      }, null, null, 1, 0, 1569, "namedArguments"],
      _getCachedInvocation$1: function(object) {
        var interceptor, $name, isIntercepted, interceptor0, receiver, method, baseName, isCatchAll;
        interceptor = J.getInterceptor(object);
        $name = this._internalName;
        isIntercepted = Object.prototype.hasOwnProperty.call(init.interceptedNames, $name);
        if (isIntercepted) {
          interceptor0 = object === interceptor ? null : interceptor;
          receiver = interceptor;
          interceptor = interceptor0;
        } else {
          receiver = object;
          interceptor = null;
        }
        method = receiver[$name];
        if (typeof method != "function") {
          baseName = this.get$memberName().get$__internal$_name();
          method = receiver[baseName + "*"];
          if (method == null) {
            interceptor = J.getInterceptor(object);
            method = interceptor[baseName + "*"];
            if (method != null)
              isIntercepted = true;
            else
              interceptor = null;
          }
          isCatchAll = true;
        } else
          isCatchAll = false;
        if (typeof method == "function")
          if (isCatchAll)
            return new H.CachedCatchAllInvocation(H.ReflectionInfo_ReflectionInfo(method), $name, method, isIntercepted, interceptor);
          else
            return new H.CachedInvocation($name, method, isIntercepted, interceptor);
        else
          return new H.CachedNoSuchMethodInvocation(interceptor);
      },
      static: {
        JSInvocationMirror_invokeFromMirror: function(invocation, victim) {
          var cached = invocation._getCachedInvocation$1(victim);
          if (cached.get$isNoSuchMethod())
            return cached.invokeOn$2(victim, invocation);
          else
            return cached.invokeOn$2(victim, invocation.get$_arguments());
        }
      }
    },
    "+JSInvocationMirror": 0,
    CachedInvocation: {
      "^": "Object;mangledName<,jsFunction<,isIntercepted<,cachedInterceptor",
      get$isNoSuchMethod: function() {
        return false;
      },
      get$isGetterStub: function() {
        return !!this.jsFunction.$getterStub;
      },
      invokeOn$2: function(victim, $arguments) {
        var receiver, arguments0;
        if (!this.isIntercepted) {
          if (typeof $arguments !== "object" || $arguments === null || $arguments.constructor !== Array)
            $arguments = P.List_List$from($arguments, true, null);
          receiver = victim;
        } else {
          arguments0 = [victim];
          C.JSArray_methods.addAll$1(arguments0, $arguments);
          receiver = this.cachedInterceptor;
          receiver = receiver != null ? receiver : victim;
          $arguments = arguments0;
        }
        return this.jsFunction.apply(receiver, $arguments);
      }
    },
    "+CachedInvocation": 0,
    CachedCatchAllInvocation: {
      "^": "CachedInvocation;info,mangledName,jsFunction,isIntercepted,cachedInterceptor",
      get$isGetterStub: function() {
        return false;
      },
      invokeOn$2: function(victim, $arguments) {
        var t1, t2, fullParameterCount, providedArgumentCount, receiver, arguments0, i;
        t1 = this.info;
        t2 = t1.requiredParameterCount;
        fullParameterCount = t2 + t1.optionalParameterCount;
        if (!this.isIntercepted) {
          if (typeof $arguments === "object" && $arguments !== null && $arguments.constructor === Array) {
            providedArgumentCount = $arguments.length;
            if (providedArgumentCount < fullParameterCount)
              $arguments = P.List_List$from($arguments, true, null);
          } else {
            $arguments = P.List_List$from($arguments, true, null);
            providedArgumentCount = $arguments.length;
          }
          receiver = victim;
        } else {
          arguments0 = [victim];
          C.JSArray_methods.addAll$1(arguments0, $arguments);
          receiver = this.cachedInterceptor;
          receiver = receiver != null ? receiver : victim;
          providedArgumentCount = arguments0.length - 1;
          $arguments = arguments0;
        }
        if (t1.areOptionalParametersNamed && providedArgumentCount > t2)
          throw H.wrapException(new H.UnimplementedNoSuchMethodError("Invocation of unstubbed method '" + t1.get$reflectionName() + "' with " + $arguments.length + " arguments."));
        else if (providedArgumentCount < t2)
          throw H.wrapException(new H.UnimplementedNoSuchMethodError("Invocation of unstubbed method '" + t1.get$reflectionName() + "' with " + providedArgumentCount + " arguments (too few)."));
        else if (providedArgumentCount > fullParameterCount)
          throw H.wrapException(new H.UnimplementedNoSuchMethodError("Invocation of unstubbed method '" + t1.get$reflectionName() + "' with " + providedArgumentCount + " arguments (too many)."));
        for (i = providedArgumentCount; i < fullParameterCount; ++i)
          C.JSArray_methods.add$1($arguments, init.metadata[t1.defaultValue$1(i)]);
        return this.jsFunction.apply(receiver, $arguments);
      }
    },
    "+CachedCatchAllInvocation": 0,
    CachedNoSuchMethodInvocation: {
      "^": "Object;interceptor",
      get$isNoSuchMethod: function() {
        return true;
      },
      get$isGetterStub: function() {
        return false;
      },
      invokeOn$2: function(victim, invocation) {
        var receiver = this.interceptor;
        return J.noSuchMethod$1$(receiver == null ? victim : receiver, invocation);
      }
    },
    "+CachedNoSuchMethodInvocation": 0,
    ReflectionInfo: {
      "^": "Object;jsFunction<,data<,isAccessor<,requiredParameterCount,optionalParameterCount,areOptionalParametersNamed,functionType,cachedSortedIndices",
      parameterName$1: function(parameter) {
        var metadataIndex = this.data[2 * parameter + this.optionalParameterCount + 3];
        return init.metadata[metadataIndex];
      },
      defaultValue$1: [function(parameter) {
        var t1 = this.requiredParameterCount;
        if (J.$lt$n(parameter, t1))
          return;
        return this.data[3 + parameter - t1];
      }, "call$1", "get$defaultValue", 2, 0, 16, 440, []],
      defaultValueInOrder$1: function(parameter) {
        var t1 = this.requiredParameterCount;
        if (parameter < t1)
          return;
        if (!this.areOptionalParametersNamed || this.optionalParameterCount === 1)
          return this.defaultValue$1(parameter);
        return this.defaultValue$1(this.sortedIndex$1(parameter - t1));
      },
      parameterNameInOrder$1: function(parameter) {
        var t1 = this.requiredParameterCount;
        if (parameter < t1)
          return;
        if (!this.areOptionalParametersNamed || this.optionalParameterCount === 1)
          return this.parameterName$1(parameter);
        return this.parameterName$1(this.sortedIndex$1(parameter - t1));
      },
      sortedIndex$1: function(unsortedIndex) {
        var t1, t2, positions, t3, i, index;
        t1 = {};
        if (this.cachedSortedIndices == null) {
          t2 = this.optionalParameterCount;
          this.cachedSortedIndices = new Array(t2);
          positions = P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.int);
          for (t3 = this.requiredParameterCount, i = 0; i < t2; ++i) {
            index = t3 + i;
            positions.$indexSet(0, this.parameterName$1(index), index);
          }
          t1.index = 0;
          t2 = positions.get$keys().toList$0(0);
          C.JSArray_methods.sort$0(t2);
          C.JSArray_methods.forEach$1(t2, new H.ReflectionInfo_sortedIndex_closure(t1, this, positions));
        }
        t1 = this.cachedSortedIndices;
        if (unsortedIndex < 0 || unsortedIndex >= t1.length)
          return H.ioore(t1, unsortedIndex);
        return t1[unsortedIndex];
      },
      computeFunctionRti$1: function(jsConstructor) {
        var t1, fakeInstance;
        t1 = this.functionType;
        if (typeof t1 == "number")
          return init.types[t1];
        else if (typeof t1 == "function") {
          if (jsConstructor != null) {
            fakeInstance = new jsConstructor();
            H.setRuntimeTypeInfo(fakeInstance, fakeInstance["<>"]);
            return t1.apply({$receiver: fakeInstance});
          }
          return t1;
        } else
          throw H.wrapException(new H.RuntimeError("Unexpected function type"));
      },
      get$reflectionName: function() {
        return this.jsFunction.$reflectionName;
      },
      static: {
        ReflectionInfo_ReflectionInfo: function(jsFunction) {
          var data, requiredParametersInfo, optionalParametersInfo;
          data = jsFunction.$reflectionInfo;
          if (data == null)
            return;
          data.fixed$length = Array;
          data = data;
          requiredParametersInfo = data[0];
          optionalParametersInfo = data[1];
          return new H.ReflectionInfo(jsFunction, data, (requiredParametersInfo & 1) === 1, requiredParametersInfo >> 1, optionalParametersInfo >> 1, (optionalParametersInfo & 1) === 1, data[2], null);
        }
      }
    },
    "+ReflectionInfo": 0,
    ReflectionInfo_sortedIndex_closure: {
      "^": "Closure:13;_box_0,$this,positions",
      call$1: [function($name) {
        var t1, t2, t3;
        t1 = this.$this.cachedSortedIndices;
        t2 = this._box_0.index++;
        t3 = this.positions.$index(0, $name);
        if (t2 >= t1.length)
          return H.ioore(t1, t2);
        t1[t2] = t3;
      }, null, null, 2, 0, null, 13, [], "call"]
    },
    "+ ReflectionInfo_sortedIndex_closure": 0,
    Primitives_initTicker_closure: {
      "^": "Closure:4;performance",
      call$0: function() {
        return C.JSNumber_methods.floor$0(1000 * this.performance.now());
      }
    },
    "+ Primitives_initTicker_closure": 0,
    Primitives_functionNoSuchMethod_closure: {
      "^": "Closure:317;_box_0,$arguments,namedArgumentList",
      call$2: [function($name, argument) {
        var t1 = this._box_0;
        t1.names = t1.names + "$" + H.S($name);
        this.namedArgumentList.push($name);
        this.$arguments.push(argument);
        ++t1.argumentCount;
      }, null, null, 4, 0, null, 13, [], 447, [], "call"]
    },
    "+ Primitives_functionNoSuchMethod_closure": 0,
    Primitives_applyFunctionWithNamedArguments_closure: {
      "^": "Closure:317;_box_0,defaultArguments",
      call$2: [function(parameter, value) {
        var t1 = this.defaultArguments;
        if (t1.containsKey$1(parameter))
          t1.$indexSet(0, parameter, value);
        else
          this._box_0.bad = true;
      }, null, null, 4, 0, null, 440, [], 1, [], "call"]
    },
    "+ Primitives_applyFunctionWithNamedArguments_closure": 0,
    TypeErrorDecoder: {
      "^": "Object;_pattern,_arguments<,_argumentsExpr,_expr,_method,_receiver",
      matchTypeError$1: function(message) {
        var match, result, t1;
        match = new RegExp(this._pattern).exec(message);
        if (match == null)
          return;
        result = Object.create(null);
        t1 = this._arguments;
        if (t1 !== -1)
          result.arguments = match[t1 + 1];
        t1 = this._argumentsExpr;
        if (t1 !== -1)
          result.argumentsExpr = match[t1 + 1];
        t1 = this._expr;
        if (t1 !== -1)
          result.expr = match[t1 + 1];
        t1 = this._method;
        if (t1 !== -1)
          result.method = match[t1 + 1];
        t1 = this._receiver;
        if (t1 !== -1)
          result.receiver = match[t1 + 1];
        return result;
      },
      static: {
        TypeErrorDecoder_extractPattern: function(message) {
          var match, $arguments, argumentsExpr, expr, method, receiver;
          message = message.replace(String({}), '$receiver$').replace(/[[\]{}()*+?.\\^$|]/g, "\\$&");
          match = message.match(/\\\$[a-zA-Z]+\\\$/g);
          if (match == null)
            match = [];
          $arguments = match.indexOf("\\$arguments\\$");
          argumentsExpr = match.indexOf("\\$argumentsExpr\\$");
          expr = match.indexOf("\\$expr\\$");
          method = match.indexOf("\\$method\\$");
          receiver = match.indexOf("\\$receiver\\$");
          return new H.TypeErrorDecoder(message.replace(new RegExp('\\\\\\$arguments\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$argumentsExpr\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$expr\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$method\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$receiver\\\\\\$', 'g'), '((?:x|[^x])*)'), $arguments, argumentsExpr, expr, method, receiver);
        },
        TypeErrorDecoder_provokeCallErrorOn: function(expression) {
          return function($expr$) {
            var $argumentsExpr$ = '$arguments$';
            try {
              $expr$.$method$($argumentsExpr$);
            } catch (e) {
              return e.message;
            }
          }(expression);
        },
        TypeErrorDecoder_provokePropertyErrorOn: function(expression) {
          return function($expr$) {
            try {
              $expr$.$method$;
            } catch (e) {
              return e.message;
            }
          }(expression);
        }
      }
    },
    "+TypeErrorDecoder": 0,
    NullError: {
      "^": "Error;_message,_method",
      toString$0: [function(_) {
        var t1 = this._method;
        if (t1 == null)
          return "NullError: " + H.S(this._message);
        return "NullError: method not found: '" + H.S(t1) + "' on null";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isNoSuchMethodError: 1
    },
    "+NullError": 0,
    JsNoSuchMethodError: {
      "^": "Error;_message,_method,_receiver",
      toString$0: [function(_) {
        var t1, t2;
        t1 = this._method;
        if (t1 == null)
          return "NoSuchMethodError: " + H.S(this._message);
        t2 = this._receiver;
        if (t2 == null)
          return "NoSuchMethodError: method not found: '" + t1 + "' (" + H.S(this._message) + ")";
        return "NoSuchMethodError: method not found: '" + t1 + "' on '" + t2 + "' (" + H.S(this._message) + ")";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isNoSuchMethodError: 1,
      static: {
        JsNoSuchMethodError$: function(_message, match) {
          var t1, t2;
          t1 = match == null;
          t2 = t1 ? null : match.method;
          return new H.JsNoSuchMethodError(_message, t2, t1 ? null : match.receiver);
        }
      }
    },
    "+JsNoSuchMethodError": 0,
    UnknownJsTypeError: {
      "^": "Error;_message",
      toString$0: [function(_) {
        var t1 = this._message;
        return C.JSString_methods.get$isEmpty(t1) ? "Error" : "Error: " + t1;
      }, "call$0", "get$toString", 0, 0, 7, "toString"]
    },
    "+UnknownJsTypeError": 0,
    ExceptionAndStackTrace: {
      "^": "Object;dartException,stackTrace@"
    },
    "+ExceptionAndStackTrace": 0,
    unwrapException_saveStackTrace: {
      "^": "Closure:3;ex",
      call$1: [function(error) {
        if (!!J.getInterceptor(error).$isError)
          if (error.$thrownJsError == null)
            error.$thrownJsError = this.ex;
        return error;
      }, null, null, 2, 0, 3, 8, [], "call"]
    },
    "+ unwrapException_saveStackTrace": [2],
    _StackTrace: {
      "^": "Object;_exception,_trace",
      toString$0: [function(_) {
        var t1, trace;
        t1 = this._trace;
        if (t1 != null)
          return t1;
        t1 = this._exception;
        trace = t1 !== null && typeof t1 === "object" ? t1.stack : null;
        t1 = trace == null ? "" : trace;
        this._trace = t1;
        return t1;
      }, "call$0", "get$toString", 0, 0, 7, "toString"]
    },
    "+_StackTrace": 0,
    invokeClosure_closure: {
      "^": "Closure:4;closure",
      call$0: [function() {
        return this.closure.call$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ invokeClosure_closure": [2],
    invokeClosure_closure0: {
      "^": "Closure:4;closure,arg1",
      call$0: [function() {
        return this.closure.call$1(this.arg1);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ invokeClosure_closure": [2],
    invokeClosure_closure1: {
      "^": "Closure:4;closure,arg1,arg2",
      call$0: [function() {
        return this.closure.call$2(this.arg1, this.arg2);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ invokeClosure_closure": [2],
    invokeClosure_closure2: {
      "^": "Closure:4;closure,arg1,arg2,arg3",
      call$0: [function() {
        return this.closure.call$3(this.arg1, this.arg2, this.arg3);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ invokeClosure_closure": [2],
    invokeClosure_closure3: {
      "^": "Closure:4;closure,arg1,arg2,arg3,arg4",
      call$0: [function() {
        return this.closure.call$4(this.arg1, this.arg2, this.arg3, this.arg4);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ invokeClosure_closure": [2],
    Closure: {
      "^": "Object;",
      toString$0: [function(_) {
        return "Closure '" + H.Primitives_objectTypeName(this).trim() + "'";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      get$$call: function() {
        return this;
      },
      $isFunction: 1,
      get$$call: function() {
        return this;
      },
      static: {
        Closure_fromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, propertyName) {
          var $function, callName, functionType, $prototype, $constructor, t1, isIntercepted, trampoline, signatureFunction, getReceiver, i, stub, stubCallName, t2;
          $function = functions[0];
          callName = $function.$callName;
          if (!!J.getInterceptor(reflectionInfo).$isList) {
            $function.$reflectionInfo = reflectionInfo;
            functionType = H.ReflectionInfo_ReflectionInfo($function).functionType;
          } else
            functionType = reflectionInfo;
          $prototype = isStatic ? Object.create(new H.StaticClosure().constructor.prototype) : Object.create(new H.BoundClosure(null, null, null, null).constructor.prototype);
          $prototype.$initialize = $prototype.constructor;
          if (isStatic)
            $constructor = function() {
              this.$initialize();
            };
          else {
            t1 = $.Closure_functionCounter;
            $.Closure_functionCounter = J.$add$ns(t1, 1);
            t1 = new Function("a,b,c,d" + t1, "this.$initialize(a,b,c,d" + t1 + ")");
            $constructor = t1;
          }
          $prototype.constructor = $constructor;
          $constructor.prototype = $prototype;
          if (!isStatic) {
            isIntercepted = jsArguments.length == 1 && true;
            trampoline = H.Closure_forwardCallTo(receiver, $function, isIntercepted);
            trampoline.$reflectionInfo = reflectionInfo;
          } else {
            $prototype.$static_name = propertyName;
            trampoline = $function;
            isIntercepted = false;
          }
          if (typeof functionType == "number")
            signatureFunction = function(getType, t) {
              return function() {
                return getType(t);
              };
            }(H.getType, functionType);
          else if (typeof functionType == "function")
            if (isStatic)
              signatureFunction = functionType;
            else {
              getReceiver = isIntercepted ? H.BoundClosure_receiverOf : H.BoundClosure_selfOf;
              signatureFunction = function(f, r) {
                return function() {
                  return f.apply({$receiver: r(this)}, arguments);
                };
              }(functionType, getReceiver);
            }
          else
            throw H.wrapException("Error in reflectionInfo.");
          $prototype.$signature = signatureFunction;
          $prototype[callName] = trampoline;
          for (t1 = functions.length, i = 1; i < t1; ++i) {
            stub = functions[i];
            stubCallName = stub.$callName;
            if (stubCallName != null) {
              t2 = isStatic ? stub : H.Closure_forwardCallTo(receiver, stub, isIntercepted);
              $prototype[stubCallName] = t2;
            }
          }
          $prototype["call*"] = trampoline;
          $prototype.$requiredArgCount = $function.$requiredArgCount;
          $prototype.$defaultValues = $function.$defaultValues;
          return $constructor;
        },
        Closure_cspForwardCall: function(arity, isSuperCall, stubName, $function) {
          var getSelf = H.BoundClosure_selfOf;
          switch (isSuperCall ? -1 : arity) {
            case 0:
              return function(n, S) {
                return function() {
                  return S(this)[n]();
                };
              }(stubName, getSelf);
            case 1:
              return function(n, S) {
                return function(a) {
                  return S(this)[n](a);
                };
              }(stubName, getSelf);
            case 2:
              return function(n, S) {
                return function(a, b) {
                  return S(this)[n](a, b);
                };
              }(stubName, getSelf);
            case 3:
              return function(n, S) {
                return function(a, b, c) {
                  return S(this)[n](a, b, c);
                };
              }(stubName, getSelf);
            case 4:
              return function(n, S) {
                return function(a, b, c, d) {
                  return S(this)[n](a, b, c, d);
                };
              }(stubName, getSelf);
            case 5:
              return function(n, S) {
                return function(a, b, c, d, e) {
                  return S(this)[n](a, b, c, d, e);
                };
              }(stubName, getSelf);
            default:
              return function(f, s) {
                return function() {
                  return f.apply(s(this), arguments);
                };
              }($function, getSelf);
          }
        },
        Closure_forwardCallTo: function(receiver, $function, isIntercepted) {
          var stubName, arity, lookedUpFunction, t1, t2, selfName, $arguments;
          if (isIntercepted)
            return H.Closure_forwardInterceptedCallTo(receiver, $function);
          stubName = $function.$stubName;
          arity = $function.length;
          lookedUpFunction = receiver[stubName];
          t1 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
          t2 = !t1 || arity >= 27;
          if (t2)
            return H.Closure_cspForwardCall(arity, !t1, stubName, $function);
          if (arity === 0) {
            t1 = $.Closure_functionCounter;
            $.Closure_functionCounter = J.$add$ns(t1, 1);
            selfName = "self" + H.S(t1);
            t1 = "return function(){var " + selfName + " = this.";
            t2 = $.BoundClosure_selfFieldNameCache;
            if (t2 == null) {
              t2 = H.BoundClosure_computeFieldNamed("self");
              $.BoundClosure_selfFieldNameCache = t2;
            }
            return new Function(t1 + H.S(t2) + ";return " + selfName + "." + H.S(stubName) + "();}")();
          }
          $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity).join(",");
          t1 = $.Closure_functionCounter;
          $.Closure_functionCounter = J.$add$ns(t1, 1);
          $arguments += H.S(t1);
          t1 = "return function(" + $arguments + "){return this.";
          t2 = $.BoundClosure_selfFieldNameCache;
          if (t2 == null) {
            t2 = H.BoundClosure_computeFieldNamed("self");
            $.BoundClosure_selfFieldNameCache = t2;
          }
          return new Function(t1 + H.S(t2) + "." + H.S(stubName) + "(" + $arguments + ");}")();
        },
        Closure_cspForwardInterceptedCall: function(arity, isSuperCall, $name, $function) {
          var getSelf, getReceiver;
          getSelf = H.BoundClosure_selfOf;
          getReceiver = H.BoundClosure_receiverOf;
          switch (isSuperCall ? -1 : arity) {
            case 0:
              throw H.wrapException(new H.RuntimeError("Intercepted function with no arguments."));
            case 1:
              return function(n, s, r) {
                return function() {
                  return s(this)[n](r(this));
                };
              }($name, getSelf, getReceiver);
            case 2:
              return function(n, s, r) {
                return function(a) {
                  return s(this)[n](r(this), a);
                };
              }($name, getSelf, getReceiver);
            case 3:
              return function(n, s, r) {
                return function(a, b) {
                  return s(this)[n](r(this), a, b);
                };
              }($name, getSelf, getReceiver);
            case 4:
              return function(n, s, r) {
                return function(a, b, c) {
                  return s(this)[n](r(this), a, b, c);
                };
              }($name, getSelf, getReceiver);
            case 5:
              return function(n, s, r) {
                return function(a, b, c, d) {
                  return s(this)[n](r(this), a, b, c, d);
                };
              }($name, getSelf, getReceiver);
            case 6:
              return function(n, s, r) {
                return function(a, b, c, d, e) {
                  return s(this)[n](r(this), a, b, c, d, e);
                };
              }($name, getSelf, getReceiver);
            default:
              return function(f, s, r, a) {
                return function() {
                  a = [r(this)];
                  Array.prototype.push.apply(a, arguments);
                  return f.apply(s(this), a);
                };
              }($function, getSelf, getReceiver);
          }
        },
        Closure_forwardInterceptedCallTo: function(receiver, $function) {
          var selfField, t1, stubName, arity, lookedUpFunction, t2, t3, $arguments;
          selfField = H.BoundClosure_selfFieldName();
          t1 = $.BoundClosure_receiverFieldNameCache;
          if (t1 == null) {
            t1 = H.BoundClosure_computeFieldNamed("receiver");
            $.BoundClosure_receiverFieldNameCache = t1;
          }
          stubName = $function.$stubName;
          arity = $function.length;
          lookedUpFunction = receiver[stubName];
          t2 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
          t3 = !t2 || arity >= 28;
          if (t3)
            return H.Closure_cspForwardInterceptedCall(arity, !t2, stubName, $function);
          if (arity === 1) {
            t1 = "return function(){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ");";
            t2 = $.Closure_functionCounter;
            $.Closure_functionCounter = J.$add$ns(t2, 1);
            return new Function(t1 + H.S(t2) + "}")();
          }
          $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity - 1).join(",");
          t1 = "return function(" + $arguments + "){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ", " + $arguments + ");";
          t2 = $.Closure_functionCounter;
          $.Closure_functionCounter = J.$add$ns(t2, 1);
          return new Function(t1 + H.S(t2) + "}")();
        }
      }
    },
    "+Closure": [1, 29],
    TearOffClosure: {
      "^": "Closure;"
    },
    "+TearOffClosure": 0,
    StaticClosure: {
      "^": "TearOffClosure;",
      toString$0: [function(_) {
        var $name = this.$static_name;
        if ($name == null)
          return "Closure of unknown static method";
        return "Closure '" + $name + "'";
      }, "call$0", "get$toString", 0, 0, 7, "toString"]
    },
    "+StaticClosure": 0,
    BoundClosure: {
      "^": "TearOffClosure;_self<,_target,_receiver,_name",
      $eq: [function(_, other) {
        if (other == null)
          return false;
        if (this === other)
          return true;
        if (!(other instanceof H.BoundClosure))
          return false;
        return this._self === other._self && this._target === other._target && this._receiver === other._receiver;
      }, null, "get$==", 2, 0, 24, 2, [], "=="],
      get$hashCode: [function(_) {
        var t1, receiverHashCode;
        t1 = this._receiver;
        if (t1 == null)
          receiverHashCode = H.Primitives_objectHashCode(this._self);
        else
          receiverHashCode = typeof t1 !== "object" ? J.get$hashCode$(t1) : H.Primitives_objectHashCode(t1);
        return J.$xor$n(receiverHashCode, H.Primitives_objectHashCode(this._target));
      }, null, null, 1, 0, 11, "hashCode"],
      toString$0: [function(_) {
        var receiver = this._receiver;
        if (receiver == null)
          receiver = this._self;
        return "Closure '" + H.S(this._name) + "' of " + H.Primitives_objectToHumanReadableString(receiver);
      }, "call$0", "get$toString", 0, 0, 4, "toString"],
      static: {
        BoundClosure_selfOf: function(closure) {
          return closure.get$_self();
        },
        BoundClosure_receiverOf: function(closure) {
          return closure._receiver;
        },
        BoundClosure_selfFieldName: function() {
          var t1 = $.BoundClosure_selfFieldNameCache;
          if (t1 == null) {
            t1 = H.BoundClosure_computeFieldNamed("self");
            $.BoundClosure_selfFieldNameCache = t1;
          }
          return t1;
        },
        BoundClosure_computeFieldNamed: function(fieldName) {
          var template, t1, names, i, $name;
          template = new H.BoundClosure("self", "target", "receiver", "name");
          t1 = Object.getOwnPropertyNames(template);
          t1.fixed$length = Array;
          names = t1;
          for (t1 = names.length, i = 0; i < t1; ++i) {
            $name = names[i];
            if (template[$name] === fieldName)
              return $name;
          }
        }
      }
    },
    "+BoundClosure": [1128],
    Creates: {
      "^": "Object;types"
    },
    "+Creates": 0,
    Returns: {
      "^": "Object;types"
    },
    "+Returns": 0,
    JSName: {
      "^": "Object;name<"
    },
    "+JSName": 0,
    TypeErrorImplementation: {
      "^": "Error;message<-",
      toString$0: [function(_) {
        return this.message;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        TypeErrorImplementation$: function(value, type) {
          return new H.TypeErrorImplementation("type '" + H.Primitives_objectTypeName(value) + "' is not a subtype of type '" + type + "'");
        }
      }
    },
    "+TypeErrorImplementation": 0,
    CastErrorImplementation: {
      "^": "Error;message<",
      toString$0: [function(_) {
        return this.message;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        CastErrorImplementation$: function(actualType, expectedType) {
          return new H.CastErrorImplementation("CastError: Casting value of type '" + actualType + "' to incompatible type '" + expectedType + "'");
        }
      }
    },
    "+CastErrorImplementation": 0,
    FallThroughErrorImplementation: {
      "^": "FallThroughError;",
      toString$0: [function(_) {
        return "Switch case fall-through.";
      }, "call$0", "get$toString", 0, 0, 7, "toString"]
    },
    "+FallThroughErrorImplementation": 0,
    RuntimeError: {
      "^": "Error;message<",
      toString$0: [function(_) {
        return "RuntimeError: " + H.S(this.message);
      }, "call$0", "get$toString", 0, 0, 7, "toString"]
    },
    "+RuntimeError": 0,
    DeferredNotLoadedError: {
      "^": "Error;libraryName@",
      toString$0: [function(_) {
        return "Deferred library " + H.S(this.libraryName) + " was not loaded.";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isNoSuchMethodError: 1
    },
    "+DeferredNotLoadedError": 0,
    UnimplementedNoSuchMethodError: {
      "^": "Error;_message",
      toString$0: [function(_) {
        return "Unsupported operation: " + this._message;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isNoSuchMethodError: 1
    },
    "+UnimplementedNoSuchMethodError": 0,
    _loadLibraryWrapper_closure: {
      "^": "Closure:4;loadId",
      call$0: [function() {
        return H.loadDeferredLibrary(this.loadId);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _loadLibraryWrapper_closure": [2],
    loadDeferredLibrary_closure: {
      "^": "Closure:3;",
      call$1: [function(i) {
        return i;
      }, null, null, 2, 0, 3, 127, [], "call"]
    },
    "+ loadDeferredLibrary_closure": [2],
    loadDeferredLibrary_closure0: {
      "^": "Closure:22;hashes,isHunkLoaded",
      call$1: [function(i) {
        var t1 = this.hashes;
        if (i >>> 0 !== i || i >= t1.length)
          return H.ioore(t1, i);
        return !this.isHunkLoaded(t1[i]);
      }, null, null, 2, 0, 22, 127, [], "call"]
    },
    "+ loadDeferredLibrary_closure": [2],
    loadDeferredLibrary_closure1: {
      "^": "Closure:22;uris",
      call$1: [function(i) {
        var t1 = this.uris;
        if (i >>> 0 !== i || i >= t1.length)
          return H.ioore(t1, i);
        return H._loadHunk(t1[i]);
      }, null, null, 2, 0, 22, 127, [], "call"]
    },
    "+ loadDeferredLibrary_closure": [2],
    loadDeferredLibrary_closure2: {
      "^": "Closure:3;loadId,hashes,indices,isHunkInitialized",
      call$1: [function(_) {
        var t1, t2, t3, indicesToInitialize, _i, i;
        t1 = this.indices;
        t2 = this.hashes;
        t3 = H.getTypeArgumentByIndex(t1, 0);
        indicesToInitialize = P.List_List$from(new H.WhereIterable(t1, new H.loadDeferredLibrary__closure(t2, this.isHunkInitialized), [t3]), true, t3);
        for (t1 = indicesToInitialize.length, _i = 0; _i < indicesToInitialize.length; indicesToInitialize.length === t1 || (0, H.throwConcurrentModificationError)(indicesToInitialize), ++_i) {
          i = indicesToInitialize[_i];
          if (i >>> 0 !== i || i >= t2.length)
            return H.ioore(t2, i);
          init.initializeLoadedHunk(t2[i]);
        }
        if ($.$get$_loadedLibraries().add$1(0, this.loadId) && $.deferredLoadHook != null)
          $.deferredLoadHook.call$0();
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ loadDeferredLibrary_closure": [2],
    loadDeferredLibrary__closure: {
      "^": "Closure:22;hashes,isHunkInitialized",
      call$1: [function(i) {
        var t1 = this.hashes;
        if (i >>> 0 !== i || i >= t1.length)
          return H.ioore(t1, i);
        return !this.isHunkInitialized(t1[i]);
      }, null, null, 2, 0, 22, 127, [], "call"]
    },
    "+ loadDeferredLibrary__closure": [2],
    _loadHunk_closure: {
      "^": "Closure:3;",
      call$1: [function(_) {
        return;
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _loadHunk_closure": [2],
    _loadHunk_success: {
      "^": "Closure:6;completer",
      call$0: [function() {
        this.completer.complete$1(null);
      }, null, null, 0, 0, 6, "call"]
    },
    "+ _loadHunk_success": [2],
    _loadHunk_failure: {
      "^": "Closure:319;_box_0,hunkName,completer",
      call$2: [function(error, stackTrace) {
        $.$get$_loadingLibraries().$indexSet(0, this.hunkName, null);
        this.completer.completeError$2(new P.DeferredLoadException("Loading " + H.S(this._box_0.uri) + " failed: " + H.S(error)), stackTrace);
      }, function(error) {
        return this.call$2(error, null);
      }, "call$1", function() {
        return this.call$2(null, null);
      }, "call$0", null, null, null, null, 0, 4, 319, 0, 0, 8, [], 12, [], "call"]
    },
    "+ _loadHunk_failure": [2],
    _loadHunk_closure0: {
      "^": "Closure:3;failure",
      call$1: [function(error) {
        this.failure.call$2(H.unwrapException(error), H.getTraceFromException(error));
      }, null, null, 2, 0, 3, 8, [], "call"]
    },
    "+ _loadHunk_closure": [2],
    _loadHunk_closure1: {
      "^": "Closure:4;",
      call$0: [function() {
        --init.globalState.topEventLoop._activeJsAsyncCount;
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _loadHunk_closure": [2],
    _loadHunk_closure2: {
      "^": "Closure:3;success,failure,xhr",
      call$1: [function($event) {
        var code, error, stackTrace, t1, exception;
        t1 = this.xhr;
        if (t1.status !== 200)
          this.failure.call$1("");
        code = t1.responseText;
        try {
          new Function(code)();
          this.success.call$0();
        } catch (exception) {
          t1 = H.unwrapException(exception);
          error = t1;
          stackTrace = H.getTraceFromException(exception);
          this.failure.call$2(error, stackTrace);
        }
      }, null, null, 2, 0, 3, 110, [], "call"]
    },
    "+ _loadHunk_closure": [2],
    MainError: {
      "^": "Error;_message",
      toString$0: [function(_) {
        return "NoSuchMethodError: " + this._message;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isNoSuchMethodError: 1
    },
    "+MainError": 0,
    _AssertionError: {
      "^": "AssertionError;message-1",
      toString$0: [function(_) {
        return C.JSString_methods.$add("Assertion failed: ", P.Error_safeToString(this.message));
      }, "call$0", "get$toString", 0, 0, 7, "toString"]
    },
    "+_AssertionError": 0,
    _UnreachableError: {
      "^": "AssertionError;message-1",
      toString$0: [function(_) {
        return "Assertion failed: Reached dead code";
      }, "call$0", "get$toString", 0, 0, 7, "toString"]
    },
    "+_UnreachableError": 0,
    TypeImpl: {
      "^": "Object;_typeName<,_unmangledName",
      toString$0: [function(_) {
        var t1, unmangledName;
        t1 = this._unmangledName;
        if (t1 != null)
          return t1;
        unmangledName = function(str, names) {
          return str.replace(/[^<,> ]+/g, function(m) {
            return names[m] || m;
          });
        }(this._typeName, init.mangledGlobalNames);
        this._unmangledName = unmangledName;
        return unmangledName;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this._typeName);
      }, null, null, 1, 0, 11, "hashCode"],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof H.TypeImpl && J.$eq$(this._typeName, other._typeName);
      }, null, "get$==", 2, 0, 24, 2, [], "=="],
      $isType: 1
    },
    "+TypeImpl": 0,
    TypeVariable: {
      "^": "Object;owner<,name<,bound<"
    },
    "+TypeVariable": 0,
    JsLinkedHashMap: {
      "^": "Object;_length,_strings,_nums,_rest,_first,_last,_modifications,$ti",
      get$length: [function(_) {
        return this._length;
      }, null, null, 1, 0, 11, "length"],
      get$isEmpty: [function(_) {
        return this._length === 0;
      }, null, null, 1, 0, 5, "isEmpty"],
      get$isNotEmpty: [function(_) {
        return !this.get$isEmpty(this);
      }, null, null, 1, 0, 5, "isNotEmpty"],
      get$keys: [function() {
        return new H.LinkedHashMapKeyIterable(this, [H.getTypeArgumentByIndex(this, 0)]);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: [P.Iterable, K]};
        }, this.$receiver, "JsLinkedHashMap");
      }, "keys"],
      get$values: [function() {
        return H.MappedIterable_MappedIterable(this.get$keys(), new H.JsLinkedHashMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: [P.Iterable, V]};
        }, this.$receiver, "JsLinkedHashMap");
      }, "values"],
      containsKey$1: [function(key) {
        var strings, nums;
        if (typeof key === "string") {
          strings = this._strings;
          if (strings == null)
            return false;
          return this._containsTableEntry$2(strings, key);
        } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
          nums = this._nums;
          if (nums == null)
            return false;
          return this._containsTableEntry$2(nums, key);
        } else
          return this.internalContainsKey$1(key);
      }, "call$1", "get$containsKey", 2, 0, 15, 6, [], "containsKey"],
      internalContainsKey$1: ["super$JsLinkedHashMap$internalContainsKey", function(key) {
        var rest = this._rest;
        if (rest == null)
          return false;
        return this.internalFindBucketIndex$2(this._getTableBucket$2(rest, this.internalComputeHashCode$1(key)), key) >= 0;
      }],
      containsValue$1: [function(value) {
        return this.get$keys().any$1(0, new H.JsLinkedHashMap_containsValue_closure(this, value));
      }, "call$1", "get$containsValue", 2, 0, 15, 1, [], "containsValue"],
      addAll$1: [function(_, other) {
        J.forEach$1$ax(other, new H.JsLinkedHashMap_addAll_closure(this));
      }, "call$1", "get$addAll", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, v: true, args: [[P.Map, K, V]]};
        }, this.$receiver, "JsLinkedHashMap");
      }, 2, [], "addAll"],
      $index: [function(_, key) {
        var strings, cell, nums;
        if (typeof key === "string") {
          strings = this._strings;
          if (strings == null)
            return;
          cell = this._getTableCell$2(strings, key);
          return cell == null ? null : cell.get$hashMapCellValue();
        } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
          nums = this._nums;
          if (nums == null)
            return;
          cell = this._getTableCell$2(nums, key);
          return cell == null ? null : cell.get$hashMapCellValue();
        } else
          return this.internalGet$1(key);
      }, null, "get$[]", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V, args: [P.Object]};
        }, this.$receiver, "JsLinkedHashMap");
      }, 6, [], "[]"],
      internalGet$1: ["super$JsLinkedHashMap$internalGet", function(key) {
        var rest, bucket, index;
        rest = this._rest;
        if (rest == null)
          return;
        bucket = this._getTableBucket$2(rest, this.internalComputeHashCode$1(key));
        index = this.internalFindBucketIndex$2(bucket, key);
        if (index < 0)
          return;
        return bucket[index].get$hashMapCellValue();
      }],
      $indexSet: [function(_, key, value) {
        var strings, cell, nums;
        if (typeof key === "string") {
          strings = this._strings;
          if (strings == null) {
            strings = this._newHashTable$0();
            this._strings = strings;
          }
          cell = this._getTableCell$2(strings, key);
          if (cell == null)
            this._setTableEntry$3(strings, key, this._newLinkedCell$2(key, value));
          else
            cell.set$hashMapCellValue(value);
        } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
          nums = this._nums;
          if (nums == null) {
            nums = this._newHashTable$0();
            this._nums = nums;
          }
          cell = this._getTableCell$2(nums, key);
          if (cell == null)
            this._setTableEntry$3(nums, key, this._newLinkedCell$2(key, value));
          else
            cell.set$hashMapCellValue(value);
        } else
          this.internalSet$2(key, value);
      }, null, "get$[]=", 4, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, v: true, args: [K, V]};
        }, this.$receiver, "JsLinkedHashMap");
      }, 6, [], 1, [], "[]="],
      internalSet$2: ["super$JsLinkedHashMap$internalSet", function(key, value) {
        var rest, hash, bucket, index;
        rest = this._rest;
        if (rest == null) {
          rest = this._newHashTable$0();
          this._rest = rest;
        }
        hash = this.internalComputeHashCode$1(key);
        bucket = this._getTableBucket$2(rest, hash);
        if (bucket == null)
          this._setTableEntry$3(rest, hash, [this._newLinkedCell$2(key, value)]);
        else {
          index = this.internalFindBucketIndex$2(bucket, key);
          if (index >= 0)
            bucket[index].set$hashMapCellValue(value);
          else
            bucket.push(this._newLinkedCell$2(key, value));
        }
      }],
      putIfAbsent$2: [function(key, ifAbsent) {
        var value;
        if (this.containsKey$1(key))
          return this.$index(0, key);
        value = ifAbsent.call$0();
        this.$indexSet(0, key, value);
        return value;
      }, "call$2", "get$putIfAbsent", 4, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V, args: [K, {func: 1, ret: V}]};
        }, this.$receiver, "JsLinkedHashMap");
      }, 6, [], 85, [], "putIfAbsent"],
      remove$1: [function(_, key) {
        if (typeof key === "string")
          return this._removeHashTableEntry$2(this._strings, key);
        else if (typeof key === "number" && (key & 0x3ffffff) === key)
          return this._removeHashTableEntry$2(this._nums, key);
        else
          return this.internalRemove$1(key);
      }, "call$1", "get$remove", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V, args: [P.Object]};
        }, this.$receiver, "JsLinkedHashMap");
      }, 6, [], "remove"],
      internalRemove$1: ["super$JsLinkedHashMap$internalRemove", function(key) {
        var rest, bucket, index, cell;
        rest = this._rest;
        if (rest == null)
          return;
        bucket = this._getTableBucket$2(rest, this.internalComputeHashCode$1(key));
        index = this.internalFindBucketIndex$2(bucket, key);
        if (index < 0)
          return;
        cell = bucket.splice(index, 1)[0];
        this._unlinkCell$1(cell);
        return cell.get$hashMapCellValue();
      }],
      clear$0: [function(_) {
        if (this._length > 0) {
          this._last = null;
          this._first = null;
          this._rest = null;
          this._nums = null;
          this._strings = null;
          this._length = 0;
          this._modifications = this._modifications + 1 & 67108863;
        }
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      forEach$1: [function(_, action) {
        var cell, modifications;
        cell = this._first;
        modifications = this._modifications;
        for (; cell != null;) {
          action.call$2(cell.hashMapCellKey, cell.hashMapCellValue);
          if (modifications !== this._modifications)
            throw H.wrapException(new P.ConcurrentModificationError(this));
          cell = cell._next;
        }
      }, "call$1", "get$forEach", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, v: true, args: [{func: 1, v: true, args: [K, V]}]};
        }, this.$receiver, "JsLinkedHashMap");
      }, 71, [], "forEach"],
      _removeHashTableEntry$2: function(table, key) {
        var cell;
        if (table == null)
          return;
        cell = this._getTableCell$2(table, key);
        if (cell == null)
          return;
        this._unlinkCell$1(cell);
        this._deleteTableEntry$2(table, key);
        return cell.get$hashMapCellValue();
      },
      _newLinkedCell$2: function(key, value) {
        var cell, last;
        cell = new H.LinkedHashMapCell(key, value, null, null, [null, null]);
        if (this._first == null) {
          this._last = cell;
          this._first = cell;
        } else {
          last = this._last;
          cell._previous = last;
          last._next = cell;
          this._last = cell;
        }
        ++this._length;
        this._modifications = this._modifications + 1 & 67108863;
        return cell;
      },
      _unlinkCell$1: function(cell) {
        var previous, next;
        previous = cell.get$_previous();
        next = cell.get$_next();
        if (previous == null)
          this._first = next;
        else
          previous._next = next;
        if (next == null)
          this._last = previous;
        else
          next._previous = previous;
        --this._length;
        this._modifications = this._modifications + 1 & 67108863;
      },
      internalComputeHashCode$1: function(key) {
        return J.get$hashCode$(key) & 0x3ffffff;
      },
      internalFindBucketIndex$2: function(bucket, key) {
        var $length, i;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (i = 0; i < $length; ++i)
          if (J.$eq$(bucket[i].get$hashMapCellKey(), key))
            return i;
        return -1;
      },
      toString$0: [function(_) {
        return P.Maps_mapToString(this);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      _getTableCell$2: function(table, key) {
        return table[key];
      },
      _getTableBucket$2: function(table, key) {
        return table[key];
      },
      _setTableEntry$3: function(table, key, value) {
        table[key] = value;
      },
      _deleteTableEntry$2: function(table, key) {
        delete table[key];
      },
      _containsTableEntry$2: function(table, key) {
        return this._getTableCell$2(table, key) != null;
      },
      _newHashTable$0: function() {
        var table = Object.create(null);
        this._setTableEntry$3(table, "<non-identifier-key>", table);
        this._deleteTableEntry$2(table, "<non-identifier-key>");
        return table;
      },
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $isInternalMap: 1,
      $isMap: 1,
      static: {
        JsLinkedHashMap_JsLinkedHashMap$es6: function($K, $V) {
          return new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [$K, $V]);
        }
      }
    },
    "+JsLinkedHashMap": 0,
    JsLinkedHashMap_values_closure: {
      "^": "Closure:3;$this",
      call$1: [function(each) {
        return this.$this.$index(0, each);
      }, null, null, 2, 0, null, 186, [], "call"]
    },
    "+ JsLinkedHashMap_values_closure": 0,
    JsLinkedHashMap_containsValue_closure: {
      "^": "Closure:3;$this,value",
      call$1: [function(each) {
        return J.$eq$(this.$this.$index(0, each), this.value);
      }, null, null, 2, 0, null, 186, [], "call"]
    },
    "+ JsLinkedHashMap_containsValue_closure": 0,
    JsLinkedHashMap_addAll_closure: {
      "^": "Closure;$this",
      call$2: [function(key, value) {
        this.$this.$indexSet(0, key, value);
      }, null, null, 4, 0, null, 6, [], 1, [], "call"],
      $signature: function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, args: [K, V]};
        }, this.$this, "JsLinkedHashMap");
      }
    },
    "+ JsLinkedHashMap_addAll_closure": 0,
    LinkedHashMapCell: {
      "^": "Object;hashMapCellKey<,hashMapCellValue@,_next<,_previous<,$ti"
    },
    "+LinkedHashMapCell": 0,
    LinkedHashMapKeyIterable: {
      "^": "EfficientLengthIterable;_map,$ti",
      get$length: [function(_) {
        return this._map._length;
      }, null, null, 1, 0, 11, "length"],
      get$isEmpty: [function(_) {
        return this._map._length === 0;
      }, null, null, 1, 0, 5, "isEmpty"],
      get$iterator: [function(_) {
        var t1, t2;
        t1 = this._map;
        t2 = new H.LinkedHashMapKeyIterator(t1, t1._modifications, null, null, this.$ti);
        t2._cell = t1._first;
        return t2;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterator, E]};
        }, this.$receiver, "LinkedHashMapKeyIterable");
      }, "iterator"],
      contains$1: [function(_, element) {
        return this._map.containsKey$1(element);
      }, "call$1", "get$contains", 2, 0, 15, 31, [], "contains"],
      forEach$1: [function(_, f) {
        var t1, cell, modifications;
        t1 = this._map;
        cell = t1._first;
        modifications = t1._modifications;
        for (; cell != null;) {
          f.call$1(cell.hashMapCellKey);
          if (modifications !== t1._modifications)
            throw H.wrapException(new P.ConcurrentModificationError(t1));
          cell = cell._next;
        }
      }, "call$1", "get$forEach", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, v: true, args: [E]}]};
        }, this.$receiver, "LinkedHashMapKeyIterable");
      }, 9, [], "forEach"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      }
    },
    "+LinkedHashMapKeyIterable": 0,
    LinkedHashMapKeyIterator: {
      "^": "Object;_map,_modifications,_cell,_current,$ti",
      get$current: [function() {
        return this._current;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "LinkedHashMapKeyIterator");
      }, "current"],
      moveNext$0: [function() {
        var t1 = this._map;
        if (this._modifications !== t1._modifications)
          throw H.wrapException(new P.ConcurrentModificationError(t1));
        else {
          t1 = this._cell;
          if (t1 == null) {
            this._current = null;
            return false;
          } else {
            this._current = t1.hashMapCellKey;
            this._cell = t1._next;
            return true;
          }
        }
      }, "call$0", "get$moveNext", 0, 0, 5, "moveNext"]
    },
    "+LinkedHashMapKeyIterator": 0,
    initHooks_closure: {
      "^": "Closure:3;getTag",
      call$1: [function(o) {
        return this.getTag(o);
      }, null, null, 2, 0, 3, 96, [], "call"]
    },
    "+ initHooks_closure": [2],
    initHooks_closure0: {
      "^": "Closure:301;getUnknownTag",
      call$2: [function(o, tag) {
        return this.getUnknownTag(o, tag);
      }, null, null, 4, 0, 301, 96, [], 467, [], "call"]
    },
    "+ initHooks_closure": [2],
    initHooks_closure1: {
      "^": "Closure:13;prototypeForTag",
      call$1: [function(tag) {
        return this.prototypeForTag(tag);
      }, null, null, 2, 0, 13, 467, [], "call"]
    },
    "+ initHooks_closure": [2],
    JSSyntaxRegExp: {
      "^": "Object;pattern<-,_nativeRegExp<,_nativeGlobalRegExp,_nativeAnchoredRegExp",
      toString$0: [function(_) {
        return "RegExp/" + H.S(this.pattern) + "/";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      get$_nativeGlobalVersion: function() {
        var t1 = this._nativeGlobalRegExp;
        if (t1 != null)
          return t1;
        t1 = this._nativeRegExp;
        t1 = H.JSSyntaxRegExp_makeNative(this.pattern, t1.multiline, !t1.ignoreCase, true);
        this._nativeGlobalRegExp = t1;
        return t1;
      },
      get$_nativeAnchoredVersion: function() {
        var t1 = this._nativeAnchoredRegExp;
        if (t1 != null)
          return t1;
        t1 = this._nativeRegExp;
        t1 = H.JSSyntaxRegExp_makeNative(H.S(this.pattern) + "|()", t1.multiline, !t1.ignoreCase, true);
        this._nativeAnchoredRegExp = t1;
        return t1;
      },
      firstMatch$1: [function(string) {
        var m = this._nativeRegExp.exec(H.checkString(string));
        if (m == null)
          return;
        return new H._MatchImplementation(this, m);
      }, "call$1", "get$firstMatch", 2, 0, 674, 39, [], "firstMatch"],
      hasMatch$1: [function(string) {
        return this._nativeRegExp.test(H.checkString(string));
      }, "call$1", "get$hasMatch", 2, 0, 30, 39, [], "hasMatch"],
      stringMatch$1: [function(string) {
        var match, t1;
        match = this.firstMatch$1(string);
        if (match != null) {
          t1 = match._match;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          return t1[0];
        }
        return;
      }, "call$1", "get$stringMatch", 2, 0, 28, 39, [], "stringMatch"],
      allMatches$2: [function(_, string, start) {
        var t1;
        H.checkString(string);
        H.checkInt(start);
        t1 = J.getInterceptor$n(start);
        if (t1.$lt(start, 0) || t1.$gt(start, J.get$length$asx(string)))
          throw H.wrapException(P.RangeError$range(start, 0, J.get$length$asx(string), null, null));
        return new H._AllMatchesIterable(this, string, start);
      }, function($receiver, string) {
        return this.allMatches$2($receiver, string, 0);
      }, "allMatches$1", "call$2", "call$1", "get$allMatches", 2, 2, 452, 7, 39, [], 3, [], "allMatches"],
      _execGlobal$2: function(string, start) {
        var regexp, match;
        regexp = this.get$_nativeGlobalVersion();
        regexp.lastIndex = start;
        match = regexp.exec(string);
        if (match == null)
          return;
        return new H._MatchImplementation(this, match);
      },
      _execAnchored$2: function(string, start) {
        var regexp, match;
        regexp = this.get$_nativeAnchoredVersion();
        regexp.lastIndex = start;
        match = regexp.exec(string);
        if (match == null)
          return;
        if (0 >= match.length)
          return H.ioore(match, -1);
        if (match.pop() != null)
          return;
        return new H._MatchImplementation(this, match);
      },
      matchAsPrefix$2: [function(_, string, start) {
        var t1 = J.getInterceptor$n(start);
        if (t1.$lt(start, 0) || t1.$gt(start, J.get$length$asx(string)))
          throw H.wrapException(P.RangeError$range(start, 0, J.get$length$asx(string), null, null));
        return this._execAnchored$2(string, start);
      }, function($receiver, string) {
        return this.matchAsPrefix$2($receiver, string, 0);
      }, "matchAsPrefix$1", "call$2", "call$1", "get$matchAsPrefix", 2, 2, 492, 7, 39, [], 3, [], "matchAsPrefix"],
      get$isMultiLine: [function() {
        return this._nativeRegExp.multiline;
      }, null, null, 1, 0, 5, "isMultiLine"],
      get$isCaseSensitive: [function() {
        return !this._nativeRegExp.ignoreCase;
      }, null, null, 1, 0, 5, "isCaseSensitive"],
      $isPattern: 1,
      static: {
        JSSyntaxRegExp_makeNative: function(source, multiLine, caseSensitive, global) {
          var m, i, g, regexp;
          H.checkString(source);
          m = J.$eq$(multiLine, true) ? "m" : "";
          i = J.$eq$(caseSensitive, true) ? "" : "i";
          g = global ? "g" : "";
          regexp = function(source, modifiers) {
            try {
              return new RegExp(source, modifiers);
            } catch (e) {
              return e;
            }
          }(source, m + i + g);
          if (regexp instanceof RegExp)
            return regexp;
          throw H.wrapException(new P.FormatException("Illegal RegExp pattern (" + String(regexp) + ")", source, null));
        }
      }
    },
    "+JSSyntaxRegExp": 0,
    _MatchImplementation: {
      "^": "Object;pattern<-,_match",
      get$input: [function() {
        return this._match.input;
      }, null, null, 1, 0, 7, "input"],
      get$start: [function() {
        return this._match.index;
      }, null, null, 1, 0, 11, "start"],
      get$end: [function() {
        var t1 = this._match;
        return t1.index + t1[0].length;
      }, null, null, 1, 0, 11, "end"],
      group$1: [function(index) {
        var t1 = this._match;
        if (index >>> 0 !== index || index >= t1.length)
          return H.ioore(t1, index);
        return t1[index];
      }, "call$1", "get$group", 2, 0, 25, 14, [], "group"],
      $index: [function(_, index) {
        var t1 = this._match;
        if (index >>> 0 !== index || index >= t1.length)
          return H.ioore(t1, index);
        return t1[index];
      }, null, "get$[]", 2, 0, 25, 14, [], "[]"],
      get$groupCount: [function() {
        return this._match.length - 1;
      }, null, null, 1, 0, 11, "groupCount"],
      groups$1: [function(groups) {
        var out, t1, t2, i;
        out = [];
        for (t1 = J.get$iterator$ax(groups), t2 = this._match; t1.moveNext$0();) {
          i = t1.get$current();
          if (i >>> 0 !== i || i >= t2.length)
            return H.ioore(t2, i);
          out.push(t2[i]);
        }
        return out;
      }, "call$1", "get$groups", 2, 0, 325, 876, [], "groups"],
      start$0: function() {
        return this.get$start().call$0();
      },
      start$2$arguments: function(arg0, arg1) {
        return this.get$start().call$2$arguments(arg0, arg1);
      },
      $isMatch: 1
    },
    "+_MatchImplementation": 0,
    _AllMatchesIterable: {
      "^": "IterableBase;_re,_string,__js_helper$_start",
      get$iterator: [function(_) {
        return new H._AllMatchesIterator(this._re, this._string, this.__js_helper$_start, null);
      }, null, null, 1, 0, 328, "iterator"],
      $asIterableBase: function() {
        return [P.Match];
      },
      $asIterable: function() {
        return [P.Match];
      }
    },
    "+_AllMatchesIterable": 0,
    _AllMatchesIterator: {
      "^": "Object;_regExp,_string,_nextIndex,_current",
      get$current: [function() {
        return this._current;
      }, null, null, 1, 0, 196, "current"],
      moveNext$0: [function() {
        var t1, match, t2, nextIndex;
        t1 = this._string;
        if (t1 == null)
          return false;
        if (J.$le$n(this._nextIndex, J.get$length$asx(t1))) {
          match = this._regExp._execGlobal$2(this._string, this._nextIndex);
          if (match != null) {
            this._current = match;
            t1 = match._match;
            t2 = t1.index;
            nextIndex = t2 + t1[0].length;
            this._nextIndex = t2 === nextIndex ? nextIndex + 1 : nextIndex;
            return true;
          }
        }
        this._current = null;
        this._string = null;
        return false;
      }, "call$0", "get$moveNext", 0, 0, 5, "moveNext"]
    },
    "+_AllMatchesIterator": 0,
    StringMatch: {
      "^": "Object;start<-,input<-,pattern<-",
      get$end: [function() {
        return J.$add$ns(this.start, J.get$length$asx(this.pattern));
      }, null, null, 1, 0, 11, "end"],
      $index: [function(_, g) {
        if (!J.$eq$(g, 0))
          H.throwExpression(P.RangeError$value(g, null, null));
        return this.pattern;
      }, null, "get$[]", 2, 0, 25, 875, [], "[]"],
      get$groupCount: [function() {
        return 0;
      }, null, null, 1, 0, 11, "groupCount"],
      group$1: [function(group_) {
        if (!J.$eq$(group_, 0))
          throw H.wrapException(P.RangeError$value(group_, null, null));
        return this.pattern;
      }, "call$1", "get$group", 2, 0, 25, 874, [], "group"],
      groups$1: [function(groups_) {
        var result, t1, t2, g;
        result = H.setRuntimeTypeInfo([], [P.String]);
        for (t1 = J.get$iterator$ax(groups_), t2 = this.pattern; t1.moveNext$0();) {
          g = t1.get$current();
          if (!J.$eq$(g, 0))
            H.throwExpression(P.RangeError$value(g, null, null));
          result.push(t2);
        }
        return result;
      }, "call$1", "get$groups", 2, 0, 325, 869, [], "groups"],
      start$0: function() {
        return this.start.call$0();
      },
      start$2$arguments: function(arg0, arg1) {
        return this.start.call$2$arguments(arg0, arg1);
      },
      $isMatch: 1
    },
    "+StringMatch": 0,
    _StringAllMatchesIterable: {
      "^": "Iterable;_input,_pattern,__js_helper$_index",
      get$iterator: [function(_) {
        return new H._StringAllMatchesIterator(this._input, this._pattern, this.__js_helper$_index, null);
      }, null, null, 1, 0, 328, "iterator"],
      get$first: [function(_) {
        var t1, t2, index;
        t1 = this._input;
        t2 = this._pattern;
        index = t1.indexOf(t2, this.__js_helper$_index);
        if (index >= 0)
          return new H.StringMatch(index, t1, t2);
        throw H.wrapException(H.IterableElementError_noElement());
      }, null, null, 1, 0, 196, "first"],
      $asIterable: function() {
        return [P.Match];
      }
    },
    "+_StringAllMatchesIterable": 0,
    _StringAllMatchesIterator: {
      "^": "Object;_input,_pattern,__js_helper$_index,_current",
      moveNext$0: [function() {
        var t1, t2, t3, t4, index, end;
        t1 = this._pattern;
        t2 = t1.length;
        t3 = this._input;
        t4 = J.getInterceptor$asx(t3);
        if (J.$gt$n(J.$add$ns(this.__js_helper$_index, t2), t4.get$length(t3))) {
          this._current = null;
          return false;
        }
        index = t3.indexOf(t1, this.__js_helper$_index);
        if (index < 0) {
          this.__js_helper$_index = J.$add$ns(t4.get$length(t3), 1);
          this._current = null;
          return false;
        }
        end = index + t2;
        this._current = new H.StringMatch(index, t3, t1);
        this.__js_helper$_index = end === this.__js_helper$_index ? end + 1 : end;
        return true;
      }, "call$0", "get$moveNext", 0, 0, 5, "moveNext"],
      get$current: [function() {
        return this._current;
      }, null, null, 1, 0, 196, "current"]
    },
    "+_StringAllMatchesIterator": 0,
    LoadLibraryFunctionType: {
      "^": "",
      $typedefType: 351,
      $$isTypedef: true
    },
    "+LoadLibraryFunctionType": "",
    DeferredLoadCallback: {
      "^": "",
      $typedefType: 6,
      $$isTypedef: true
    },
    "+DeferredLoadCallback": ""
  }], ["dart._js_mirrors", "dart:_js_mirrors",, H, {
    "^": "",
    hasReflectableProperty: function(jsFunction) {
      return "$reflectable" in jsFunction;
    },
    disableTreeShaking: function() {
      return;
    },
    preserveMetadata: function() {
    },
    preserveUris: function() {
    },
    preserveLibraryNames: function() {
    },
    getName: function(symbol) {
      return symbol.get$__internal$_name();
    },
    n: function(symbol) {
      return symbol.get$__internal$_name();
    },
    s: function($name) {
      if ($name == null)
        return;
      return new H.Symbol0($name);
    },
    setterSymbol: function(symbol) {
      return H.s(H.S(symbol.get$__internal$_name()) + "=");
    },
    reflect: [function(reflectee) {
      if (!!J.getInterceptor(reflectee).$isFunction)
        return new H.JsClosureMirror(reflectee, 4);
      else
        return new H.JsInstanceMirror(reflectee, 4);
    }, "call$1", "_js_mirrors__reflect$closure", 2, 0, 382, 496, []],
    reflectType: function(key, typeArguments) {
      var mangledName, t1, mangledTypeArguments;
      mangledName = key.get$_typeName();
      if (typeArguments != null) {
        t1 = J.getInterceptor$asx(typeArguments);
        if (t1.get$isEmpty(typeArguments) === true || t1.every$1(typeArguments, new H.reflectType_closure()) !== true)
          throw H.wrapException(P.ArgumentError$value(typeArguments, "typeArguments", t1.get$isEmpty(typeArguments) === true ? "Type arguments list can not be empty." : "Type arguments list must contain only instances of Type."));
        mangledTypeArguments = t1.map$1(typeArguments, H._js_helper__getMangledTypeName$closure());
        mangledName = H.S(mangledName) + "<" + H.S(mangledTypeArguments.join$1(0, ", ")) + ">";
      }
      return H.reflectClassByMangledName(mangledName);
    },
    reflectClassByMangledName: function(mangledName) {
      var result, unmangledName, t1;
      result = $.$get$mangledGlobalNames()._jsMangledNames[mangledName];
      unmangledName = typeof result !== "string" ? null : result;
      t1 = J.getInterceptor(mangledName);
      if (t1.$eq(mangledName, "dynamic"))
        return $.$get$JsMirrorSystem__dynamicType();
      if (t1.$eq(mangledName, "void"))
        return $.$get$JsMirrorSystem__voidType();
      return H.reflectClassByName(H.s(unmangledName == null ? mangledName : unmangledName), mangledName);
    },
    reflectClassByName: function(symbol, mangledName) {
      var t1, mirror, typeArgIndex, t2, originalDeclaration, $constructor, descriptor, fields, fieldsMetadata, mixins, classMirror, typeVariables, typeArguments, i;
      t1 = $.classMirrors;
      if (t1 == null) {
        t1 = H.JsCache_allocate();
        $.classMirrors = t1;
      }
      mirror = t1[mangledName];
      if (mirror != null)
        return mirror;
      t1 = J.getInterceptor$asx(mangledName);
      typeArgIndex = t1.indexOf$1(mangledName, "<");
      t2 = J.getInterceptor(typeArgIndex);
      if (!t2.$eq(typeArgIndex, -1)) {
        originalDeclaration = H.reflectClassByMangledName(t1.substring$2(mangledName, 0, typeArgIndex)).get$originalDeclaration();
        if (!!originalDeclaration.$isJsTypedefMirror)
          throw H.wrapException(new P.UnimplementedError(null));
        mirror = new H.JsTypeBoundClassMirror(originalDeclaration, t1.substring$2(mangledName, t2.$add(typeArgIndex, 1), J.$sub$n(t1.get$length(mangledName), 1)), null, null, null, null, null, null, null, null, null, null, null, null, null, originalDeclaration.get$simpleName());
        $.classMirrors[mangledName] = mirror;
        return mirror;
      }
      $constructor = init.allClasses[mangledName];
      if ($constructor == null)
        throw H.wrapException(new P.UnsupportedError("Cannot find class for: " + H.S(H.n(symbol))));
      descriptor = $constructor["@"];
      if (descriptor == null) {
        fields = null;
        fieldsMetadata = null;
      } else if ("$$isTypedef" in descriptor) {
        mirror = new H.JsTypedefMirror(mangledName, null, symbol);
        mirror.referent = new H.JsFunctionTypeMirror(init.types[descriptor.$typedefType], null, null, null, null, mirror);
        fields = null;
        fieldsMetadata = null;
      } else {
        fields = descriptor["^"];
        t1 = J.getInterceptor(fields);
        if (!!t1.$isList) {
          fieldsMetadata = t1.getRange$2(fields, 1, t1.get$length(fields)).toList$0(0);
          fields = t1.$index(fields, 0);
        } else
          fieldsMetadata = null;
        if (typeof fields !== "string")
          fields = "";
      }
      if (mirror == null) {
        t1 = J.split$1$s(fields, ";");
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        mixins = J.split$1$s(t1[0], "+");
        if (mixins.length > 1 && $.$get$mangledGlobalNames().$index(0, mangledName) == null)
          mirror = H.reflectMixinApplication(mixins, mangledName);
        else {
          classMirror = new H.JsClassMirror(mangledName, $constructor, fields, fieldsMetadata, H.JsCache_allocate(), null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, symbol);
          typeVariables = $constructor.prototype["<>"];
          if (typeVariables == null || typeVariables.length === 0)
            mirror = classMirror;
          else {
            for (t1 = typeVariables.length, typeArguments = "dynamic", i = 1; i < t1; ++i)
              typeArguments += ",dynamic";
            mirror = new H.JsTypeBoundClassMirror(classMirror, typeArguments, null, null, null, null, null, null, null, null, null, null, null, null, null, classMirror.simpleName);
          }
        }
      }
      $.classMirrors[mangledName] = mirror;
      return mirror;
    },
    splitTypeArguments: function(typeArguments) {
      var argumentList, t1, level, currentTypeArgument, i, character;
      if (C.JSString_methods.indexOf$1(typeArguments, "<") === -1)
        return typeArguments.split(",");
      argumentList = H.setRuntimeTypeInfo([], [P.String]);
      for (t1 = typeArguments.length, level = 0, currentTypeArgument = "", i = 0; i < t1; ++i) {
        character = typeArguments[i];
        if (character === " ")
          continue;
        else if (character === "<") {
          currentTypeArgument += character;
          ++level;
        } else if (character === ">") {
          currentTypeArgument += character;
          --level;
        } else if (character === ",")
          if (level > 0)
            currentTypeArgument += character;
          else {
            argumentList.push(currentTypeArgument);
            currentTypeArgument = "";
          }
        else
          currentTypeArgument += character;
      }
      argumentList.push(currentTypeArgument);
      return argumentList;
    },
    filterMethods: function(methods) {
      var result, t1, _i, method;
      result = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [null, null]);
      for (t1 = methods.length, _i = 0; _i < methods.length; methods.length === t1 || (0, H.throwConcurrentModificationError)(methods), ++_i) {
        method = methods[_i];
        if (method.get$isConstructor() !== true && method.get$isGetter() !== true && method.get$isSetter() !== true)
          result.$indexSet(0, method.get$simpleName(), method);
      }
      return result;
    },
    filterConstructors: function(methods) {
      var result, t1, _i, method;
      result = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [null, null]);
      for (t1 = methods.length, _i = 0; _i < methods.length; methods.length === t1 || (0, H.throwConcurrentModificationError)(methods), ++_i) {
        method = methods[_i];
        if (method.get$isConstructor() === true)
          result.$indexSet(0, method.get$simpleName(), method);
      }
      return result;
    },
    filterGetters: function(methods, fields) {
      var result, t1, _i, method, t2;
      result = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [null, null]);
      for (t1 = methods.length, _i = 0; _i < methods.length; methods.length === t1 || (0, H.throwConcurrentModificationError)(methods), ++_i) {
        method = methods[_i];
        if (method.get$isGetter() === true) {
          t2 = method.get$simpleName();
          if (J.$index$asx(fields._collection$_map, t2) != null)
            continue;
          result.$indexSet(0, method.get$simpleName(), method);
        }
      }
      return result;
    },
    filterSetters: function(methods, fields) {
      var result, t1, _i, method, $name, t2;
      result = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [null, null]);
      for (t1 = methods.length, _i = 0; _i < methods.length; methods.length === t1 || (0, H.throwConcurrentModificationError)(methods), ++_i) {
        method = methods[_i];
        if (method.get$isSetter() === true) {
          $name = method.get$simpleName().get$__internal$_name();
          t2 = J.getInterceptor$asx($name);
          t2 = H.s(t2.substring$2($name, 0, J.$sub$n(t2.get$length($name), 1)));
          if (J.$index$asx(fields._collection$_map, t2) != null)
            continue;
          result.$indexSet(0, method.get$simpleName(), method);
        }
      }
      return result;
    },
    filterMembers: function(methods, variables) {
      var result, t1, _i, method, $name, t2;
      result = P.LinkedHashMap_LinkedHashMap$from(variables, null, null);
      for (t1 = methods.length, _i = 0; _i < methods.length; methods.length === t1 || (0, H.throwConcurrentModificationError)(methods), ++_i) {
        method = methods[_i];
        if (method.get$isSetter() === true) {
          $name = method.get$simpleName().get$__internal$_name();
          t2 = J.getInterceptor$asx($name);
          if (!!J.getInterceptor(result.$index(0, H.s(t2.substring$2($name, 0, J.$sub$n(t2.get$length($name), 1))))).$isVariableMirror)
            continue;
        }
        if (method.get$isConstructor() === true)
          continue;
        if (!!method.get$_jsFunction().$getterStub)
          continue;
        result.putIfAbsent$2(method.get$simpleName(), new H.filterMembers_closure(method));
      }
      return result;
    },
    reflectMixinApplication: function(mixinNames, mangledName) {
      var mixins, t1, _i, it, superclass;
      mixins = [];
      for (t1 = mixinNames.length, _i = 0; _i < mixinNames.length; mixinNames.length === t1 || (0, H.throwConcurrentModificationError)(mixinNames), ++_i)
        mixins.push(H.reflectClassByMangledName(mixinNames[_i]));
      it = new J.ArrayIterator(mixins, mixins.length, 0, null, [H.getTypeArgumentByIndex(mixins, 0)]);
      it.moveNext$0();
      superclass = it.__interceptors$_current;
      for (; it.moveNext$0();)
        superclass = new H.JsMixinApplication(superclass, it.__interceptors$_current, null, null, H.s(mangledName));
      return superclass;
    },
    findTypeVariableIndex: function(typeVariables, $name) {
      var t1, i, t2;
      t1 = J.getInterceptor$asx(typeVariables);
      i = 0;
      while (true) {
        t2 = t1.get$length(typeVariables);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        if (J.$eq$(t1.$index(typeVariables, i).get$simpleName(), H.s($name)))
          return i;
        ++i;
      }
      throw H.wrapException(P.ArgumentError$("Type variable not present in list."));
    },
    typeMirrorFromRuntimeTypeRepresentation: function(owner, type) {
      var t1, context, t2, representation, typeVariable, typeVariables, typeArgument;
      t1 = {};
      if (type == null)
        return $.$get$JsMirrorSystem__dynamicType();
      t1.ownerClass = null;
      for (context = owner; context != null;) {
        t2 = J.getInterceptor(context);
        if (!!t2.$isClassMirror) {
          t1.ownerClass = context;
          break;
        }
        if (!!t2.$isTypedefMirror)
          break;
        context = context.get$owner();
      }
      if (type instanceof H.TypeImpl)
        return H.reflectType(type, null);
      else {
        t2 = t1.ownerClass;
        if (t2 == null)
          representation = H.runtimeTypeToString(type, null);
        else if (t2.get$isOriginalDeclaration())
          if (typeof type === "number") {
            typeVariable = init.metadata[type];
            typeVariables = t1.ownerClass.get$typeVariables();
            return J.$index$asx(typeVariables, H.findTypeVariableIndex(typeVariables, typeVariable.get$name()));
          } else
            representation = H.runtimeTypeToString(type, null);
        else {
          t1 = new H.typeMirrorFromRuntimeTypeRepresentation_getTypeArgument(t1);
          if (typeof type === "number") {
            typeArgument = t1.call$1(type);
            if (typeArgument instanceof H.JsTypeVariableMirror)
              return typeArgument;
          }
          representation = H.runtimeTypeToString(type, new H.typeMirrorFromRuntimeTypeRepresentation_substituteTypeVariable(t1));
        }
      }
      return H.reflectClassByMangledName(representation);
    },
    computeQualifiedName: function(owner, simpleName) {
      if (owner == null)
        return simpleName;
      return H.s(H.S(owner.get$qualifiedName().get$__internal$_name()) + "." + H.S(simpleName.get$__internal$_name()));
    },
    extractMetadata: function(victim) {
      var metadataFunction, t1;
      metadataFunction = Object.prototype.hasOwnProperty.call(victim, "@") ? victim["@"] : null;
      if (metadataFunction != null)
        return metadataFunction();
      if (typeof victim != "function")
        return C.List_empty;
      if ("$metadataIndex" in victim) {
        t1 = victim.$reflectionInfo.splice(victim.$metadataIndex);
        t1.fixed$length = Array;
        return new H.MappedListIterable(t1, new H.extractMetadata_closure(), [null, null]).toList$0(0);
      }
      return C.List_empty;
    },
    parseCompactFieldSpecification: function(owner, fieldSpecification, isStatic, result) {
      var t1, fields, fieldsMetadata, t2, fieldNumber, _i, field, fieldNumber0, metadata, mirror;
      t1 = J.getInterceptor(fieldSpecification);
      if (!!t1.$isList) {
        fields = H.splitFields(t1.$index(fieldSpecification, 0), ",");
        fieldsMetadata = t1.sublist$1(fieldSpecification, 1);
      } else {
        fields = typeof fieldSpecification === "string" ? H.splitFields(fieldSpecification, ",") : [];
        fieldsMetadata = null;
      }
      for (t1 = fields.length, t2 = fieldsMetadata != null, fieldNumber = 0, _i = 0; _i < fields.length; fields.length === t1 || (0, H.throwConcurrentModificationError)(fields), ++_i) {
        field = fields[_i];
        if ("$ti" === field)
          continue;
        if (t2) {
          fieldNumber0 = fieldNumber + 1;
          metadata = J.$index$asx(fieldsMetadata, fieldNumber);
          fieldNumber = fieldNumber0;
        } else
          metadata = null;
        mirror = H.JsVariableMirror_JsVariableMirror$from(field, metadata, owner, isStatic);
        if (mirror != null)
          result.push(mirror);
      }
    },
    splitFields: function(string, pattern) {
      var t1 = J.getInterceptor$asx(string);
      if (t1.get$isEmpty(string) === true)
        return H.setRuntimeTypeInfo([], [P.String]);
      return t1.split$1(string, pattern);
    },
    isOperatorName: function($name) {
      switch ($name) {
        case "==":
        case "[]":
        case "*":
        case "/":
        case "%":
        case "~/":
        case "+":
        case "<<":
        case ">>":
        case ">=":
        case ">":
        case "<=":
        case "<":
        case "&":
        case "^":
        case "|":
        case "-":
        case "unary-":
        case "[]=":
        case "~":
          return true;
        default:
          return false;
      }
    },
    isReflectiveDataInPrototype: function(key) {
      var t1, firstChar;
      t1 = J.getInterceptor(key);
      if (t1.$eq(key, "^") || t1.$eq(key, "$methodsWithOptionalArguments"))
        return true;
      firstChar = t1.$index(key, 0);
      t1 = J.getInterceptor(firstChar);
      return t1.$eq(firstChar, "*") || t1.$eq(firstChar, "+");
    },
    isOrdinaryReflectableMethod: function(jsFunction) {
      return jsFunction.$reflectable === 1;
    },
    isAliasedSuperMethod: function(jsFunction, key) {
      var stubName = jsFunction.$stubName;
      return stubName != null && !J.$eq$(key, stubName);
    },
    getSymbol: function($name, library) {
      if (H._isPublicSymbol($name))
        return new H.Symbol0(H.Symbol_validatePublicSymbol($name));
      if (library == null)
        throw H.wrapException(P.ArgumentError$("Library required for private symbol name: " + H.S($name)));
      if (!(J.get$isEmpty$asx($name) === true || $.$get$Symbol_symbolPattern()._nativeRegExp.test(H.checkString($name))))
        throw H.wrapException(P.ArgumentError$("Not a valid symbol name: " + H.S($name)));
      throw H.wrapException(new P.UnimplementedError("MirrorSystem.getSymbol not implemented for private names"));
    },
    _isPublicSymbol: function($name) {
      var t1, index, t2;
      t1 = J.getInterceptor$asx($name);
      if (t1.get$isEmpty($name) === true)
        return true;
      index = -1;
      do {
        t2 = J.getInterceptor$ns(index);
        if (t1.codeUnitAt$1($name, t2.$add(index, 1)) === 95)
          return false;
        index = t1.indexOf$2($name, ".", t2.$add(index, 1));
        t2 = J.getInterceptor$n(index);
      } while (t2.$ge(index, 0) && J.$lt$n(t2.$add(index, 1), t1.get$length($name)));
      return true;
    },
    JsMirrorSystem: {
      "^": "Object;_cachedLibraries,isolate<-",
      get$dynamicType: [function() {
        return $.$get$JsMirrorSystem__dynamicType();
      }, null, null, 1, 0, 329, "dynamicType"],
      get$voidType: [function() {
        return $.$get$JsMirrorSystem__voidType();
      }, null, null, 1, 0, 329, "voidType"],
      get$libraries: [function() {
        var t1, result, t2, library;
        t1 = this._cachedLibraries;
        if (t1 != null)
          return t1;
        result = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [null, null]);
        for (t1 = H.JsMirrorSystem_librariesByName().get$values(), t1 = t1.get$iterator(t1); t1.moveNext$0();)
          for (t2 = J.get$iterator$ax(t1.get$current()); t2.moveNext$0();) {
            library = t2.get$current();
            result.$indexSet(0, library.get$uri(), library);
          }
        t1 = new P.UnmodifiableMapView(result, [P.Uri, P.LibraryMirror]);
        this._cachedLibraries = t1;
        return t1;
      }, null, null, 1, 0, 1027, "libraries"],
      findLibrary$1: [function(libraryName) {
        return J.get$single$ax(H.JsMirrorSystem_librariesByName().$index(0, libraryName.get$__internal$_name()));
      }, "call$1", "get$findLibrary", 2, 0, 339, 388, [], "findLibrary"],
      static: {
        JsMirrorSystem_librariesByName: function() {
          var t1 = $.JsMirrorSystem__librariesByName;
          if (t1 == null) {
            t1 = H.JsMirrorSystem_computeLibrariesByName();
            $.JsMirrorSystem__librariesByName = t1;
            if (!$.JsMirrorSystem__hasInstalledDeferredLoadHook) {
              $.JsMirrorSystem__hasInstalledDeferredLoadHook = true;
              $.deferredLoadHook = new H.JsMirrorSystem_librariesByName_closure();
            }
          }
          return t1;
        },
        JsMirrorSystem_computeLibrariesByName: function() {
          var result, jsLibraries, t1, _i, data, t2, $name, uriString, uri, classes, functions, metadataFunction, fields, isRoot, globalObject, metadata;
          result = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [P.String, [P.List, P.LibraryMirror]]);
          jsLibraries = init.libraries;
          if (jsLibraries == null)
            return result;
          for (t1 = jsLibraries.length, _i = 0; _i < jsLibraries.length; jsLibraries.length === t1 || (0, H.throwConcurrentModificationError)(jsLibraries), ++_i) {
            data = jsLibraries[_i];
            t2 = J.getInterceptor$asx(data);
            $name = t2.$index(data, 0);
            uriString = t2.$index(data, 1);
            uri = !J.$eq$(uriString, "") ? P.Uri_parse(uriString, 0, null) : P._Uri__Uri(null, "dartlang.org", "dart2js-stripped-uri", null, null, null, P.LinkedHashMap__makeLiteral(["lib", $name]), "https", null);
            classes = t2.$index(data, 2);
            functions = t2.$index(data, 3);
            metadataFunction = t2.$index(data, 4);
            fields = t2.$index(data, 5);
            isRoot = t2.$index(data, 6);
            globalObject = t2.$index(data, 7);
            metadata = metadataFunction == null ? C.List_empty : metadataFunction();
            J.add$1$ax(result.putIfAbsent$2($name, new H.JsMirrorSystem_computeLibrariesByName_closure()), new H.JsLibraryMirror(uri, classes, functions, metadata, fields, isRoot, globalObject, null, null, null, null, null, null, null, null, null, null, H.s($name)));
          }
          return result;
        }
      }
    },
    "+JsMirrorSystem": 0,
    JsMirrorSystem_librariesByName_closure: {
      "^": "Closure:4;",
      call$0: function() {
        $.JsMirrorSystem__librariesByName = null;
        return;
      }
    },
    "+ JsMirrorSystem_librariesByName_closure": 0,
    JsMirrorSystem_computeLibrariesByName_closure: {
      "^": "Closure:4;",
      call$0: [function() {
        return H.setRuntimeTypeInfo([], [P.LibraryMirror]);
      }, null, null, 0, 0, null, "call"]
    },
    "+ JsMirrorSystem_computeLibrariesByName_closure": 0,
    JsMirror: {
      "^": "Object;",
      toString$0: [function(_) {
        return this.get$_prettyName();
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      _getField$1: function(receiver) {
        throw H.wrapException(new P.UnimplementedError(null));
      },
      _setField$2: function(receiver, arg) {
        throw H.wrapException(new P.UnimplementedError(null));
      },
      $isMirror: 1
    },
    "+JsMirror": 0,
    JsIsolateMirror: {
      "^": "JsMirror;_isolateContext",
      get$_prettyName: function() {
        return "Isolate";
      },
      get$debugName: [function() {
        var t1, id;
        t1 = this._isolateContext;
        id = t1 == null ? "X" : J.toString$0$(t1.get$id());
        return H.S(this.get$rootLibrary().get$simpleName().get$__internal$_name()) + "-" + H.S(id);
      }, null, null, 1, 0, 7, "debugName"],
      get$isCurrent: [function() {
        var t1, t2;
        t1 = init.globalState.currentContext;
        t2 = this._isolateContext;
        return t1 == null ? t2 == null : t1 === t2;
      }, null, null, 1, 0, 5, "isCurrent"],
      get$rootLibrary: [function() {
        return $.$get$currentJsMirrorSystem().get$libraries()._collection$_map.get$values().firstWhere$1(0, new H.JsIsolateMirror_rootLibrary_closure());
      }, null, null, 1, 0, 343, "rootLibrary"],
      $isMirror: 1
    },
    "+JsIsolateMirror": 0,
    JsIsolateMirror_rootLibrary_closure: {
      "^": "Closure:687;",
      call$1: [function(library) {
        return library.get$_isRoot();
      }, null, null, 2, 0, null, 372, [], "call"]
    },
    "+ JsIsolateMirror_rootLibrary_closure": 0,
    JsDeclarationMirror: {
      "^": "JsMirror;simpleName<-",
      get$qualifiedName: [function() {
        return H.computeQualifiedName(this.get$owner(), this.get$simpleName());
      }, null, null, 1, 0, 45, "qualifiedName"],
      get$isPrivate: [function() {
        return J.startsWith$1$s(this.get$simpleName().get$__internal$_name(), "_");
      }, null, null, 1, 0, 5, "isPrivate"],
      get$isTopLevel: [function() {
        return this.get$owner() != null && !!J.getInterceptor(this.get$owner()).$isLibraryMirror;
      }, null, null, 1, 0, 5, "isTopLevel"],
      toString$0: [function(_) {
        return this.get$_prettyName() + " on '" + H.S(this.get$simpleName().get$__internal$_name()) + "'";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      _invoke$2: function(positionalArguments, namedArguments) {
        throw H.wrapException(new H.RuntimeError("Should not call _invoke"));
      },
      get$location: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 123, "location"],
      $isDeclarationMirror: 1,
      $isMirror: 1
    },
    "+JsDeclarationMirror": 0,
    JsTypeVariableMirror: {
      "^": "JsTypeMirror;owner<-,_typeVariable,_metadataIndex,_cachedUpperBound,simpleName-",
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof H.JsTypeVariableMirror && J.$eq$(this.simpleName, other.simpleName) && J.$eq$(this.owner, other.owner);
      }, null, "get$==", 2, 0, 24, 2, [], "=="],
      get$hashCode: [function(_) {
        var t1, t2, t3;
        t1 = J.get$hashCode$(C.Type_JsTypeVariableMirror_gT2._typeName);
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2 = J.get$hashCode$(this.simpleName);
        if (typeof t2 !== "number")
          return H.iae(t2);
        t3 = J.get$hashCode$(this.owner);
        if (typeof t3 !== "number")
          return H.iae(t3);
        return (1073741823 & t1 ^ 17 * t2 ^ 19 * t3) >>> 0;
      }, null, null, 1, 0, 11, "hashCode"],
      get$_prettyName: function() {
        return "TypeVariableMirror";
      },
      get$isTopLevel: [function() {
        return false;
      }, null, null, 1, 0, 5, "isTopLevel"],
      get$isStatic: [function() {
        return false;
      }, null, null, 1, 0, 5, "isStatic"],
      get$upperBound: [function() {
        var t1 = this._cachedUpperBound;
        if (t1 != null)
          return t1;
        t1 = H.typeMirrorFromRuntimeTypeRepresentation(this.owner, init.types[this._typeVariable.get$bound()]);
        this._cachedUpperBound = t1;
        return t1;
      }, null, null, 1, 0, 53, "upperBound"],
      isSubtypeOf$1: [function(other) {
        return H.throwExpression(new P.UnimplementedError(null));
      }, "call$1", "get$isSubtypeOf", 2, 0, 54, 2, [], "isSubtypeOf"],
      isAssignableTo$1: [function(other) {
        return H.throwExpression(new P.UnimplementedError(null));
      }, "call$1", "get$isAssignableTo", 2, 0, 54, 2, [], "isAssignableTo"],
      _asRuntimeType$0: function() {
        return this._metadataIndex;
      },
      $isTypeVariableMirror: 1,
      $isTypeMirror: 1,
      $isDeclarationMirror: 1,
      $isMirror: 1
    },
    "+JsTypeVariableMirror": 0,
    JsTypeMirror: {
      "^": "JsDeclarationMirror;simpleName-",
      get$_prettyName: function() {
        return "TypeMirror";
      },
      get$owner: [function() {
        return;
      }, null, null, 1, 0, 125, "owner"],
      get$isTopLevel: [function() {
        return true;
      }, null, null, 1, 0, 5, "isTopLevel"],
      get$metadata: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 59, "metadata"],
      get$hasReflectedType: [function() {
        return false;
      }, null, null, 1, 0, 5, "hasReflectedType"],
      get$reflectedType: [function() {
        throw H.wrapException(new P.UnsupportedError("This type does not support reflectedType"));
      }, null, null, 1, 0, 20, "reflectedType"],
      get$typeVariables: [function() {
        return C.List_empty2;
      }, null, null, 1, 0, 130, "typeVariables"],
      get$typeArguments: [function() {
        return C.List_empty1;
      }, null, null, 1, 0, 131, "typeArguments"],
      get$isOriginalDeclaration: [function() {
        return true;
      }, null, null, 1, 0, 5, "isOriginalDeclaration"],
      get$originalDeclaration: [function() {
        return this;
      }, null, null, 1, 0, 53, "originalDeclaration"],
      isSubtypeOf$1: [function(other) {
        return H.throwExpression(new P.UnimplementedError(null));
      }, "call$1", "get$isSubtypeOf", 2, 0, 54, 2, [], "isSubtypeOf"],
      isAssignableTo$1: [function(other) {
        return H.throwExpression(new P.UnimplementedError(null));
      }, "call$1", "get$isAssignableTo", 2, 0, 54, 2, [], "isAssignableTo"],
      _asRuntimeType$0: [function() {
        if (this.$eq(0, $.$get$JsMirrorSystem__dynamicType()))
          return;
        if (this.$eq(0, $.$get$JsMirrorSystem__voidType()))
          return;
        throw H.wrapException(new H.RuntimeError("Should not call _asRuntimeType"));
      }, "call$0", "get$_asRuntimeType", 0, 0, 4],
      $isTypeMirror: 1,
      $isDeclarationMirror: 1,
      $isMirror: 1,
      static: {
        JsTypeMirror$: function(simpleName) {
          return new H.JsTypeMirror(simpleName);
        }
      }
    },
    "+JsTypeMirror": 0,
    JsLibraryMirror: {
      "^": "JsDeclarationMirror_JsObjectMirror;__js_mirrors$_uri,_classes,_functions,_metadata,_compactFieldSpecification,_isRoot<,_globalObject,_cachedFunctionMirrors,_cachedFields,_cachedClasses,_cachedFunctions,_cachedGetters,_cachedSetters,_cachedVariables,_cachedMembers,_cachedDeclarations,_cachedMetadata,simpleName-",
      get$_prettyName: function() {
        return "LibraryMirror";
      },
      get$uri: [function() {
        return this.__js_mirrors$_uri;
      }, null, null, 1, 0, 43, "uri"],
      get$qualifiedName: [function() {
        return this.simpleName;
      }, null, null, 1, 0, 45, "qualifiedName"],
      get$_methods: function() {
        return this.get$_functionMirrors();
      },
      get$__classes: function() {
        var t1, result, cls, t2;
        t1 = this._cachedClasses;
        if (t1 != null)
          return t1;
        result = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [null, null]);
        for (t1 = J.get$iterator$ax(this._classes); t1.moveNext$0();) {
          cls = H.reflectClassByMangledName(t1.get$current());
          if (!!J.getInterceptor(cls).$isClassMirror)
            cls = cls.get$originalDeclaration();
          t2 = J.getInterceptor(cls);
          if (!!t2.$isJsClassMirror) {
            result.$indexSet(0, cls.simpleName, cls);
            cls._owner = this;
          } else if (!!t2.$isJsTypedefMirror)
            result.$indexSet(0, cls.simpleName, cls);
        }
        t1 = new P.UnmodifiableMapView(result, [P.Symbol, P.ClassMirror]);
        this._cachedClasses = t1;
        return t1;
      },
      setField$2: [function(fieldName, arg) {
        var $name, t1, t2, mirror;
        $name = fieldName.get$__internal$_name();
        if (J.endsWith$1$s($name, "="))
          throw H.wrapException(P.ArgumentError$(""));
        t1 = this.get$__functions();
        t2 = H.s(H.S($name) + "=");
        mirror = J.$index$asx(t1._collection$_map, t2);
        if (mirror == null)
          mirror = J.$index$asx(this.get$__variables()._collection$_map, fieldName);
        if (mirror == null)
          throw H.wrapException(H.NoSuchStaticMethodError$method(null, H.setterSymbol(fieldName), [arg], null));
        mirror._setField$2(this, arg);
        return H.reflect(arg);
      }, "call$2", "get$setField", 4, 0, 108, 83, [], 68, [], "setField"],
      getField$1: [function(fieldName) {
        var mirror, getter;
        mirror = J.$index$asx(this.get$__members()._collection$_map, fieldName);
        if (mirror == null)
          throw H.wrapException(H.NoSuchStaticMethodError$method(null, fieldName, [], null));
        if (!J.getInterceptor(mirror).$isMethodMirror)
          return H.reflect(mirror._getField$1(this));
        if (mirror.get$isGetter() === true)
          return H.reflect(mirror._getField$1(this));
        getter = mirror.get$_jsFunction().$getter;
        if (getter == null)
          throw H.wrapException(new P.UnimplementedError(null));
        return H.reflect(getter());
      }, "call$1", "get$getField", 2, 0, 112, 83, [], "getField"],
      invoke$3: [function(memberName, positionalArguments, namedArguments) {
        var mirror, t1, t2;
        if (namedArguments != null && J.get$isEmpty$asx(namedArguments) !== true)
          throw H.wrapException(new P.UnsupportedError("Named arguments are not implemented."));
        mirror = J.$index$asx(this.get$__members()._collection$_map, memberName);
        t1 = mirror instanceof H.JsMethodMirror;
        if (t1 && !("$reflectable" in mirror._jsFunction))
          H.throwInvalidReflectionError(memberName.get$__internal$_name());
        if (mirror != null)
          t2 = t1 && mirror.isSetter === true;
        else
          t2 = true;
        if (t2)
          throw H.wrapException(H.NoSuchStaticMethodError$method(null, memberName, positionalArguments, namedArguments));
        if (t1 && mirror.isGetter !== true)
          return H.reflect(mirror._invoke$2(positionalArguments, namedArguments));
        return this.getField$1(memberName).invoke$3(C.Symbol_call, positionalArguments, namedArguments);
      }, function(memberName, positionalArguments) {
        return this.invoke$3(memberName, positionalArguments, null);
      }, "invoke$2", "call$3", "call$2", "get$invoke", 4, 2, 63, 0, 146, [], 77, [], 74, [], "invoke"],
      delegate$1: [function(invocation) {
        throw H.wrapException(new P.UnimplementedError(null));
      }, "call$1", "get$delegate", 2, 0, 77, 118, [], "delegate"],
      get$_functionMirrors: function() {
        var t1, result, t2, t3, i, t4, $name, jsFunction, result0, unmangledName, isConstructor, mirror;
        t1 = this._cachedFunctionMirrors;
        if (t1 != null)
          return t1;
        result = H.setRuntimeTypeInfo([], [H.JsMethodMirror]);
        t1 = this._functions;
        t2 = J.getInterceptor$asx(t1);
        t3 = this._globalObject;
        i = 0;
        while (true) {
          t4 = t2.get$length(t1);
          if (typeof t4 !== "number")
            return H.iae(t4);
          if (!(i < t4))
            break;
          c$0: {
            $name = t2.$index(t1, i);
            jsFunction = t3[$name];
            result0 = $.$get$mangledGlobalNames()._jsMangledNames[$name];
            unmangledName = typeof result0 !== "string" ? null : result0;
            if (unmangledName == null || !!jsFunction.$getterStub)
              break c$0;
            t4 = J.getInterceptor$s(unmangledName);
            isConstructor = t4.startsWith$1(unmangledName, "new ");
            if (isConstructor) {
              t4 = t4.substring$1(unmangledName, 4);
              unmangledName = H.stringReplaceAllUnchecked(t4, "$", ".");
            }
            mirror = H.JsMethodMirror_JsMethodMirror$fromUnmangledName(unmangledName, jsFunction, !isConstructor, isConstructor);
            result.push(mirror);
            mirror._owner = this;
          }
          ++i;
        }
        this._cachedFunctionMirrors = result;
        return result;
      },
      get$_fields: function() {
        var t1, result;
        t1 = this._cachedFields;
        if (t1 != null)
          return t1;
        result = H.setRuntimeTypeInfo([], [P.VariableMirror]);
        H.parseCompactFieldSpecification(this, this._compactFieldSpecification, true, result);
        this._cachedFields = result;
        return result;
      },
      get$__functions: function() {
        var t1, result, t2, _i, mirror;
        t1 = this._cachedFunctions;
        if (t1 != null)
          return t1;
        result = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [null, null]);
        for (t1 = this.get$_functionMirrors(), t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          mirror = t1[_i];
          if (mirror.isConstructor !== true)
            result.$indexSet(0, mirror.simpleName, mirror);
        }
        t1 = new P.UnmodifiableMapView(result, [P.Symbol, P.MethodMirror]);
        this._cachedFunctions = t1;
        return t1;
      },
      get$__getters: function() {
        var t1, result;
        t1 = this._cachedGetters;
        if (t1 != null)
          return t1;
        result = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [null, null]);
        t1 = new P.UnmodifiableMapView(result, [P.Symbol, P.MethodMirror]);
        this._cachedGetters = t1;
        return t1;
      },
      get$__setters: function() {
        var t1, result;
        t1 = this._cachedSetters;
        if (t1 != null)
          return t1;
        result = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [null, null]);
        t1 = new P.UnmodifiableMapView(result, [P.Symbol, P.MethodMirror]);
        this._cachedSetters = t1;
        return t1;
      },
      get$__variables: function() {
        var t1, result, t2, _i, mirror;
        t1 = this._cachedVariables;
        if (t1 != null)
          return t1;
        result = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [null, null]);
        for (t1 = this.get$_fields(), t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          mirror = t1[_i];
          result.$indexSet(0, mirror.simpleName, mirror);
        }
        t1 = new P.UnmodifiableMapView(result, [P.Symbol, P.VariableMirror]);
        this._cachedVariables = t1;
        return t1;
      },
      get$__members: function() {
        var t1, result;
        t1 = this._cachedMembers;
        if (t1 != null)
          return t1;
        result = P.LinkedHashMap_LinkedHashMap$from(this.get$__classes(), null, null);
        t1 = new H.JsLibraryMirror___members_addToResult(result);
        J.forEach$1$ax(this.get$__functions()._collection$_map, t1);
        J.forEach$1$ax(this.get$__getters()._collection$_map, t1);
        J.forEach$1$ax(this.get$__setters()._collection$_map, t1);
        J.forEach$1$ax(this.get$__variables()._collection$_map, t1);
        t1 = new P.UnmodifiableMapView(result, [P.Symbol, P.Mirror]);
        this._cachedMembers = t1;
        return t1;
      },
      get$declarations: [function() {
        var t1, t2, result;
        t1 = this._cachedDeclarations;
        if (t1 != null)
          return t1;
        t1 = P.Symbol;
        t2 = P.DeclarationMirror;
        result = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [t1, t2]);
        J.forEach$1$ax(this.get$__members()._collection$_map, new H.JsLibraryMirror_declarations_addToResult(result));
        t1 = new P.UnmodifiableMapView(result, [t1, t2]);
        this._cachedDeclarations = t1;
        return t1;
      }, null, null, 1, 0, 132, "declarations"],
      get$metadata: [function() {
        var t1 = this._cachedMetadata;
        if (t1 != null)
          return t1;
        t1 = new P.UnmodifiableListView(J.map$1$ax(this._metadata, H._js_mirrors__reflect$closure()), [P.InstanceMirror]);
        this._cachedMetadata = t1;
        return t1;
      }, null, null, 1, 0, 59, "metadata"],
      get$owner: [function() {
        return;
      }, null, null, 1, 0, 125, "owner"],
      get$libraryDependencies: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 689, "libraryDependencies"],
      $isLibraryMirror: 1,
      $isMirror: 1,
      $isDeclarationMirror: 1
    },
    "+JsLibraryMirror": 0,
    JsDeclarationMirror_JsObjectMirror: {
      "^": "JsDeclarationMirror+JsObjectMirror;",
      $isMirror: 1
    },
    JsLibraryMirror___members_addToResult: {
      "^": "Closure:300;result",
      call$2: [function(key, value) {
        this.result.$indexSet(0, key, value);
      }, null, null, 4, 0, null, 6, [], 1, [], "call"]
    },
    "+ JsLibraryMirror___members_addToResult": 0,
    JsLibraryMirror_declarations_addToResult: {
      "^": "Closure:300;result",
      call$2: [function(key, value) {
        this.result.$indexSet(0, key, value);
      }, null, null, 4, 0, null, 6, [], 1, [], "call"]
    },
    "+ JsLibraryMirror_declarations_addToResult": 0,
    reflectType_closure: {
      "^": "Closure:3;",
      call$1: [function(_) {
        return _ instanceof H.TypeImpl;
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ reflectType_closure": [2],
    filterMembers_closure: {
      "^": "Closure:4;method",
      call$0: [function() {
        return this.method;
      }, null, null, 0, 0, 4, "call"]
    },
    "+ filterMembers_closure": [2],
    JsMixinApplication: {
      "^": "JsTypeMirror_JsObjectMirror;superclass<-,mixin<-,_cachedSimpleName,_cachedInstanceMembers,simpleName-",
      get$_prettyName: function() {
        return "ClassMirror";
      },
      get$simpleName: [function() {
        var t1, superName;
        t1 = this._cachedSimpleName;
        if (t1 != null)
          return t1;
        superName = this.superclass.get$qualifiedName().get$__internal$_name();
        t1 = this.mixin;
        t1 = J.contains$1$asx(superName, " with ") === true ? H.s(H.S(superName) + ", " + H.S(t1.get$qualifiedName().get$__internal$_name())) : H.s(H.S(superName) + " with " + H.S(t1.get$qualifiedName().get$__internal$_name()));
        this._cachedSimpleName = t1;
        return t1;
      }, null, null, 1, 0, 45, "simpleName"],
      get$qualifiedName: [function() {
        return this.get$simpleName();
      }, null, null, 1, 0, 45, "qualifiedName"],
      get$declarations: [function() {
        return this.mixin.get$declarations();
      }, null, null, 1, 0, 132, "declarations"],
      get$instanceMembers: [function() {
        var t1, result;
        t1 = this._cachedInstanceMembers;
        if (t1 == null) {
          result = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [P.Symbol, P.MethodMirror]);
          t1 = this.superclass;
          if (t1 != null)
            result.addAll$1(0, t1.get$instanceMembers());
          result.addAll$1(0, this.mixin.get$instanceMembers());
          this._cachedInstanceMembers = result;
          t1 = result;
        }
        return t1;
      }, null, null, 1, 0, 88, "instanceMembers"],
      get$staticMembers: [function() {
        return this.mixin.get$staticMembers();
      }, null, null, 1, 0, 88, "staticMembers"],
      _asRuntimeType$0: function() {
        return;
      },
      invoke$3: [function(memberName, positionalArguments, namedArguments) {
        throw H.wrapException(H.NoSuchStaticMethodError$method(null, memberName, positionalArguments, namedArguments));
      }, function(memberName, positionalArguments) {
        return this.invoke$3(memberName, positionalArguments, null);
      }, "invoke$2", "call$3", "call$2", "get$invoke", 4, 2, 63, 0, 146, [], 77, [], 74, [], "invoke"],
      getField$1: [function(fieldName) {
        throw H.wrapException(H.NoSuchStaticMethodError$method(null, fieldName, null, null));
      }, "call$1", "get$getField", 2, 0, 112, 83, [], "getField"],
      setField$2: [function(fieldName, arg) {
        throw H.wrapException(H.NoSuchStaticMethodError$method(null, H.setterSymbol(fieldName), [arg], null));
      }, "call$2", "get$setField", 4, 0, 108, 83, [], 68, [], "setField"],
      delegate$1: [function(invocation) {
        throw H.wrapException(new P.UnimplementedError(null));
      }, "call$1", "get$delegate", 2, 0, 77, 118, [], "delegate"],
      get$superinterfaces: [function() {
        return [this.mixin];
      }, null, null, 1, 0, 178, "superinterfaces"],
      newInstance$3: [function(constructorName, positionalArguments, namedArguments) {
        throw H.wrapException(new P.UnsupportedError("Can't instantiate mixin application '" + H.S(H.n(this.get$qualifiedName())) + "'"));
      }, function(constructorName, positionalArguments) {
        return this.newInstance$3(constructorName, positionalArguments, null);
      }, "newInstance$2", "call$3", "call$2", "get$newInstance", 4, 2, 63, 0, 240, [], 77, [], 74, [], "newInstance"],
      get$isOriginalDeclaration: [function() {
        return true;
      }, null, null, 1, 0, 5, "isOriginalDeclaration"],
      get$originalDeclaration: [function() {
        return this;
      }, null, null, 1, 0, 56, "originalDeclaration"],
      get$typeVariables: [function() {
        throw H.wrapException(new P.UnimplementedError(null));
      }, null, null, 1, 0, 130, "typeVariables"],
      get$typeArguments: [function() {
        return C.List_empty1;
      }, null, null, 1, 0, 131, "typeArguments"],
      get$isAbstract: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 5, "isAbstract"],
      get$isEnum: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 5, "isEnum"],
      isSubclassOf$1: [function(other) {
        if (this.superclass.isSubclassOf$1(other) !== true)
          this.mixin.isSubclassOf$1(other);
      }, "call$1", "get$isSubclassOf", 2, 0, 190, 2, [], "isSubclassOf"],
      isSubtypeOf$1: [function(other) {
        return H.throwExpression(new P.UnimplementedError(null));
      }, "call$1", "get$isSubtypeOf", 2, 0, 54, 2, [], "isSubtypeOf"],
      isAssignableTo$1: [function(other) {
        return H.throwExpression(new P.UnimplementedError(null));
      }, "call$1", "get$isAssignableTo", 2, 0, 54, 2, [], "isAssignableTo"],
      $isClassMirror: 1,
      $isMirror: 1,
      $isTypeMirror: 1,
      $isDeclarationMirror: 1
    },
    "+JsMixinApplication": 0,
    JsTypeMirror_JsObjectMirror: {
      "^": "JsTypeMirror+JsObjectMirror;",
      $isMirror: 1
    },
    JsObjectMirror: {
      "^": "Object;",
      $isMirror: 1
    },
    "+JsObjectMirror": 0,
    JsInstanceMirror: {
      "^": "JsObjectMirror;reflectee<-,_getterCache",
      get$hasReflectee: [function() {
        return true;
      }, null, null, 1, 0, 5, "hasReflectee"],
      get$type: [function() {
        var t1 = this.reflectee;
        if (t1 == null)
          return P.reflectClass(C.Type_Null_Yyn);
        return H.reflectType(new H.TypeImpl(H.getRuntimeTypeString(t1), null), null);
      }, null, null, 1, 0, 56, "type"],
      invoke$3: [function(memberName, positionalArguments, namedArguments) {
        return this._invoke$4(memberName, 0, positionalArguments, namedArguments == null ? C.Map_empty2 : namedArguments);
      }, function(memberName, positionalArguments) {
        return this.invoke$3(memberName, positionalArguments, null);
      }, "invoke$2", "call$3", "call$2", "get$invoke", 4, 2, 63, 0, 146, [], 77, [], 74, [], "invoke"],
      _invokeMethodWithNamedArguments$3: function(reflectiveName, positionalArguments, namedArguments) {
        var t1, jsFunction, info, t2, defaultArguments, t3, i, t4;
        t1 = this.reflectee;
        jsFunction = J.getInterceptor(t1)[reflectiveName];
        if (jsFunction == null)
          throw H.wrapException(new H.UnimplementedNoSuchMethodError("Invoking noSuchMethod with named arguments not implemented"));
        info = H.ReflectionInfo_ReflectionInfo(jsFunction);
        positionalArguments = P.List_List$from(positionalArguments, true, null);
        t2 = info.requiredParameterCount;
        if (t2 !== positionalArguments.length)
          throw H.wrapException(new H.UnimplementedNoSuchMethodError("Invoking noSuchMethod with named arguments not implemented"));
        defaultArguments = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [null, null]);
        for (t3 = info.optionalParameterCount, i = 0; i < t3; ++i) {
          t4 = i + t2;
          defaultArguments.$indexSet(0, info.parameterName$1(t4), init.metadata[info.defaultValue$1(t4)]);
        }
        J.forEach$1$ax(namedArguments, new H.JsInstanceMirror__invokeMethodWithNamedArguments_closure(defaultArguments));
        C.JSArray_methods.addAll$1(positionalArguments, defaultArguments.get$values());
        return H.reflect(jsFunction.apply(t1, positionalArguments));
      },
      get$_classInvocationCache: function() {
        var cacheName, cacheHolder, cache;
        cacheName = $.Primitives_mirrorInvokeCacheName;
        cacheHolder = this.reflectee;
        if (cacheHolder == null)
          cacheHolder = J.getInterceptor(null);
        cache = cacheHolder.constructor[cacheName];
        if (cache == null) {
          cache = H.JsCache_allocate();
          cacheHolder.constructor[cacheName] = cache;
        }
        return cache;
      },
      _computeReflectiveName$4: function(symbolName, type, positionalArguments, namedArguments) {
        var $name, nbArgs;
        $name = symbolName.get$__internal$_name();
        switch (type) {
          case 1:
            return $name;
          case 2:
            return H.S($name) + "=";
          case 0:
            if (J.get$isNotEmpty$asx(namedArguments))
              return H.S($name) + "*";
            nbArgs = H.intTypeCast(J.get$length$asx(positionalArguments));
            return H.S($name) + ":" + H.S(nbArgs);
        }
        throw H.wrapException(new H.RuntimeError("Could not compute reflective name for " + H.S($name)));
      },
      __js_mirrors$_getCachedInvocation$5: function($name, type, reflectiveName, positionalArguments, namedArguments) {
        var cache, cacheEntry;
        cache = this.get$_classInvocationCache();
        cacheEntry = cache[reflectiveName];
        if (cacheEntry == null) {
          cacheEntry = new H.JSInvocationMirror($name, $.$get$reflectiveNames().$index(0, reflectiveName), type, positionalArguments, C.List_empty, null)._getCachedInvocation$1(this.reflectee);
          cache[reflectiveName] = cacheEntry;
        }
        return cacheEntry;
      },
      _invoke$4: function($name, type, positionalArguments, namedArguments) {
        var reflectiveName, cacheEntry, t1, getterCacheEntry;
        reflectiveName = this._computeReflectiveName$4($name, type, positionalArguments, namedArguments);
        if (J.get$isNotEmpty$asx(namedArguments))
          return this._invokeMethodWithNamedArguments$3(reflectiveName, positionalArguments, namedArguments);
        cacheEntry = this.__js_mirrors$_getCachedInvocation$5($name, type, reflectiveName, positionalArguments, namedArguments);
        if (!cacheEntry.get$isNoSuchMethod())
          t1 = !("$reflectable" in cacheEntry.get$jsFunction() || this.reflectee instanceof H.TearOffClosure);
        else
          t1 = true;
        if (t1) {
          if (type === 0) {
            getterCacheEntry = this.__js_mirrors$_getCachedInvocation$5($name, 1, this._computeReflectiveName$4($name, 1, C.List_empty, C.Map_empty2), C.List_empty, C.Map_empty2);
            t1 = !getterCacheEntry.get$isNoSuchMethod() && !getterCacheEntry.get$isGetterStub();
          } else
            t1 = false;
          if (t1)
            return this.getField$1($name).invoke$3(C.Symbol_call, positionalArguments, namedArguments);
          if (type === 2)
            $name = H.s(H.S($name.get$__internal$_name()) + "=");
          if (!cacheEntry.get$isNoSuchMethod())
            H.throwInvalidReflectionError(reflectiveName);
          return H.reflect(cacheEntry.invokeOn$2(this.reflectee, new H.JSInvocationMirror($name, $.$get$reflectiveNames().$index(0, reflectiveName), type, positionalArguments, [], null)));
        } else
          return H.reflect(cacheEntry.invokeOn$2(this.reflectee, positionalArguments));
      },
      setField$2: [function(fieldName, arg) {
        this._invoke$4(fieldName, 2, [arg], C.Map_empty2);
        return H.reflect(arg);
      }, "call$2", "get$setField", 4, 0, 108, 83, [], 68, [], "setField"],
      getField$1: [function(fieldName) {
        var cache, getter, value, result;
        $FASTPATH$0: {
          cache = this._getterCache;
          if (typeof cache == "number" || typeof fieldName.$p == "undefined")
            break $FASTPATH$0;
          getter = fieldName.$p(cache);
          if (typeof getter == "undefined")
            break $FASTPATH$0;
          value = getter(this.reflectee);
          if (value === getter.v)
            return getter.m;
          else {
            result = H.reflect(value);
            getter.v = value;
            getter.m = result;
            return result;
          }
        }
        return this._getFieldSlow$1(fieldName);
      }, "call$1", "get$getField", 2, 0, 112, 83, [], "getField"],
      _getFieldSlow$1: function(fieldName) {
        var result, $name, cacheEntry, cache, mangledName, getter;
        result = this._invoke$4(fieldName, 1, C.List_empty, C.Map_empty2);
        $name = fieldName.get$__internal$_name();
        cacheEntry = this.get$_classInvocationCache()[$name];
        if (cacheEntry.get$isNoSuchMethod())
          return result;
        cache = this._getterCache;
        if (typeof cache == "number") {
          cache = J.$sub$n(cache, 1);
          this._getterCache = cache;
          if (!J.$eq$(cache, 0))
            return result;
          cache = Object.create(null);
          this._getterCache = cache;
        }
        if (typeof fieldName.$p == "undefined")
          fieldName.$p = this._newProbeFn$2($name, true);
        mangledName = cacheEntry.get$mangledName();
        getter = cacheEntry.get$isIntercepted() ? this._newInterceptedGetterFn$2(mangledName, true) : this._newGetterFn$2(mangledName, true);
        cache[$name] = getter;
        getter.v = getter.m = cache;
        return result;
      },
      _newProbeFn$2: function(id, useEval) {
        if (useEval)
          return new Function("c", "return c." + H.S(id) + ";");
        else
          return function(n) {
            return function(c) {
              return c[n];
            };
          }(id);
      },
      _newGetterFn$2: function($name, useEval) {
        if (!useEval)
          return function(n) {
            return function(o) {
              return o[n]();
            };
          }($name);
        return new Function("o", "/* " + this.reflectee.constructor.name + " */ return o." + H.S($name) + "();");
      },
      _newInterceptedGetterFn$2: function($name, useEval) {
        var interceptor, functionName;
        interceptor = J.getInterceptor(this.reflectee);
        if (!useEval)
          return function(n, i) {
            return function(o) {
              return i[n](o);
            };
          }($name, interceptor);
        functionName = interceptor.constructor.name + "$" + H.S($name);
        return new Function("i", "  function " + functionName + "(o){return i." + H.S($name) + "(o)}  return " + functionName + ";")(interceptor);
      },
      delegate$1: [function(invocation) {
        return H.JSInvocationMirror_invokeFromMirror(invocation, this.reflectee);
      }, "call$1", "get$delegate", 2, 0, 77, 118, [], "delegate"],
      $eq: [function(_, other) {
        var t1, t2;
        if (other == null)
          return false;
        if (other instanceof H.JsInstanceMirror) {
          t1 = this.reflectee;
          t2 = other.reflectee;
          t2 = t1 == null ? t2 == null : t1 === t2;
          t1 = t2;
        } else
          t1 = false;
        return t1;
      }, null, "get$==", 2, 0, 3, 2, [], "=="],
      get$hashCode: [function(_) {
        return J.$xor$n(H.objectHashCode(this.reflectee), 909522486);
      }, null, null, 1, 0, 11, "hashCode"],
      toString$0: [function(_) {
        return "InstanceMirror on " + H.S(P.Error_safeToString(this.reflectee));
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isInstanceMirror: 1,
      $isMirror: 1
    },
    "+JsInstanceMirror": 0,
    JsInstanceMirror__invokeMethodWithNamedArguments_closure: {
      "^": "Closure:150;defaultArguments",
      call$2: [function(symbol, value) {
        var parameter, t1;
        parameter = symbol.get$__internal$_name();
        t1 = this.defaultArguments;
        if (t1.containsKey$1(parameter))
          t1.$indexSet(0, parameter, value);
        else
          throw H.wrapException(new H.UnimplementedNoSuchMethodError("Invoking noSuchMethod with named arguments not implemented"));
      }, null, null, 4, 0, null, 419, [], 1, [], "call"]
    },
    "+ JsInstanceMirror__invokeMethodWithNamedArguments_closure": 0,
    JsTypeBoundClassMirror: {
      "^": "JsDeclarationMirror;_class,_typeArguments,_cachedTypeArguments,_cachedDeclarations,_cachedMembers,_cachedConstructors,_cachedVariables,_cachedGetters,_cachedSetters,_cachedMethodsMap,_cachedMethods,_superclass,_cachedSuperinterfaces,_cachedInstanceMembers,_cachedStaticMembers,simpleName-",
      get$_prettyName: function() {
        return "ClassMirror";
      },
      toString$0: [function(_) {
        var result, t1, t2;
        result = "ClassMirror on " + H.S(this._class.get$simpleName().get$__internal$_name());
        if (this.get$typeArguments() != null) {
          t1 = result + "<";
          t2 = this.get$typeArguments();
          result = t1 + t2.join$1(t2, ", ") + ">";
        }
        return result;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      get$_mangledName: function() {
        for (var t1 = this.get$typeArguments(), t1 = new H.ListIterator(t1, t1.get$length(t1), 0, null, [H.getRuntimeTypeArgument(t1, "ListMixin", 0)]); t1.moveNext$0();)
          if (!J.$eq$(t1.__internal$_current, $.$get$JsMirrorSystem__dynamicType()))
            return H.S(this._class.get$_mangledName()) + "<" + this._typeArguments + ">";
        return this._class.get$_mangledName();
      },
      get$typeVariables: [function() {
        return this._class.get$typeVariables();
      }, null, null, 1, 0, 130, "typeVariables"],
      get$typeArguments: [function() {
        var t1, result;
        t1 = this._cachedTypeArguments;
        if (t1 != null)
          return t1;
        result = [];
        C.JSArray_methods.forEach$1(H.splitTypeArguments(this._typeArguments), new H.JsTypeBoundClassMirror_typeArguments_addTypeArgument(result));
        t1 = new P.UnmodifiableListView(result, [null]);
        this._cachedTypeArguments = t1;
        return t1;
      }, null, null, 1, 0, 131, "typeArguments"],
      get$_methods: function() {
        var t1 = this._cachedMethods;
        if (t1 != null)
          return t1;
        t1 = this._class._getMethodsWithOwner$1(this);
        this._cachedMethods = t1;
        return t1;
      },
      get$__constructors: function() {
        var t1 = this._cachedConstructors;
        if (t1 != null)
          return t1;
        t1 = new P.UnmodifiableMapView(H.filterConstructors(this.get$_methods()), [P.Symbol, P.MethodMirror]);
        this._cachedConstructors = t1;
        return t1;
      },
      get$__variables: function() {
        var t1, result, t2, _i, mirror;
        t1 = this._cachedVariables;
        if (t1 != null)
          return t1;
        result = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [null, null]);
        for (t1 = this._class._getFieldsWithOwner$1(this), t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          mirror = t1[_i];
          result.$indexSet(0, mirror.simpleName, mirror);
        }
        t1 = new P.UnmodifiableMapView(result, [P.Symbol, P.VariableMirror]);
        this._cachedVariables = t1;
        return t1;
      },
      get$__members: function() {
        var t1 = this._cachedMembers;
        if (t1 != null)
          return t1;
        t1 = new P.UnmodifiableMapView(H.filterMembers(this.get$_methods(), this.get$__variables()), [P.Symbol, P.DeclarationMirror]);
        this._cachedMembers = t1;
        return t1;
      },
      get$declarations: [function() {
        var t1, t2, result;
        t1 = this._cachedDeclarations;
        if (t1 != null)
          return t1;
        t1 = P.Symbol;
        t2 = P.DeclarationMirror;
        result = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [t1, t2]);
        result.addAll$1(0, this.get$__members());
        result.addAll$1(0, this.get$__constructors());
        J.forEach$1$ax(this._class.get$typeVariables(), new H.JsTypeBoundClassMirror_declarations_closure(result));
        t1 = new P.UnmodifiableMapView(result, [t1, t2]);
        this._cachedDeclarations = t1;
        return t1;
      }, null, null, 1, 0, 132, "declarations"],
      get$staticMembers: [function() {
        var t1, result;
        t1 = this._cachedStaticMembers;
        if (t1 == null) {
          result = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [P.Symbol, P.MethodMirror]);
          this.get$declarations()._collection$_map.get$values().forEach$1(0, new H.JsTypeBoundClassMirror_staticMembers_closure(this, result));
          this._cachedStaticMembers = result;
          t1 = result;
        }
        return t1;
      }, null, null, 1, 0, 88, "staticMembers"],
      get$instanceMembers: [function() {
        var t1, result;
        t1 = this._cachedInstanceMembers;
        if (t1 == null) {
          result = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [P.Symbol, P.MethodMirror]);
          if (this.get$superclass() != null)
            result.addAll$1(0, this.get$superclass().get$instanceMembers());
          this.get$declarations()._collection$_map.get$values().forEach$1(0, new H.JsTypeBoundClassMirror_instanceMembers_closure(this, result));
          this._cachedInstanceMembers = result;
          t1 = result;
        }
        return t1;
      }, null, null, 1, 0, 88, "instanceMembers"],
      setField$2: [function(fieldName, arg) {
        return this._class.setField$2(fieldName, arg);
      }, "call$2", "get$setField", 4, 0, 108, 83, [], 68, [], "setField"],
      getField$1: [function(fieldName) {
        return this._class.getField$1(fieldName);
      }, "call$1", "get$getField", 2, 0, 112, 83, [], "getField"],
      newInstance$3: [function(constructorName, positionalArguments, namedArguments) {
        var instance, t1;
        instance = this._class._getInvokedInstance$3(constructorName, positionalArguments, namedArguments);
        t1 = this.get$typeArguments();
        t1.toString;
        return H.reflect(H.setRuntimeTypeInfo(instance, new H.MappedListIterable(t1, new H.JsTypeBoundClassMirror_newInstance_closure(), [H.getRuntimeTypeArgument(t1, "ListMixin", 0), null]).toList$0(0)));
      }, function(constructorName, positionalArguments) {
        return this.newInstance$3(constructorName, positionalArguments, null);
      }, "newInstance$2", "call$3", "call$2", "get$newInstance", 4, 2, 63, 0, 240, [], 77, [], 74, [], "newInstance"],
      _asRuntimeType$0: function() {
        var t1, t2;
        t1 = this._class.get$_jsConstructor();
        t2 = this.get$typeArguments();
        t2.toString;
        return C.JSArray_methods.addAll$1([t1], new H.MappedListIterable(t2, new H.JsTypeBoundClassMirror__asRuntimeType_closure(), [H.getRuntimeTypeArgument(t2, "ListMixin", 0), null]));
      },
      get$owner: [function() {
        return this._class.get$owner();
      }, null, null, 1, 0, 442, "owner"],
      get$metadata: [function() {
        return this._class.get$metadata();
      }, null, null, 1, 0, 59, "metadata"],
      get$superclass: [function() {
        var t1 = this._superclass;
        if (t1 != null)
          return t1;
        t1 = H.typeMirrorFromRuntimeTypeRepresentation(this, init.types[J.$index$asx(init.typeInformation[this._class.get$_mangledName()], 0)]);
        this._superclass = t1;
        return t1;
      }, null, null, 1, 0, 56, "superclass"],
      invoke$3: [function(memberName, positionalArguments, namedArguments) {
        return this._class.invoke$3(memberName, positionalArguments, namedArguments);
      }, function(memberName, positionalArguments) {
        return this.invoke$3(memberName, positionalArguments, null);
      }, "invoke$2", "call$3", "call$2", "get$invoke", 4, 2, 63, 0, 146, [], 77, [], 74, [], "invoke"],
      delegate$1: [function(invocation) {
        throw H.wrapException(new P.UnimplementedError(null));
      }, "call$1", "get$delegate", 2, 0, 77, 118, [], "delegate"],
      get$isOriginalDeclaration: [function() {
        return false;
      }, null, null, 1, 0, 5, "isOriginalDeclaration"],
      get$originalDeclaration: [function() {
        return this._class;
      }, null, null, 1, 0, 56, "originalDeclaration"],
      get$superinterfaces: [function() {
        var t1 = this._cachedSuperinterfaces;
        if (t1 != null)
          return t1;
        t1 = this._class._getSuperinterfacesWithOwner$1(this);
        this._cachedSuperinterfaces = t1;
        return t1;
      }, null, null, 1, 0, 178, "superinterfaces"],
      get$isPrivate: [function() {
        return J.startsWith$1$s(this._class.get$simpleName().get$__internal$_name(), "_");
      }, null, null, 1, 0, 5, "isPrivate"],
      get$isTopLevel: [function() {
        return this._class.get$isTopLevel();
      }, null, null, 1, 0, 5, "isTopLevel"],
      get$isAbstract: [function() {
        return this._class.get$isAbstract();
      }, null, null, 1, 0, 5, "isAbstract"],
      get$isEnum: [function() {
        return this._class.get$isEnum();
      }, null, null, 1, 0, 5, "isEnum"],
      isSubclassOf$1: [function(other) {
        return this._class.isSubclassOf$1(other);
      }, "call$1", "get$isSubclassOf", 2, 0, 190, 2, [], "isSubclassOf"],
      get$location: [function() {
        return this._class.get$location();
      }, null, null, 1, 0, 123, "location"],
      get$qualifiedName: [function() {
        return this._class.get$qualifiedName();
      }, null, null, 1, 0, 45, "qualifiedName"],
      get$hasReflectedType: [function() {
        return true;
      }, null, null, 1, 0, 5, "hasReflectedType"],
      get$reflectedType: [function() {
        return new H.TypeImpl(this.get$_mangledName(), null);
      }, null, null, 1, 0, 20, "reflectedType"],
      get$simpleName: [function() {
        return this._class.get$simpleName();
      }, null, null, 1, 0, 45, "simpleName"],
      get$mixin: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 56, "mixin"],
      isSubtypeOf$1: [function(other) {
        return H.throwExpression(new P.UnimplementedError(null));
      }, "call$1", "get$isSubtypeOf", 2, 0, 54, 2, [], "isSubtypeOf"],
      isAssignableTo$1: [function(other) {
        return H.throwExpression(new P.UnimplementedError(null));
      }, "call$1", "get$isAssignableTo", 2, 0, 54, 2, [], "isAssignableTo"],
      $isClassMirror: 1,
      $isMirror: 1,
      $isTypeMirror: 1,
      $isDeclarationMirror: 1
    },
    "+JsTypeBoundClassMirror": 0,
    JsTypeBoundClassMirror_typeArguments_addTypeArgument: {
      "^": "Closure:13;result",
      call$1: [function(typeArgument) {
        var parsedIndex, t1, typeVariable;
        parsedIndex = H.Primitives_parseInt(typeArgument, null, new H.JsTypeBoundClassMirror_typeArguments_addTypeArgument_closure());
        t1 = this.result;
        if (J.$eq$(parsedIndex, -1))
          t1.push(H.reflectClassByMangledName(J.trim$0$s(typeArgument)));
        else {
          typeVariable = init.metadata[parsedIndex];
          t1.push(new H.JsTypeVariableMirror(P.reflectClass(typeVariable.get$owner()), typeVariable, parsedIndex, null, H.s(typeVariable.get$name())));
        }
      }, null, null, 2, 0, null, 866, [], "call"]
    },
    "+ JsTypeBoundClassMirror_typeArguments_addTypeArgument": 0,
    JsTypeBoundClassMirror_typeArguments_addTypeArgument_closure: {
      "^": "Closure:3;",
      call$1: [function(_) {
        return -1;
      }, null, null, 2, 0, null, 16, [], "call"]
    },
    "+ JsTypeBoundClassMirror_typeArguments_addTypeArgument_closure": 0,
    JsTypeBoundClassMirror_declarations_closure: {
      "^": "Closure:3;result",
      call$1: [function(tv) {
        this.result.$indexSet(0, tv.get$simpleName(), tv);
        return tv;
      }, null, null, 2, 0, null, 553, [], "call"]
    },
    "+ JsTypeBoundClassMirror_declarations_closure": 0,
    JsTypeBoundClassMirror_staticMembers_closure: {
      "^": "Closure:3;$this,result",
      call$1: [function(decl) {
        var t1, getterName, t2, setterName;
        t1 = J.getInterceptor(decl);
        if (!!t1.$isMethodMirror && decl.get$isStatic() === true && decl.get$isConstructor() !== true)
          this.result.$indexSet(0, decl.get$simpleName(), decl);
        if (!!t1.$isVariableMirror && decl.get$isStatic() === true) {
          getterName = decl.get$simpleName();
          t1 = this.result;
          t2 = this.$this;
          t1.$indexSet(0, getterName, new H.JsSyntheticAccessor(t2, getterName, true, true, false, decl));
          if (decl.get$isFinal() !== true) {
            setterName = H.s(H.S(decl.get$simpleName().get$__internal$_name()) + "=");
            t1.$indexSet(0, setterName, new H.JsSyntheticAccessor(t2, setterName, false, true, false, decl));
          }
        }
      }, null, null, 2, 0, null, 241, [], "call"]
    },
    "+ JsTypeBoundClassMirror_staticMembers_closure": 0,
    JsTypeBoundClassMirror_instanceMembers_closure: {
      "^": "Closure:3;$this,result",
      call$1: [function(decl) {
        var t1, t2, getterName, setterName;
        t1 = J.getInterceptor(decl);
        if (!!t1.$isMethodMirror)
          if (decl.get$isStatic() !== true)
            if (decl.get$isConstructor() !== true) {
              decl.get$isAbstract();
              t2 = true;
            } else
              t2 = false;
          else
            t2 = false;
        else
          t2 = false;
        if (t2)
          this.result.$indexSet(0, decl.get$simpleName(), decl);
        if (!!t1.$isVariableMirror && decl.get$isStatic() !== true) {
          getterName = decl.get$simpleName();
          t1 = this.result;
          t2 = this.$this;
          t1.$indexSet(0, getterName, new H.JsSyntheticAccessor(t2, getterName, true, false, false, decl));
          if (decl.get$isFinal() !== true) {
            setterName = H.s(H.S(decl.get$simpleName().get$__internal$_name()) + "=");
            t1.$indexSet(0, setterName, new H.JsSyntheticAccessor(t2, setterName, false, false, false, decl));
          }
        }
      }, null, null, 2, 0, null, 241, [], "call"]
    },
    "+ JsTypeBoundClassMirror_instanceMembers_closure": 0,
    JsTypeBoundClassMirror_newInstance_closure: {
      "^": "Closure:3;",
      call$1: [function(t) {
        return t._asRuntimeType$0();
      }, null, null, 2, 0, null, 556, [], "call"]
    },
    "+ JsTypeBoundClassMirror_newInstance_closure": 0,
    JsTypeBoundClassMirror__asRuntimeType_closure: {
      "^": "Closure:3;",
      call$1: [function(t) {
        return t._asRuntimeType$0();
      }, null, null, 2, 0, null, 556, [], "call"]
    },
    "+ JsTypeBoundClassMirror__asRuntimeType_closure": 0,
    JsSyntheticAccessor: {
      "^": "Object;owner<-,simpleName<-,isGetter<-,isStatic<-,isTopLevel<-,__js_mirrors$_target",
      get$isSynthetic: [function() {
        return true;
      }, null, null, 1, 0, 5, "isSynthetic"],
      get$isRegularMethod: [function() {
        return false;
      }, null, null, 1, 0, 5, "isRegularMethod"],
      get$isOperator: [function() {
        return false;
      }, null, null, 1, 0, 5, "isOperator"],
      get$isConstructor: [function() {
        return false;
      }, null, null, 1, 0, 5, "isConstructor"],
      get$isConstConstructor: [function() {
        return false;
      }, null, null, 1, 0, 5, "isConstConstructor"],
      get$isGenerativeConstructor: [function() {
        return false;
      }, null, null, 1, 0, 5, "isGenerativeConstructor"],
      get$isFactoryConstructor: [function() {
        return false;
      }, null, null, 1, 0, 5, "isFactoryConstructor"],
      get$isRedirectingConstructor: [function() {
        return false;
      }, null, null, 1, 0, 5, "isRedirectingConstructor"],
      get$isAbstract: [function() {
        return false;
      }, null, null, 1, 0, 5, "isAbstract"],
      get$isSetter: [function() {
        return this.isGetter !== true;
      }, null, null, 1, 0, 5, "isSetter"],
      get$isPrivate: [function() {
        return J.startsWith$1$s(this.simpleName.get$__internal$_name(), "_");
      }, null, null, 1, 0, 5, "isPrivate"],
      get$qualifiedName: [function() {
        return H.computeQualifiedName(this.owner, this.simpleName);
      }, null, null, 1, 0, 45, "qualifiedName"],
      get$constructorName: [function() {
        return C.Symbol_0c4;
      }, null, null, 1, 0, 45, "constructorName"],
      get$returnType: [function() {
        return this.__js_mirrors$_target.get$type();
      }, null, null, 1, 0, 53, "returnType"],
      get$parameters: [function() {
        if (this.isGetter === true)
          return C.List_empty;
        return new P.UnmodifiableListView([new H.JsSyntheticSetterParameter(this, this.__js_mirrors$_target)], [null]);
      }, null, null, 1, 0, 296, "parameters"],
      get$metadata: [function() {
        return C.List_empty;
      }, null, null, 1, 0, 59, "metadata"],
      get$source: [function() {
        return;
      }, null, null, 1, 0, 7, "source"],
      get$location: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 123, "location"],
      $isMethodMirror: 1,
      $isDeclarationMirror: 1,
      $isMirror: 1
    },
    "+JsSyntheticAccessor": 0,
    JsSyntheticSetterParameter: {
      "^": "Object;owner<-,__js_mirrors$_target",
      get$simpleName: [function() {
        return this.__js_mirrors$_target.get$simpleName();
      }, null, null, 1, 0, 45, "simpleName"],
      get$qualifiedName: [function() {
        return H.computeQualifiedName(this.owner, this.__js_mirrors$_target.get$simpleName());
      }, null, null, 1, 0, 45, "qualifiedName"],
      get$type: [function() {
        return this.__js_mirrors$_target.get$type();
      }, null, null, 1, 0, 53, "type"],
      get$isOptional: [function() {
        return false;
      }, null, null, 1, 0, 5, "isOptional"],
      get$isNamed: [function() {
        return false;
      }, null, null, 1, 0, 5, "isNamed"],
      get$isStatic: [function() {
        return false;
      }, null, null, 1, 0, 5, "isStatic"],
      get$isTopLevel: [function() {
        return false;
      }, null, null, 1, 0, 5, "isTopLevel"],
      get$isConst: [function() {
        return false;
      }, null, null, 1, 0, 5, "isConst"],
      get$isFinal: [function() {
        return true;
      }, null, null, 1, 0, 5, "isFinal"],
      get$isPrivate: [function() {
        return false;
      }, null, null, 1, 0, 5, "isPrivate"],
      get$hasDefaultValue: [function() {
        return false;
      }, null, null, 1, 0, 5, "hasDefaultValue"],
      get$defaultValue: [function() {
        return;
      }, null, null, 1, 0, 446, "defaultValue"],
      get$metadata: [function() {
        return C.List_empty;
      }, null, null, 1, 0, 59, "metadata"],
      get$location: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 123, "location"],
      $isParameterMirror: 1,
      $isVariableMirror: 1,
      $isDeclarationMirror: 1,
      $isMirror: 1
    },
    "+JsSyntheticSetterParameter": 0,
    JsClassMirror: {
      "^": "JsTypeMirror_JsObjectMirror0;_mangledName<,_jsConstructor<,_fieldsDescriptor,_fieldsMetadata,_jsConstructorCache,_metadata,_superclass,_cachedMethods,_cachedFields,_cachedConstructors,_cachedMethodsMap,_cachedGetters,_cachedSetters,_cachedVariables,_cachedMembers,_cachedDeclarations,_cachedMetadata,_cachedSuperinterfaces,_cachedTypeVariables,_cachedInstanceMembers,_cachedStaticMembers,_owner,simpleName-",
      get$_prettyName: function() {
        return "ClassMirror";
      },
      get$__constructors: function() {
        var t1 = this._cachedConstructors;
        if (t1 != null)
          return t1;
        t1 = new P.UnmodifiableMapView(H.filterConstructors(this.get$_methods()), [P.Symbol, P.MethodMirror]);
        this._cachedConstructors = t1;
        return t1;
      },
      _asRuntimeType$0: function() {
        var type, i, t1;
        if (J.get$isEmpty$asx(this.get$typeVariables()))
          return this._jsConstructor;
        type = [this._jsConstructor];
        i = 0;
        while (true) {
          t1 = J.get$length$asx(this.get$typeVariables());
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          type.push($.$get$JsMirrorSystem__dynamicType().get$_asRuntimeType());
          ++i;
        }
        return type;
      },
      _getMethodsWithOwner$1: function(methodOwner) {
        var $prototype, keys, result, t1, _i, key, simpleName, $function, stubName, mirror, mangledName, jsFunction, reflectionName, isConstructor, t2;
        $prototype = this._jsConstructor.prototype;
        $prototype.$deferredAction();
        keys = H.extractKeys($prototype);
        result = H.setRuntimeTypeInfo([], [H.JsMethodMirror]);
        for (t1 = keys.length, _i = 0; _i < t1; ++_i) {
          key = keys[_i];
          if (H.isReflectiveDataInPrototype(key))
            continue;
          simpleName = $.$get$mangledNames().$index(0, key);
          if (simpleName == null)
            continue;
          $function = $prototype[key];
          if (!($function.$reflectable === 1))
            continue;
          stubName = $function.$stubName;
          if (stubName != null && !J.$eq$(key, stubName))
            continue;
          mirror = H.JsMethodMirror_JsMethodMirror$fromUnmangledName(simpleName, $function, false, false);
          result.push(mirror);
          mirror._owner = methodOwner;
        }
        keys = H.extractKeys(init.statics[this._mangledName]);
        for (t1 = keys.length, _i = 0; _i < t1; ++_i) {
          mangledName = keys[_i];
          if (H.isReflectiveDataInPrototype(mangledName))
            continue;
          jsFunction = this.get$owner()._globalObject[mangledName];
          if ("$reflectable" in jsFunction) {
            reflectionName = jsFunction.$reflectionName;
            if (reflectionName == null)
              continue;
            isConstructor = C.JSString_methods.startsWith$1(reflectionName, "new ");
            if (isConstructor) {
              t2 = C.JSString_methods.substring$1(reflectionName, 4);
              reflectionName = H.stringReplaceAllUnchecked(t2, "$", ".");
            }
          } else
            continue;
          mirror = H.JsMethodMirror_JsMethodMirror$fromUnmangledName(reflectionName, jsFunction, !isConstructor, isConstructor);
          result.push(mirror);
          mirror._owner = methodOwner;
        }
        return result;
      },
      get$_methods: function() {
        var t1 = this._cachedMethods;
        if (t1 != null)
          return t1;
        t1 = this._getMethodsWithOwner$1(this);
        this._cachedMethods = t1;
        return t1;
      },
      _getFieldsWithOwner$1: function(fieldOwner) {
        var result, t1, instanceFieldSpecfication, staticDescriptor;
        result = H.setRuntimeTypeInfo([], [P.VariableMirror]);
        t1 = this._fieldsDescriptor.split(";");
        if (1 >= t1.length)
          return H.ioore(t1, 1);
        instanceFieldSpecfication = t1[1];
        t1 = this._fieldsMetadata;
        if (t1 != null) {
          instanceFieldSpecfication = [instanceFieldSpecfication];
          C.JSArray_methods.addAll$1(instanceFieldSpecfication, t1);
        }
        H.parseCompactFieldSpecification(fieldOwner, instanceFieldSpecfication, false, result);
        staticDescriptor = init.statics[this._mangledName];
        if (staticDescriptor != null)
          H.parseCompactFieldSpecification(fieldOwner, staticDescriptor["^"], true, result);
        return result;
      },
      get$_fields: function() {
        var t1 = this._cachedFields;
        if (t1 != null)
          return t1;
        t1 = this._getFieldsWithOwner$1(this);
        this._cachedFields = t1;
        return t1;
      },
      get$__methods: function() {
        var t1 = this._cachedMethodsMap;
        if (t1 != null)
          return t1;
        t1 = new P.UnmodifiableMapView(H.filterMethods(this.get$_methods()), [P.Symbol, P.MethodMirror]);
        this._cachedMethodsMap = t1;
        return t1;
      },
      get$__getters: function() {
        var t1 = this._cachedGetters;
        if (t1 != null)
          return t1;
        t1 = new P.UnmodifiableMapView(H.filterGetters(this.get$_methods(), this.get$__variables()), [P.Symbol, P.MethodMirror]);
        this._cachedGetters = t1;
        return t1;
      },
      get$__setters: function() {
        var t1 = this._cachedSetters;
        if (t1 != null)
          return t1;
        t1 = new P.UnmodifiableMapView(H.filterSetters(this.get$_methods(), this.get$__variables()), [P.Symbol, P.MethodMirror]);
        this._cachedSetters = t1;
        return t1;
      },
      get$__variables: function() {
        var t1, result, t2, _i, mirror;
        t1 = this._cachedVariables;
        if (t1 != null)
          return t1;
        result = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [null, null]);
        for (t1 = this.get$_fields(), t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          mirror = t1[_i];
          result.$indexSet(0, mirror.simpleName, mirror);
        }
        t1 = new P.UnmodifiableMapView(result, [P.Symbol, P.VariableMirror]);
        this._cachedVariables = t1;
        return t1;
      },
      get$__members: function() {
        var t1 = this._cachedMembers;
        if (t1 != null)
          return t1;
        t1 = new P.UnmodifiableMapView(H.filterMembers(this.get$_methods(), this.get$__variables()), [P.Symbol, P.Mirror]);
        this._cachedMembers = t1;
        return t1;
      },
      get$declarations: [function() {
        var t1, t2, result, t3;
        t1 = this._cachedDeclarations;
        if (t1 != null)
          return t1;
        t1 = P.Symbol;
        t2 = P.DeclarationMirror;
        result = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [t1, t2]);
        t3 = new H.JsClassMirror_declarations_addToResult(result);
        J.forEach$1$ax(this.get$__members()._collection$_map, t3);
        J.forEach$1$ax(this.get$__constructors()._collection$_map, t3);
        J.forEach$1$ax(this.get$typeVariables(), new H.JsClassMirror_declarations_closure(result));
        t2 = new P.UnmodifiableMapView(result, [t1, t2]);
        this._cachedDeclarations = t2;
        return t2;
      }, null, null, 1, 0, 132, "declarations"],
      get$staticMembers: [function() {
        var t1, result;
        t1 = this._cachedStaticMembers;
        if (t1 == null) {
          result = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [P.Symbol, P.MethodMirror]);
          this.get$declarations()._collection$_map.get$values().forEach$1(0, new H.JsClassMirror_staticMembers_closure(this, result));
          this._cachedStaticMembers = result;
          t1 = result;
        }
        return t1;
      }, null, null, 1, 0, 88, "staticMembers"],
      get$instanceMembers: [function() {
        var t1, result;
        t1 = this._cachedInstanceMembers;
        if (t1 == null) {
          result = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [P.Symbol, P.MethodMirror]);
          if (this.get$superclass() != null)
            result.addAll$1(0, this.get$superclass().get$instanceMembers());
          this.get$declarations()._collection$_map.get$values().forEach$1(0, new H.JsClassMirror_instanceMembers_closure(this, result));
          this._cachedInstanceMembers = result;
          t1 = result;
        }
        return t1;
      }, null, null, 1, 0, 88, "instanceMembers"],
      setField$2: [function(fieldName, arg) {
        var mirror, t1, jsName, setterName, setter;
        mirror = J.$index$asx(this.get$__variables()._collection$_map, fieldName);
        t1 = mirror == null;
        if (!t1 && mirror.get$isStatic() === true && mirror.get$isFinal() !== true) {
          jsName = mirror.get$_jsName();
          if (!(jsName in $))
            throw H.wrapException(new H.RuntimeError('Cannot find "' + jsName + '" in current isolate.'));
          $[jsName] = arg;
          return H.reflect(arg);
        }
        setterName = H.s(H.S(fieldName.get$__internal$_name()) + "=");
        if (t1) {
          setter = J.$index$asx(this.get$__setters()._collection$_map, setterName);
          if (setter != null) {
            setter._invoke$2([arg], C.Map_empty2);
            return H.reflect(arg);
          }
        }
        throw H.wrapException(H.NoSuchStaticMethodError$method(null, setterName, [arg], null));
      }, "call$2", "get$setField", 4, 0, 108, 83, [], 68, [], "setField"],
      _staticFieldExists$1: function(fieldName) {
        var mirror, getter;
        mirror = J.$index$asx(this.get$__variables()._collection$_map, fieldName);
        if (mirror != null)
          return mirror.get$isStatic();
        getter = J.$index$asx(this.get$__getters()._collection$_map, fieldName);
        return getter != null && getter.get$isStatic() === true;
      },
      getField$1: [function(fieldName) {
        var mirror, jsName, lazies, getterName, getter, method;
        mirror = J.$index$asx(this.get$__variables()._collection$_map, fieldName);
        if (mirror != null && mirror.get$isStatic() === true) {
          jsName = mirror.get$_jsName();
          if (!(jsName in $))
            throw H.wrapException(new H.RuntimeError('Cannot find "' + jsName + '" in current isolate.'));
          lazies = init.lazies;
          if (jsName in lazies) {
            getterName = lazies[jsName];
            return H.reflect($[getterName]());
          } else
            return H.reflect($[jsName]);
        }
        getter = J.$index$asx(this.get$__getters()._collection$_map, fieldName);
        if (getter != null && getter.get$isStatic() === true)
          return H.reflect(getter._invoke$2(C.List_empty, C.Map_empty2));
        method = J.$index$asx(this.get$__methods()._collection$_map, fieldName);
        if (method != null && method.get$isStatic() === true) {
          getter = method.get$_jsFunction().$getter;
          if (getter == null)
            throw H.wrapException(new P.UnimplementedError(null));
          return H.reflect(getter());
        }
        throw H.wrapException(H.NoSuchStaticMethodError$method(null, fieldName, null, null));
      }, "call$1", "get$getField", 2, 0, 112, 83, [], "getField"],
      _getInvokedInstance$3: function(constructorName, positionalArguments, namedArguments) {
        var t1, mirror;
        if (namedArguments != null && J.get$isEmpty$asx(namedArguments) !== true)
          throw H.wrapException(new P.UnsupportedError("Named arguments are not implemented."));
        t1 = this._jsConstructorCache;
        mirror = t1[constructorName.get$__internal$_name()];
        if (mirror == null) {
          mirror = this.get$__constructors()._collection$_map.get$values().firstWhere$2$orElse(0, new H.JsClassMirror__getInvokedInstance_closure(constructorName), new H.JsClassMirror__getInvokedInstance_closure0(constructorName, positionalArguments, namedArguments));
          t1[constructorName.get$__internal$_name()] = mirror;
        }
        return mirror._invoke$2(positionalArguments, namedArguments);
      },
      newInstance$3: [function(constructorName, positionalArguments, namedArguments) {
        return H.reflect(this._getInvokedInstance$3(constructorName, positionalArguments, namedArguments));
      }, function(constructorName, positionalArguments) {
        return this.newInstance$3(constructorName, positionalArguments, null);
      }, "newInstance$2", "call$3", "call$2", "get$newInstance", 4, 2, 63, 0, 240, [], 77, [], 74, [], "newInstance"],
      get$owner: [function() {
        var t1, t2;
        t1 = this._owner;
        if (t1 == null) {
          for (t1 = H.JsMirrorSystem_librariesByName().get$values(), t1 = t1.get$iterator(t1); t1.moveNext$0();)
            for (t2 = J.get$iterator$ax(t1.get$current()); t2.moveNext$0();)
              t2.get$current().get$__classes();
          t1 = this._owner;
          if (t1 == null)
            throw H.wrapException(new P.StateError('Class "' + H.S(H.n(this.simpleName)) + '" has no owner'));
        }
        return t1;
      }, null, null, 1, 0, 442, "owner"],
      get$metadata: [function() {
        var t1 = this._cachedMetadata;
        if (t1 != null)
          return t1;
        t1 = this._metadata;
        if (t1 == null) {
          t1 = H.extractMetadata(this._jsConstructor.prototype);
          this._metadata = t1;
        }
        t1 = new P.UnmodifiableListView(J.map$1$ax(t1, H._js_mirrors__reflect$closure()), [P.InstanceMirror]);
        this._cachedMetadata = t1;
        return t1;
      }, null, null, 1, 0, 59, "metadata"],
      get$superclass: [function() {
        var t1, typeInformation, t2, superclassName, mixins, t3;
        t1 = this._superclass;
        if (t1 == null) {
          typeInformation = init.typeInformation[this._mangledName];
          if (typeInformation != null) {
            t1 = H.typeMirrorFromRuntimeTypeRepresentation(this, init.types[J.$index$asx(typeInformation, 0)]);
            this._superclass = t1;
          } else {
            t1 = this._fieldsDescriptor;
            t2 = t1.split(";");
            if (0 >= t2.length)
              return H.ioore(t2, 0);
            t2 = J.split$1$s(t2[0], ":");
            if (0 >= t2.length)
              return H.ioore(t2, 0);
            superclassName = t2[0];
            t2 = J.getInterceptor$s(superclassName);
            mixins = t2.split$1(superclassName, "+");
            t3 = mixins.length;
            if (t3 > 1) {
              if (t3 !== 2)
                throw H.wrapException(new H.RuntimeError("Strange mixin: " + H.S(t1)));
              t1 = H.reflectClassByMangledName(mixins[0]);
              this._superclass = t1;
            } else {
              t1 = t2.$eq(superclassName, "") ? this : H.reflectClassByMangledName(superclassName);
              this._superclass = t1;
            }
          }
        }
        return J.$eq$(t1, this) ? null : this._superclass;
      }, null, null, 1, 0, 56, "superclass"],
      invoke$3: [function(memberName, positionalArguments, namedArguments) {
        var mirror, t1;
        if (namedArguments != null && J.get$isEmpty$asx(namedArguments) !== true)
          throw H.wrapException(new P.UnsupportedError("Named arguments are not implemented."));
        mirror = J.$index$asx(this.get$__methods()._collection$_map, memberName);
        t1 = mirror == null;
        if (t1 && this._staticFieldExists$1(memberName) === true)
          return this.getField$1(memberName).invoke$3(C.Symbol_call, positionalArguments, namedArguments);
        if (t1 || mirror.get$isStatic() !== true)
          throw H.wrapException(H.NoSuchStaticMethodError$method(null, memberName, positionalArguments, namedArguments));
        if (!mirror.canInvokeReflectively$0())
          H.throwInvalidReflectionError(memberName.get$__internal$_name());
        return H.reflect(mirror._invoke$2(positionalArguments, namedArguments));
      }, function(memberName, positionalArguments) {
        return this.invoke$3(memberName, positionalArguments, null);
      }, "invoke$2", "call$3", "call$2", "get$invoke", 4, 2, 63, 0, 146, [], 77, [], 74, [], "invoke"],
      delegate$1: [function(invocation) {
        throw H.wrapException(new P.UnimplementedError(null));
      }, "call$1", "get$delegate", 2, 0, 77, 118, [], "delegate"],
      get$isOriginalDeclaration: [function() {
        return true;
      }, null, null, 1, 0, 5, "isOriginalDeclaration"],
      get$originalDeclaration: [function() {
        return this;
      }, null, null, 1, 0, 56, "originalDeclaration"],
      _getSuperinterfacesWithOwner$1: function(owner) {
        var typeInformation, t1, result;
        typeInformation = init.typeInformation[this._mangledName];
        if (typeInformation != null) {
          t1 = J.skip$1$ax(typeInformation, 1);
          result = new H.MappedListIterable(t1, new H.JsClassMirror__getSuperinterfacesWithOwner_lookupType(owner), [H.getTypeArgumentByIndex(t1, 0), null]).toList$0(0);
        } else
          result = C.List_empty0;
        return new P.UnmodifiableListView(result, [P.ClassMirror]);
      },
      get$superinterfaces: [function() {
        var t1 = this._cachedSuperinterfaces;
        if (t1 != null)
          return t1;
        t1 = this._getSuperinterfacesWithOwner$1(this);
        this._cachedSuperinterfaces = t1;
        return t1;
      }, null, null, 1, 0, 178, "superinterfaces"],
      get$typeVariables: [function() {
        var t1, result, typeVariables, i, typeVariable;
        t1 = this._cachedTypeVariables;
        if (t1 != null)
          return t1;
        result = [];
        typeVariables = this._jsConstructor.prototype["<>"];
        if (typeVariables == null)
          return result;
        for (i = 0; i < typeVariables.length; ++i) {
          t1 = typeVariables[i];
          typeVariable = init.metadata[t1];
          result.push(new H.JsTypeVariableMirror(this, typeVariable, t1, null, H.s(typeVariable.get$name())));
        }
        t1 = new P.UnmodifiableListView(result, [null]);
        this._cachedTypeVariables = t1;
        return t1;
      }, null, null, 1, 0, 130, "typeVariables"],
      get$typeArguments: [function() {
        return C.List_empty1;
      }, null, null, 1, 0, 131, "typeArguments"],
      get$hasReflectedType: [function() {
        return J.$eq$(J.get$length$asx(this.get$typeVariables()), 0);
      }, null, null, 1, 0, 5, "hasReflectedType"],
      get$reflectedType: [function() {
        if (!J.$eq$(J.get$length$asx(this.get$typeVariables()), 0))
          throw H.wrapException(new P.UnsupportedError("Declarations of generics have no reflected type"));
        return new H.TypeImpl(this._mangledName, null);
      }, null, null, 1, 0, 20, "reflectedType"],
      get$mixin: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 56, "mixin"],
      get$isAbstract: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 5, "isAbstract"],
      get$isEnum: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 5, "isEnum"],
      isSubclassOf$1: [function(other) {
        var t1 = J.getInterceptor(other);
        if (!t1.$isClassMirror)
          throw H.wrapException(P.ArgumentError$(other));
        if (!!t1.$isJsFunctionTypeMirror)
          return false;
        if (!!t1.$isJsClassMirror && other._jsConstructor == this._jsConstructor)
          return true;
        else if (this.get$superclass() == null)
          return false;
        else
          return this.get$superclass().isSubclassOf$1(other);
      }, "call$1", "get$isSubclassOf", 2, 0, 190, 2, [], "isSubclassOf"],
      $isClassMirror: 1,
      $isMirror: 1,
      $isTypeMirror: 1,
      $isDeclarationMirror: 1
    },
    "+JsClassMirror": 0,
    JsTypeMirror_JsObjectMirror0: {
      "^": "JsTypeMirror+JsObjectMirror;",
      $isMirror: 1
    },
    JsClassMirror_declarations_addToResult: {
      "^": "Closure:300;result",
      call$2: [function(key, value) {
        this.result.$indexSet(0, key, value);
      }, null, null, 4, 0, null, 6, [], 1, [], "call"]
    },
    "+ JsClassMirror_declarations_addToResult": 0,
    JsClassMirror_declarations_closure: {
      "^": "Closure:3;result",
      call$1: [function(tv) {
        this.result.$indexSet(0, tv.get$simpleName(), tv);
        return tv;
      }, null, null, 2, 0, null, 553, [], "call"]
    },
    "+ JsClassMirror_declarations_closure": 0,
    JsClassMirror_staticMembers_closure: {
      "^": "Closure:3;$this,result",
      call$1: [function(decl) {
        var t1, getterName, t2, setterName;
        t1 = J.getInterceptor(decl);
        if (!!t1.$isMethodMirror && decl.get$isStatic() === true && decl.get$isConstructor() !== true)
          this.result.$indexSet(0, decl.get$simpleName(), decl);
        if (!!t1.$isVariableMirror && decl.get$isStatic() === true) {
          getterName = decl.get$simpleName();
          t1 = this.result;
          t2 = this.$this;
          t1.$indexSet(0, getterName, new H.JsSyntheticAccessor(t2, getterName, true, true, false, decl));
          if (decl.get$isFinal() !== true) {
            setterName = H.s(H.S(decl.get$simpleName().get$__internal$_name()) + "=");
            t1.$indexSet(0, setterName, new H.JsSyntheticAccessor(t2, setterName, false, true, false, decl));
          }
        }
      }, null, null, 2, 0, null, 241, [], "call"]
    },
    "+ JsClassMirror_staticMembers_closure": 0,
    JsClassMirror_instanceMembers_closure: {
      "^": "Closure:3;$this,result",
      call$1: [function(decl) {
        var t1, t2, getterName, setterName;
        t1 = J.getInterceptor(decl);
        if (!!t1.$isMethodMirror)
          if (decl.get$isStatic() !== true)
            if (decl.get$isConstructor() !== true) {
              decl.get$isAbstract();
              t2 = true;
            } else
              t2 = false;
          else
            t2 = false;
        else
          t2 = false;
        if (t2)
          this.result.$indexSet(0, decl.get$simpleName(), decl);
        if (!!t1.$isVariableMirror && decl.get$isStatic() !== true) {
          getterName = decl.get$simpleName();
          t1 = this.result;
          t2 = this.$this;
          t1.$indexSet(0, getterName, new H.JsSyntheticAccessor(t2, getterName, true, false, false, decl));
          if (decl.get$isFinal() !== true) {
            setterName = H.s(H.S(decl.get$simpleName().get$__internal$_name()) + "=");
            t1.$indexSet(0, setterName, new H.JsSyntheticAccessor(t2, setterName, false, false, false, decl));
          }
        }
      }, null, null, 2, 0, null, 241, [], "call"]
    },
    "+ JsClassMirror_instanceMembers_closure": 0,
    JsClassMirror__getInvokedInstance_closure: {
      "^": "Closure:3;constructorName",
      call$1: [function(m) {
        return J.$eq$(m.get$constructorName(), this.constructorName);
      }, null, null, 2, 0, null, 173, [], "call"]
    },
    "+ JsClassMirror__getInvokedInstance_closure": 0,
    JsClassMirror__getInvokedInstance_closure0: {
      "^": "Closure:4;constructorName,positionalArguments,namedArguments",
      call$0: [function() {
        throw H.wrapException(H.NoSuchStaticMethodError$method(null, this.constructorName, this.positionalArguments, this.namedArguments));
      }, null, null, 0, 0, null, "call"]
    },
    "+ JsClassMirror__getInvokedInstance_closure": 0,
    JsClassMirror__getSuperinterfacesWithOwner_lookupType: {
      "^": "Closure:1189;owner",
      call$1: [function(i) {
        return H.typeMirrorFromRuntimeTypeRepresentation(this.owner, init.types[i]);
      }, null, null, 2, 0, null, 127, [], "call"]
    },
    "+ JsClassMirror__getSuperinterfacesWithOwner_lookupType": 0,
    JsVariableMirror: {
      "^": "JsDeclarationMirror;_jsName<,isFinal<-,isStatic<-,_metadataFunction,_owner,_type<,_metadata,simpleName-",
      get$_prettyName: function() {
        return "VariableMirror";
      },
      get$type: [function() {
        return H.typeMirrorFromRuntimeTypeRepresentation(this._owner, init.types[this._type]);
      }, null, null, 1, 0, 53, "type"],
      get$owner: [function() {
        return this._owner;
      }, null, null, 1, 0, 125, "owner"],
      get$metadata: [function() {
        var t1 = this._metadata;
        if (t1 == null) {
          t1 = this._metadataFunction;
          t1 = t1 == null ? C.List_empty : t1();
          this._metadata = t1;
        }
        return J.map$1$ax(t1, H._js_mirrors__reflect$closure()).toList$0(0);
      }, null, null, 1, 0, 59, "metadata"],
      _getField$1: function(receiver) {
        return $[this._jsName];
      },
      _setField$2: function(receiver, arg) {
        if (this.isFinal === true) {
          if (this.isStatic === true)
            throw H.wrapException(H.NoSuchStaticMethodError$method(null, H.setterSymbol(this.simpleName), [arg], null));
          throw H.wrapException(P.NoSuchMethodError$(this, H.setterSymbol(this.simpleName), [arg], null, null));
        }
        $[this._jsName] = arg;
      },
      get$isConst: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 5, "isConst"],
      $isVariableMirror: 1,
      $isDeclarationMirror: 1,
      $isMirror: 1,
      static: {
        JsVariableMirror_JsVariableMirror$from: function(descriptor, metadataFunction, owner, isStatic) {
          var fieldInformation, t1, field, $length, t2, code, isFinal, jsName, divider, accessorName, result, unmangledName, setterName, _i;
          fieldInformation = J.split$1$s(descriptor, "-");
          t1 = fieldInformation.length;
          if (t1 === 1)
            return;
          if (0 >= t1)
            return H.ioore(fieldInformation, 0);
          field = fieldInformation[0];
          t1 = J.getInterceptor$asx(field);
          $length = t1.get$length(field);
          t2 = J.getInterceptor$n($length);
          code = H.JsVariableMirror_fieldCode(t1.codeUnitAt$1(field, t2.$sub($length, 1)));
          if (code === 0)
            return;
          isFinal = C.JSInt_methods._shrOtherPositive$1(code, 2) === 0;
          jsName = t1.substring$2(field, 0, t2.$sub($length, 1));
          divider = t1.indexOf$1(field, ":");
          t2 = J.getInterceptor$n(divider);
          if (t2.$gt(divider, 0)) {
            accessorName = C.JSString_methods.substring$2(jsName, 0, divider);
            jsName = t1.substring$1(field, t2.$add(divider, 1));
          } else
            accessorName = jsName;
          if (isStatic) {
            result = $.$get$mangledGlobalNames()._jsMangledNames[accessorName];
            unmangledName = typeof result !== "string" ? null : result;
          } else
            unmangledName = $.$get$mangledNames().$index(0, "get$" + accessorName);
          if (unmangledName == null)
            unmangledName = accessorName;
          if (isFinal) {
            setterName = H.s(H.S(unmangledName) + "=");
            t1 = owner.get$_methods();
            t2 = t1.length;
            _i = 0;
            while (true) {
              if (!(_i < t1.length)) {
                isFinal = true;
                break;
              }
              if (J.$eq$(t1[_i].get$simpleName(), setterName)) {
                isFinal = false;
                break;
              }
              t1.length === t2 || (0, H.throwConcurrentModificationError)(t1);
              ++_i;
            }
          }
          if (1 >= fieldInformation.length)
            return H.ioore(fieldInformation, 1);
          return new H.JsVariableMirror(jsName, isFinal, isStatic, metadataFunction, owner, H.Primitives_parseInt(fieldInformation[1], null, new H.closure()), null, H.s(unmangledName));
        },
        JsVariableMirror_fieldCode: function(code) {
          if (code >= 60 && code <= 64)
            return code - 59;
          if (code >= 123 && code <= 126)
            return code - 117;
          if (code >= 37 && code <= 43)
            return code - 27;
          return 0;
        }
      }
    },
    "+JsVariableMirror": 0,
    closure: {
      "^": "Closure:3;",
      call$1: [function(_) {
        return;
      }, null, null, 2, 0, null, 16, [], "call"]
    },
    "+ closure": 0,
    JsClosureMirror: {
      "^": "JsInstanceMirror;reflectee-,_getterCache",
      get$$function: [function() {
        var cacheName, t1, callName, t2, parameterCount, target, $name, cachedFunction;
        cacheName = $.Primitives_mirrorFunctionCacheName;
        t1 = this.reflectee;
        callName = function(reflectee, callPrefix) {
          var properties = Object.keys(reflectee.constructor.prototype);
          var callPrefixLength = callPrefix.length;
          for (var i = 0; i < properties.length; i++) {
            var property = properties[i];
            if (callPrefix == property.substring(0, callPrefixLength) && property[callPrefixLength] >= "0" && property[callPrefixLength] <= "9")
              return property;
          }
          return null;
        }(t1, "call" + "$");
        if (callName == null)
          throw H.wrapException(new H.RuntimeError('Cannot find callName on "' + H.S(t1) + '"'));
        t2 = callName.split("$");
        if (1 >= t2.length)
          return H.ioore(t2, 1);
        parameterCount = H.Primitives_parseInt(t2[1], null, null);
        if (t1 instanceof H.BoundClosure) {
          target = t1._target;
          H.BoundClosure_selfOf(t1);
          $name = $.$get$mangledNames().$index(0, t1._name);
          if ($name == null)
            H.throwInvalidReflectionError($name);
          cachedFunction = H.JsMethodMirror_JsMethodMirror$fromUnmangledName($name, target, false, false);
        } else
          cachedFunction = new H.JsMethodMirror(t1[callName], parameterCount, 0, false, false, true, false, false, null, null, null, null, H.s(callName));
        t1.constructor[cacheName] = cachedFunction;
        return cachedFunction;
      }, null, null, 1, 0, 295, "function"],
      apply$2: [function(positionalArguments, namedArguments) {
        var t1, t2;
        t1 = this.reflectee;
        t2 = namedArguments == null ? null : P.Function__toMangledNames(namedArguments);
        return H.reflect(t2 == null ? H.Primitives_applyFunctionWithPositionalArguments(t1, positionalArguments) : H.Primitives_applyFunctionWithNamedArguments(t1, positionalArguments, t2));
      }, function(positionalArguments) {
        return this.apply$2(positionalArguments, null);
      }, "apply$1", "call$2", "call$1", "get$apply", 2, 2, 1273, 0, 77, [], 74, [], "apply"],
      get$type: [function() {
        var t1, functionRti;
        t1 = this.reflectee;
        if (t1 instanceof H.Closure) {
          functionRti = H.extractFunctionTypeObjectFrom(t1);
          if (functionRti != null)
            return new H.JsFunctionTypeMirror(functionRti, null, null, null, null, null);
        }
        return H.JsInstanceMirror.prototype.get$type.call(this);
      }, null, null, 1, 0, 53, "type"],
      toString$0: [function(_) {
        return "ClosureMirror on '" + H.S(P.Error_safeToString(this.reflectee)) + "'";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      get$source: function() {
        return H.throwExpression(new P.UnimplementedError(null));
      },
      $isInstanceMirror: 1,
      $isMirror: 1
    },
    "+JsClosureMirror": 0,
    JsMethodMirror: {
      "^": "JsDeclarationMirror;_jsFunction<,_requiredParameterCount,_optionalParameterCount,isGetter<-,isSetter<-,isStatic<-,isConstructor<-,isOperator<-,_owner,_metadata,_returnType,_parameters,simpleName-",
      get$_prettyName: function() {
        return "MethodMirror";
      },
      get$parameters: [function() {
        var t1 = this._parameters;
        if (t1 != null)
          return t1;
        this.get$metadata();
        return this._parameters;
      }, null, null, 1, 0, 296, "parameters"],
      canInvokeReflectively$0: function() {
        return "$reflectable" in this._jsFunction;
      },
      get$owner: [function() {
        return this._owner;
      }, null, null, 1, 0, 125, "owner"],
      get$returnType: [function() {
        this.get$metadata();
        return this._returnType;
      }, null, null, 1, 0, 53, "returnType"],
      get$metadata: [function() {
        var t1, raw, t2, formals, info, functionType, type, isNamed, t3, t4, t5, i, parameter, $name, result, p, defaultValue, i0;
        t1 = this._metadata;
        if (t1 == null) {
          t1 = this._jsFunction;
          raw = H.extractMetadata(t1);
          t2 = J.$add$ns(this._requiredParameterCount, this._optionalParameterCount);
          if (typeof t2 !== "number")
            return H.iae(t2);
          formals = new Array(t2);
          formals.fixed$length = Array;
          info = H.ReflectionInfo_ReflectionInfo(t1);
          if (info != null) {
            functionType = info.functionType;
            if (typeof functionType === "number" && Math.floor(functionType) === functionType)
              type = new H.JsFunctionTypeMirror(info.computeFunctionRti$1(null), null, null, null, null, this);
            else
              type = this.get$owner() != null && !!J.getInterceptor(this.get$owner()).$isLibraryMirror ? new H.JsFunctionTypeMirror(info.computeFunctionRti$1(null), null, null, null, null, this._owner) : new H.JsFunctionTypeMirror(info.computeFunctionRti$1(this._owner.get$originalDeclaration().get$_jsConstructor()), null, null, null, null, this._owner);
            if (this.isConstructor === true)
              this._returnType = this._owner;
            else
              this._returnType = type.get$returnType();
            isNamed = info.areOptionalParametersNamed;
            for (t1 = type.get$parameters(), t1 = new H.ListIterator(t1, t1.get$length(t1), 0, null, [H.getRuntimeTypeArgument(t1, "ListMixin", 0)]), t2 = formals.length, t3 = info.requiredParameterCount, t4 = info.data, t5 = info.optionalParameterCount, i = 0; t1.moveNext$0(); i = i0) {
              parameter = t1.__internal$_current;
              $name = info.parameterName$1(i);
              result = t4[2 * i + t5 + 3 + 1];
              if (i < t3)
                p = new H.JsParameterMirror(this, parameter.get$_type(), false, false, null, result, H.s($name));
              else {
                defaultValue = info.defaultValue$1(i);
                p = new H.JsParameterMirror(this, parameter.get$_type(), true, isNamed, defaultValue, result, H.s($name));
              }
              i0 = i + 1;
              if (i >= t2)
                return H.ioore(formals, i);
              formals[i] = p;
            }
          }
          this._parameters = new P.UnmodifiableListView(formals, [P.ParameterMirror]);
          t1 = new P.UnmodifiableListView(J.map$1$ax(raw, H._js_mirrors__reflect$closure()), [null]);
          this._metadata = t1;
        }
        return t1;
      }, null, null, 1, 0, 59, "metadata"],
      get$constructorName: [function() {
        var $name, t1, index, t2;
        if (this.isConstructor !== true)
          return C.Symbol_0c4;
        $name = this.simpleName.get$__internal$_name();
        t1 = J.getInterceptor$asx($name);
        index = t1.indexOf$1($name, ".");
        t2 = J.getInterceptor(index);
        if (t2.$eq(index, -1))
          return C.Symbol_0c4;
        return H.s(t1.substring$1($name, t2.$add(index, 1)));
      }, null, null, 1, 0, 45, "constructorName"],
      _invoke$2: function(positionalArguments, namedArguments) {
        var t1, positionalLength, t2, t3, i;
        if (namedArguments != null && J.get$isEmpty$asx(namedArguments) !== true)
          throw H.wrapException(new P.UnsupportedError("Named arguments are not implemented."));
        if (this.isStatic !== true && this.isConstructor !== true)
          throw H.wrapException(new H.RuntimeError("Cannot invoke instance method without receiver."));
        t1 = J.getInterceptor$asx(positionalArguments);
        positionalLength = t1.get$length(positionalArguments);
        t2 = this._requiredParameterCount;
        t3 = J.getInterceptor$n(positionalLength);
        if (t3.$lt(positionalLength, t2) || t3.$gt(positionalLength, J.$add$ns(t2, this._optionalParameterCount)) || this._jsFunction == null)
          throw H.wrapException(P.NoSuchMethodError$(this.get$owner(), this.simpleName, positionalArguments, namedArguments, null));
        if (t3.$lt(positionalLength, J.$add$ns(t2, this._optionalParameterCount))) {
          positionalArguments = t1.toList$0(positionalArguments);
          for (t1 = J.getInterceptor$ax(positionalArguments), i = positionalLength; t2 = J.getInterceptor$n(i), t2.$lt(i, J.get$length$asx(this.get$parameters()._collection$_source)); i = t2.$add(i, 1))
            t1.add$1(positionalArguments, J.elementAt$1$ax(this.get$parameters()._collection$_source, i).get$defaultValue().get$reflectee());
        }
        return this._jsFunction.apply($, P.List_List$from(positionalArguments, true, null));
      },
      _getField$1: function(receiver) {
        if (this.isGetter === true)
          return this._invoke$2([], null);
        else
          throw H.wrapException(new P.UnimplementedError("getField on " + receiver.toString$0(0)));
      },
      _setField$2: function(receiver, arg) {
        if (this.isSetter === true)
          return this._invoke$2([arg], null);
        else
          throw H.wrapException(P.NoSuchMethodError$(this, H.setterSymbol(this.simpleName), [], null, null));
      },
      get$isAbstract: [function() {
        return false;
      }, null, null, 1, 0, 5, "isAbstract"],
      get$isSynthetic: [function() {
        return false;
      }, null, null, 1, 0, 5, "isSynthetic"],
      get$isRegularMethod: [function() {
        return this.isGetter !== true && this.isSetter !== true && this.isConstructor !== true;
      }, null, null, 1, 0, 5, "isRegularMethod"],
      get$isConstConstructor: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 5, "isConstConstructor"],
      get$isGenerativeConstructor: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 5, "isGenerativeConstructor"],
      get$isRedirectingConstructor: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 5, "isRedirectingConstructor"],
      get$isFactoryConstructor: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 5, "isFactoryConstructor"],
      get$source: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 7, "source"],
      $isMirror: 1,
      $isMethodMirror: 1,
      $isDeclarationMirror: 1,
      static: {
        JsMethodMirror_JsMethodMirror$fromUnmangledName: function($name, jsFunction, isStatic, isConstructor) {
          var info, isOperator, isSetter, requiredParameterCount, isGetter, optionalParameterCount, reflectionInfo;
          info = $name.split(":");
          if (0 >= info.length)
            return H.ioore(info, 0);
          $name = info[0];
          isOperator = H.isOperatorName($name);
          isSetter = !isOperator && J.endsWith$1$s($name, "=");
          if (info.length === 1) {
            if (isSetter) {
              requiredParameterCount = 1;
              isGetter = false;
            } else {
              requiredParameterCount = 0;
              isGetter = true;
            }
            optionalParameterCount = 0;
          } else {
            reflectionInfo = H.ReflectionInfo_ReflectionInfo(jsFunction);
            requiredParameterCount = reflectionInfo.requiredParameterCount;
            optionalParameterCount = reflectionInfo.optionalParameterCount;
            isGetter = false;
          }
          return new H.JsMethodMirror(jsFunction, requiredParameterCount, optionalParameterCount, isGetter, isSetter, isStatic, isConstructor, isOperator, null, null, null, null, H.s($name));
        }
      }
    },
    "+JsMethodMirror": 0,
    JsParameterMirror: {
      "^": "JsDeclarationMirror;owner<-,_type<,isOptional<-,isNamed<-,_defaultValue,metadataList,simpleName-",
      get$_prettyName: function() {
        return "ParameterMirror";
      },
      get$type: [function() {
        return H.typeMirrorFromRuntimeTypeRepresentation(this.owner, this._type);
      }, null, null, 1, 0, 53, "type"],
      get$isStatic: [function() {
        return false;
      }, null, null, 1, 0, 5, "isStatic"],
      get$isFinal: [function() {
        return false;
      }, null, null, 1, 0, 5, "isFinal"],
      get$isConst: [function() {
        return false;
      }, null, null, 1, 0, 5, "isConst"],
      get$hasDefaultValue: [function() {
        return this._defaultValue != null;
      }, null, null, 1, 0, 5, "hasDefaultValue"],
      get$defaultValue: [function() {
        var t1 = this._defaultValue;
        return t1 != null ? H.reflect(init.metadata[t1]) : null;
      }, null, null, 1, 0, 4, "defaultValue"],
      get$metadata: [function() {
        return J.map$1$ax(this.metadataList, new H.JsParameterMirror_metadata_closure()).toList$0(0);
      }, null, null, 1, 0, 59, "metadata"],
      $isParameterMirror: 1,
      $isVariableMirror: 1,
      $isDeclarationMirror: 1,
      $isMirror: 1
    },
    "+JsParameterMirror": 0,
    JsParameterMirror_metadata_closure: {
      "^": "Closure:22;",
      call$1: [function(i) {
        return H.reflect(init.metadata[i]);
      }, null, null, 2, 0, null, 127, [], "call"]
    },
    "+ JsParameterMirror_metadata_closure": 0,
    JsTypedefMirror: {
      "^": "JsDeclarationMirror;_mangledName<,referent@-,simpleName-",
      get$value: function() {
        return this.referent;
      },
      get$_prettyName: function() {
        return "TypedefMirror";
      },
      get$hasReflectedType: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 5, "hasReflectedType"],
      get$reflectedType: [function() {
        return new H.TypeImpl(this._mangledName, null);
      }, null, null, 1, 0, 20, "reflectedType"],
      get$typeVariables: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 130, "typeVariables"],
      get$typeArguments: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 131, "typeArguments"],
      get$isOriginalDeclaration: [function() {
        return true;
      }, null, null, 1, 0, 5, "isOriginalDeclaration"],
      get$originalDeclaration: [function() {
        return this;
      }, null, null, 1, 0, 53, "originalDeclaration"],
      get$owner: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 125, "owner"],
      get$metadata: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 59, "metadata"],
      isSubtypeOf$1: [function(other) {
        return H.throwExpression(new P.UnimplementedError(null));
      }, "call$1", "get$isSubtypeOf", 2, 0, 54, 2, [], "isSubtypeOf"],
      isAssignableTo$1: [function(other) {
        return H.throwExpression(new P.UnimplementedError(null));
      }, "call$1", "get$isAssignableTo", 2, 0, 54, 2, [], "isAssignableTo"],
      value$1: function(arg0) {
        return this.get$value().call$1(arg0);
      },
      $isTypedefMirror: 1,
      $isTypeMirror: 1,
      $isDeclarationMirror: 1,
      $isMirror: 1
    },
    "+JsTypedefMirror": 0,
    BrokenClassMirror: {
      "^": "Object;",
      get$hasReflectedType: function() {
        return H.throwExpression(new P.UnimplementedError(null));
      },
      get$reflectedType: function() {
        return H.throwExpression(new P.UnimplementedError(null));
      },
      get$superclass: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 56, "superclass"],
      get$superinterfaces: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 178, "superinterfaces"],
      get$declarations: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 132, "declarations"],
      get$instanceMembers: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 88, "instanceMembers"],
      get$staticMembers: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 88, "staticMembers"],
      get$mixin: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 56, "mixin"],
      newInstance$3: [function(constructorName, positionalArguments, namedArguments) {
        return H.throwExpression(new P.UnimplementedError(null));
      }, function(constructorName, positionalArguments) {
        return this.newInstance$3(constructorName, positionalArguments, null);
      }, "newInstance$2", "call$3", "call$2", "get$newInstance", 4, 2, 63, 0, 240, [], 77, [], 74, [], "newInstance"],
      invoke$3: [function(memberName, positionalArguments, namedArguments) {
        return H.throwExpression(new P.UnimplementedError(null));
      }, function(memberName, positionalArguments) {
        return this.invoke$3(memberName, positionalArguments, null);
      }, "invoke$2", "call$3", "call$2", "get$invoke", 4, 2, 63, 0, 146, [], 77, [], 74, [], "invoke"],
      getField$1: [function(fieldName) {
        return H.throwExpression(new P.UnimplementedError(null));
      }, "call$1", "get$getField", 2, 0, 112, 83, [], "getField"],
      setField$2: [function(fieldName, value) {
        return H.throwExpression(new P.UnimplementedError(null));
      }, "call$2", "get$setField", 4, 0, 108, 83, [], 1, [], "setField"],
      delegate$1: [function(invocation) {
        return H.throwExpression(new P.UnimplementedError(null));
      }, "call$1", "get$delegate", 2, 0, 77, 118, [], "delegate"],
      get$typeVariables: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 130, "typeVariables"],
      get$typeArguments: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 131, "typeArguments"],
      get$originalDeclaration: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 53, "originalDeclaration"],
      get$simpleName: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 45, "simpleName"],
      get$qualifiedName: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 45, "qualifiedName"],
      get$isPrivate: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 5, "isPrivate"],
      get$isTopLevel: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 5, "isTopLevel"],
      get$location: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 123, "location"],
      get$metadata: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 59, "metadata"]
    },
    "+BrokenClassMirror": 0,
    JsFunctionTypeMirror: {
      "^": "BrokenClassMirror;_typeData,_cachedToString,_cachedReturnType,_cachedParameters,_cachedReflectedType,owner@-",
      get$isOriginalDeclaration: [function() {
        return true;
      }, null, null, 1, 0, 5, "isOriginalDeclaration"],
      get$isAbstract: [function() {
        return false;
      }, null, null, 1, 0, 5, "isAbstract"],
      get$isEnum: [function() {
        return false;
      }, null, null, 1, 0, 5, "isEnum"],
      get$returnType: [function() {
        var t1 = this._cachedReturnType;
        if (t1 != null)
          return t1;
        t1 = this._typeData;
        if (!!t1.v) {
          t1 = $.$get$JsMirrorSystem__voidType();
          this._cachedReturnType = t1;
          return t1;
        }
        if (!("ret" in t1)) {
          t1 = $.$get$JsMirrorSystem__dynamicType();
          this._cachedReturnType = t1;
          return t1;
        }
        t1 = H.typeMirrorFromRuntimeTypeRepresentation(this.owner, t1.ret);
        this._cachedReturnType = t1;
        return t1;
      }, null, null, 1, 0, 53, "returnType"],
      get$parameters: [function() {
        var t1, result, t2, t3, parameterCount, _i, parameterCount0, $name;
        t1 = this._cachedParameters;
        if (t1 != null)
          return t1;
        result = [];
        t1 = this._typeData;
        if ("args" in t1)
          for (t2 = t1.args, t3 = t2.length, parameterCount = 0, _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i, parameterCount = parameterCount0) {
            parameterCount0 = parameterCount + 1;
            result.push(new H.JsParameterMirror(this, t2[_i], false, false, null, C.List_empty3, H.s("argument" + parameterCount)));
          }
        else
          parameterCount = 0;
        if ("opt" in t1)
          for (t2 = t1.opt, t3 = t2.length, _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i, parameterCount = parameterCount0) {
            parameterCount0 = parameterCount + 1;
            result.push(new H.JsParameterMirror(this, t2[_i], false, false, null, C.List_empty3, H.s("argument" + parameterCount)));
          }
        if ("named" in t1)
          for (t2 = H.extractKeys(t1.named), t3 = t2.length, _i = 0; _i < t3; ++_i) {
            $name = t2[_i];
            result.push(new H.JsParameterMirror(this, t1.named[$name], false, false, null, C.List_empty3, H.s($name)));
          }
        t1 = new P.UnmodifiableListView(result, [P.ParameterMirror]);
        this._cachedParameters = t1;
        return t1;
      }, null, null, 1, 0, 296, "parameters"],
      get$hasReflectedType: [function() {
        return true;
      }, null, null, 1, 0, 5, "hasReflectedType"],
      get$reflectedType: [function() {
        var t1 = this._cachedReflectedType;
        if (t1 == null) {
          t1 = new H.TypeImpl(H.runtimeTypeToString(this._typeData, null), null);
          this._cachedReflectedType = t1;
        }
        return t1;
      }, null, null, 1, 0, 20, "reflectedType"],
      _unmangleIfPreserved$1: function(mangled) {
        var result = init.mangledGlobalNames[mangled];
        if (result != null)
          return result;
        return mangled;
      },
      toString$0: [function(_) {
        var t1, t2, t3, s, sep, _i, argument, $name;
        t1 = this._cachedToString;
        if (t1 != null)
          return t1;
        t1 = this._typeData;
        if ("args" in t1)
          for (t2 = t1.args, t3 = t2.length, s = "FunctionTypeMirror on '(", sep = "", _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i, sep = ", ") {
            argument = t2[_i];
            s = C.JSString_methods.$add(s + sep, this._unmangleIfPreserved$1(H.runtimeTypeToString(argument, null)));
          }
        else {
          s = "FunctionTypeMirror on '(";
          sep = "";
        }
        if ("opt" in t1) {
          s += sep + "[";
          for (t2 = t1.opt, t3 = t2.length, sep = "", _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i, sep = ", ") {
            argument = t2[_i];
            s = C.JSString_methods.$add(s + sep, this._unmangleIfPreserved$1(H.runtimeTypeToString(argument, null)));
          }
          s += "]";
        }
        if ("named" in t1) {
          s += sep + "{";
          for (t2 = H.extractKeys(t1.named), t3 = t2.length, sep = "", _i = 0; _i < t3; ++_i, sep = ", ") {
            $name = t2[_i];
            s = C.JSString_methods.$add(s + sep + (H.S($name) + ": "), this._unmangleIfPreserved$1(H.runtimeTypeToString(t1.named[$name], null)));
          }
          s += "}";
        }
        s += ") -> ";
        if (!!t1.v)
          s += "void";
        else
          s = "ret" in t1 ? C.JSString_methods.$add(s, this._unmangleIfPreserved$1(H.runtimeTypeToString(t1.ret, null))) : s + "dynamic";
        t1 = s + "'";
        this._cachedToString = t1;
        return t1;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      isSubclassOf$1: [function(other) {
        return false;
      }, "call$1", "get$isSubclassOf", 2, 0, 190, 2, [], "isSubclassOf"],
      isSubtypeOf$1: [function(other) {
        return H.throwExpression(new P.UnimplementedError(null));
      }, "call$1", "get$isSubtypeOf", 2, 0, 54, 2, [], "isSubtypeOf"],
      isAssignableTo$1: [function(other) {
        return H.throwExpression(new P.UnimplementedError(null));
      }, "call$1", "get$isAssignableTo", 2, 0, 54, 2, [], "isAssignableTo"],
      get$callMethod: [function() {
        return H.throwExpression(new P.UnimplementedError(null));
      }, null, null, 1, 0, 295, "callMethod"],
      $isClassMirror: 1,
      $isMirror: 1,
      $isTypeMirror: 1,
      $isDeclarationMirror: 1
    },
    "+JsFunctionTypeMirror": 0,
    typeMirrorFromRuntimeTypeRepresentation_getTypeArgument: {
      "^": "Closure:457;_box_0",
      call$1: [function(index) {
        var typeVariable, t1, variableIndex;
        typeVariable = init.metadata[index];
        t1 = this._box_0;
        variableIndex = H.findTypeVariableIndex(t1.ownerClass.get$typeVariables(), typeVariable.get$name());
        return J.$index$asx(t1.ownerClass.get$typeArguments(), variableIndex);
      }, null, null, 2, 0, 457, 14, [], "call"]
    },
    "+ typeMirrorFromRuntimeTypeRepresentation_getTypeArgument": [2],
    typeMirrorFromRuntimeTypeRepresentation_substituteTypeVariable: {
      "^": "Closure:25;getTypeArgument",
      call$1: [function(index) {
        var typeArgument, t1;
        typeArgument = this.getTypeArgument.call$1(index);
        t1 = J.getInterceptor(typeArgument);
        if (!!t1.$isJsTypeVariableMirror)
          return H.S(typeArgument._metadataIndex);
        if (!t1.$isJsClassMirror && !t1.$isJsTypeBoundClassMirror)
          if (t1.$eq(typeArgument, $.$get$JsMirrorSystem__dynamicType()))
            return "dynamic";
          else if (t1.$eq(typeArgument, $.$get$JsMirrorSystem__voidType()))
            return "void";
          else
            return "dynamic";
        return typeArgument.get$_mangledName();
      }, null, null, 2, 0, 25, 14, [], "call"]
    },
    "+ typeMirrorFromRuntimeTypeRepresentation_substituteTypeVariable": [2],
    extractMetadata_closure: {
      "^": "Closure:22;",
      call$1: [function(i) {
        return init.metadata[i];
      }, null, null, 2, 0, 22, 127, [], "call"]
    },
    "+ extractMetadata_closure": [2],
    NoSuchStaticMethodError: {
      "^": "Error;_cls,__js_mirrors$_name,_positionalArguments,__js_mirrors$_namedArguments,_kind",
      toString$0: [function(_) {
        switch (this._kind) {
          case 0:
            return "NoSuchMethodError: No constructor named '" + H.S(this.__js_mirrors$_name.get$__internal$_name()) + "' in class '" + H.S(this._cls.get$qualifiedName().get$__internal$_name()) + "'.";
          case 1:
            return "NoSuchMethodError: No top-level method named '" + H.S(this.__js_mirrors$_name.get$__internal$_name()) + "'.";
          default:
            return "NoSuchMethodError";
        }
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isNoSuchMethodError: 1,
      static: {
        NoSuchStaticMethodError$method: function(_cls, _name, _positionalArguments, _namedArguments) {
          return new H.NoSuchStaticMethodError(_cls, _name, _positionalArguments, _namedArguments, 1);
        }
      }
    },
    "+NoSuchStaticMethodError": 0
  }], ["dart._js_names", "dart:_js_names",, H, {
    "^": "",
    preserveNames: function() {
    },
    extractKeys: function(victim) {
      var t1 = H.setRuntimeTypeInfo(victim ? Object.keys(victim) : [], [null]);
      t1.fixed$length = Array;
      return t1;
    },
    unmangleGlobalNameIfPreservedAnyways: function($name) {
      return init.mangledGlobalNames[$name];
    },
    unmangleAllIdentifiersIfPreservedAnyways: function(str) {
      return function(str, names) {
        return str.replace(/[^<,> ]+/g, function(m) {
          return names[m] || m;
        });
      }(str, init.mangledGlobalNames);
    },
    _LazyMangledNamesMap: {
      "^": "Object;_jsMangledNames",
      $index: ["super$_LazyMangledNamesMap$$index", function(_, key) {
        var result = this._jsMangledNames[key];
        return typeof result !== "string" ? null : result;
      }]
    },
    "+_LazyMangledNamesMap": 0,
    _LazyMangledInstanceNamesMap: {
      "^": "_LazyMangledNamesMap;_jsMangledNames",
      $index: function(_, key) {
        var result = this.super$_LazyMangledNamesMap$$index(0, key);
        if (result == null && J.startsWith$1$s(key, "set$")) {
          result = this.super$_LazyMangledNamesMap$$index(0, "get$" + J.substring$1$s(key, "set$".length));
          return result != null ? result + "=" : null;
        }
        return result;
      }
    },
    "+_LazyMangledInstanceNamesMap": 0,
    _LazyReflectiveNamesMap: {
      "^": "Object;_jsMangledNames,_isInstance,_cacheLength,_cache",
      _updateReflectiveNames$0: function() {
        var t1, result, t2, t3, getterPrefixLength, key, reflectiveName;
        t1 = P.String;
        result = P.LinkedHashMap_LinkedHashMap$_empty(t1, t1);
        t1 = this._jsMangledNames;
        for (t2 = J.get$iterator$ax(Object.keys(t1)), t3 = this._isInstance, getterPrefixLength = "get$".length; t2.moveNext$0();) {
          key = t2.get$current();
          reflectiveName = t1[key];
          if (typeof reflectiveName !== "string")
            continue;
          result.$indexSet(0, reflectiveName, key);
          if (t3 && J.startsWith$1$s(key, "get$"))
            result.$indexSet(0, H.S(reflectiveName) + "=", "set$" + J.substring$1$s(key, getterPrefixLength));
        }
        return result;
      },
      $index: function(_, key) {
        if (this._cache == null || Object.keys(this._jsMangledNames).length !== this._cacheLength) {
          this._cache = this._updateReflectiveNames$0();
          this._cacheLength = Object.keys(this._jsMangledNames).length;
        }
        return this._cache.$index(0, key);
      }
    },
    "+_LazyReflectiveNamesMap": 0
  }], ["dart2js._js_primitives", "dart:_js_primitives",, H, {
    "^": "",
    printString: function(string) {
      if (typeof dartPrint == "function") {
        dartPrint(string);
        return;
      }
      if (typeof console == "object" && typeof console.log != "undefined") {
        console.log(string);
        return;
      }
      if (typeof window == "object")
        return;
      if (typeof print == "function") {
        print(string);
        return;
      }
      throw "Unable to print message: " + String(string);
    }
  }], ["dart.typed_data.implementation", "dart:_native_typed_data",, H, {
    "^": "",
    _checkLength: function($length) {
      if (typeof $length !== "number" || Math.floor($length) !== $length)
        throw H.wrapException(P.ArgumentError$("Invalid length " + H.S($length)));
      return $length;
    },
    _checkViewArguments: function(buffer, offsetInBytes, $length) {
      if (typeof offsetInBytes !== "number" || Math.floor(offsetInBytes) !== offsetInBytes)
        throw H.wrapException(P.ArgumentError$("Invalid view offsetInBytes " + H.S(offsetInBytes)));
      if ($length != null && (typeof $length !== "number" || Math.floor($length) !== $length))
        throw H.wrapException(P.ArgumentError$("Invalid view length " + H.S($length)));
    },
    _ensureNativeList: function(list) {
      var t1, t2, result, i, t3;
      t1 = J.getInterceptor(list);
      if (!!t1.$isJSIndexable)
        return list;
      t2 = t1.get$length(list);
      if (typeof t2 !== "number")
        return H.iae(t2);
      result = new Array(t2);
      result.fixed$length = Array;
      t2 = result.length;
      i = 0;
      while (true) {
        t3 = t1.get$length(list);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        t3 = t1.$index(list, i);
        if (i >= t2)
          return H.ioore(result, i);
        result[i] = t3;
        ++i;
      }
      return result;
    },
    NativeFloat32List_NativeFloat32List: function($length) {
      return new Float32Array(H._checkLength($length));
    },
    NativeFloat32List_NativeFloat32List$view: function(buffer, offsetInBytes, $length) {
      H._checkViewArguments(buffer, offsetInBytes, $length);
      return $length == null ? new Float32Array(buffer, offsetInBytes) : new Float32Array(buffer, offsetInBytes, $length);
    },
    NativeFloat64List_NativeFloat64List: function($length) {
      return new Float64Array(H._checkLength($length));
    },
    NativeFloat64List_NativeFloat64List$view: function(buffer, offsetInBytes, $length) {
      H._checkViewArguments(buffer, offsetInBytes, $length);
      return $length == null ? new Float64Array(buffer, offsetInBytes) : new Float64Array(buffer, offsetInBytes, $length);
    },
    NativeInt32List_NativeInt32List: function($length) {
      return new Int32Array(H._checkLength($length));
    },
    NativeInt32List_NativeInt32List$view: function(buffer, offsetInBytes, $length) {
      H._checkViewArguments(buffer, offsetInBytes, $length);
      return $length == null ? new Int32Array(buffer, offsetInBytes) : new Int32Array(buffer, offsetInBytes, $length);
    },
    NativeInt8List_NativeInt8List$fromList: function(elements) {
      return new Int8Array(H._ensureNativeList(elements));
    },
    NativeUint16List_NativeUint16List$fromList: function(list) {
      return new Uint16Array(H._ensureNativeList(list));
    },
    NativeUint8List_NativeUint8List: function($length) {
      return new Uint8Array(H._checkLength($length));
    },
    _isInvalidArrayIndex: function(index) {
      return index >>> 0 !== index;
    },
    _checkValidIndex: function(index, list, $length) {
      if (index >>> 0 !== index || index >= $length)
        throw H.wrapException(H.diagnoseIndexError(list, index));
    },
    _checkValidRange: function(start, end, $length) {
      var t1;
      if (!(start >>> 0 !== start))
        if (end == null)
          t1 = J.$gt$n(start, $length);
        else
          t1 = end >>> 0 !== end || J.$gt$n(start, end) || J.$gt$n(end, $length);
      else
        t1 = true;
      if (t1)
        throw H.wrapException(H.diagnoseRangeError(start, end, $length));
      if (end == null)
        return $length;
      return end;
    },
    NativeByteBuffer: {
      "^": ["Interceptor;lengthInBytes:byteLength=-", function() {
        return [C.JSName_byteLength];
      }],
      get$runtimeType: [function(receiver) {
        return C.Type_ByteBuffer_RkP;
      }, null, null, 1, 0, 20, "runtimeType"],
      asUint8List$2: [function(receiver, offsetInBytes, $length) {
        H._checkViewArguments(receiver, offsetInBytes, $length);
        return $length == null ? new Uint8Array(receiver, offsetInBytes) : new Uint8Array(receiver, offsetInBytes, $length);
      }, function($receiver, offsetInBytes) {
        return this.asUint8List$2($receiver, offsetInBytes, null);
      }, "asUint8List$1", function($receiver) {
        return this.asUint8List$2($receiver, 0, null);
      }, "asUint8List$0", "call$2", "call$1", "call$0", "get$asUint8List", 0, 4, 1344, 7, 0, 36, [], 15, [], "asUint8List"],
      asInt8List$2: [function(receiver, offsetInBytes, $length) {
        H._checkViewArguments(receiver, offsetInBytes, $length);
        return $length == null ? new Int8Array(receiver, offsetInBytes) : new Int8Array(receiver, offsetInBytes, $length);
      }, function($receiver, offsetInBytes) {
        return this.asInt8List$2($receiver, offsetInBytes, null);
      }, "asInt8List$1", function($receiver) {
        return this.asInt8List$2($receiver, 0, null);
      }, "asInt8List$0", "call$2", "call$1", "call$0", "get$asInt8List", 0, 4, 1352, 7, 0, 36, [], 15, [], "asInt8List"],
      asUint8ClampedList$2: [function(receiver, offsetInBytes, $length) {
        H._checkViewArguments(receiver, offsetInBytes, $length);
        return $length == null ? new Uint8ClampedArray(receiver, offsetInBytes) : new Uint8ClampedArray(receiver, offsetInBytes, $length);
      }, function($receiver, offsetInBytes) {
        return this.asUint8ClampedList$2($receiver, offsetInBytes, null);
      }, "asUint8ClampedList$1", function($receiver) {
        return this.asUint8ClampedList$2($receiver, 0, null);
      }, "asUint8ClampedList$0", "call$2", "call$1", "call$0", "get$asUint8ClampedList", 0, 4, 1354, 7, 0, 36, [], 15, [], "asUint8ClampedList"],
      asUint16List$2: [function(receiver, offsetInBytes, $length) {
        H._checkViewArguments(receiver, offsetInBytes, $length);
        return $length == null ? new Uint16Array(receiver, offsetInBytes) : new Uint16Array(receiver, offsetInBytes, $length);
      }, function($receiver, offsetInBytes) {
        return this.asUint16List$2($receiver, offsetInBytes, null);
      }, "asUint16List$1", function($receiver) {
        return this.asUint16List$2($receiver, 0, null);
      }, "asUint16List$0", "call$2", "call$1", "call$0", "get$asUint16List", 0, 4, 1369, 7, 0, 36, [], 15, [], "asUint16List"],
      asInt16List$2: [function(receiver, offsetInBytes, $length) {
        H._checkViewArguments(receiver, offsetInBytes, $length);
        return $length == null ? new Int16Array(receiver, offsetInBytes) : new Int16Array(receiver, offsetInBytes, $length);
      }, function($receiver, offsetInBytes) {
        return this.asInt16List$2($receiver, offsetInBytes, null);
      }, "asInt16List$1", function($receiver) {
        return this.asInt16List$2($receiver, 0, null);
      }, "asInt16List$0", "call$2", "call$1", "call$0", "get$asInt16List", 0, 4, 1370, 7, 0, 36, [], 15, [], "asInt16List"],
      asUint32List$2: [function(receiver, offsetInBytes, $length) {
        H._checkViewArguments(receiver, offsetInBytes, $length);
        return $length == null ? new Uint32Array(receiver, offsetInBytes) : new Uint32Array(receiver, offsetInBytes, $length);
      }, function($receiver, offsetInBytes) {
        return this.asUint32List$2($receiver, offsetInBytes, null);
      }, "asUint32List$1", function($receiver) {
        return this.asUint32List$2($receiver, 0, null);
      }, "asUint32List$0", "call$2", "call$1", "call$0", "get$asUint32List", 0, 4, 1372, 7, 0, 36, [], 15, [], "asUint32List"],
      asInt32List$2: [function(receiver, offsetInBytes, $length) {
        return H.NativeInt32List_NativeInt32List$view(receiver, offsetInBytes, $length);
      }, function($receiver, offsetInBytes) {
        return this.asInt32List$2($receiver, offsetInBytes, null);
      }, "asInt32List$1", function($receiver) {
        return this.asInt32List$2($receiver, 0, null);
      }, "asInt32List$0", "call$2", "call$1", "call$0", "get$asInt32List", 0, 4, 1377, 7, 0, 36, [], 15, [], "asInt32List"],
      asUint64List$2: [function(receiver, offsetInBytes, $length) {
        throw H.wrapException(new P.UnsupportedError("Uint64List not supported by dart2js."));
      }, function($receiver, offsetInBytes) {
        return this.asUint64List$2($receiver, offsetInBytes, null);
      }, "asUint64List$1", function($receiver) {
        return this.asUint64List$2($receiver, 0, null);
      }, "asUint64List$0", "call$2", "call$1", "call$0", "get$asUint64List", 0, 4, 1381, 7, 0, 36, [], 15, [], "asUint64List"],
      asInt64List$2: [function(receiver, offsetInBytes, $length) {
        throw H.wrapException(new P.UnsupportedError("Int64List not supported by dart2js."));
      }, function($receiver, offsetInBytes) {
        return this.asInt64List$2($receiver, offsetInBytes, null);
      }, "asInt64List$1", function($receiver) {
        return this.asInt64List$2($receiver, 0, null);
      }, "asInt64List$0", "call$2", "call$1", "call$0", "get$asInt64List", 0, 4, 1385, 7, 0, 36, [], 15, [], "asInt64List"],
      asInt32x4List$2: [function(receiver, offsetInBytes, $length) {
        return new H.NativeInt32x4List(H.NativeInt32List_NativeInt32List$view(receiver, offsetInBytes, $length != null ? J.$mul$ns($length, 4) : null));
      }, function($receiver, offsetInBytes) {
        return this.asInt32x4List$2($receiver, offsetInBytes, null);
      }, "asInt32x4List$1", function($receiver) {
        return this.asInt32x4List$2($receiver, 0, null);
      }, "asInt32x4List$0", "call$2", "call$1", "call$0", "get$asInt32x4List", 0, 4, 1414, 7, 0, 36, [], 15, [], "asInt32x4List"],
      asFloat32List$2: [function(receiver, offsetInBytes, $length) {
        return H.NativeFloat32List_NativeFloat32List$view(receiver, offsetInBytes, $length);
      }, function($receiver, offsetInBytes) {
        return this.asFloat32List$2($receiver, offsetInBytes, null);
      }, "asFloat32List$1", function($receiver) {
        return this.asFloat32List$2($receiver, 0, null);
      }, "asFloat32List$0", "call$2", "call$1", "call$0", "get$asFloat32List", 0, 4, 1426, 7, 0, 36, [], 15, [], "asFloat32List"],
      asFloat64List$2: [function(receiver, offsetInBytes, $length) {
        return H.NativeFloat64List_NativeFloat64List$view(receiver, offsetInBytes, $length);
      }, function($receiver, offsetInBytes) {
        return this.asFloat64List$2($receiver, offsetInBytes, null);
      }, "asFloat64List$1", function($receiver) {
        return this.asFloat64List$2($receiver, 0, null);
      }, "asFloat64List$0", "call$2", "call$1", "call$0", "get$asFloat64List", 0, 4, 1428, 7, 0, 36, [], 15, [], "asFloat64List"],
      asFloat32x4List$2: [function(receiver, offsetInBytes, $length) {
        return new H.NativeFloat32x4List(H.NativeFloat32List_NativeFloat32List$view(receiver, offsetInBytes, $length != null ? J.$mul$ns($length, 4) : null));
      }, function($receiver, offsetInBytes) {
        return this.asFloat32x4List$2($receiver, offsetInBytes, null);
      }, "asFloat32x4List$1", function($receiver) {
        return this.asFloat32x4List$2($receiver, 0, null);
      }, "asFloat32x4List$0", "call$2", "call$1", "call$0", "get$asFloat32x4List", 0, 4, 1470, 7, 0, 36, [], 15, [], "asFloat32x4List"],
      asFloat64x2List$2: [function(receiver, offsetInBytes, $length) {
        return new H.NativeFloat64x2List(H.NativeFloat64List_NativeFloat64List$view(receiver, offsetInBytes, $length != null ? J.$mul$ns($length, 2) : null));
      }, function($receiver, offsetInBytes) {
        return this.asFloat64x2List$2($receiver, offsetInBytes, null);
      }, "asFloat64x2List$1", function($receiver) {
        return this.asFloat64x2List$2($receiver, 0, null);
      }, "asFloat64x2List$0", "call$2", "call$1", "call$0", "get$asFloat64x2List", 0, 4, 1492, 7, 0, 36, [], 15, [], "asFloat64x2List"],
      asByteData$2: [function(receiver, offsetInBytes, $length) {
        H._checkViewArguments(receiver, offsetInBytes, $length);
        return $length == null ? new DataView(receiver, offsetInBytes) : new DataView(receiver, offsetInBytes, $length);
      }, function($receiver, offsetInBytes) {
        return this.asByteData$2($receiver, offsetInBytes, null);
      }, "asByteData$1", function($receiver) {
        return this.asByteData$2($receiver, 0, null);
      }, "asByteData$0", "call$2", "call$1", "call$0", "get$asByteData", 0, 4, 1494, 7, 0, 36, [], 15, [], "asByteData"],
      $isNativeByteBuffer: 1,
      $isObject: 1,
      "%": "ArrayBuffer",
      "@": function() {
        return [C.Native_ArrayBuffer];
      }
    },
    "+NativeByteBuffer": 0,
    NativeFloat32x4List: {
      "^": "Object_ListMixin_FixedLengthListMixin;_storage",
      get$runtimeType: [function(_) {
        return C.Type_Float32x4List_0ez;
      }, null, null, 1, 0, 20, "runtimeType"],
      get$buffer: [function(_) {
        return this._storage.buffer;
      }, null, null, 1, 0, 169, "buffer"],
      get$lengthInBytes: [function(_) {
        return this._storage.byteLength;
      }, null, null, 1, 0, 11, "lengthInBytes"],
      get$offsetInBytes: [function(_) {
        return this._storage.byteOffset;
      }, null, null, 1, 0, 11, "offsetInBytes"],
      get$elementSizeInBytes: [function(_) {
        return 16;
      }, null, null, 1, 0, 11, "elementSizeInBytes"],
      get$length: [function(_) {
        return this._storage.length / 4 | 0;
      }, null, null, 1, 0, 11, "length"],
      $index: [function(_, index) {
        var t1, t2, t3, t4, _x, _y, _z;
        t1 = this._storage;
        t2 = t1.length;
        if (index >>> 0 !== index || index >= (t2 / 4 | 0))
          H.throwExpression(H.diagnoseIndexError(this, index));
        t3 = J.getInterceptor$ns(index);
        t4 = J.$add$ns(t3.$mul(index, 4), 0);
        if (t4 >>> 0 !== t4 || t4 >= t2)
          return H.ioore(t1, t4);
        _x = t1[t4];
        t4 = J.$add$ns(t3.$mul(index, 4), 1);
        if (t4 >>> 0 !== t4 || t4 >= t2)
          return H.ioore(t1, t4);
        _y = t1[t4];
        t4 = J.$add$ns(t3.$mul(index, 4), 2);
        if (t4 >>> 0 !== t4 || t4 >= t2)
          return H.ioore(t1, t4);
        _z = t1[t4];
        t3 = J.$add$ns(t3.$mul(index, 4), 3);
        if (t3 >>> 0 !== t3 || t3 >= t2)
          return H.ioore(t1, t3);
        return new H.NativeFloat32x4(_x, _y, _z, t1[t3]);
      }, null, "get$[]", 2, 0, 496, 14, [], "[]"],
      $indexSet: [function(_, index, value) {
        var t1, t2, t3, t4, t5;
        t1 = this._storage;
        t2 = t1.length;
        if (index >>> 0 !== index || index >= (t2 / 4 | 0))
          H.throwExpression(H.diagnoseIndexError(this, index));
        t3 = J.getInterceptor$ns(index);
        t4 = J.$add$ns(t3.$mul(index, 4), 0);
        t5 = value.get$x();
        if (t4 >>> 0 !== t4 || t4 >= t2)
          return H.ioore(t1, t4);
        t1[t4] = t5;
        t5 = J.$add$ns(t3.$mul(index, 4), 1);
        t4 = value.get$y();
        if (t5 >>> 0 !== t5 || t5 >= t2)
          return H.ioore(t1, t5);
        t1[t5] = t4;
        t4 = J.$add$ns(t3.$mul(index, 4), 2);
        t5 = value.get$z();
        if (t4 >>> 0 !== t4 || t4 >= t2)
          return H.ioore(t1, t4);
        t1[t4] = t5;
        t3 = J.$add$ns(t3.$mul(index, 4), 3);
        t5 = value.get$w();
        if (t3 >>> 0 !== t3 || t3 >= t2)
          return H.ioore(t1, t3);
        t1[t3] = t5;
      }, null, "get$[]=", 4, 0, 1519, 14, [], 1, [], "[]="],
      sublist$2: [function(_, start, end) {
        var t1 = this._storage;
        end = H._checkValidRange(start, end, t1.length / 4 | 0);
        return new H.NativeFloat32x4List(C.NativeFloat32List_methods.sublist$2(t1, J.$mul$ns(start, 4), J.$mul$ns(end, 4)));
      }, function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      }, "sublist$1", "call$2", "call$1", "get$sublist", 2, 2, 1524, 0, 3, [], 5, [], "sublist"],
      NativeFloat32x4List$_slowFromList$1: function(list) {
        var t1, t2, t3, i, t4, e, t5, t6;
        t1 = J.getInterceptor$asx(list);
        t2 = this._storage;
        t3 = t2.length;
        i = 0;
        while (true) {
          t4 = t1.get$length(list);
          if (typeof t4 !== "number")
            return H.iae(t4);
          if (!(i < t4))
            break;
          e = t1.$index(list, i);
          t4 = i * 4;
          t5 = e.get$x();
          if (t4 >= t3)
            return H.ioore(t2, t4);
          t2[t4] = t5;
          t5 = t4 + 1;
          t6 = e.get$y();
          if (t5 >= t3)
            return H.ioore(t2, t5);
          t2[t5] = t6;
          t6 = t4 + 2;
          t5 = e.get$z();
          if (t6 >= t3)
            return H.ioore(t2, t6);
          t2[t6] = t5;
          t4 += 3;
          t5 = e.get$w();
          if (t4 >= t3)
            return H.ioore(t2, t4);
          t2[t4] = t5;
          ++i;
        }
      },
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $isList: 1,
      $asList: function() {
        return [P.Float32x4];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Float32x4];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Float32x4];
      },
      static: {
        NativeFloat32x4List$_slowFromList: function(list) {
          var t1 = new H.NativeFloat32x4List(new Float32Array(H._checkLength(J.$mul$ns(J.get$length$asx(list), 4))));
          t1.NativeFloat32x4List$_slowFromList$1(list);
          return t1;
        },
        NativeFloat32x4List_NativeFloat32x4List$fromList: function(list) {
          if (list instanceof H.NativeFloat32x4List)
            return new H.NativeFloat32x4List(new Float32Array(H._ensureNativeList(list._storage)));
          else
            return H.NativeFloat32x4List$_slowFromList(list);
        }
      }
    },
    "+NativeFloat32x4List": 0,
    Object_ListMixin0: {
      "^": "Object+ListMixin;",
      $asList: function() {
        return [P.Float32x4];
      },
      $asEfficientLengthIterable: function() {
        return [P.Float32x4];
      },
      $asIterable: function() {
        return [P.Float32x4];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1,
      $isIterable: 1
    },
    Object_ListMixin_FixedLengthListMixin: {
      "^": "Object_ListMixin0+FixedLengthListMixin;",
      $asList: function() {
        return [P.Float32x4];
      },
      $asEfficientLengthIterable: function() {
        return [P.Float32x4];
      },
      $asIterable: function() {
        return [P.Float32x4];
      }
    },
    NativeInt32x4List: {
      "^": "Object_ListMixin_FixedLengthListMixin0;_storage",
      get$runtimeType: [function(_) {
        return C.Type_Int32x4List_pCi;
      }, null, null, 1, 0, 20, "runtimeType"],
      get$buffer: [function(_) {
        return this._storage.buffer;
      }, null, null, 1, 0, 169, "buffer"],
      get$lengthInBytes: [function(_) {
        return this._storage.byteLength;
      }, null, null, 1, 0, 11, "lengthInBytes"],
      get$offsetInBytes: [function(_) {
        return this._storage.byteOffset;
      }, null, null, 1, 0, 11, "offsetInBytes"],
      get$elementSizeInBytes: [function(_) {
        return 16;
      }, null, null, 1, 0, 11, "elementSizeInBytes"],
      get$length: [function(_) {
        return this._storage.length / 4 | 0;
      }, null, null, 1, 0, 11, "length"],
      $index: [function(_, index) {
        var t1, t2, t3, t4, _x, _y, _z;
        t1 = this._storage;
        t2 = t1.length;
        if (index >>> 0 !== index || index >= (t2 / 4 | 0))
          H.throwExpression(H.diagnoseIndexError(this, index));
        t3 = J.getInterceptor$ns(index);
        t4 = J.$add$ns(t3.$mul(index, 4), 0);
        if (t4 >>> 0 !== t4 || t4 >= t2)
          return H.ioore(t1, t4);
        _x = t1[t4];
        t4 = J.$add$ns(t3.$mul(index, 4), 1);
        if (t4 >>> 0 !== t4 || t4 >= t2)
          return H.ioore(t1, t4);
        _y = t1[t4];
        t4 = J.$add$ns(t3.$mul(index, 4), 2);
        if (t4 >>> 0 !== t4 || t4 >= t2)
          return H.ioore(t1, t4);
        _z = t1[t4];
        t3 = J.$add$ns(t3.$mul(index, 4), 3);
        if (t3 >>> 0 !== t3 || t3 >= t2)
          return H.ioore(t1, t3);
        return new H.NativeInt32x4(_x, _y, _z, t1[t3]);
      }, null, "get$[]", 2, 0, 109, 14, [], "[]"],
      $indexSet: [function(_, index, value) {
        var t1, t2, t3, t4, t5;
        t1 = this._storage;
        t2 = t1.length;
        if (index >>> 0 !== index || index >= (t2 / 4 | 0))
          H.throwExpression(H.diagnoseIndexError(this, index));
        t3 = J.getInterceptor$ns(index);
        t4 = J.$add$ns(t3.$mul(index, 4), 0);
        t5 = value.get$x();
        if (t4 >>> 0 !== t4 || t4 >= t2)
          return H.ioore(t1, t4);
        t1[t4] = t5;
        t5 = J.$add$ns(t3.$mul(index, 4), 1);
        t4 = value.get$y();
        if (t5 >>> 0 !== t5 || t5 >= t2)
          return H.ioore(t1, t5);
        t1[t5] = t4;
        t4 = J.$add$ns(t3.$mul(index, 4), 2);
        t5 = value.get$z();
        if (t4 >>> 0 !== t4 || t4 >= t2)
          return H.ioore(t1, t4);
        t1[t4] = t5;
        t3 = J.$add$ns(t3.$mul(index, 4), 3);
        t5 = value.get$w();
        if (t3 >>> 0 !== t3 || t3 >= t2)
          return H.ioore(t1, t3);
        t1[t3] = t5;
      }, null, "get$[]=", 4, 0, 1530, 14, [], 1, [], "[]="],
      sublist$2: [function(_, start, end) {
        var t1 = this._storage;
        end = H._checkValidRange(start, end, t1.length / 4 | 0);
        return new H.NativeInt32x4List(C.NativeInt32List_methods.sublist$2(t1, J.$mul$ns(start, 4), J.$mul$ns(end, 4)));
      }, function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      }, "sublist$1", "call$2", "call$1", "get$sublist", 2, 2, 1531, 0, 3, [], 5, [], "sublist"],
      NativeInt32x4List$_slowFromList$1: function(list) {
        var t1, t2, t3, i, t4, e, t5, t6;
        t1 = J.getInterceptor$asx(list);
        t2 = this._storage;
        t3 = t2.length;
        i = 0;
        while (true) {
          t4 = t1.get$length(list);
          if (typeof t4 !== "number")
            return H.iae(t4);
          if (!(i < t4))
            break;
          e = t1.$index(list, i);
          t4 = i * 4;
          t5 = e.get$x();
          if (t4 >= t3)
            return H.ioore(t2, t4);
          t2[t4] = t5;
          t5 = t4 + 1;
          t6 = e.get$y();
          if (t5 >= t3)
            return H.ioore(t2, t5);
          t2[t5] = t6;
          t6 = t4 + 2;
          t5 = e.get$z();
          if (t6 >= t3)
            return H.ioore(t2, t6);
          t2[t6] = t5;
          t4 += 3;
          t5 = e.get$w();
          if (t4 >= t3)
            return H.ioore(t2, t4);
          t2[t4] = t5;
          ++i;
        }
      },
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $isList: 1,
      $asList: function() {
        return [P.Int32x4];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Int32x4];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Int32x4];
      },
      static: {
        NativeInt32x4List$_slowFromList: function(list) {
          var t1 = new H.NativeInt32x4List(new Int32Array(H._checkLength(J.$mul$ns(J.get$length$asx(list), 4))));
          t1.NativeInt32x4List$_slowFromList$1(list);
          return t1;
        },
        NativeInt32x4List_NativeInt32x4List$fromList: function(list) {
          if (list instanceof H.NativeInt32x4List)
            return new H.NativeInt32x4List(new Int32Array(H._ensureNativeList(list._storage)));
          else
            return H.NativeInt32x4List$_slowFromList(list);
        }
      }
    },
    "+NativeInt32x4List": 0,
    Object_ListMixin1: {
      "^": "Object+ListMixin;",
      $asList: function() {
        return [P.Int32x4];
      },
      $asEfficientLengthIterable: function() {
        return [P.Int32x4];
      },
      $asIterable: function() {
        return [P.Int32x4];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1,
      $isIterable: 1
    },
    Object_ListMixin_FixedLengthListMixin0: {
      "^": "Object_ListMixin1+FixedLengthListMixin;",
      $asList: function() {
        return [P.Int32x4];
      },
      $asEfficientLengthIterable: function() {
        return [P.Int32x4];
      },
      $asIterable: function() {
        return [P.Int32x4];
      }
    },
    NativeFloat64x2List: {
      "^": "Object_ListMixin_FixedLengthListMixin1;_storage",
      get$runtimeType: [function(_) {
        return C.Type_Float64x2List_0ez;
      }, null, null, 1, 0, 20, "runtimeType"],
      get$buffer: [function(_) {
        return this._storage.buffer;
      }, null, null, 1, 0, 169, "buffer"],
      get$lengthInBytes: [function(_) {
        return this._storage.byteLength;
      }, null, null, 1, 0, 11, "lengthInBytes"],
      get$offsetInBytes: [function(_) {
        return this._storage.byteOffset;
      }, null, null, 1, 0, 11, "offsetInBytes"],
      get$elementSizeInBytes: [function(_) {
        return 16;
      }, null, null, 1, 0, 11, "elementSizeInBytes"],
      get$length: [function(_) {
        return this._storage.length / 2 | 0;
      }, null, null, 1, 0, 11, "length"],
      $index: [function(_, index) {
        var t1, t2, t3, t4, _x, _y;
        t1 = this._storage;
        t2 = t1.length;
        if (index >>> 0 !== index || index >= (t2 / 2 | 0))
          H.throwExpression(H.diagnoseIndexError(this, index));
        t3 = J.getInterceptor$ns(index);
        t4 = J.$add$ns(t3.$mul(index, 2), 0);
        if (t4 >>> 0 !== t4 || t4 >= t2)
          return H.ioore(t1, t4);
        _x = t1[t4];
        t3 = J.$add$ns(t3.$mul(index, 2), 1);
        if (t3 >>> 0 !== t3 || t3 >= t2)
          return H.ioore(t1, t3);
        _y = t1[t3];
        return new H.NativeFloat64x2(_x, _y);
      }, null, "get$[]", 2, 0, 1545, 14, [], "[]"],
      $indexSet: [function(_, index, value) {
        var t1, t2, t3, t4, t5;
        t1 = this._storage;
        t2 = t1.length;
        if (index >>> 0 !== index || index >= (t2 / 2 | 0))
          H.throwExpression(H.diagnoseIndexError(this, index));
        t3 = J.getInterceptor$ns(index);
        t4 = J.$add$ns(t3.$mul(index, 2), 0);
        t5 = value.get$x();
        if (t4 >>> 0 !== t4 || t4 >= t2)
          return H.ioore(t1, t4);
        t1[t4] = t5;
        t3 = J.$add$ns(t3.$mul(index, 2), 1);
        t5 = value.get$y();
        if (t3 >>> 0 !== t3 || t3 >= t2)
          return H.ioore(t1, t3);
        t1[t3] = t5;
      }, null, "get$[]=", 4, 0, 1590, 14, [], 1, [], "[]="],
      sublist$2: [function(_, start, end) {
        var t1 = this._storage;
        end = H._checkValidRange(start, end, t1.length / 2 | 0);
        return new H.NativeFloat64x2List(C.NativeFloat64List_methods.sublist$2(t1, J.$mul$ns(start, 2), J.$mul$ns(end, 2)));
      }, function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      }, "sublist$1", "call$2", "call$1", "get$sublist", 2, 2, 1602, 0, 3, [], 5, [], "sublist"],
      NativeFloat64x2List$_slowFromList$1: function(list) {
        var t1, t2, t3, i, t4, e, t5;
        t1 = J.getInterceptor$asx(list);
        t2 = this._storage;
        t3 = t2.length;
        i = 0;
        while (true) {
          t4 = t1.get$length(list);
          if (typeof t4 !== "number")
            return H.iae(t4);
          if (!(i < t4))
            break;
          e = t1.$index(list, i);
          t4 = i * 2;
          t5 = e.get$x();
          if (t4 >= t3)
            return H.ioore(t2, t4);
          t2[t4] = t5;
          ++t4;
          t5 = e.get$y();
          if (t4 >= t3)
            return H.ioore(t2, t4);
          t2[t4] = t5;
          ++i;
        }
      },
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $isList: 1,
      $asList: function() {
        return [P.Float64x2];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Float64x2];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Float64x2];
      },
      static: {
        NativeFloat64x2List$_slowFromList: function(list) {
          var t1 = new H.NativeFloat64x2List(new Float64Array(H._checkLength(J.$mul$ns(J.get$length$asx(list), 2))));
          t1.NativeFloat64x2List$_slowFromList$1(list);
          return t1;
        },
        NativeFloat64x2List_NativeFloat64x2List$fromList: function(list) {
          if (list instanceof H.NativeFloat64x2List)
            return new H.NativeFloat64x2List(new Float64Array(H._ensureNativeList(list._storage)));
          else
            return H.NativeFloat64x2List$_slowFromList(list);
        }
      }
    },
    "+NativeFloat64x2List": 0,
    Object_ListMixin2: {
      "^": "Object+ListMixin;",
      $asList: function() {
        return [P.Float64x2];
      },
      $asEfficientLengthIterable: function() {
        return [P.Float64x2];
      },
      $asIterable: function() {
        return [P.Float64x2];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1,
      $isIterable: 1
    },
    Object_ListMixin_FixedLengthListMixin1: {
      "^": "Object_ListMixin2+FixedLengthListMixin;",
      $asList: function() {
        return [P.Float64x2];
      },
      $asEfficientLengthIterable: function() {
        return [P.Float64x2];
      },
      $asIterable: function() {
        return [P.Float64x2];
      }
    },
    NativeTypedData: {
      "^": ["Interceptor;buffer=-,lengthInBytes:byteLength=-,offsetInBytes:byteOffset=-,elementSizeInBytes:BYTES_PER_ELEMENT=-", function() {
        return [C.Creates_NativeByteBuffer, C.Returns_EKW];
      }, function() {
        return [C.JSName_byteLength];
      }, function() {
        return [C.JSName_byteOffset];
      }, function() {
        return [C.JSName_BYTES_PER_ELEMENT];
      }],
      _invalidPosition$3: function(receiver, position, $length, $name) {
        if (typeof position !== "number" || Math.floor(position) !== position)
          throw H.wrapException(P.ArgumentError$value(position, $name, "Invalid list position"));
        else
          throw H.wrapException(P.RangeError$range(position, 0, $length, $name, null));
      },
      _checkPosition$3: function(receiver, position, $length, $name) {
        if (position >>> 0 !== position || position > $length)
          this._invalidPosition$3(receiver, position, $length, $name);
      },
      $isNativeTypedData: 1,
      $isObject: 1,
      "%": ";ArrayBufferView;NativeTypedArray|NativeTypedArray_ListMixin|NativeTypedArray_ListMixin_FixedLengthListMixin|NativeTypedArrayOfDouble|NativeTypedArray_ListMixin0|NativeTypedArray_ListMixin_FixedLengthListMixin0|NativeTypedArrayOfInt",
      "@": function() {
        return [C.Native_ArrayBufferView];
      }
    },
    "+NativeTypedData": 0,
    NativeByteData: {
      "^": "NativeTypedData;",
      get$runtimeType: [function(receiver) {
        return C.Type_ByteData_zNC;
      }, null, null, 1, 0, 20, "runtimeType"],
      get$elementSizeInBytes: [function(receiver) {
        return 1;
      }, null, null, 1, 0, 11, "elementSizeInBytes"],
      getFloat32$2: [function(receiver, byteOffset, endian) {
        return receiver.getFloat32(byteOffset, C.Endianness_true === endian);
      }, function($receiver, byteOffset) {
        return this.getFloat32$2($receiver, byteOffset, C.Endianness_false);
      }, "getFloat32$1", "call$2", "call$1", "get$getFloat32", 2, 2, 520, 64, 53, [], 60, [], "getFloat32"],
      getFloat64$2: [function(receiver, byteOffset, endian) {
        return receiver.getFloat64(byteOffset, C.Endianness_true === endian);
      }, function($receiver, byteOffset) {
        return this.getFloat64$2($receiver, byteOffset, C.Endianness_false);
      }, "getFloat64$1", "call$2", "call$1", "get$getFloat64", 2, 2, 520, 64, 53, [], 60, [], "getFloat64"],
      getInt16$2: [function(receiver, byteOffset, endian) {
        return receiver.getInt16(byteOffset, C.Endianness_true === endian);
      }, function($receiver, byteOffset) {
        return this.getInt16$2($receiver, byteOffset, C.Endianness_false);
      }, "getInt16$1", "call$2", "call$1", "get$getInt16", 2, 2, 113, 64, 53, [], 60, [], "getInt16"],
      getInt32$2: [function(receiver, byteOffset, endian) {
        return receiver.getInt32(byteOffset, C.Endianness_true === endian);
      }, function($receiver, byteOffset) {
        return this.getInt32$2($receiver, byteOffset, C.Endianness_false);
      }, "getInt32$1", "call$2", "call$1", "get$getInt32", 2, 2, 113, 64, 53, [], 60, [], "getInt32"],
      getInt64$2: [function(receiver, byteOffset, endian) {
        throw H.wrapException(new P.UnsupportedError("Int64 accessor not supported by dart2js."));
      }, function($receiver, byteOffset) {
        return this.getInt64$2($receiver, byteOffset, C.Endianness_false);
      }, "getInt64$1", "call$2", "call$1", "get$getInt64", 2, 2, 113, 64, 53, [], 60, [], "getInt64"],
      getInt8$1: [function(receiver, byteOffset) {
        return receiver.getInt8(byteOffset);
      }, "call$1", "get$getInt8", 2, 0, 16, 53, [], "getInt8"],
      getUint16$2: [function(receiver, byteOffset, endian) {
        return receiver.getUint16(byteOffset, C.Endianness_true === endian);
      }, function($receiver, byteOffset) {
        return this.getUint16$2($receiver, byteOffset, C.Endianness_false);
      }, "getUint16$1", "call$2", "call$1", "get$getUint16", 2, 2, 113, 64, 53, [], 60, [], "getUint16"],
      getUint32$2: [function(receiver, byteOffset, endian) {
        return receiver.getUint32(byteOffset, C.Endianness_true === endian);
      }, function($receiver, byteOffset) {
        return this.getUint32$2($receiver, byteOffset, C.Endianness_false);
      }, "getUint32$1", "call$2", "call$1", "get$getUint32", 2, 2, 113, 64, 53, [], 60, [], "getUint32"],
      getUint64$2: [function(receiver, byteOffset, endian) {
        throw H.wrapException(new P.UnsupportedError("Uint64 accessor not supported by dart2js."));
      }, function($receiver, byteOffset) {
        return this.getUint64$2($receiver, byteOffset, C.Endianness_false);
      }, "getUint64$1", "call$2", "call$1", "get$getUint64", 2, 2, 113, 64, 53, [], 60, [], "getUint64"],
      getUint8$1: [function(receiver, byteOffset) {
        return receiver.getUint8(byteOffset);
      }, "call$1", "get$getUint8", 2, 0, 16, 53, [], "getUint8"],
      setFloat32$3: [function(receiver, byteOffset, value, endian) {
        return receiver.setFloat32(byteOffset, value, C.Endianness_true === endian);
      }, function($receiver, byteOffset, value) {
        return this.setFloat32$3($receiver, byteOffset, value, C.Endianness_false);
      }, "setFloat32$2", "call$3", "call$2", "get$setFloat32", 4, 2, 529, 64, 53, [], 1, [], 60, [], "setFloat32"],
      setFloat64$3: [function(receiver, byteOffset, value, endian) {
        return receiver.setFloat64(byteOffset, value, C.Endianness_true === endian);
      }, function($receiver, byteOffset, value) {
        return this.setFloat64$3($receiver, byteOffset, value, C.Endianness_false);
      }, "setFloat64$2", "call$3", "call$2", "get$setFloat64", 4, 2, 529, 64, 53, [], 1, [], 60, [], "setFloat64"],
      setInt16$3: [function(receiver, byteOffset, value, endian) {
        return receiver.setInt16(byteOffset, value, C.Endianness_true === endian);
      }, function($receiver, byteOffset, value) {
        return this.setInt16$3($receiver, byteOffset, value, C.Endianness_false);
      }, "setInt16$2", "call$3", "call$2", "get$setInt16", 4, 2, 114, 64, 53, [], 1, [], 60, [], "setInt16"],
      setInt32$3: [function(receiver, byteOffset, value, endian) {
        return receiver.setInt32(byteOffset, value, C.Endianness_true === endian);
      }, function($receiver, byteOffset, value) {
        return this.setInt32$3($receiver, byteOffset, value, C.Endianness_false);
      }, "setInt32$2", "call$3", "call$2", "get$setInt32", 4, 2, 114, 64, 53, [], 1, [], 60, [], "setInt32"],
      setInt64$3: [function(receiver, byteOffset, value, endian) {
        throw H.wrapException(new P.UnsupportedError("Int64 accessor not supported by dart2js."));
      }, function($receiver, byteOffset, value) {
        return this.setInt64$3($receiver, byteOffset, value, C.Endianness_false);
      }, "setInt64$2", "call$3", "call$2", "get$setInt64", 4, 2, 114, 64, 53, [], 1, [], 60, [], "setInt64"],
      setInt8$2: [function(receiver, byteOffset, value) {
        return receiver.setInt8(byteOffset, value);
      }, "call$2", "get$setInt8", 4, 0, 76, 53, [], 1, [], "setInt8"],
      setUint16$3: [function(receiver, byteOffset, value, endian) {
        return receiver.setUint16(byteOffset, value, C.Endianness_true === endian);
      }, function($receiver, byteOffset, value) {
        return this.setUint16$3($receiver, byteOffset, value, C.Endianness_false);
      }, "setUint16$2", "call$3", "call$2", "get$setUint16", 4, 2, 114, 64, 53, [], 1, [], 60, [], "setUint16"],
      setUint32$3: [function(receiver, byteOffset, value, endian) {
        return receiver.setUint32(byteOffset, value, C.Endianness_true === endian);
      }, function($receiver, byteOffset, value) {
        return this.setUint32$3($receiver, byteOffset, value, C.Endianness_false);
      }, "setUint32$2", "call$3", "call$2", "get$setUint32", 4, 2, 114, 64, 53, [], 1, [], 60, [], "setUint32"],
      setUint64$3: [function(receiver, byteOffset, value, endian) {
        throw H.wrapException(new P.UnsupportedError("Uint64 accessor not supported by dart2js."));
      }, function($receiver, byteOffset, value) {
        return this.setUint64$3($receiver, byteOffset, value, C.Endianness_false);
      }, "setUint64$2", "call$3", "call$2", "get$setUint64", 4, 2, 114, 64, 53, [], 1, [], 60, [], "setUint64"],
      setUint8$2: [function(receiver, byteOffset, value) {
        return receiver.setUint8(byteOffset, value);
      }, "call$2", "get$setUint8", 4, 0, 76, 53, [], 1, [], "setUint8"],
      $isObject: 1,
      "%": "DataView",
      "@": function() {
        return [C.Native_DataView];
      }
    },
    "+NativeByteData": 0,
    NativeTypedArray: {
      "^": "NativeTypedData;",
      get$length: [function(receiver) {
        return receiver.length;
      }, null, null, 1, 0, 11, "length"],
      _setRangeFast$4: function(receiver, start, end, source, skipCount) {
        var targetLength, count, sourceLength;
        targetLength = receiver.length;
        this._checkPosition$3(receiver, start, targetLength, "start");
        this._checkPosition$3(receiver, end, targetLength, "end");
        if (J.$gt$n(start, end))
          throw H.wrapException(P.RangeError$range(start, 0, end, null, null));
        count = J.$sub$n(end, start);
        if (J.$lt$n(skipCount, 0))
          throw H.wrapException(P.ArgumentError$(skipCount));
        sourceLength = source.length;
        if (typeof skipCount !== "number")
          return H.iae(skipCount);
        if (typeof count !== "number")
          return H.iae(count);
        if (sourceLength - skipCount < count)
          throw H.wrapException(new P.StateError("Not enough elements"));
        if (skipCount !== 0 || sourceLength !== count)
          source = source.subarray(skipCount, skipCount + count);
        receiver.set(source, start);
      },
      length$0: function($receiver) {
        return this.get$length($receiver).call$0();
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: Isolate.functionThatReturnsNull,
      $isJSIndexable: 1,
      $asJSIndexable: Isolate.functionThatReturnsNull
    },
    "+NativeTypedArray": 0,
    NativeTypedArrayOfDouble: {
      "^": "NativeTypedArray_ListMixin_FixedLengthListMixin;",
      $index: [function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          H.throwExpression(H.diagnoseIndexError(receiver, index));
        return receiver[index];
      }, null, "get$[]", 2, 0, 1655, 14, [], "[]"],
      $indexSet: [function(receiver, index, value) {
        if (index >>> 0 !== index || index >= receiver.length)
          H.throwExpression(H.diagnoseIndexError(receiver, index));
        receiver[index] = value;
      }, null, "get$[]=", 4, 0, 1656, 14, [], 1, [], "[]="],
      setRange$4: [function(receiver, start, end, iterable, skipCount) {
        if (!!J.getInterceptor(iterable).$isNativeTypedArrayOfDouble) {
          this._setRangeFast$4(receiver, start, end, iterable, skipCount);
          return;
        }
        this.super$ListMixin$setRange(receiver, start, end, iterable, skipCount);
      }, function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      }, "setRange$3", "call$4", "call$3", "get$setRange", 6, 2, 1670, 7, 3, [], 5, [], 42, [], 197, [], "setRange"]
    },
    "+NativeTypedArrayOfDouble": 0,
    NativeTypedArray_ListMixin: {
      "^": "NativeTypedArray+ListMixin;",
      $asJavaScriptIndexingBehavior: Isolate.functionThatReturnsNull,
      $asJSIndexable: Isolate.functionThatReturnsNull,
      $asList: function() {
        return [P.double];
      },
      $asEfficientLengthIterable: function() {
        return [P.double];
      },
      $asIterable: function() {
        return [P.double];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1,
      $isIterable: 1
    },
    NativeTypedArray_ListMixin_FixedLengthListMixin: {
      "^": "NativeTypedArray_ListMixin+FixedLengthListMixin;",
      $asJavaScriptIndexingBehavior: Isolate.functionThatReturnsNull,
      $asJSIndexable: Isolate.functionThatReturnsNull,
      $asList: function() {
        return [P.double];
      },
      $asEfficientLengthIterable: function() {
        return [P.double];
      },
      $asIterable: function() {
        return [P.double];
      }
    },
    NativeTypedArrayOfInt: {
      "^": "NativeTypedArray_ListMixin_FixedLengthListMixin0;",
      $indexSet: [function(receiver, index, value) {
        if (index >>> 0 !== index || index >= receiver.length)
          H.throwExpression(H.diagnoseIndexError(receiver, index));
        receiver[index] = value;
      }, null, "get$[]=", 4, 0, 76, 14, [], 1, [], "[]="],
      setRange$4: [function(receiver, start, end, iterable, skipCount) {
        if (!!J.getInterceptor(iterable).$isNativeTypedArrayOfInt) {
          this._setRangeFast$4(receiver, start, end, iterable, skipCount);
          return;
        }
        this.super$ListMixin$setRange(receiver, start, end, iterable, skipCount);
      }, function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      }, "setRange$3", "call$4", "call$3", "get$setRange", 6, 2, 1199, 7, 3, [], 5, [], 42, [], 197, [], "setRange"],
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      }
    },
    "+NativeTypedArrayOfInt": 0,
    NativeTypedArray_ListMixin0: {
      "^": "NativeTypedArray+ListMixin;",
      $asJavaScriptIndexingBehavior: Isolate.functionThatReturnsNull,
      $asJSIndexable: Isolate.functionThatReturnsNull,
      $asList: function() {
        return [P.int];
      },
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      },
      $isList: 1,
      $isEfficientLengthIterable: 1,
      $isIterable: 1
    },
    NativeTypedArray_ListMixin_FixedLengthListMixin0: {
      "^": "NativeTypedArray_ListMixin0+FixedLengthListMixin;",
      $asJavaScriptIndexingBehavior: Isolate.functionThatReturnsNull,
      $asJSIndexable: Isolate.functionThatReturnsNull,
      $asList: function() {
        return [P.int];
      },
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      }
    },
    NativeFloat32List: {
      "^": "NativeTypedArrayOfDouble;",
      get$runtimeType: [function(receiver) {
        return C.Type_Float32List_LB7;
      }, null, null, 1, 0, 20, "runtimeType"],
      sublist$2: [function(receiver, start, end) {
        return new Float32Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
      }, function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      }, "sublist$1", "call$2", "call$1", "get$sublist", 2, 2, 313, 0, 3, [], 5, [], "sublist"],
      $isObject: 1,
      $isList: 1,
      $asList: function() {
        return [P.double];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.double];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.double];
      },
      "%": "Float32Array",
      "@": function() {
        return [C.Native_Float32Array];
      }
    },
    "+NativeFloat32List": 0,
    NativeFloat64List: {
      "^": "NativeTypedArrayOfDouble;",
      get$runtimeType: [function(receiver) {
        return C.Type_Float64List_LB7;
      }, null, null, 1, 0, 20, "runtimeType"],
      sublist$2: [function(receiver, start, end) {
        return new Float64Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
      }, function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      }, "sublist$1", "call$2", "call$1", "get$sublist", 2, 2, 313, 0, 3, [], 5, [], "sublist"],
      $isObject: 1,
      $isList: 1,
      $asList: function() {
        return [P.double];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.double];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.double];
      },
      "%": "Float64Array",
      "@": function() {
        return [C.Native_Float64Array];
      }
    },
    "+NativeFloat64List": 0,
    NativeInt16List: {
      "^": "NativeTypedArrayOfInt;",
      get$runtimeType: [function(receiver) {
        return C.Type_Int16List_uXf;
      }, null, null, 1, 0, 20, "runtimeType"],
      $index: [function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          H.throwExpression(H.diagnoseIndexError(receiver, index));
        return receiver[index];
      }, null, "get$[]", 2, 0, 16, 14, [], "[]"],
      sublist$2: [function(receiver, start, end) {
        return new Int16Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
      }, function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      }, "sublist$1", "call$2", "call$1", "get$sublist", 2, 2, 96, 0, 3, [], 5, [], "sublist"],
      $isObject: 1,
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      "%": "Int16Array",
      "@": function() {
        return [C.Native_Int16Array];
      }
    },
    "+NativeInt16List": 0,
    NativeInt32List: {
      "^": "NativeTypedArrayOfInt;",
      get$runtimeType: [function(receiver) {
        return C.Type_Int32List_O50;
      }, null, null, 1, 0, 20, "runtimeType"],
      $index: [function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          H.throwExpression(H.diagnoseIndexError(receiver, index));
        return receiver[index];
      }, null, "get$[]", 2, 0, 16, 14, [], "[]"],
      sublist$2: [function(receiver, start, end) {
        return new Int32Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
      }, function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      }, "sublist$1", "call$2", "call$1", "get$sublist", 2, 2, 96, 0, 3, [], 5, [], "sublist"],
      $isObject: 1,
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      "%": "Int32Array",
      "@": function() {
        return [C.Native_Int32Array];
      }
    },
    "+NativeInt32List": 0,
    NativeInt8List: {
      "^": "NativeTypedArrayOfInt;",
      get$runtimeType: [function(receiver) {
        return C.Type_Int8List_ekJ;
      }, null, null, 1, 0, 20, "runtimeType"],
      $index: [function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          H.throwExpression(H.diagnoseIndexError(receiver, index));
        return receiver[index];
      }, null, "get$[]", 2, 0, 16, 14, [], "[]"],
      sublist$2: [function(receiver, start, end) {
        return new Int8Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
      }, function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      }, "sublist$1", "call$2", "call$1", "get$sublist", 2, 2, 96, 0, 3, [], 5, [], "sublist"],
      $isInt8List: 1,
      $isObject: 1,
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      "%": "Int8Array",
      "@": function() {
        return [C.Native_Int8Array];
      }
    },
    "+NativeInt8List": 0,
    NativeUint16List: {
      "^": "NativeTypedArrayOfInt;",
      get$runtimeType: [function(receiver) {
        return C.Type_Uint16List_2bx;
      }, null, null, 1, 0, 20, "runtimeType"],
      $index: [function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          H.throwExpression(H.diagnoseIndexError(receiver, index));
        return receiver[index];
      }, null, "get$[]", 2, 0, 16, 14, [], "[]"],
      sublist$2: [function(receiver, start, end) {
        return new Uint16Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
      }, function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      }, "sublist$1", "call$2", "call$1", "get$sublist", 2, 2, 96, 0, 3, [], 5, [], "sublist"],
      $isObject: 1,
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      "%": "Uint16Array",
      "@": function() {
        return [C.Native_Uint16Array];
      }
    },
    "+NativeUint16List": 0,
    NativeUint32List: {
      "^": "NativeTypedArrayOfInt;",
      get$runtimeType: [function(receiver) {
        return C.Type_Uint32List_2bx;
      }, null, null, 1, 0, 20, "runtimeType"],
      $index: [function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          H.throwExpression(H.diagnoseIndexError(receiver, index));
        return receiver[index];
      }, null, "get$[]", 2, 0, 16, 14, [], "[]"],
      sublist$2: [function(receiver, start, end) {
        return new Uint32Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
      }, function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      }, "sublist$1", "call$2", "call$1", "get$sublist", 2, 2, 96, 0, 3, [], 5, [], "sublist"],
      $isObject: 1,
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      "%": "Uint32Array",
      "@": function() {
        return [C.Native_Uint32Array];
      }
    },
    "+NativeUint32List": 0,
    NativeUint8ClampedList: {
      "^": "NativeTypedArrayOfInt;",
      get$runtimeType: [function(receiver) {
        return C.Type_Uint8ClampedList_Jik;
      }, null, null, 1, 0, 20, "runtimeType"],
      get$length: [function(receiver) {
        return receiver.length;
      }, null, null, 1, 0, 11, "length"],
      $index: [function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          H.throwExpression(H.diagnoseIndexError(receiver, index));
        return receiver[index];
      }, null, "get$[]", 2, 0, 16, 14, [], "[]"],
      sublist$2: [function(receiver, start, end) {
        return new Uint8ClampedArray(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
      }, function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      }, "sublist$1", "call$2", "call$1", "get$sublist", 2, 2, 96, 0, 3, [], 5, [], "sublist"],
      length$0: function($receiver) {
        return this.get$length($receiver).call$0();
      },
      $isObject: 1,
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      "%": "CanvasPixelArray|Uint8ClampedArray",
      "@": function() {
        return [C.Native_4si];
      }
    },
    "+NativeUint8ClampedList": 0,
    NativeUint8List: {
      "^": "NativeTypedArrayOfInt;",
      get$runtimeType: [function(receiver) {
        return C.Type_Uint8List_WLA;
      }, null, null, 1, 0, 20, "runtimeType"],
      get$length: [function(receiver) {
        return receiver.length;
      }, null, null, 1, 0, 11, "length"],
      $index: [function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          H.throwExpression(H.diagnoseIndexError(receiver, index));
        return receiver[index];
      }, null, "get$[]", 2, 0, 16, 14, [], "[]"],
      sublist$2: [function(receiver, start, end) {
        return new Uint8Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
      }, function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      }, "sublist$1", "call$2", "call$1", "get$sublist", 2, 2, 96, 0, 3, [], 5, [], "sublist"],
      length$0: function($receiver) {
        return this.get$length($receiver).call$0();
      },
      $isNativeUint8List: 1,
      $isUint8List: 1,
      $isObject: 1,
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      "%": ";Uint8Array",
      "@": function() {
        return [C.Native_eZS];
      }
    },
    "+NativeUint8List": 0,
    NativeFloat32x4: {
      "^": "Object;x<-,y<-,z<-,w<-",
      toString$0: [function(_) {
        return "[" + H.S(this.x) + ", " + H.S(this.y) + ", " + H.S(this.z) + ", " + H.S(this.w) + "]";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $add: [function(_, other) {
        return H.NativeFloat32x4$_doubles(J.$add$ns(this.x, other.get$x()), J.$add$ns(this.y, other.get$y()), J.$add$ns(this.z, other.get$z()), J.$add$ns(this.w, other.get$w()));
      }, null, "get$+", 2, 0, 107, 2, [], "+"],
      $negate: [function(_) {
        return new H.NativeFloat32x4(J.$negate$n(this.x), J.$negate$n(this.y), J.$negate$n(this.z), J.$negate$n(this.w));
      }, null, "get$unary-", 0, 0, 118, "unary-"],
      $sub: [function(_, other) {
        return H.NativeFloat32x4$_doubles(J.$sub$n(this.x, other.get$x()), J.$sub$n(this.y, other.get$y()), J.$sub$n(this.z, other.get$z()), J.$sub$n(this.w, other.get$w()));
      }, null, "get$-", 2, 0, 107, 2, [], "-"],
      $mul: [function(_, other) {
        return H.NativeFloat32x4$_doubles(J.$mul$ns(this.x, other.get$x()), J.$mul$ns(this.y, other.get$y()), J.$mul$ns(this.z, other.get$z()), J.$mul$ns(this.w, other.get$w()));
      }, null, "get$*", 2, 0, 107, 2, [], "*"],
      $div: [function(_, other) {
        return H.NativeFloat32x4$_doubles(J.$div$n(this.x, other.get$x()), J.$div$n(this.y, other.get$y()), J.$div$n(this.z, other.get$z()), J.$div$n(this.w, other.get$w()));
      }, null, "get$/", 2, 0, 107, 2, [], "/"],
      lessThan$1: [function(other) {
        var _cx, _cy, _cz, _cw, t1, t2, t3;
        _cx = J.$lt$n(this.x, other.get$x());
        _cy = J.$lt$n(this.y, other.get$y());
        _cz = J.$lt$n(this.z, other.get$z());
        _cw = J.$lt$n(this.w, other.get$w());
        t1 = _cx ? -1 : 0;
        t2 = _cy ? -1 : 0;
        t3 = _cz ? -1 : 0;
        return new H.NativeInt32x4(t1, t2, t3, _cw ? -1 : 0);
      }, "call$1", "get$lessThan", 2, 0, 98, 2, [], "lessThan"],
      lessThanOrEqual$1: [function(other) {
        var _cx, _cy, _cz, _cw, t1, t2, t3;
        _cx = J.$le$n(this.x, other.get$x());
        _cy = J.$le$n(this.y, other.get$y());
        _cz = J.$le$n(this.z, other.get$z());
        _cw = J.$le$n(this.w, other.get$w());
        t1 = _cx ? -1 : 0;
        t2 = _cy ? -1 : 0;
        t3 = _cz ? -1 : 0;
        return new H.NativeInt32x4(t1, t2, t3, _cw ? -1 : 0);
      }, "call$1", "get$lessThanOrEqual", 2, 0, 98, 2, [], "lessThanOrEqual"],
      greaterThan$1: [function(other) {
        var _cx, _cy, _cz, _cw, t1, t2, t3;
        _cx = J.$gt$n(this.x, other.get$x());
        _cy = J.$gt$n(this.y, other.get$y());
        _cz = J.$gt$n(this.z, other.get$z());
        _cw = J.$gt$n(this.w, other.get$w());
        t1 = _cx ? -1 : 0;
        t2 = _cy ? -1 : 0;
        t3 = _cz ? -1 : 0;
        return new H.NativeInt32x4(t1, t2, t3, _cw ? -1 : 0);
      }, "call$1", "get$greaterThan", 2, 0, 98, 2, [], "greaterThan"],
      greaterThanOrEqual$1: [function(other) {
        var _cx, _cy, _cz, _cw, t1, t2, t3;
        _cx = J.$ge$n(this.x, other.get$x());
        _cy = J.$ge$n(this.y, other.get$y());
        _cz = J.$ge$n(this.z, other.get$z());
        _cw = J.$ge$n(this.w, other.get$w());
        t1 = _cx ? -1 : 0;
        t2 = _cy ? -1 : 0;
        t3 = _cz ? -1 : 0;
        return new H.NativeInt32x4(t1, t2, t3, _cw ? -1 : 0);
      }, "call$1", "get$greaterThanOrEqual", 2, 0, 98, 2, [], "greaterThanOrEqual"],
      equal$1: [function(other) {
        var _cx, _cy, _cz, _cw, t1, t2, t3;
        _cx = J.$eq$(this.x, other.get$x());
        _cy = J.$eq$(this.y, other.get$y());
        _cz = J.$eq$(this.z, other.get$z());
        _cw = J.$eq$(this.w, other.get$w());
        t1 = _cx ? -1 : 0;
        t2 = _cy ? -1 : 0;
        t3 = _cz ? -1 : 0;
        return new H.NativeInt32x4(t1, t2, t3, _cw ? -1 : 0);
      }, "call$1", "get$equal", 2, 0, 98, 2, [], "equal"],
      notEqual$1: [function(other) {
        var t1, t2, t3, t4;
        t1 = J.$eq$(this.x, other.get$x());
        t2 = J.$eq$(this.y, other.get$y());
        t3 = J.$eq$(this.z, other.get$z());
        t4 = J.$eq$(this.w, other.get$w());
        t1 = !t1 ? -1 : 0;
        t2 = !t2 ? -1 : 0;
        t3 = !t3 ? -1 : 0;
        return new H.NativeInt32x4(t1, t2, t3, !t4 ? -1 : 0);
      }, "call$1", "get$notEqual", 2, 0, 98, 2, [], "notEqual"],
      scale$1: [function(s) {
        var t1 = J.getInterceptor$ns(s);
        return H.NativeFloat32x4$_doubles(t1.$mul(s, this.x), t1.$mul(s, this.y), t1.$mul(s, this.z), t1.$mul(s, this.w));
      }, "call$1", "get$scale", 2, 0, 119, 49, [], "scale"],
      abs$0: [function(_) {
        return new H.NativeFloat32x4(J.abs$0$n(this.x), J.abs$0$n(this.y), J.abs$0$n(this.z), J.abs$0$n(this.w));
      }, "call$0", "get$abs", 0, 0, 118, "abs"],
      clamp$2: [function(_, lowerLimit, upperLimit) {
        var _lx, _ly, _lz, _lw, _ux, _uy, _uz, _uw, _x, _y, _z, _w;
        _lx = lowerLimit.get$x();
        _ly = lowerLimit.get$y();
        _lz = lowerLimit.get$z();
        _lw = lowerLimit.get$w();
        _ux = upperLimit.get$x();
        _uy = upperLimit.get$y();
        _uz = upperLimit.get$z();
        _uw = upperLimit.get$w();
        _x = this.x;
        _y = this.y;
        _z = this.z;
        _w = this.w;
        if (J.$gt$n(_x, _ux))
          _x = _ux;
        if (J.$gt$n(_y, _uy))
          _y = _uy;
        if (J.$gt$n(_z, _uz))
          _z = _uz;
        if (J.$gt$n(_w, _uw))
          _w = _uw;
        if (J.$lt$n(_x, _lx))
          _x = _lx;
        if (J.$lt$n(_y, _ly))
          _y = _ly;
        if (J.$lt$n(_z, _lz))
          _z = _lz;
        return new H.NativeFloat32x4(_x, _y, _z, J.$lt$n(_w, _lw) ? _lw : _w);
      }, "call$2", "get$clamp", 4, 0, 324, 379, [], 374, [], "clamp"],
      get$signMask: [function() {
        var view, t1, t2, t3, t4;
        view = $.$get$NativeFloat32x4__uint32view();
        t1 = $.$get$NativeFloat32x4__list();
        t1[0] = this.x;
        t1[1] = this.y;
        t1[2] = this.z;
        t1[3] = this.w;
        t1 = view.length;
        if (0 >= t1)
          return H.ioore(view, 0);
        t2 = view[0];
        if (1 >= t1)
          return H.ioore(view, 1);
        t3 = view[1];
        if (2 >= t1)
          return H.ioore(view, 2);
        t4 = view[2];
        if (3 >= t1)
          return H.ioore(view, 3);
        return ((t2 & 2147483648) >>> 31 | (t3 & 2147483648) >>> 30 | (t4 & 2147483648) >>> 29 | (view[3] & 2147483648) >>> 28) >>> 0;
      }, null, null, 1, 0, 11, "signMask"],
      shuffle$1: [function(_, mask) {
        var t1, t2, t3;
        t1 = J.getInterceptor$n(mask);
        if (t1.$lt(mask, 0) || t1.$gt(mask, 255))
          throw H.wrapException(P.RangeError$range(mask, 0, 255, "mask", null));
        t2 = $.$get$NativeFloat32x4__list();
        t2[0] = this.x;
        t2[1] = this.y;
        t2[2] = this.z;
        t2[3] = this.w;
        t3 = t1.$and(mask, 3);
        t2.length;
        if (t3 >>> 0 !== t3 || t3 >= 4)
          return H.ioore(t2, t3);
        return new H.NativeFloat32x4(t2[t3], t2[t1.$shr(mask, 2) & 3], t2[t1.$shr(mask, 4) & 3], t2[t1.$shr(mask, 6) & 3]);
      }, "call$1", "get$shuffle", 2, 0, 496, 242, [], "shuffle"],
      shuffleMix$2: [function(other, mask) {
        var t1, t2, t3, _x, _y;
        t1 = J.getInterceptor$n(mask);
        if (t1.$lt(mask, 0) || t1.$gt(mask, 255))
          throw H.wrapException(P.RangeError$range(mask, 0, 255, "mask", null));
        t2 = $.$get$NativeFloat32x4__list();
        t2[0] = this.x;
        t2[1] = this.y;
        t2[2] = this.z;
        t2[3] = this.w;
        t3 = t1.$and(mask, 3);
        t2.length;
        if (t3 >>> 0 !== t3 || t3 >= 4)
          return H.ioore(t2, t3);
        _x = t2[t3];
        _y = t2[t1.$shr(mask, 2) & 3];
        t2[0] = other.get$x();
        t2[1] = other.get$y();
        t2[2] = other.get$z();
        t2[3] = other.get$w();
        return new H.NativeFloat32x4(_x, _y, t2[t1.$shr(mask, 4) & 3], t2[t1.$shr(mask, 6) & 3]);
      }, "call$2", "get$shuffleMix", 4, 0, 1497, 2, [], 242, [], "shuffleMix"],
      withX$1: [function(newX) {
        var t1 = $.$get$NativeFloat32x4__list();
        t1[0] = newX;
        return new H.NativeFloat32x4(t1[0], this.y, this.z, this.w);
      }, "call$1", "get$withX", 2, 0, 119, 864, [], "withX"],
      withY$1: [function(newY) {
        var t1 = $.$get$NativeFloat32x4__list();
        t1[0] = newY;
        return new H.NativeFloat32x4(this.x, t1[0], this.z, this.w);
      }, "call$1", "get$withY", 2, 0, 119, 863, [], "withY"],
      withZ$1: [function(newZ) {
        var t1 = $.$get$NativeFloat32x4__list();
        t1[0] = newZ;
        return new H.NativeFloat32x4(this.x, this.y, t1[0], this.w);
      }, "call$1", "get$withZ", 2, 0, 119, 862, [], "withZ"],
      withW$1: [function(newW) {
        var t1 = $.$get$NativeFloat32x4__list();
        t1[0] = newW;
        return new H.NativeFloat32x4(this.x, this.y, this.z, t1[0]);
      }, "call$1", "get$withW", 2, 0, 119, 861, [], "withW"],
      min$1: [function(other) {
        var _x, _y, _z, _w;
        _x = this.x;
        _x = J.$lt$n(_x, other.get$x()) ? _x : other.get$x();
        _y = this.y;
        _y = J.$lt$n(_y, other.get$y()) ? _y : other.get$y();
        _z = this.z;
        _z = J.$lt$n(_z, other.get$z()) ? _z : other.get$z();
        _w = this.w;
        return new H.NativeFloat32x4(_x, _y, _z, J.$lt$n(_w, other.get$w()) ? _w : other.get$w());
      }, "call$1", "get$min", 2, 0, 107, 2, [], "min"],
      max$1: [function(other) {
        var _x, _y, _z, _w;
        _x = this.x;
        _x = J.$gt$n(_x, other.get$x()) ? _x : other.get$x();
        _y = this.y;
        _y = J.$gt$n(_y, other.get$y()) ? _y : other.get$y();
        _z = this.z;
        _z = J.$gt$n(_z, other.get$z()) ? _z : other.get$z();
        _w = this.w;
        return new H.NativeFloat32x4(_x, _y, _z, J.$gt$n(_w, other.get$w()) ? _w : other.get$w());
      }, "call$1", "get$max", 2, 0, 107, 2, [], "max"],
      sqrt$0: [function() {
        return H.NativeFloat32x4$_doubles(Math.sqrt(H.checkNum(this.x)), Math.sqrt(H.checkNum(this.y)), Math.sqrt(H.checkNum(this.z)), Math.sqrt(H.checkNum(this.w)));
      }, "call$0", "get$sqrt", 0, 0, 118, "sqrt"],
      reciprocal$0: [function() {
        var t1, t2, t3, t4;
        t1 = this.x;
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2 = this.y;
        if (typeof t2 !== "number")
          return H.iae(t2);
        t3 = this.z;
        if (typeof t3 !== "number")
          return H.iae(t3);
        t4 = this.w;
        if (typeof t4 !== "number")
          return H.iae(t4);
        return H.NativeFloat32x4$_doubles(1 / t1, 1 / t2, 1 / t3, 1 / t4);
      }, "call$0", "get$reciprocal", 0, 0, 118, "reciprocal"],
      reciprocalSqrt$0: [function() {
        var t1, _x, _y, _z;
        t1 = this.x;
        if (typeof t1 !== "number")
          return H.iae(t1);
        _x = Math.sqrt(1 / t1);
        t1 = this.y;
        if (typeof t1 !== "number")
          return H.iae(t1);
        _y = Math.sqrt(1 / t1);
        t1 = this.z;
        if (typeof t1 !== "number")
          return H.iae(t1);
        _z = Math.sqrt(1 / t1);
        t1 = this.w;
        if (typeof t1 !== "number")
          return H.iae(t1);
        return H.NativeFloat32x4$_doubles(_x, _y, _z, Math.sqrt(1 / t1));
      }, "call$0", "get$reciprocalSqrt", 0, 0, 118, "reciprocalSqrt"],
      NativeFloat32x4$4: function(x, y, z, w) {
        if (typeof x !== "number")
          throw H.wrapException(P.ArgumentError$(x));
        if (typeof y !== "number")
          throw H.wrapException(P.ArgumentError$(y));
        if (typeof z !== "number")
          throw H.wrapException(P.ArgumentError$(z));
        if (typeof w !== "number")
          throw H.wrapException(P.ArgumentError$(w));
      },
      static: {
        NativeFloat32x4$: function(x, y, z, w) {
          var t1, t2, t3, t4;
          t1 = $.$get$NativeFloat32x4__list();
          t1[0] = x;
          t2 = t1[0];
          t1[0] = y;
          t3 = t1[0];
          t1[0] = z;
          t4 = t1[0];
          t1[0] = w;
          t1 = new H.NativeFloat32x4(t2, t3, t4, t1[0]);
          t1.NativeFloat32x4$4(x, y, z, w);
          return t1;
        },
        NativeFloat32x4$_doubles: function(x, y, z, w) {
          var t1, t2, t3, t4;
          t1 = $.$get$NativeFloat32x4__list();
          t1[0] = x;
          t2 = t1[0];
          t1[0] = y;
          t3 = t1[0];
          t1[0] = z;
          t4 = t1[0];
          t1[0] = w;
          return new H.NativeFloat32x4(t2, t3, t4, t1[0]);
        }
      }
    },
    "+NativeFloat32x4": 0,
    NativeInt32x4: {
      "^": "Object;x<-,y<-,z<-,w<-",
      toString$0: [function(_) {
        return "[" + H.S(this.x) + ", " + H.S(this.y) + ", " + H.S(this.z) + ", " + H.S(this.w) + "]";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $or: [function(_, other) {
        return new H.NativeInt32x4(this.x | other.get$x(), this.y | other.get$y(), this.z | other.get$z(), this.w | other.get$w());
      }, null, "get$|", 2, 0, 168, 2, [], "|"],
      $and: [function(_, other) {
        return new H.NativeInt32x4(this.x & other.get$x(), this.y & other.get$y(), this.z & other.get$z(), this.w & other.get$w());
      }, null, "get$&", 2, 0, 168, 2, [], "&"],
      $xor: [function(_, other) {
        return new H.NativeInt32x4(this.x ^ other.get$x(), this.y ^ other.get$y(), this.z ^ other.get$z(), this.w ^ other.get$w());
      }, null, "get$^", 2, 0, 168, 2, [], "^"],
      $add: [function(_, other) {
        return new H.NativeInt32x4(this.x + other.get$x() | 0, this.y + other.get$y() | 0, this.z + other.get$z() | 0, this.w + other.get$w() | 0);
      }, null, "get$+", 2, 0, 168, 2, [], "+"],
      $sub: [function(_, other) {
        return new H.NativeInt32x4(this.x - other.get$x() | 0, this.y - other.get$y() | 0, this.z - other.get$z() | 0, this.w - other.get$w() | 0);
      }, null, "get$-", 2, 0, 168, 2, [], "-"],
      $negate: function(_) {
        return new H.NativeInt32x4(-this.x | 0, -this.y | 0, -this.z | 0, -this.w | 0);
      },
      get$signMask: [function() {
        return (J.$shr$n(J.$and$n(this.x, 2147483648), 31) | J.$shr$n(J.$and$n(this.y, 2147483648), 31) << 1 | J.$shr$n(J.$and$n(this.z, 2147483648), 31) << 2 | J.$shr$n(J.$and$n(this.w, 2147483648), 31) << 3) >>> 0;
      }, null, null, 1, 0, 11, "signMask"],
      shuffle$1: [function(_, mask) {
        var t1, t2, t3;
        t1 = J.getInterceptor$n(mask);
        if (t1.$lt(mask, 0) || t1.$gt(mask, 255))
          throw H.wrapException(P.RangeError$range(mask, 0, 255, "mask", null));
        t2 = $.$get$NativeInt32x4__list();
        t2[0] = this.x;
        t2[1] = this.y;
        t2[2] = this.z;
        t2[3] = this.w;
        t3 = t1.$and(mask, 3);
        t2.length;
        if (t3 >>> 0 !== t3 || t3 >= 4)
          return H.ioore(t2, t3);
        return new H.NativeInt32x4(t2[t3], t2[t1.$shr(mask, 2) & 3], t2[t1.$shr(mask, 4) & 3], t2[t1.$shr(mask, 6) & 3]);
      }, "call$1", "get$shuffle", 2, 0, 109, 242, [], "shuffle"],
      shuffleMix$2: [function(other, mask) {
        var t1, t2, t3, _x, _y;
        t1 = J.getInterceptor$n(mask);
        if (t1.$lt(mask, 0) || t1.$gt(mask, 255))
          throw H.wrapException(P.RangeError$range(mask, 0, 255, "mask", null));
        t2 = $.$get$NativeInt32x4__list();
        t2[0] = this.x;
        t2[1] = this.y;
        t2[2] = this.z;
        t2[3] = this.w;
        t3 = t1.$and(mask, 3);
        t2.length;
        if (t3 >>> 0 !== t3 || t3 >= 4)
          return H.ioore(t2, t3);
        _x = t2[t3];
        _y = t2[t1.$shr(mask, 2) & 3];
        t2[0] = other.get$x();
        t2[1] = other.get$y();
        t2[2] = other.get$z();
        t2[3] = other.get$w();
        return new H.NativeInt32x4(_x, _y, t2[t1.$shr(mask, 4) & 3], t2[t1.$shr(mask, 6) & 3]);
      }, "call$2", "get$shuffleMix", 4, 0, 1613, 2, [], 242, [], "shuffleMix"],
      withX$1: [function(x) {
        var t1 = $.$get$NativeInt32x4__list();
        t1[0] = x;
        return new H.NativeInt32x4(t1[0], this.y, this.z, this.w);
      }, "call$1", "get$withX", 2, 0, 109, 38, [], "withX"],
      withY$1: [function(y) {
        var t1 = $.$get$NativeInt32x4__list();
        t1[0] = y;
        return new H.NativeInt32x4(this.x, t1[0], this.z, this.w);
      }, "call$1", "get$withY", 2, 0, 109, 132, [], "withY"],
      withZ$1: [function(z) {
        var t1 = $.$get$NativeInt32x4__list();
        t1[0] = z;
        return new H.NativeInt32x4(this.x, this.y, t1[0], this.w);
      }, "call$1", "get$withZ", 2, 0, 109, 244, [], "withZ"],
      withW$1: [function(w) {
        var t1 = $.$get$NativeInt32x4__list();
        t1[0] = w;
        return new H.NativeInt32x4(this.x, this.y, this.z, t1[0]);
      }, "call$1", "get$withW", 2, 0, 109, 245, [], "withW"],
      get$flagX: [function() {
        return !J.$eq$(this.x, 0);
      }, null, null, 1, 0, 5, "flagX"],
      get$flagY: [function() {
        return !J.$eq$(this.y, 0);
      }, null, null, 1, 0, 5, "flagY"],
      get$flagZ: [function() {
        return !J.$eq$(this.z, 0);
      }, null, null, 1, 0, 5, "flagZ"],
      get$flagW: [function() {
        return !J.$eq$(this.w, 0);
      }, null, null, 1, 0, 5, "flagW"],
      withFlagX$1: [function(flagX) {
        var _x = flagX === true ? -1 : 0;
        return new H.NativeInt32x4(_x, this.y, this.z, this.w);
      }, "call$1", "get$withFlagX", 2, 0, 176, 860, [], "withFlagX"],
      withFlagY$1: [function(flagY) {
        var _y = flagY === true ? -1 : 0;
        return new H.NativeInt32x4(this.x, _y, this.z, this.w);
      }, "call$1", "get$withFlagY", 2, 0, 176, 859, [], "withFlagY"],
      withFlagZ$1: [function(flagZ) {
        var _z = flagZ === true ? -1 : 0;
        return new H.NativeInt32x4(this.x, this.y, _z, this.w);
      }, "call$1", "get$withFlagZ", 2, 0, 176, 856, [], "withFlagZ"],
      withFlagW$1: [function(flagW) {
        var _w = flagW === true ? -1 : 0;
        return new H.NativeInt32x4(this.x, this.y, this.z, _w);
      }, "call$1", "get$withFlagW", 2, 0, 176, 849, [], "withFlagW"],
      select$2: [function(trueValue, falseValue) {
        var floatList, intView, t1, stx, sty, stz, stw, sfx, sfy, sfz, sfw, t2, _x, _y, _z, _w;
        floatList = $.$get$NativeFloat32x4__list();
        intView = $.$get$NativeFloat32x4__uint32view();
        floatList[0] = trueValue.get$x();
        floatList[1] = trueValue.get$y();
        floatList[2] = trueValue.get$z();
        floatList[3] = trueValue.get$w();
        t1 = intView.length;
        if (0 >= t1)
          return H.ioore(intView, 0);
        stx = intView[0];
        if (1 >= t1)
          return H.ioore(intView, 1);
        sty = intView[1];
        if (2 >= t1)
          return H.ioore(intView, 2);
        stz = intView[2];
        if (3 >= t1)
          return H.ioore(intView, 3);
        stw = intView[3];
        floatList[0] = falseValue.get$x();
        floatList[1] = falseValue.get$y();
        floatList[2] = falseValue.get$z();
        floatList[3] = falseValue.get$w();
        sfx = intView[0];
        sfy = intView[1];
        sfz = intView[2];
        sfw = intView[3];
        t1 = this.x;
        t2 = J.getInterceptor$in(t1);
        _x = J.$or$n(t2.$and(t1, stx), (t2.$not(t1) & sfx) >>> 0);
        t1 = this.y;
        t2 = J.getInterceptor$in(t1);
        _y = J.$or$n(t2.$and(t1, sty), (t2.$not(t1) & sfy) >>> 0);
        t1 = this.z;
        t2 = J.getInterceptor$in(t1);
        _z = J.$or$n(t2.$and(t1, stz), (t2.$not(t1) & sfz) >>> 0);
        t1 = this.w;
        t2 = J.getInterceptor$in(t1);
        _w = J.$or$n(t2.$and(t1, stw), (t2.$not(t1) & sfw) >>> 0);
        intView[0] = _x;
        intView[1] = _y;
        intView[2] = _z;
        intView[3] = _w;
        return new H.NativeFloat32x4(floatList[0], floatList[1], floatList[2], floatList[3]);
      }, "call$2", "get$select", 4, 0, 324, 848, [], 846, [], "select"],
      NativeInt32x4$4: function(x, y, z, w) {
        if (!J.$eq$(x, this.x) && (typeof x !== "number" || Math.floor(x) !== x))
          throw H.wrapException(P.ArgumentError$(x));
        if (!J.$eq$(y, this.y) && (typeof y !== "number" || Math.floor(y) !== y))
          throw H.wrapException(P.ArgumentError$(y));
        if (!J.$eq$(z, this.z) && (typeof z !== "number" || Math.floor(z) !== z))
          throw H.wrapException(P.ArgumentError$(z));
        if (!J.$eq$(w, this.w) && (typeof w !== "number" || Math.floor(w) !== w))
          throw H.wrapException(P.ArgumentError$(w));
      },
      static: {
        NativeInt32x4$: function(x, y, z, w) {
          var t1, t2, t3, t4;
          t1 = $.$get$NativeInt32x4__list();
          t1[0] = x;
          t2 = t1[0];
          t1[0] = y;
          t3 = t1[0];
          t1[0] = z;
          t4 = t1[0];
          t1[0] = w;
          t1 = new H.NativeInt32x4(t2, t3, t4, t1[0]);
          t1.NativeInt32x4$4(x, y, z, w);
          return t1;
        }
      }
    },
    "+NativeInt32x4": 0,
    NativeFloat64x2: {
      "^": "Object;x<-,y<-",
      toString$0: [function(_) {
        return "[" + H.S(this.x) + ", " + H.S(this.y) + "]";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $add: [function(_, other) {
        return new H.NativeFloat64x2(J.$add$ns(this.x, other.get$x()), J.$add$ns(this.y, other.get$y()));
      }, null, "get$+", 2, 0, 121, 2, [], "+"],
      $negate: [function(_) {
        return new H.NativeFloat64x2(J.$negate$n(this.x), J.$negate$n(this.y));
      }, null, "get$unary-", 0, 0, 180, "unary-"],
      $sub: [function(_, other) {
        return new H.NativeFloat64x2(J.$sub$n(this.x, other.get$x()), J.$sub$n(this.y, other.get$y()));
      }, null, "get$-", 2, 0, 121, 2, [], "-"],
      $mul: [function(_, other) {
        return new H.NativeFloat64x2(J.$mul$ns(this.x, other.get$x()), J.$mul$ns(this.y, other.get$y()));
      }, null, "get$*", 2, 0, 121, 2, [], "*"],
      $div: [function(_, other) {
        return new H.NativeFloat64x2(J.$div$n(this.x, other.get$x()), J.$div$n(this.y, other.get$y()));
      }, null, "get$/", 2, 0, 121, 2, [], "/"],
      scale$1: [function(s) {
        return new H.NativeFloat64x2(J.$mul$ns(this.x, s), J.$mul$ns(this.y, s));
      }, "call$1", "get$scale", 2, 0, 182, 49, [], "scale"],
      abs$0: [function(_) {
        return new H.NativeFloat64x2(J.abs$0$n(this.x), J.abs$0$n(this.y));
      }, "call$0", "get$abs", 0, 0, 180, "abs"],
      clamp$2: [function(_, lowerLimit, upperLimit) {
        var _lx, _ly, _ux, _uy, _x, _y;
        _lx = lowerLimit.get$x();
        _ly = lowerLimit.get$y();
        _ux = upperLimit.get$x();
        _uy = upperLimit.get$y();
        _x = this.x;
        _y = this.y;
        if (J.$gt$n(_x, _ux))
          _x = _ux;
        if (J.$gt$n(_y, _uy))
          _y = _uy;
        if (J.$lt$n(_x, _lx))
          _x = _lx;
        return new H.NativeFloat64x2(_x, J.$lt$n(_y, _ly) ? _ly : _y);
      }, "call$2", "get$clamp", 4, 0, 1205, 379, [], 374, [], "clamp"],
      get$signMask: [function() {
        var view, t1, t2;
        view = $.$get$NativeFloat64x2__uint32View();
        t1 = $.$get$NativeFloat64x2__list();
        t1[0] = this.x;
        t1[1] = this.y;
        t1 = view.length;
        if (1 >= t1)
          return H.ioore(view, 1);
        t2 = view[1];
        if (3 >= t1)
          return H.ioore(view, 3);
        return ((t2 & 2147483648) >>> 31 | (view[3] & 2147483648) >>> 31 << 1) >>> 0;
      }, null, null, 1, 0, 11, "signMask"],
      withX$1: [function(x) {
        if (typeof x !== "number")
          throw H.wrapException(P.ArgumentError$(x));
        return new H.NativeFloat64x2(x, this.y);
      }, "call$1", "get$withX", 2, 0, 182, 38, [], "withX"],
      withY$1: [function(y) {
        if (typeof y !== "number")
          throw H.wrapException(P.ArgumentError$(y));
        return new H.NativeFloat64x2(this.x, y);
      }, "call$1", "get$withY", 2, 0, 182, 132, [], "withY"],
      min$1: [function(other) {
        var t1, t2;
        t1 = this.x;
        t1 = J.$lt$n(t1, other.get$x()) ? t1 : other.get$x();
        t2 = this.y;
        return new H.NativeFloat64x2(t1, J.$lt$n(t2, other.get$y()) ? t2 : other.get$y());
      }, "call$1", "get$min", 2, 0, 121, 2, [], "min"],
      max$1: [function(other) {
        var t1, t2;
        t1 = this.x;
        t1 = J.$gt$n(t1, other.get$x()) ? t1 : other.get$x();
        t2 = this.y;
        return new H.NativeFloat64x2(t1, J.$gt$n(t2, other.get$y()) ? t2 : other.get$y());
      }, "call$1", "get$max", 2, 0, 121, 2, [], "max"],
      sqrt$0: [function() {
        return new H.NativeFloat64x2(Math.sqrt(H.checkNum(this.x)), Math.sqrt(H.checkNum(this.y)));
      }, "call$0", "get$sqrt", 0, 0, 180, "sqrt"],
      NativeFloat64x2$2: function(x, y) {
        var t1 = this.x;
        if (typeof t1 !== "number")
          throw H.wrapException(P.ArgumentError$(t1));
        t1 = this.y;
        if (typeof t1 !== "number")
          throw H.wrapException(P.ArgumentError$(t1));
      },
      static: {
        NativeFloat64x2$: function(x, y) {
          var t1 = new H.NativeFloat64x2(x, y);
          t1.NativeFloat64x2$2(x, y);
          return t1;
        }
      }
    },
    "+NativeFloat64x2": 0
  }], ["dart.async", "dart:async",, P, {
    "^": "_ROOT_ZONE<-10,_isInCallbackLoop@-8,_lastPriorityCallback@-216,_lastCallback@-216,_nextCallback@-216",
    _asyncHelper: function(object, bodyFunctionOrErrorCode, completer) {
      if (bodyFunctionOrErrorCode === 0) {
        completer.complete$1(object);
        return;
      } else if (bodyFunctionOrErrorCode === 1) {
        completer.completeError$2(H.unwrapException(object), H.getTraceFromException(object));
        return;
      }
      P._awaitOnObject(object, bodyFunctionOrErrorCode);
      return completer.get$future();
    },
    _awaitOnObject: function(object, bodyFunction) {
      var thenCallback, errorCallback, t1, future;
      thenCallback = new P._awaitOnObject_closure(bodyFunction);
      errorCallback = new P._awaitOnObject_closure0(bodyFunction);
      t1 = J.getInterceptor(object);
      if (!!t1.$is_Future)
        object._thenNoZoneRegistration$2(thenCallback, errorCallback);
      else if (!!t1.$isFuture)
        object.then$2$onError(thenCallback, errorCallback);
      else {
        future = new P._Future(0, $.Zone__current, null, [null]);
        future._state = 4;
        future._resultOrListeners = object;
        future._thenNoZoneRegistration$2(thenCallback, null);
      }
    },
    _wrapJsFunctionForAsync: function($function) {
      var $protected = function(fn, ERROR) {
        return function(errorCode, result) {
          while (true)
            try {
              fn(errorCode, result);
              break;
            } catch (error) {
              result = error;
              errorCode = ERROR;
            }
        };
      }($function, 1);
      return $.Zone__current.registerBinaryCallback$1(new P._wrapJsFunctionForAsync_closure($protected));
    },
    _invokeErrorHandler: [function(errorHandler, error, stackTrace) {
      if (H.functionTypeTest(errorHandler, {func: 1, args: [,,]}))
        return errorHandler.call$2(error, stackTrace);
      else
        return errorHandler.call$1(error);
    }, "call$3", "async___invokeErrorHandler$closure", 6, 0, 560, 595, [], 8, [], 12, [], "_invokeErrorHandler"],
    _registerErrorHandler: [function(errorHandler, zone) {
      if (H.functionTypeTest(errorHandler, {func: 1, args: [,,]}))
        return zone.registerBinaryCallback$1(errorHandler);
      else
        return zone.registerUnaryCallback$1(errorHandler);
    }, "call$2", "async___registerErrorHandler$closure", 4, 0, 561, 595, [], 34, [], "_registerErrorHandler"],
    _completeWithErrorCallback: [function(result, error, stackTrace) {
      var replacement = $.Zone__current.errorCallback$2(error, stackTrace);
      if (replacement != null) {
        error = replacement.get$error();
        if (error == null)
          error = new P.NullThrownError();
        stackTrace = replacement.get$stackTrace();
      }
      result._completeError$2(error, stackTrace);
    }, "call$3", "async___completeWithErrorCallback$closure", 6, 0, 567, 93, [], 8, [], 12, [], "_completeWithErrorCallback"],
    _nonNullError: [function(error) {
      return error == null ? new P.NullThrownError() : error;
    }, "call$1", "async___nonNullError$closure", 2, 0, 420, 8, [], "_nonNullError"],
    _microtaskLoop: [function() {
      var t1, t2;
      for (; t1 = $._nextCallback, t1 != null;) {
        $._lastPriorityCallback = null;
        t2 = t1.get$next();
        $._nextCallback = t2;
        if (t2 == null)
          $._lastCallback = null;
        t1.get$callback().call$0();
      }
    }, "call$0", "async___microtaskLoop$closure", 0, 0, 6, "_microtaskLoop"],
    _startMicrotaskLoop: [function() {
      $._isInCallbackLoop = true;
      try {
        P._microtaskLoop();
      } finally {
        $._lastPriorityCallback = null;
        $._isInCallbackLoop = false;
        if ($._nextCallback != null)
          $.$get$_AsyncRun__scheduleImmediateClosure().call$1(P.async___startMicrotaskLoop$closure());
      }
    }, "call$0", "async___startMicrotaskLoop$closure", 0, 0, 6, "_startMicrotaskLoop"],
    _scheduleAsyncCallback: [function(callback) {
      var newEntry = new P._AsyncCallbackEntry(callback, null);
      if ($._nextCallback == null) {
        $._lastCallback = newEntry;
        $._nextCallback = newEntry;
        if ($._isInCallbackLoop !== true)
          $.$get$_AsyncRun__scheduleImmediateClosure().call$1(P.async___startMicrotaskLoop$closure());
      } else {
        $._lastCallback.set$next(newEntry);
        $._lastCallback = newEntry;
      }
    }, "call$1", "async___scheduleAsyncCallback$closure", 2, 0, 309, 33, [], "_scheduleAsyncCallback"],
    _schedulePriorityAsyncCallback: [function(callback) {
      var t1, entry, t2;
      t1 = $._nextCallback;
      if (t1 == null) {
        P._scheduleAsyncCallback(callback);
        $._lastPriorityCallback = $._lastCallback;
        return;
      }
      entry = new P._AsyncCallbackEntry(callback, null);
      t2 = $._lastPriorityCallback;
      if (t2 == null) {
        entry.next = t1;
        $._lastPriorityCallback = entry;
        $._nextCallback = entry;
      } else {
        entry.next = t2.get$next();
        $._lastPriorityCallback.set$next(entry);
        $._lastPriorityCallback = entry;
        if (entry.next == null)
          $._lastCallback = entry;
      }
    }, "call$1", "async___schedulePriorityAsyncCallback$closure", 2, 0, 309, 33, [], "_schedulePriorityAsyncCallback"],
    scheduleMicrotask: [function(callback) {
      var currentZone, t1;
      currentZone = $.Zone__current;
      if (C.C__RootZone === currentZone) {
        P._rootScheduleMicrotask(null, null, C.C__RootZone, callback);
        return;
      }
      if (C.C__RootZone === currentZone.get$_scheduleMicrotask().get$zone())
        t1 = C.C__RootZone.get$errorZone() === currentZone.get$errorZone();
      else
        t1 = false;
      if (t1) {
        P._rootScheduleMicrotask(null, null, currentZone, currentZone.registerCallback$1(callback));
        return;
      }
      t1 = $.Zone__current;
      t1.scheduleMicrotask$1(t1.bindCallback$2$runGuarded(callback, true));
    }, "call$1", "async__scheduleMicrotask$closure", 2, 0, 37, 33, [], "scheduleMicrotask"],
    _runGuarded: [function(notificationHandler) {
      var e, s, exception, t1;
      if (notificationHandler == null)
        return;
      try {
        notificationHandler.call$0();
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = H.getTraceFromException(exception);
        $.Zone__current.handleUncaughtError$2(e, s);
      }
    }, "call$1", "async___runGuarded$closure", 2, 0, 576, 835, [], "_runGuarded"],
    _nullDataHandler: [function(value) {
    }, "call$1", "async___nullDataHandler$closure", 2, 0, 64, 1, [], "_nullDataHandler"],
    _nullErrorHandler: [function(error, stackTrace) {
      $.Zone__current.handleUncaughtError$2(error, stackTrace);
    }, function(error) {
      return P._nullErrorHandler(error, null);
    }, "call$2", "call$1", "async___nullErrorHandler$closure", 2, 2, 48, 0, 8, [], 12, [], "_nullErrorHandler"],
    _nullDoneHandler: [function() {
    }, "call$0", "async___nullDoneHandler$closure", 0, 0, 6, "_nullDoneHandler"],
    _runUserCode: [function(userCode, onSuccess, onError) {
      var e, s, replacement, error, stackTrace, exception, t1, error0;
      try {
        onSuccess.call$1(userCode.call$0());
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = H.getTraceFromException(exception);
        replacement = $.Zone__current.errorCallback$2(e, s);
        if (replacement == null)
          onError.call$2(e, s);
        else {
          error0 = replacement.get$error();
          error = error0 == null ? new P.NullThrownError() : error0;
          stackTrace = replacement.get$stackTrace();
          onError.call$2(error, stackTrace);
        }
      }
    }, "call$3", "async___runUserCode$closure", 6, 0, function() {
      return {func: 1, args: [{func: 1}, {func: 1, args: [,]}, {func: 1, args: [, P.StackTrace]}]};
    }, 825, [], 821, [], 20, [], "_runUserCode"],
    _cancelAndError: [function(subscription, future, error, stackTrace) {
      var cancelFuture = subscription.cancel$0();
      if (!!J.getInterceptor(cancelFuture).$isFuture && cancelFuture !== $.$get$Future__nullFuture())
        cancelFuture.whenComplete$1(new P._cancelAndError_closure(future, error, stackTrace));
      else
        future._completeError$2(error, stackTrace);
    }, "call$4", "async___cancelAndError$closure", 8, 0, 386, 50, [], 179, [], 8, [], 12, [], "_cancelAndError"],
    _cancelAndErrorWithReplacement: [function(subscription, future, error, stackTrace) {
      var replacement = $.Zone__current.errorCallback$2(error, stackTrace);
      if (replacement != null) {
        error = replacement.get$error();
        if (error == null)
          error = new P.NullThrownError();
        stackTrace = replacement.get$stackTrace();
      }
      P._cancelAndError(subscription, future, error, stackTrace);
    }, "call$4", "async___cancelAndErrorWithReplacement$closure", 8, 0, 386, 50, [], 179, [], 8, [], 12, [], "_cancelAndErrorWithReplacement"],
    _cancelAndErrorClosure: [function(subscription, future) {
      return new P._cancelAndErrorClosure_closure(subscription, future);
    }, "call$2", "async___cancelAndErrorClosure$closure", 4, 0, 582, 50, [], 179, [], "_cancelAndErrorClosure"],
    _cancelAndValue: [function(subscription, future, value) {
      var cancelFuture = subscription.cancel$0();
      if (!!J.getInterceptor(cancelFuture).$isFuture && cancelFuture !== $.$get$Future__nullFuture())
        cancelFuture.whenComplete$1(new P._cancelAndValue_closure(future, value));
      else
        future._complete$1(value);
    }, "call$3", "async___cancelAndValue$closure", 6, 0, 583, 50, [], 179, [], 1, [], "_cancelAndValue"],
    _addErrorWithReplacement: [function(sink, error, stackTrace) {
      var replacement = $.Zone__current.errorCallback$2(error, stackTrace);
      if (replacement != null) {
        error = replacement.get$error();
        if (error == null)
          error = new P.NullThrownError();
        stackTrace = replacement.get$stackTrace();
      }
      sink._addError$2(error, stackTrace);
    }, "call$3", "async___addErrorWithReplacement$closure", 6, 0, 584, 22, [], 8, [], 12, [], "_addErrorWithReplacement"],
    _parentDelegate: [function(zone) {
      if (zone.get$parent() == null)
        return;
      return zone.get$parent().get$_delegate();
    }, "call$1", "async___parentDelegate$closure", 2, 0, 591, 34, [], "_parentDelegate"],
    _rootHandleUncaughtError: [function($self, $parent, zone, error, stackTrace) {
      var t1 = {};
      t1.error = error;
      P._schedulePriorityAsyncCallback(new P._rootHandleUncaughtError_closure(t1, stackTrace));
    }, "call$5", "async___rootHandleUncaughtError$closure", 10, 0, function() {
      return {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone,, P.StackTrace]};
    }, 72, [], 62, [], 34, [], 8, [], 12, [], "_rootHandleUncaughtError"],
    _rethrow: [function(error, stackTrace) {
      error = H.wrapException(error);
      error.stack = J.toString$0$(stackTrace);
      throw error;
    }, "call$2", "async___rethrow$closure", 4, 0, 49, 8, [], 12, [], "_rethrow"],
    _rootRun: [function($self, $parent, zone, f) {
      var old, previous, t1;
      if (J.$eq$($.Zone__current, zone))
        return f.call$0();
      previous = $.Zone__current;
      $.Zone__current = zone;
      old = previous;
      try {
        t1 = f.call$0();
        return t1;
      } finally {
        $.Zone__current = old;
      }
    }, "call$4", "async___rootRun$closure", 8, 0, function() {
      return {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1}]};
    }, 72, [], 62, [], 34, [], 9, [], "_rootRun"],
    _rootRunUnary: [function($self, $parent, zone, f, arg) {
      var old, previous, t1;
      if (J.$eq$($.Zone__current, zone))
        return f.call$1(arg);
      previous = $.Zone__current;
      $.Zone__current = zone;
      old = previous;
      try {
        t1 = f.call$1(arg);
        return t1;
      } finally {
        $.Zone__current = old;
      }
    }, "call$5", "async___rootRunUnary$closure", 10, 0, function() {
      return {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,]},,]};
    }, 72, [], 62, [], 34, [], 9, [], 68, [], "_rootRunUnary"],
    _rootRunBinary: [function($self, $parent, zone, f, arg1, arg2) {
      var old, previous, t1;
      if (J.$eq$($.Zone__current, zone))
        return f.call$2(arg1, arg2);
      previous = $.Zone__current;
      $.Zone__current = zone;
      old = previous;
      try {
        t1 = f.call$2(arg1, arg2);
        return t1;
      } finally {
        $.Zone__current = old;
      }
    }, "call$6", "async___rootRunBinary$closure", 12, 0, function() {
      return {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,,]},,,]};
    }, 72, [], 62, [], 34, [], 9, [], 91, [], 90, [], "_rootRunBinary"],
    _rootRegisterCallback: [function($self, $parent, zone, f) {
      return f;
    }, "call$4", "async___rootRegisterCallback$closure", 8, 0, function() {
      return {func: 1, ret: {func: 1}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1}]};
    }, 72, [], 62, [], 34, [], 9, [], "_rootRegisterCallback"],
    _rootRegisterUnaryCallback: [function($self, $parent, zone, f) {
      return f;
    }, "call$4", "async___rootRegisterUnaryCallback$closure", 8, 0, function() {
      return {func: 1, ret: {func: 1, args: [,]}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,]}]};
    }, 72, [], 62, [], 34, [], 9, [], "_rootRegisterUnaryCallback"],
    _rootRegisterBinaryCallback: [function($self, $parent, zone, f) {
      return f;
    }, "call$4", "async___rootRegisterBinaryCallback$closure", 8, 0, function() {
      return {func: 1, ret: {func: 1, args: [,,]}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,,]}]};
    }, 72, [], 62, [], 34, [], 9, [], "_rootRegisterBinaryCallback"],
    _rootErrorCallback: [function($self, $parent, zone, error, stackTrace) {
      return;
    }, "call$5", "async___rootErrorCallback$closure", 10, 0, 387, 72, [], 62, [], 34, [], 8, [], 12, [], "_rootErrorCallback"],
    _rootScheduleMicrotask: [function($self, $parent, zone, f) {
      var t1 = C.C__RootZone !== zone;
      if (t1)
        f = zone.bindCallback$2$runGuarded(f, !(!t1 || C.C__RootZone.get$errorZone() === zone.get$errorZone()));
      P._scheduleAsyncCallback(f);
    }, "call$4", "async___rootScheduleMicrotask$closure", 8, 0, 595, 72, [], 62, [], 34, [], 9, [], "_rootScheduleMicrotask"],
    _rootCreateTimer: [function($self, $parent, zone, duration, callback) {
      return P.Timer__createTimer(duration, C.C__RootZone !== zone ? zone.bindCallback$1(callback) : callback);
    }, "call$5", "async___rootCreateTimer$closure", 10, 0, 388, 72, [], 62, [], 34, [], 59, [], 33, [], "_rootCreateTimer"],
    _rootCreatePeriodicTimer: [function($self, $parent, zone, duration, callback) {
      return P.Timer__createPeriodicTimer(duration, C.C__RootZone !== zone ? zone.bindUnaryCallback$1(callback) : callback);
    }, "call$5", "async___rootCreatePeriodicTimer$closure", 10, 0, 389, 72, [], 62, [], 34, [], 59, [], 33, [], "_rootCreatePeriodicTimer"],
    _rootPrint: [function($self, $parent, zone, line) {
      H.printString(H.S(line));
    }, "call$4", "async___rootPrint$closure", 8, 0, 390, 72, [], 62, [], 34, [], 161, [], "_rootPrint"],
    _printToZone: [function(line) {
      $.Zone__current.print$1(line);
    }, "call$1", "async___printToZone$closure", 2, 0, 19, 161, [], "_printToZone"],
    _rootFork: [function($self, $parent, zone, specification, zoneValues) {
      var valueMap, t1;
      $.printToZone = P.async___printToZone$closure();
      if (specification == null)
        specification = C._ZoneSpecification_ALf;
      else if (!(specification instanceof P._ZoneSpecification))
        throw H.wrapException(P.ArgumentError$("ZoneSpecifications must be instantiated with the provided constructor."));
      if (zoneValues == null)
        valueMap = zone instanceof P._Zone ? zone.get$_async$_map() : P.HashMap_HashMap(null, null, null, null, null);
      else
        valueMap = P.HashMap_HashMap$from(zoneValues, null, null);
      t1 = new P._CustomZone(null, null, null, null, null, null, null, null, null, null, null, null, null, null, zone, valueMap);
      t1._run = specification.get$run() != null ? new P._ZoneFunction(t1, specification.get$run(), [{func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1}]}]) : zone.get$_run();
      t1._runUnary = specification.get$runUnary() != null ? new P._ZoneFunction(t1, specification.get$runUnary(), [{func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,]},,]}]) : zone.get$_runUnary();
      t1._runBinary = specification.get$runBinary() != null ? new P._ZoneFunction(t1, specification.get$runBinary(), [{func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,,]},,,]}]) : zone.get$_runBinary();
      t1._registerCallback = specification.get$registerCallback() != null ? new P._ZoneFunction(t1, specification.get$registerCallback(), [{func: 1, ret: {func: 1}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1}]}]) : zone.get$_registerCallback();
      t1._registerUnaryCallback = specification.get$registerUnaryCallback() != null ? new P._ZoneFunction(t1, specification.get$registerUnaryCallback(), [{func: 1, ret: {func: 1, args: [,]}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,]}]}]) : zone.get$_registerUnaryCallback();
      t1._registerBinaryCallback = specification.get$registerBinaryCallback() != null ? new P._ZoneFunction(t1, specification.get$registerBinaryCallback(), [{func: 1, ret: {func: 1, args: [,,]}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,,]}]}]) : zone.get$_registerBinaryCallback();
      t1._errorCallback = specification.get$errorCallback() != null ? new P._ZoneFunction(t1, specification.get$errorCallback(), [{func: 1, ret: P.AsyncError, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Object, P.StackTrace]}]) : zone.get$_errorCallback();
      t1._scheduleMicrotask = specification.get$scheduleMicrotask() != null ? new P._ZoneFunction(t1, specification.get$scheduleMicrotask(), [{func: 1, v: true, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, v: true}]}]) : zone.get$_scheduleMicrotask();
      t1._createTimer = specification.get$createTimer() != null ? new P._ZoneFunction(t1, specification.get$createTimer(), [{func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, v: true}]}]) : zone.get$_createTimer();
      t1._createPeriodicTimer = specification.get$createPeriodicTimer() != null ? new P._ZoneFunction(t1, specification.get$createPeriodicTimer(), [{func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, v: true, args: [P.Timer]}]}]) : zone.get$_createPeriodicTimer();
      t1._print = specification.get$print() != null ? new P._ZoneFunction(t1, specification.get$print(), [{func: 1, v: true, args: [P.Zone, P.ZoneDelegate, P.Zone, P.String]}]) : zone.get$_print();
      t1._fork = specification.get$fork() != null ? new P._ZoneFunction(t1, specification.get$fork(), [{func: 1, ret: P.Zone, args: [P.Zone, P.ZoneDelegate, P.Zone, P.ZoneSpecification, P.Map]}]) : zone.get$_fork();
      t1._handleUncaughtError = specification.get$handleUncaughtError() != null ? new P._ZoneFunction(t1, specification.get$handleUncaughtError(), [{func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone,, P.StackTrace]}]) : zone.get$_handleUncaughtError();
      return t1;
    }, "call$5", "async___rootFork$closure", 10, 0, 391, 72, [], 62, [], 34, [], 198, [], 200, [], "_rootFork"],
    runZoned: [function(body, onError, zoneSpecification, zoneValues) {
      var t1, errorHandler, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, zone;
      t1 = onError != null;
      errorHandler = t1 ? new P.runZoned_closure(onError) : null;
      if (zoneSpecification == null)
        zoneSpecification = new P._ZoneSpecification(errorHandler, null, null, null, null, null, null, null, null, null, null, null, null);
      else if (errorHandler != null) {
        t2 = zoneSpecification.get$run();
        t3 = zoneSpecification.get$runUnary();
        t4 = zoneSpecification.get$runBinary();
        t5 = zoneSpecification.get$registerCallback();
        t6 = zoneSpecification.get$registerUnaryCallback();
        t7 = zoneSpecification.get$registerBinaryCallback();
        t8 = zoneSpecification.get$errorCallback();
        t9 = zoneSpecification.get$scheduleMicrotask();
        t10 = zoneSpecification.get$createTimer();
        t11 = zoneSpecification.get$createPeriodicTimer();
        t12 = zoneSpecification.get$print();
        zoneSpecification = new P._ZoneSpecification(errorHandler, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, zoneSpecification.get$fork());
      }
      zone = $.Zone__current.fork$2$specification$zoneValues(zoneSpecification, zoneValues);
      if (t1)
        return zone.runGuarded$1(body);
      else
        return zone.run$1(body);
    }, function(body) {
      return P.runZoned(body, null, null, null);
    }, function(body, onError) {
      return P.runZoned(body, onError, null, null);
    }, "call$4$onError$zoneSpecification$zoneValues", "call$1", "call$2$onError", "async__runZoned$closure", 2, 7, function() {
      return {func: 1, args: [{func: 1}], named: {onError: P.Function, zoneSpecification: P.ZoneSpecification, zoneValues: P.Map}};
    }, 0, 0, 0, 806, [], 200, [], 805, [], 20, [], "runZoned"],
    _AsyncRun__initializeScheduleImmediate_internalCallback: {
      "^": "Closure:3;_box_0",
      call$1: [function(_) {
        var t1, f;
        --init.globalState.topEventLoop._activeJsAsyncCount;
        t1 = this._box_0;
        f = t1.storedCallback;
        t1.storedCallback = null;
        f.call$0();
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _AsyncRun__initializeScheduleImmediate_internalCallback": [2],
    _AsyncRun__initializeScheduleImmediate_closure: {
      "^": "Closure:337;_box_0,div,span",
      call$1: [function(callback) {
        var t1, t2;
        ++init.globalState.topEventLoop._activeJsAsyncCount;
        this._box_0.storedCallback = callback;
        t1 = this.div;
        t2 = this.span;
        t1.firstChild ? t1.removeChild(t2) : t1.appendChild(t2);
      }, null, null, 2, 0, 337, 33, [], "call"]
    },
    "+ _AsyncRun__initializeScheduleImmediate_closure": [2],
    _AsyncRun__scheduleImmediateJsOverride_internalCallback: {
      "^": "Closure:4;callback",
      call$0: [function() {
        --init.globalState.topEventLoop._activeJsAsyncCount;
        this.callback.call$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _AsyncRun__scheduleImmediateJsOverride_internalCallback": [2],
    _AsyncRun__scheduleImmediateWithSetImmediate_internalCallback: {
      "^": "Closure:4;callback",
      call$0: [function() {
        --init.globalState.topEventLoop._activeJsAsyncCount;
        this.callback.call$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _AsyncRun__scheduleImmediateWithSetImmediate_internalCallback": [2],
    _awaitOnObject_closure: {
      "^": "Closure:3;bodyFunction",
      call$1: [function(result) {
        return this.bodyFunction.call$2(0, result);
      }, null, null, 2, 0, 3, 93, [], "call"]
    },
    "+ _awaitOnObject_closure": [2],
    _awaitOnObject_closure0: {
      "^": "Closure:80;bodyFunction",
      call$2: [function(error, stackTrace) {
        this.bodyFunction.call$2(1, new H.ExceptionAndStackTrace(error, stackTrace));
      }, null, null, 4, 0, 80, 8, [], 12, [], "call"]
    },
    "+ _awaitOnObject_closure": [2],
    _wrapJsFunctionForAsync_closure: {
      "^": "Closure:340;$protected",
      call$2: [function(errorCode, result) {
        this.$protected(errorCode, result);
      }, null, null, 4, 0, 340, 160, [], 93, [], "call"]
    },
    "+ _wrapJsFunctionForAsync_closure": [2],
    _IterationMarker: {
      "^": "Object;value<,state<",
      toString$0: [function(_) {
        return "IterationMarker(" + this.state + ", " + H.S(this.value) + ")";
      }, "call$0", "get$toString", 0, 0, 4, "toString"],
      value$1: function(arg0) {
        return this.value.call$1(arg0);
      },
      static: {
        _IterationMarker_yieldStar: function(values) {
          return new P._IterationMarker(values, 1);
        },
        _IterationMarker_endOfIteration: function() {
          return C._IterationMarker_null_2;
        },
        _IterationMarker_uncaughtError: function(error) {
          return new P._IterationMarker(error, 3);
        }
      }
    },
    "+_IterationMarker": 0,
    _SyncStarIterator: {
      "^": "Object;_body,_async$_current,_nestedIterator,_suspendedBodies",
      get$current: [function() {
        var t1 = this._nestedIterator;
        return t1 == null ? this._async$_current : t1.get$current();
      }, null, null, 1, 0, 4, "current"],
      moveNext$0: [function() {
        var t1, value, state, inner;
        for (; true;) {
          t1 = this._nestedIterator;
          if (t1 != null)
            if (t1.moveNext$0())
              return true;
            else
              this._nestedIterator = null;
          value = function(body, SUCCESS, ERROR) {
            var errorValue, errorCode = SUCCESS;
            while (true)
              try {
                return body(errorCode, errorValue);
              } catch (error) {
                errorValue = error;
                errorCode = ERROR;
              }
          }(this._body, 0, 1);
          if (value instanceof P._IterationMarker) {
            state = value.state;
            if (state === 2) {
              t1 = this._suspendedBodies;
              if (t1 == null || t1.length === 0) {
                this._async$_current = null;
                return false;
              }
              if (0 >= t1.length)
                return H.ioore(t1, -1);
              this._body = t1.pop();
              continue;
            } else {
              t1 = value.value;
              if (state === 3)
                throw t1;
              else {
                inner = J.get$iterator$ax(t1);
                if (!!inner.$is_SyncStarIterator) {
                  t1 = this._suspendedBodies;
                  if (t1 == null) {
                    t1 = [];
                    this._suspendedBodies = t1;
                  }
                  t1.push(this._body);
                  this._body = inner._body;
                  continue;
                } else {
                  this._nestedIterator = inner;
                  continue;
                }
              }
            }
          } else {
            this._async$_current = value;
            return true;
          }
        }
        return false;
      }, "call$0", "get$moveNext", 0, 0, 5, "moveNext"]
    },
    "+_SyncStarIterator": 0,
    _SyncStarIterable: {
      "^": "IterableBase;_outerHelper",
      get$iterator: [function(_) {
        return new P._SyncStarIterator(this._outerHelper(), null, null, null);
      }, null, null, 1, 0, 341, "iterator"],
      $asIterableBase: Isolate.functionThatReturnsNull,
      $asIterable: Isolate.functionThatReturnsNull,
      static: {
        _SyncStarIterable$: function(_outerHelper) {
          return new P._SyncStarIterable(_outerHelper);
        }
      }
    },
    "+_SyncStarIterable": 0,
    _BroadcastStream: {
      "^": "_ControllerStream;_async$_controller-443,$ti",
      get$isBroadcast: [function() {
        return true;
      }, null, null, 1, 0, 5, "isBroadcast"],
      "<>": [506],
      static: {
        _BroadcastStream$: [function(controller, $T) {
          return new P._BroadcastStream(controller, [$T]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [[P._StreamControllerLifecycle, T]]};
          }, this.$receiver, "_BroadcastStream");
        }, 184, [], "new _BroadcastStream"]
      }
    },
    "+_BroadcastStream": [1130],
    _BroadcastSubscription: {
      "^": "_ControllerSubscription;_eventState@-0,_async$_next@-444,_async$_previous@-444,_async$_controller-445,_onData-124,_onError-29,_onDone-90,_zone-51,_state-0,_cancelFuture-86,_pending-126,$ti",
      _expectsEvent$1: [function(eventId) {
        return J.$and$n(this._eventState, 1) === eventId;
      }, "call$1", "get$_expectsEvent", 2, 0, 32, 804, [], "_expectsEvent"],
      _toggleEventId$0: [function() {
        this._eventState = J.$xor$n(this._eventState, 1);
      }, "call$0", "get$_toggleEventId", 0, 0, 6, "_toggleEventId"],
      get$_isFiring: [function() {
        return J.$and$n(this._eventState, 2) !== 0;
      }, null, null, 1, 0, 5, "_isFiring"],
      _setRemoveAfterFiring$0: [function() {
        this._eventState = J.$or$n(this._eventState, 4);
      }, "call$0", "get$_setRemoveAfterFiring", 0, 0, 6, "_setRemoveAfterFiring"],
      get$_removeAfterFiring: [function() {
        return J.$and$n(this._eventState, 4) !== 0;
      }, null, null, 1, 0, 5, "_removeAfterFiring"],
      _onPause$0: [function() {
      }, "call$0", "get$_onPause", 0, 0, 6, "_onPause"],
      _onResume$0: [function() {
      }, "call$0", "get$_onResume", 0, 0, 6, "_onResume"],
      "<>": [392],
      static: {
        "^": "_BroadcastSubscription__STATE_EVENT_ID<-0,_BroadcastSubscription__STATE_FIRING<-0,_BroadcastSubscription__STATE_REMOVE_AFTER_FIRING<-0",
        _BroadcastSubscription$: [function(controller, onData, onError, onDone, cancelOnError, $T) {
          var t1, t2;
          t1 = $.Zone__current;
          t2 = cancelOnError === true ? 1 : 0;
          t2 = new P._BroadcastSubscription(0, null, null, controller, null, null, null, t1, t2, null, null, [$T]);
          t2._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, $T);
          t2._async$_previous = t2;
          t2._async$_next = t2;
          return t2;
        }, null, null, 10, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [[P._StreamControllerLifecycle, T], {func: 1, v: true, args: [T]}, P.Function, {func: 1, v: true}, P.bool]};
          }, this.$receiver, "_BroadcastSubscription");
        }, 184, [], 27, [], 20, [], 28, [], 24, [], "new _BroadcastSubscription"]
      }
    },
    "+_BroadcastSubscription": [1138],
    _BroadcastStreamController: {
      "^": "Object;onListen@-47,onCancel@-101,_state@-0,_firstSubscription@-84,_lastSubscription@-84,_addStreamState@-210,_doneFuture@-66,$ti",
      get$onPause: [function() {
        throw H.wrapException(new P.UnsupportedError("Broadcast stream controllers do not support pause callbacks"));
      }, null, null, 1, 0, 345, "onPause"],
      set$onPause: [function(onPauseHandler) {
        throw H.wrapException(new P.UnsupportedError("Broadcast stream controllers do not support pause callbacks"));
      }, null, null, 3, 0, 37, 803, [], "onPause"],
      get$onResume: [function() {
        throw H.wrapException(new P.UnsupportedError("Broadcast stream controllers do not support pause callbacks"));
      }, null, null, 1, 0, 345, "onResume"],
      set$onResume: [function(onResumeHandler) {
        throw H.wrapException(new P.UnsupportedError("Broadcast stream controllers do not support pause callbacks"));
      }, null, null, 3, 0, 37, 802, [], "onResume"],
      get$stream: [function() {
        return new P._BroadcastStream(this, this.$ti);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Stream, T]};
        }, this.$receiver, "_BroadcastStreamController");
      }, "stream"],
      get$sink: [function() {
        return new P._StreamSinkWrapper(this, this.$ti);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.StreamSink, T]};
        }, this.$receiver, "_BroadcastStreamController");
      }, "sink"],
      get$isClosed: [function() {
        return J.$and$n(this._state, 4) !== 0;
      }, null, null, 1, 0, 5, "isClosed"],
      get$isPaused: [function() {
        return false;
      }, null, null, 1, 0, 5, "isPaused"],
      get$hasListener: [function() {
        return this._firstSubscription != null;
      }, null, null, 1, 0, 5, "hasListener"],
      get$_hasOneListener: [function() {
        var t1, t2;
        t1 = this._firstSubscription;
        t2 = this._lastSubscription;
        return t1 == null ? t2 == null : t1 === t2;
      }, null, null, 1, 0, 5, "_hasOneListener"],
      get$_isFiring: [function() {
        return J.$and$n(this._state, 2) !== 0;
      }, null, null, 1, 0, 5, "_isFiring"],
      get$_isAddingStream: [function() {
        return J.$and$n(this._state, 8) !== 0;
      }, null, null, 1, 0, 5, "_isAddingStream"],
      get$_mayAddEvent: [function() {
        return J.$lt$n(this._state, 4);
      }, null, null, 1, 0, 5, "_mayAddEvent"],
      _ensureDoneFuture$0: [function() {
        var t1 = this._doneFuture;
        if (t1 != null)
          return t1;
        t1 = new P._Future(0, $.Zone__current, null, [null]);
        this._doneFuture = t1;
        return t1;
      }, "call$0", "get$_ensureDoneFuture", 0, 0, 346, "_ensureDoneFuture"],
      get$_isEmpty: [function() {
        return this._firstSubscription == null;
      }, null, null, 1, 0, 5, "_isEmpty"],
      _addListener$1: [function(subscription) {
        var oldLast;
        subscription.set$_eventState(J.$and$n(this._state, 1));
        oldLast = this._lastSubscription;
        this._lastSubscription = subscription;
        subscription.set$_async$_next(null);
        subscription.set$_async$_previous(oldLast);
        if (oldLast == null)
          this._firstSubscription = subscription;
        else
          oldLast.set$_async$_next(subscription);
      }, "call$1", "get$_addListener", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [[P._BroadcastSubscription, T]]};
        }, this.$receiver, "_BroadcastStreamController");
      }, 50, [], "_addListener"],
      _removeListener$1: [function(subscription) {
        var previous, next;
        previous = subscription.get$_async$_previous();
        next = subscription.get$_async$_next();
        if (previous == null)
          this._firstSubscription = next;
        else
          previous.set$_async$_next(next);
        if (next == null)
          this._lastSubscription = previous;
        else
          next.set$_async$_previous(previous);
        subscription.set$_async$_previous(subscription);
        subscription.set$_async$_next(subscription);
      }, "call$1", "get$_removeListener", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [[P._BroadcastSubscription, T]]};
        }, this.$receiver, "_BroadcastStreamController");
      }, 50, [], "_removeListener"],
      _subscribe$4: [function(onData, onError, onDone, cancelOnError) {
        var t1, t2, subscription;
        if (J.$and$n(this._state, 4) !== 0) {
          if (onDone == null)
            onDone = P.async___nullDoneHandler$closure();
          t1 = new P._DoneStreamSubscription($.Zone__current, 0, onDone, this.$ti);
          t1._schedule$0();
          return t1;
        }
        t1 = $.Zone__current;
        t2 = cancelOnError === true ? 1 : 0;
        subscription = new P._BroadcastSubscription(0, null, null, this, null, null, null, t1, t2, null, null, this.$ti);
        subscription._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, H.getTypeArgumentByIndex(this, 0));
        subscription._async$_previous = subscription;
        subscription._async$_next = subscription;
        this._addListener$1(subscription);
        t1 = this._firstSubscription;
        t2 = this._lastSubscription;
        if (t1 == null ? t2 == null : t1 === t2)
          P._runGuarded(this.onListen);
        return subscription;
      }, "call$4", "get$_subscribe", 8, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.StreamSubscription, T], args: [{func: 1, v: true, args: [T]}, P.Function, {func: 1, v: true}, P.bool]};
        }, this.$receiver, "_BroadcastStreamController");
      }, 27, [], 20, [], 28, [], 24, [], "_subscribe"],
      _recordCancel$1: [function(sub) {
        var t1 = sub.get$_async$_next();
        if (t1 == null ? sub == null : t1 === sub)
          return;
        if (sub.get$_isFiring())
          sub._setRemoveAfterFiring$0();
        else {
          this._removeListener$1(sub);
          if (J.$and$n(this._state, 2) === 0 && this._firstSubscription == null)
            this._callOnCancel$0();
        }
        return;
      }, "call$1", "get$_recordCancel", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: P.Future, args: [[P.StreamSubscription, T]]};
        }, this.$receiver, "_BroadcastStreamController");
      }, 800, [], "_recordCancel"],
      _recordPause$1: [function(subscription) {
      }, "call$1", "get$_recordPause", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [[P.StreamSubscription, T]]};
        }, this.$receiver, "_BroadcastStreamController");
      }, 50, [], "_recordPause"],
      _recordResume$1: [function(subscription) {
      }, "call$1", "get$_recordResume", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [[P.StreamSubscription, T]]};
        }, this.$receiver, "_BroadcastStreamController");
      }, 50, [], "_recordResume"],
      _addEventError$0: ["super$_BroadcastStreamController$_addEventError", function() {
        if (J.$and$n(this._state, 4) !== 0)
          return new P.StateError("Cannot add new events after calling close");
        return new P.StateError("Cannot add new events while doing an addStream");
      }, "call$0", "get$_addEventError", 0, 0, 347, "_addEventError"],
      add$1: ["super$_BroadcastStreamController$add", function(_, data) {
        if (!this.get$_mayAddEvent())
          throw H.wrapException(this._addEventError$0());
        this._sendData$1(data);
      }, "call$1", "get$add", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "_BroadcastStreamController");
      }, 21, [], "add"],
      addError$2: [function(error, stackTrace) {
        var replacement;
        if (error == null)
          error = new P.NullThrownError();
        if (!this.get$_mayAddEvent())
          throw H.wrapException(this._addEventError$0());
        replacement = $.Zone__current.errorCallback$2(error, stackTrace);
        if (replacement != null) {
          error = replacement.get$error();
          if (error == null)
            error = new P.NullThrownError();
          stackTrace = replacement.get$stackTrace();
        }
        this._sendError$2(error, stackTrace);
      }, function(error) {
        return this.addError$2(error, null);
      }, "addError$1", "call$2", "call$1", "get$addError", 2, 2, 48, 0, 8, [], 12, [], "addError"],
      close$0: ["super$_BroadcastStreamController$close", function() {
        if (J.$and$n(this._state, 4) !== 0)
          return this._doneFuture;
        if (!this.get$_mayAddEvent())
          throw H.wrapException(this._addEventError$0());
        this._state = J.$or$n(this._state, 4);
        var doneFuture = this._ensureDoneFuture$0();
        this._sendDone$0();
        return doneFuture;
      }, "call$0", "get$close", 0, 0, 18, "close"],
      get$done: [function() {
        return this._ensureDoneFuture$0();
      }, null, null, 1, 0, 18, "done"],
      addStream$2$cancelOnError: [function(stream, cancelOnError) {
        var t1;
        if (!this.get$_mayAddEvent())
          throw H.wrapException(this._addEventError$0());
        this._state = J.$or$n(this._state, 8);
        t1 = P._AddStreamState$(this, stream, cancelOnError, null);
        this._addStreamState = t1;
        return t1.addStreamFuture;
      }, function(stream) {
        return this.addStream$2$cancelOnError(stream, true);
      }, "addStream$1", "call$2$cancelOnError", "call$1", "get$addStream", 2, 3, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: P.Future, args: [[P.Stream, T]], named: {cancelOnError: P.bool}};
        }, this.$receiver, "_BroadcastStreamController");
      }, 25, 37, [], 24, [], "addStream"],
      _async$_add$1: [function(data) {
        this._sendData$1(data);
      }, "call$1", "get$_async$_add", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "_BroadcastStreamController");
      }, 21, [], "_async$_add"],
      _addError$2: [function(error, stackTrace) {
        this._sendError$2(error, stackTrace);
      }, "call$2", "get$_addError", 4, 0, 49, 8, [], 12, [], "_addError"],
      _async$_close$0: [function() {
        var addState = this._addStreamState;
        this._addStreamState = null;
        this._state = J.$and$n(this._state, 4294967287);
        addState.complete$0();
      }, "call$0", "get$_async$_close", 0, 0, 6, "_async$_close"],
      _forEachListener$1: [function(action) {
        var id, subscription, next;
        if (J.$and$n(this._state, 2) !== 0)
          throw H.wrapException(new P.StateError("Cannot fire new event. Controller is already firing an event"));
        if (this._firstSubscription == null)
          return;
        id = J.$and$n(this._state, 1);
        this._state = J.$xor$n(this._state, 3);
        subscription = this._firstSubscription;
        for (; subscription != null;)
          if (subscription._expectsEvent$1(id)) {
            subscription.set$_eventState(J.$or$n(subscription.get$_eventState(), 2));
            action.call$1(subscription);
            subscription._toggleEventId$0();
            next = subscription.get$_async$_next();
            if (subscription.get$_removeAfterFiring())
              this._removeListener$1(subscription);
            subscription.set$_eventState(J.$and$n(subscription.get$_eventState(), 4294967293));
            subscription = next;
          } else
            subscription = subscription.get$_async$_next();
        this._state = J.$and$n(this._state, 4294967293);
        if (this._firstSubscription == null)
          this._callOnCancel$0();
      }, "call$1", "get$_forEachListener", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [{func: 1, v: true, args: [[P._BufferingStreamSubscription, T]]}]};
        }, this.$receiver, "_BroadcastStreamController");
      }, 71, [], "_forEachListener"],
      _callOnCancel$0: ["super$_BroadcastStreamController$_callOnCancel", function() {
        if (J.$and$n(this._state, 4) !== 0 && this._doneFuture.get$_mayComplete())
          this._doneFuture._asyncComplete$1(null);
        P._runGuarded(this.onCancel);
      }, "call$0", "get$_callOnCancel", 0, 0, 6, "_callOnCancel"],
      onListen$0: function() {
        return this.onListen.call$0();
      },
      onCancel$0: function() {
        return this.onCancel.call$0();
      },
      onResume$0: function() {
        return this.get$onResume().call$0();
      },
      "<>": [141],
      static: {
        "^": "_BroadcastStreamController__STATE_INITIAL<-0,_BroadcastStreamController__STATE_EVENT_ID<-0,_BroadcastStreamController__STATE_FIRING<-0,_BroadcastStreamController__STATE_CLOSED<-0,_BroadcastStreamController__STATE_ADDSTREAM<-0",
        _BroadcastStreamController$: [function(onListen, onCancel, $T) {
          return new P._BroadcastStreamController(onListen, onCancel, 0, null, null, null, null, [$T]);
        }, null, null, 4, 0, 562, 94, [], 95, [], "new _BroadcastStreamController"]
      }
    },
    "+_BroadcastStreamController": [1, 1144, 1145, 1146, 1147],
    _SyncBroadcastStreamController: {
      "^": "_BroadcastStreamController;onListen-47,onCancel-101,_state-0,_firstSubscription-84,_lastSubscription-84,_addStreamState-210,_doneFuture-66,$ti",
      get$_mayAddEvent: [function() {
        return P._BroadcastStreamController.prototype.get$_mayAddEvent.call(this) === true && J.$and$n(this._state, 2) === 0;
      }, null, null, 1, 0, 5, "_mayAddEvent"],
      _addEventError$0: [function() {
        if (J.$and$n(this._state, 2) !== 0)
          return new P.StateError("Cannot fire new event. Controller is already firing an event");
        return this.super$_BroadcastStreamController$_addEventError();
      }, "call$0", "get$_addEventError", 0, 0, 4, "_addEventError"],
      _sendData$1: [function(data) {
        var t1 = this._firstSubscription;
        if (t1 == null)
          return;
        if (t1 === this._lastSubscription) {
          this._state = J.$or$n(this._state, 2);
          this._firstSubscription._async$_add$1(data);
          this._state = J.$and$n(this._state, 4294967293);
          if (this._firstSubscription == null)
            this._callOnCancel$0();
          return;
        }
        this._forEachListener$1(new P._SyncBroadcastStreamController__sendData_closure(this, data));
      }, "call$1", "get$_sendData", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "_SyncBroadcastStreamController");
      }, 21, [], "_sendData"],
      _sendError$2: [function(error, stackTrace) {
        if (this._firstSubscription == null)
          return;
        this._forEachListener$1(new P._SyncBroadcastStreamController__sendError_closure(this, error, stackTrace));
      }, "call$2", "get$_sendError", 4, 0, 49, 8, [], 12, [], "_sendError"],
      _sendDone$0: [function() {
        if (this._firstSubscription != null)
          this._forEachListener$1(new P._SyncBroadcastStreamController__sendDone_closure(this));
        else
          this._doneFuture._asyncComplete$1(null);
      }, "call$0", "get$_sendDone", 0, 0, 6, "_sendDone"],
      "<>": [393],
      static: {
        _SyncBroadcastStreamController$: [function(onListen, onCancel, $T) {
          return new P._SyncBroadcastStreamController(onListen, onCancel, 0, null, null, null, null, [$T]);
        }, null, null, 4, 0, 252, 94, [], 95, [], "new _SyncBroadcastStreamController"]
      }
    },
    "+_SyncBroadcastStreamController": [1148, 1149],
    _SyncBroadcastStreamController__sendData_closure: {
      "^": "Closure;$this,data",
      call$1: [function(subscription) {
        subscription._async$_add$1(this.data);
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [[P._BufferingStreamSubscription, T]]};
        }, this.$receiver, "_SyncBroadcastStreamController");
      }, 50, [], "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [[P._BufferingStreamSubscription, T]]};
        }, this.$this, "_SyncBroadcastStreamController");
      }
    },
    "+ _SyncBroadcastStreamController__sendData_closure": [2],
    _SyncBroadcastStreamController__sendError_closure: {
      "^": "Closure;$this,error,stackTrace",
      call$1: [function(subscription) {
        subscription._addError$2(this.error, this.stackTrace);
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [[P._BufferingStreamSubscription, T]]};
        }, this.$receiver, "_SyncBroadcastStreamController");
      }, 50, [], "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [[P._BufferingStreamSubscription, T]]};
        }, this.$this, "_SyncBroadcastStreamController");
      }
    },
    "+ _SyncBroadcastStreamController__sendError_closure": [2],
    _SyncBroadcastStreamController__sendDone_closure: {
      "^": "Closure;$this",
      call$1: [function(subscription) {
        subscription._async$_close$0();
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [[P._BufferingStreamSubscription, T]]};
        }, this.$receiver, "_SyncBroadcastStreamController");
      }, 50, [], "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [[P._BufferingStreamSubscription, T]]};
        }, this.$this, "_SyncBroadcastStreamController");
      }
    },
    "+ _SyncBroadcastStreamController__sendDone_closure": [2],
    _AsyncBroadcastStreamController: {
      "^": "_BroadcastStreamController;onListen-47,onCancel-101,_state-0,_firstSubscription-84,_lastSubscription-84,_addStreamState-210,_doneFuture-66,$ti",
      _sendData$1: [function(data) {
        var subscription, t1;
        for (subscription = this._firstSubscription, t1 = this.$ti; subscription != null; subscription = subscription.get$_async$_next())
          subscription._addPending$1(new P._DelayedData(data, null, t1));
      }, "call$1", "get$_sendData", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "_AsyncBroadcastStreamController");
      }, 21, [], "_sendData"],
      _sendError$2: [function(error, stackTrace) {
        var subscription;
        for (subscription = this._firstSubscription; subscription != null; subscription = subscription.get$_async$_next())
          subscription._addPending$1(new P._DelayedError(error, stackTrace, null));
      }, "call$2", "get$_sendError", 4, 0, 49, 8, [], 12, [], "_sendError"],
      _sendDone$0: [function() {
        var subscription = this._firstSubscription;
        if (subscription != null)
          for (; subscription != null; subscription = subscription.get$_async$_next())
            subscription._addPending$1(C.C__DelayedDone);
        else
          this._doneFuture._asyncComplete$1(null);
      }, "call$0", "get$_sendDone", 0, 0, 6, "_sendDone"],
      "<>": [503],
      static: {
        _AsyncBroadcastStreamController$: [function(onListen, onCancel, $T) {
          return new P._AsyncBroadcastStreamController(onListen, onCancel, 0, null, null, null, null, [$T]);
        }, null, null, 4, 0, 252, 94, [], 95, [], "new _AsyncBroadcastStreamController"]
      }
    },
    "+_AsyncBroadcastStreamController": [1150],
    _AsBroadcastStreamController: {
      "^": "_SyncBroadcastStreamController;_pending@-1151,onListen-47,onCancel-101,_state-0,_firstSubscription-84,_lastSubscription-84,_addStreamState-210,_doneFuture-66,$ti",
      get$_hasPending: [function() {
        var t1 = this._pending;
        return t1 != null && J.get$isEmpty$asx(t1) !== true;
      }, null, null, 1, 0, 5, "_hasPending"],
      _addPendingEvent$1: [function($event) {
        var t1 = this._pending;
        if (t1 == null) {
          t1 = new P._StreamImplEvents(null, null, 0, this.$ti);
          this._pending = t1;
        }
        J.add$1$ax(t1, $event);
      }, "call$1", "get$_addPendingEvent", 2, 0, 201, 110, [], "_addPendingEvent"],
      add$1: [function(_, data) {
        var t1, t2;
        if (J.$and$n(this._state, 4) === 0 && J.$and$n(this._state, 2) !== 0) {
          t1 = this.$ti;
          t2 = this._pending;
          if (t2 == null) {
            t2 = new P._StreamImplEvents(null, null, 0, t1);
            this._pending = t2;
          }
          J.add$1$ax(t2, new P._DelayedData(data, null, t1));
          return;
        }
        this.super$_BroadcastStreamController$add(0, data);
        while (true) {
          t1 = this._pending;
          if (!(t1 != null && J.get$isEmpty$asx(t1) !== true))
            break;
          this._pending.handleNext$1(this);
        }
      }, "call$1", "get$add", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "_AsBroadcastStreamController");
      }, 21, [], "add"],
      addError$2: [function(error, stackTrace) {
        var t1;
        if (J.$and$n(this._state, 4) === 0 && J.$and$n(this._state, 2) !== 0) {
          this._addPendingEvent$1(new P._DelayedError(error, stackTrace, null));
          return;
        }
        if (!(P._BroadcastStreamController.prototype.get$_mayAddEvent.call(this) === true && J.$and$n(this._state, 2) === 0))
          throw H.wrapException(this._addEventError$0());
        this._sendError$2(error, stackTrace);
        while (true) {
          t1 = this._pending;
          if (!(t1 != null && J.get$isEmpty$asx(t1) !== true))
            break;
          this._pending.handleNext$1(this);
        }
      }, function(error) {
        return this.addError$2(error, null);
      }, "addError$1", "call$2", "call$1", "get$addError", 2, 2, 48, 0, 8, [], 12, [], "addError"],
      close$0: [function() {
        if (J.$and$n(this._state, 4) === 0 && J.$and$n(this._state, 2) !== 0) {
          this._addPendingEvent$1(C.C__DelayedDone);
          this._state = J.$or$n(this._state, 4);
          return P._BroadcastStreamController.prototype.get$done.call(this);
        }
        return this.super$_BroadcastStreamController$close();
      }, "call$0", "get$close", 0, 0, 18, "close"],
      _callOnCancel$0: [function() {
        var t1 = this._pending;
        if (t1 != null && J.get$isEmpty$asx(t1) !== true) {
          J.clear$0$ax(this._pending);
          this._pending = null;
        }
        this.super$_BroadcastStreamController$_callOnCancel();
      }, "call$0", "get$_callOnCancel", 0, 0, 6, "_callOnCancel"],
      "<>": [280],
      static: {
        _AsBroadcastStreamController$: [function(onListen, onCancel, $T) {
          return new P._AsBroadcastStreamController(null, onListen, onCancel, 0, null, null, null, null, [$T]);
        }, null, null, 4, 0, 252, 94, [], 95, [], "new _AsBroadcastStreamController"]
      }
    },
    "+_AsBroadcastStreamController": [1152, 1153],
    DeferredLibrary: {
      "^": "Object;libraryName<-9,uri<-9",
      load$0: [function() {
        throw H.wrapException('DeferredLibrary not supported. please use the `import "lib.dart" deferred as lib` syntax.');
      }, "call$0", "get$load", 0, 0, 351, "load"],
      "@": function() {
        return [C.Deprecated_adS];
      },
      static: {
        DeferredLibrary$: [function(libraryName, uri) {
          return new P.DeferredLibrary(libraryName, uri);
        }, null, null, 2, 3, 564, 0, 388, [], 40, [], "new DeferredLibrary"]
      }
    },
    "+DeferredLibrary": [1],
    DeferredLoadException: {
      "^": "Object;_s<-9",
      toString$0: [function(_) {
        return "DeferredLoadException: '" + H.S(this._s) + "'";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isException: 1,
      static: {
        DeferredLoadException$: [function(_s) {
          return new P.DeferredLoadException(_s);
        }, null, null, 2, 0, 13, 845, [], "new DeferredLoadException"]
      }
    },
    "+DeferredLoadException": [1, 102],
    FutureOr: {
      "^": "Object;$ti",
      "<>": [911],
      static: {
        FutureOr$_: [function($T) {
          H.throwExpression(new P.UnsupportedError("FutureOr can't be instantiated"));
          return new P.FutureOr([$T]);
        }, null, null, 0, 0, 4, "new FutureOr$_"]
      }
    },
    "+FutureOr": [1],
    Future: {
      "^": "Object;$ti",
      "<>": [966],
      static: {
        "^": "Future__nullFuture<-66",
        Future_Future: [function(computation, $T) {
          var result = new P._Future(0, $.Zone__current, null, [$T]);
          P.Timer_Timer(C.Duration_0, new P.closure3(computation, result));
          return result;
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P.Future, T], args: [{func: 1}]};
          }, this.$receiver, "Future");
        }, 183, [], "new Future"],
        Future_Future$microtask: [function(computation, $T) {
          var result = new P._Future(0, $.Zone__current, null, [$T]);
          P.scheduleMicrotask(new P.closure13(computation, result));
          return result;
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P.Future, T], args: [{func: 1}]};
          }, this.$receiver, "Future");
        }, 183, [], "new Future$microtask"],
        Future_Future$sync: [function(computation, $T) {
          var result, error, stackTrace, t1, exception;
          try {
            result = computation.call$0();
            t1 = new P._Future(0, $.Zone__current, null, [$T]);
            t1._asyncComplete$1(result);
            return t1;
          } catch (exception) {
            t1 = H.unwrapException(exception);
            error = t1;
            stackTrace = H.getTraceFromException(exception);
            return P.Future_Future$error(error, stackTrace, $T);
          }
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P.Future, T], args: [{func: 1}]};
          }, this.$receiver, "Future");
        }, 183, [], "new Future$sync"],
        Future_Future$value: [function(value, $T) {
          var t1 = new P._Future(0, $.Zone__current, null, [$T]);
          t1._asyncComplete$1(value);
          return t1;
        }, null, null, 0, 2, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P.Future, T], opt: [,]};
          }, this.$receiver, "Future");
        }, 0, 1, [], "new Future$value"],
        Future_Future$error: [function(error, stackTrace, $T) {
          var t1, replacement;
          if (error == null)
            error = new P.NullThrownError();
          t1 = $.Zone__current;
          if (t1 !== C.C__RootZone) {
            replacement = t1.errorCallback$2(error, stackTrace);
            if (replacement != null) {
              error = replacement.get$error();
              if (error == null)
                error = new P.NullThrownError();
              stackTrace = replacement.get$stackTrace();
            }
          }
          t1 = new P._Future(0, $.Zone__current, null, [$T]);
          t1._asyncCompleteError$2(error, stackTrace);
          return t1;
        }, null, null, 2, 2, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P.Future, T], args: [P.Object], opt: [P.StackTrace]};
          }, this.$receiver, "Future");
        }, 0, 8, [], 12, [], "new Future$error"],
        Future_Future$delayed: [function(duration, computation, $T) {
          var result = new P._Future(0, $.Zone__current, null, [$T]);
          P.Timer_Timer(duration, new P.closure14(computation, result));
          return result;
        }, null, null, 2, 2, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P.Future, T], args: [P.Duration], opt: [{func: 1}]};
          }, this.$receiver, "Future");
        }, 0, 59, [], 183, [], "new Future$delayed"],
        Future_wait: [function(futures, cleanUp, eagerError) {
          var t1, result, handleError, future, pos, e, st, t2, values, exception;
          t1 = {};
          result = new P._Future(0, $.Zone__current, null, [P.List]);
          t1.values = null;
          t1.remaining = 0;
          t1.error = null;
          t1.stackTrace = null;
          handleError = new P.Future_wait_handleError(t1, eagerError, cleanUp, result);
          try {
            for (t2 = J.get$iterator$ax(futures); t2.moveNext$0();) {
              future = t2.get$current();
              pos = t1.remaining;
              future.then$2$onError(new P.Future_wait_closure(t1, eagerError, cleanUp, result, pos), handleError);
              ++t1.remaining;
            }
            t2 = t1.remaining;
            if (t2 === 0) {
              t2 = new P._Future(0, $.Zone__current, null, [null]);
              t2._asyncComplete$1(C.List_empty);
              return t2;
            }
            values = new Array(t2);
            values.fixed$length = Array;
            t1.values = values;
          } catch (exception) {
            t2 = H.unwrapException(exception);
            e = t2;
            st = H.getTraceFromException(exception);
            if (t1.remaining === 0 || eagerError === true)
              return P.Future_Future$error(e, st, null);
            else {
              t1.error = e;
              t1.stackTrace = st;
            }
          }
          return result;
        }, function(futures) {
          return P.Future_wait(futures, null, false);
        }, "call$3$cleanUp$eagerError", "call$1", "async_Future_wait$closure", 2, 5, function() {
          return {func: 1, ret: [P.Future, P.List], args: [[P.Iterable, P.Future]], named: {cleanUp: {func: 1, v: true, args: [,]}, eagerError: P.bool}};
        }, 4, 0, 310, [], 843, [], 841, [], "wait"],
        Future_any: [function(futures) {
          var completer, onValue, onError, t1;
          completer = new P._SyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]);
          onValue = new P.Future_any_closure(completer);
          onError = new P.Future_any_closure0(completer);
          for (t1 = J.get$iterator$ax(futures); t1.moveNext$0();)
            t1.get$current().then$2$onError(onValue, onError);
          return completer.future;
        }, "call$1", "async_Future_any$closure", 2, 0, function() {
          return {func: 1, ret: P.Future, args: [[P.Iterable, P.Future]]};
        }, 310, [], "any"],
        Future_forEach: [function(input, f) {
          return P.Future_doWhile(new P.Future_forEach_closure(f, J.get$iterator$ax(input)));
        }, "call$2", "async_Future_forEach$closure", 4, 0, function() {
          return {func: 1, ret: P.Future, args: [P.Iterable, {func: 1, args: [,]}]};
        }, 58, [], 9, [], "forEach"],
        Future_doWhile: [function(f) {
          var t1, t2, doneSignal, nextIteration;
          t1 = {};
          t2 = $.Zone__current;
          doneSignal = new P._Future(0, t2, null, [null]);
          t1.nextIteration = null;
          nextIteration = t2.bindUnaryCallback$2$runGuarded(new P.Future_doWhile_closure(t1, f, doneSignal), true);
          t1.nextIteration = nextIteration;
          nextIteration.call$1(true);
          return doneSignal;
        }, "call$1", "async_Future_doWhile$closure", 2, 0, 565, 9, [], "doWhile"]
      }
    },
    "+Future": [1],
    closure3: {
      "^": "Closure:4;computation,result",
      call$0: [function() {
        var e, s, exception, t1;
        try {
          this.result._complete$1(this.computation.call$0());
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          P._completeWithErrorCallback(this.result, e, s);
        }
      }, null, null, 0, 0, 4, "call"]
    },
    "+ closure": [2],
    closure13: {
      "^": "Closure:4;computation,result",
      call$0: [function() {
        var e, s, exception, t1;
        try {
          this.result._complete$1(this.computation.call$0());
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          P._completeWithErrorCallback(this.result, e, s);
        }
      }, null, null, 0, 0, 4, "call"]
    },
    "+ closure": [2],
    closure14: {
      "^": "Closure:4;computation,result",
      call$0: [function() {
        var e, s, t1, exception;
        try {
          t1 = this.computation;
          t1 = t1 == null ? t1 : t1.call$0();
          this.result._complete$1(t1);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          P._completeWithErrorCallback(this.result, e, s);
        }
      }, null, null, 0, 0, 4, "call"]
    },
    "+ closure": [2],
    Future_wait_handleError: {
      "^": "Closure:12;_box_0,eagerError,cleanUp,result",
      call$2: [function(theError, theStackTrace) {
        var t1, t2, t3, t4, _i, value;
        t1 = this._box_0;
        t2 = --t1.remaining;
        t3 = t1.values;
        if (t3 != null) {
          t2 = this.cleanUp;
          if (t2 != null)
            for (t4 = t3.length, _i = 0; _i < t4; ++_i) {
              value = t3[_i];
              if (value != null)
                P.Future_Future$sync(new P.Future_wait_handleError_closure(t2, value), null);
            }
          t1.values = null;
          if (t1.remaining === 0 || this.eagerError === true)
            this.result._completeError$2(theError, theStackTrace);
          else {
            t1.error = theError;
            t1.stackTrace = theStackTrace;
          }
        } else if (t2 === 0 && this.eagerError !== true)
          this.result._completeError$2(t1.error, t1.stackTrace);
      }, null, null, 4, 0, 12, 799, [], 797, [], "call"]
    },
    "+ Future_wait_handleError": [2],
    Future_wait_handleError_closure: {
      "^": "Closure:4;cleanUp,value",
      call$0: [function() {
        this.cleanUp.call$1(this.value);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Future_wait_handleError_closure": [2],
    Future_wait_closure: {
      "^": "Closure;_box_0,eagerError,cleanUp,result,pos",
      call$1: [function(value) {
        var t1, t2, t3;
        t1 = this._box_0;
        t2 = --t1.remaining;
        t3 = t1.values;
        if (t3 != null) {
          t1 = this.pos;
          if (t1 < 0 || t1 >= t3.length)
            return H.ioore(t3, t1);
          t3[t1] = value;
          if (t2 === 0)
            this.result._completeWithValue$1(t3);
        } else {
          t2 = this.cleanUp;
          if (t2 != null && value != null)
            P.Future_Future$sync(new P.Future_wait__closure(t2, value), null);
          if (t1.remaining === 0 && this.eagerError !== true)
            this.result._completeError$2(t1.error, t1.stackTrace);
        }
      }, null, null, 2, 0, function() {
        return {func: 1, args: [,]};
      }, 1, [], "call"],
      $signature: function() {
        return {func: 1, args: [,]};
      }
    },
    "+ Future_wait_closure": [2],
    Future_wait__closure: {
      "^": "Closure:4;cleanUp,value",
      call$0: [function() {
        this.cleanUp.call$1(this.value);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Future_wait__closure": [2],
    Future_any_closure: {
      "^": "Closure;completer",
      call$1: [function(value) {
        var t1 = this.completer;
        if (t1.future.get$_mayComplete())
          t1.complete$1(value);
      }, null, null, 2, 0, function() {
        return {func: 1, args: [,]};
      }, 1, [], "call"],
      $signature: function() {
        return {func: 1, args: [,]};
      }
    },
    "+ Future_any_closure": [2],
    Future_any_closure0: {
      "^": "Closure:12;completer",
      call$2: [function(error, stack) {
        var t1 = this.completer;
        if (t1.future.get$_mayComplete())
          t1.completeError$2(error, stack);
      }, null, null, 4, 0, 12, 8, [], 478, [], "call"]
    },
    "+ Future_any_closure": [2],
    Future_forEach_closure: {
      "^": "Closure:4;f,iterator",
      call$0: [function() {
        var t1 = this.iterator;
        if (!t1.moveNext$0())
          return false;
        return P.Future_Future$sync(new P.Future_forEach__closure(this.f, t1), null).then$1(new P.Future_forEach__closure0());
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Future_forEach_closure": [2],
    Future_forEach__closure: {
      "^": "Closure:4;f,iterator",
      call$0: [function() {
        return this.f.call$1(this.iterator.get$current());
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Future_forEach__closure": [2],
    Future_forEach__closure0: {
      "^": "Closure:3;",
      call$1: [function(_) {
        return true;
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ Future_forEach__closure": [2],
    Future_doWhile_closure: {
      "^": "Closure:33;_box_0,f,doneSignal",
      call$1: [function(keepGoing) {
        var t1 = this.doneSignal;
        if (keepGoing === true)
          P.Future_Future$sync(this.f, null).then$2$onError(this._box_0.nextIteration, t1.get$_completeError());
        else
          t1._complete$1(null);
      }, null, null, 2, 0, 33, 796, [], "call"]
    },
    "+ Future_doWhile_closure": [2],
    TimeoutException: {
      "^": "Object;message<-9,duration<-65",
      toString$0: [function(_) {
        var t1, result;
        t1 = this.duration;
        result = t1 != null ? "TimeoutException after " + H.S(t1) : "TimeoutException";
        t1 = this.message;
        return t1 != null ? result + ": " + H.S(t1) : result;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isException: 1,
      static: {
        TimeoutException$: [function(message, duration) {
          return new P.TimeoutException(message, duration);
        }, null, null, 2, 2, 566, 0, 17, [], 59, [], "new TimeoutException"]
      }
    },
    "+TimeoutException": [1, 102],
    Completer: {
      "^": "Object;$ti",
      "<>": [967],
      static: {
        Completer_Completer: [function($T) {
          return new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [$T]), [$T]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P.Completer, T]};
          }, this.$receiver, "Completer");
        }, "new Completer"],
        Completer_Completer$sync: [function($T) {
          return new P._SyncCompleter(new P._Future(0, $.Zone__current, null, [$T]), [$T]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P.Completer, T]};
          }, this.$receiver, "Completer");
        }, "new Completer$sync"]
      }
    },
    "+Completer": [1],
    _Completer: {
      "^": "Object;future<-238,$ti",
      completeError$2: [function(error, stackTrace) {
        var replacement;
        if (error == null)
          error = new P.NullThrownError();
        if (!this.future.get$_mayComplete())
          throw H.wrapException(new P.StateError("Future already completed"));
        replacement = $.Zone__current.errorCallback$2(error, stackTrace);
        if (replacement != null) {
          error = replacement.get$error();
          if (error == null)
            error = new P.NullThrownError();
          stackTrace = replacement.get$stackTrace();
        }
        this._completeError$2(error, stackTrace);
      }, function(error) {
        return this.completeError$2(error, null);
      }, "completeError$1", "call$2", "call$1", "get$completeError", 2, 2, 48, 0, 8, [], 12, [], "completeError"],
      get$isCompleted: [function() {
        return !this.future.get$_mayComplete();
      }, null, null, 1, 0, 5, "isCompleted"],
      "<>": [353],
      static: {
        _Completer$: [function($T) {
          return new P._Completer(new P._Future(0, $.Zone__current, null, [$T]), [$T]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P._Completer, T]};
          }, this.$receiver, "_Completer");
        }, "new _Completer"]
      }
    },
    "+_Completer": [1, 1157],
    _AsyncCompleter: {
      "^": "_Completer;future-238,$ti",
      complete$1: [function(value) {
        var t1 = this.future;
        if (!t1.get$_mayComplete())
          throw H.wrapException(new P.StateError("Future already completed"));
        t1._asyncComplete$1(value);
      }, function() {
        return this.complete$1(null);
      }, "complete$0", "call$1", "call$0", "get$complete", 0, 2, 294, 0, 1, [], "complete"],
      _completeError$2: [function(error, stackTrace) {
        this.future._asyncCompleteError$2(error, stackTrace);
      }, "call$2", "get$_completeError", 4, 0, 49, 8, [], 12, [], "_completeError"],
      "<>": [540],
      static: {
        _AsyncCompleter$: [function($T) {
          return new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [$T]), [$T]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P._AsyncCompleter, T]};
          }, this.$receiver, "_AsyncCompleter");
        }, "new _AsyncCompleter"]
      }
    },
    "+_AsyncCompleter": [1158],
    _SyncCompleter: {
      "^": "_Completer;future-238,$ti",
      complete$1: [function(value) {
        var t1 = this.future;
        if (!t1.get$_mayComplete())
          throw H.wrapException(new P.StateError("Future already completed"));
        t1._complete$1(value);
      }, function() {
        return this.complete$1(null);
      }, "complete$0", "call$1", "call$0", "get$complete", 0, 2, 294, 0, 1, [], "complete"],
      _completeError$2: [function(error, stackTrace) {
        this.future._completeError$2(error, stackTrace);
      }, "call$2", "get$_completeError", 4, 0, 49, 8, [], 12, [], "_completeError"],
      "<>": [490],
      static: {
        _SyncCompleter$: [function($T) {
          return new P._SyncCompleter(new P._Future(0, $.Zone__current, null, [$T]), [$T]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P._SyncCompleter, T]};
          }, this.$receiver, "_SyncCompleter");
        }, "new _SyncCompleter"]
      }
    },
    "+_SyncCompleter": [1159],
    _FutureListener: {
      "^": "Object;_nextListener@-1160,result<-1161,state<-0,callback<-29,errorCallback<-29,$ti",
      get$_zone: [function() {
        return this.result.get$_zone();
      }, null, null, 1, 0, 209, "_zone"],
      get$handlesValue: [function() {
        return J.$and$n(this.state, 1) !== 0;
      }, null, null, 1, 0, 5, "handlesValue"],
      get$handlesError: [function() {
        return J.$and$n(this.state, 2) !== 0;
      }, null, null, 1, 0, 5, "handlesError"],
      get$hasErrorTest: [function() {
        return J.$eq$(this.state, 6);
      }, null, null, 1, 0, 5, "hasErrorTest"],
      get$handlesComplete: [function() {
        return J.$eq$(this.state, 8);
      }, null, null, 1, 0, 5, "handlesComplete"],
      get$_onValue: [function() {
        return this.callback;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, ret: {func: 1, args: [S]}};
        }, this.$receiver, "_FutureListener");
      }, "_onValue"],
      get$_onError: [function() {
        return this.errorCallback;
      }, null, null, 1, 0, 292, "_onError"],
      get$_errorTest: [function() {
        return this.callback;
      }, null, null, 1, 0, 1240, "_errorTest"],
      get$_whenCompleteAction: [function() {
        return this.callback;
      }, null, null, 1, 0, 1287, "_whenCompleteAction"],
      get$hasErrorCallback: [function() {
        return this.errorCallback != null;
      }, null, null, 1, 0, 5, "hasErrorCallback"],
      handleValue$1: [function(sourceResult) {
        return this.result.get$_zone().runUnary$2(this.callback, sourceResult);
      }, "call$1", "get$handleValue", 2, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, args: [S]};
        }, this.$receiver, "_FutureListener");
      }, 795, [], "handleValue"],
      matchesErrorTest$1: [function(asyncError) {
        if (!J.$eq$(this.state, 6))
          return true;
        return this.result.get$_zone().runUnary$2(this.callback, asyncError.get$error());
      }, "call$1", "get$matchesErrorTest", 2, 0, 1347, 474, [], "matchesErrorTest"],
      handleError$1: [function(asyncError) {
        var t1, t2;
        t1 = this.errorCallback;
        t2 = this.result;
        if (H.functionTypeTest(t1, {func: 1, args: [,,]}))
          return t2.get$_zone().runBinary$3(t1, asyncError.get$error(), asyncError.get$stackTrace());
        else
          return t2.get$_zone().runUnary$2(t1, asyncError.get$error());
      }, "call$1", "get$handleError", 2, 0, 1349, 474, [], "handleError"],
      handleWhenComplete$0: [function() {
        return this.result.get$_zone().run$1(this.callback);
      }, "call$0", "get$handleWhenComplete", 0, 0, 4, "handleWhenComplete"],
      callback$1: function(arg0) {
        return this.callback.call$1(arg0);
      },
      errorCallback$2: function(arg0, arg1) {
        return this.errorCallback.call$2(arg0, arg1);
      },
      errorCallback$3: function(arg0, arg1, arg2) {
        return this.errorCallback.call$3(arg0, arg1, arg2);
      },
      _onError$2: function(arg0, arg1) {
        return this.get$_onError().call$2(arg0, arg1);
      },
      "<>": [965, 559],
      static: {
        "^": "_FutureListener_MASK_VALUE<-0,_FutureListener_MASK_ERROR<-0,_FutureListener_MASK_TEST_ERROR<-0,_FutureListener_MASK_WHENCOMPLETE<-0,_FutureListener_STATE_CHAIN<-0,_FutureListener_STATE_THEN<-0,_FutureListener_STATE_THEN_ONERROR<-0,_FutureListener_STATE_CATCHERROR<-0,_FutureListener_STATE_CATCHERROR_TEST<-0,_FutureListener_STATE_WHENCOMPLETE<-0",
        _FutureListener$then: [function(result, onValue, errorCallback, $S, $T) {
          var t1 = errorCallback == null ? 1 : 3;
          return new P._FutureListener(null, result, t1, onValue, errorCallback, [$S, $T]);
        }, null, null, 6, 0, function() {
          return H.computeSignature(function(S, T) {
            return {func: 1, args: [[P._Future, T], {func: 1, args: [S]}, P.Function]};
          }, this.$receiver, "_FutureListener");
        }, 93, [], 840, [], 181, [], "new _FutureListener$then"],
        _FutureListener$catchError: [function(result, errorCallback, test, $S, $T) {
          var t1 = test == null ? 2 : 6;
          return new P._FutureListener(null, result, t1, test, errorCallback, [$S, $T]);
        }, null, null, 6, 0, function() {
          return H.computeSignature(function(S, T) {
            return {func: 1, args: [[P._Future, T], P.Function, {func: 1, ret: P.bool, args: [P.Object]}]};
          }, this.$receiver, "_FutureListener");
        }, 93, [], 181, [], 11, [], "new _FutureListener$catchError"],
        _FutureListener$whenComplete: [function(result, onComplete, $S, $T) {
          return new P._FutureListener(null, result, 8, onComplete, null, [$S, $T]);
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(S, T) {
            return {func: 1, args: [[P._Future, T], {func: 1}]};
          }, this.$receiver, "_FutureListener");
        }, 93, [], 838, [], "new _FutureListener$whenComplete"]
      }
    },
    "+_FutureListener": [1],
    _Future: {
      "^": "Object;_state@-0,_zone<-51,_resultOrListeners@-10,$ti",
      get$_mayComplete: [function() {
        return J.$eq$(this._state, 0);
      }, null, null, 1, 0, 5, "_mayComplete"],
      get$_isPendingComplete: [function() {
        return J.$eq$(this._state, 1);
      }, null, null, 1, 0, 5, "_isPendingComplete"],
      get$_mayAddListener: [function() {
        return J.$le$n(this._state, 1);
      }, null, null, 1, 0, 5, "_mayAddListener"],
      get$_isChained: [function() {
        return J.$eq$(this._state, 2);
      }, null, null, 1, 0, 5, "_isChained"],
      get$_isComplete: [function() {
        return J.$ge$n(this._state, 4);
      }, null, null, 1, 0, 5, "_isComplete"],
      get$_hasError: [function() {
        return J.$eq$(this._state, 8);
      }, null, null, 1, 0, 5, "_hasError"],
      _setChained$1: [function(source) {
        this._state = 2;
        this._resultOrListeners = source;
      }, "call$1", "get$_setChained", 2, 0, 363, 19, [], "_setChained"],
      then$2$onError: [function(f, onError) {
        var currentZone = $.Zone__current;
        if (currentZone !== C.C__RootZone) {
          f = currentZone.registerUnaryCallback$1(f);
          if (onError != null)
            onError = P._registerErrorHandler(onError, currentZone);
        }
        return this._thenNoZoneRegistration$2(f, onError);
      }, function(f) {
        return this.then$2$onError(f, null);
      }, "then$1", "call$2$onError", "call$1", "get$then", 2, 3, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: P.Future, args: [{func: 1, args: [T]}], named: {onError: P.Function}};
        }, this.$receiver, "_Future");
      }, 0, 9, [], 20, [], "then"],
      _thenNoZoneRegistration$2: [function(f, onError) {
        var result, t1;
        result = new P._Future(0, $.Zone__current, null, [null]);
        t1 = onError == null ? 1 : 3;
        this._addListener$1(new P._FutureListener(null, result, t1, f, onError, [H.getTypeArgumentByIndex(this, 0), null]));
        return result;
      }, "call$2", "get$_thenNoZoneRegistration", 4, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: P.Future, args: [{func: 1, args: [T]}, P.Function]};
        }, this.$receiver, "_Future");
      }, 9, [], 20, [], "_thenNoZoneRegistration"],
      catchError$2$test: [function(onError, test) {
        var t1, result, t2;
        t1 = $.Zone__current;
        result = new P._Future(0, t1, null, this.$ti);
        if (t1 !== C.C__RootZone) {
          onError = P._registerErrorHandler(onError, t1);
          if (test != null)
            test = t1.registerUnaryCallback$1(test);
        }
        t1 = H.getTypeArgumentByIndex(this, 0);
        t2 = test == null ? 2 : 6;
        this._addListener$1(new P._FutureListener(null, result, t2, test, onError, [t1, t1]));
        return result;
      }, function(onError) {
        return this.catchError$2$test(onError, null);
      }, "catchError$1", "call$2$test", "call$1", "get$catchError", 2, 3, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Future, T], args: [P.Function], named: {test: {func: 1, ret: P.bool, args: [,]}}};
        }, this.$receiver, "_Future");
      }, 0, 20, [], 11, [], "catchError"],
      whenComplete$1: [function(action) {
        var t1, result;
        t1 = $.Zone__current;
        result = new P._Future(0, t1, null, this.$ti);
        if (t1 !== C.C__RootZone)
          action = t1.registerCallback$1(action);
        t1 = H.getTypeArgumentByIndex(this, 0);
        this._addListener$1(new P._FutureListener(null, result, 8, action, null, [t1, t1]));
        return result;
      }, "call$1", "get$whenComplete", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Future, T], args: [{func: 1}]};
        }, this.$receiver, "_Future");
      }, 71, [], "whenComplete"],
      asStream$0: [function() {
        return P.Stream_Stream$fromFuture(this, H.getTypeArgumentByIndex(this, 0));
      }, "call$0", "get$asStream", 0, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Stream, T]};
        }, this.$receiver, "_Future");
      }, "asStream"],
      _setPendingComplete$0: [function() {
        this._state = 1;
      }, "call$0", "get$_setPendingComplete", 0, 0, 6, "_setPendingComplete"],
      _clearPendingComplete$0: [function() {
        this._state = 0;
      }, "call$0", "get$_clearPendingComplete", 0, 0, 6, "_clearPendingComplete"],
      get$_error: [function() {
        return this._resultOrListeners;
      }, null, null, 1, 0, 1462, "_error"],
      get$_chainSource: [function() {
        return this._resultOrListeners;
      }, null, null, 1, 0, 346, "_chainSource"],
      _setValue$1: [function(value) {
        this._state = 4;
        this._resultOrListeners = value;
      }, "call$1", "get$_setValue", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "_Future");
      }, 1, [], "_setValue"],
      _setErrorObject$1: [function(error) {
        this._state = 8;
        this._resultOrListeners = error;
      }, "call$1", "get$_setErrorObject", 2, 0, 1474, 8, [], "_setErrorObject"],
      _setError$2: [function(error, stackTrace) {
        this._state = 8;
        this._resultOrListeners = new P.AsyncError(error, stackTrace);
      }, "call$2", "get$_setError", 4, 0, 49, 8, [], 12, [], "_setError"],
      _cloneResult$1: [function(source) {
        this._state = source.get$_state();
        this._resultOrListeners = source.get$_resultOrListeners();
      }, "call$1", "get$_cloneResult", 2, 0, 363, 19, [], "_cloneResult"],
      _addListener$1: [function(listener) {
        var source;
        if (J.$le$n(this._state, 1)) {
          listener.set$_nextListener(this._resultOrListeners);
          this._resultOrListeners = listener;
        } else {
          if (J.$eq$(this._state, 2)) {
            source = this._resultOrListeners;
            if (!source.get$_isComplete()) {
              source._addListener$1(listener);
              return;
            }
            this._state = source.get$_state();
            this._resultOrListeners = source.get$_resultOrListeners();
          }
          this._zone.scheduleMicrotask$1(new P._Future__addListener_closure(this, listener));
        }
      }, "call$1", "get$_addListener", 2, 0, 374, 794, [], "_addListener"],
      _prependListeners$1: [function(listeners) {
        var t1, existingListeners, cursor, source;
        t1 = {};
        t1.listeners = listeners;
        if (listeners == null)
          return;
        if (J.$le$n(this._state, 1)) {
          existingListeners = this._resultOrListeners;
          this._resultOrListeners = listeners;
          if (existingListeners != null) {
            for (cursor = listeners; cursor.get$_nextListener() != null;)
              cursor = cursor.get$_nextListener();
            cursor.set$_nextListener(existingListeners);
          }
        } else {
          if (J.$eq$(this._state, 2)) {
            source = this._resultOrListeners;
            if (!source.get$_isComplete()) {
              source._prependListeners$1(listeners);
              return;
            }
            this._state = source.get$_state();
            this._resultOrListeners = source.get$_resultOrListeners();
          }
          t1.listeners = this._reverseListeners$1(listeners);
          this._zone.scheduleMicrotask$1(new P._Future__prependListeners_closure(t1, this));
        }
      }, "call$1", "get$_prependListeners", 2, 0, 374, 315, [], "_prependListeners"],
      _removeListeners$0: [function() {
        var current = this._resultOrListeners;
        this._resultOrListeners = null;
        return this._reverseListeners$1(current);
      }, "call$0", "get$_removeListeners", 0, 0, 1664, "_removeListeners"],
      _reverseListeners$1: [function(listeners) {
        var current, prev, next;
        for (current = listeners, prev = null; current != null; prev = current, current = next) {
          next = current.get$_nextListener();
          current.set$_nextListener(prev);
        }
        return prev;
      }, "call$1", "get$_reverseListeners", 2, 0, 554, 315, [], "_reverseListeners"],
      _complete$1: [function(value) {
        var t1, listeners;
        t1 = this.$ti;
        if (H.checkSubtype(value, "$isFuture", t1, "$asFuture"))
          if (H.checkSubtype(value, "$is_Future", t1, null))
            P._Future__chainCoreFuture(value, this);
          else
            P._Future__chainForeignFuture(value, this);
        else {
          listeners = this._removeListeners$0();
          this._state = 4;
          this._resultOrListeners = value;
          P._Future__propagateToListeners(this, listeners);
        }
      }, "call$1", "get$_complete", 2, 0, 27, 1, [], "_complete"],
      _completeWithValue$1: [function(value) {
        var listeners = this._removeListeners$0();
        this._state = 4;
        this._resultOrListeners = value;
        P._Future__propagateToListeners(this, listeners);
      }, "call$1", "get$_completeWithValue", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "_Future");
      }, 1, [], "_completeWithValue"],
      _completeError$2: [function(error, stackTrace) {
        var listeners = this._removeListeners$0();
        this._state = 8;
        this._resultOrListeners = new P.AsyncError(error, stackTrace);
        P._Future__propagateToListeners(this, listeners);
      }, function(error) {
        return this._completeError$2(error, null);
      }, "_completeError$1", "call$2", "call$1", "get$_completeError", 2, 2, 48, 0, 8, [], 12, [], "_completeError"],
      _asyncComplete$1: [function(value) {
        var t1 = this.$ti;
        if (H.checkSubtype(value, "$isFuture", t1, "$asFuture")) {
          if (H.checkSubtype(value, "$is_Future", t1, null))
            if (J.$eq$(value.get$_state(), 8)) {
              this._state = 1;
              this._zone.scheduleMicrotask$1(new P._Future__asyncComplete_closure(this, value));
            } else
              P._Future__chainCoreFuture(value, this);
          else
            P._Future__chainForeignFuture(value, this);
          return;
        }
        this._state = 1;
        this._zone.scheduleMicrotask$1(new P._Future__asyncComplete_closure0(this, value));
      }, "call$1", "get$_asyncComplete", 2, 0, 27, 1, [], "_asyncComplete"],
      _asyncCompleteError$2: [function(error, stackTrace) {
        this._state = 1;
        this._zone.scheduleMicrotask$1(new P._Future__asyncCompleteError_closure(this, error, stackTrace));
      }, "call$2", "get$_asyncCompleteError", 4, 0, 71, 8, [], 12, [], "_asyncCompleteError"],
      timeout$2$onTimeout: [function(timeLimit, onTimeout) {
        var t1, t2, result;
        t1 = {};
        t1.onTimeout = onTimeout;
        if (J.$ge$n(this._state, 4)) {
          t1 = new P._Future(0, $.Zone__current, null, [null]);
          t1._asyncComplete$1(this);
          return t1;
        }
        t2 = $.Zone__current;
        result = new P._Future(0, t2, null, this.$ti);
        t1.timer = null;
        if (onTimeout == null)
          t1.timer = P.Timer_Timer(timeLimit, new P._Future_timeout_closure(timeLimit, result));
        else {
          t1.onTimeout = t2.registerCallback$1(onTimeout);
          t1.timer = P.Timer_Timer(timeLimit, new P._Future_timeout_closure0(t1, result, t2));
        }
        this.then$2$onError(new P._Future_timeout_closure1(t1, this, result), new P._Future_timeout_closure2(t1, result));
        return result;
      }, function(timeLimit) {
        return this.timeout$2$onTimeout(timeLimit, null);
      }, "timeout$1", "call$2$onTimeout", "call$1", "get$timeout", 2, 3, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Future, T], args: [P.Duration], named: {onTimeout: {func: 1}}};
        }, this.$receiver, "_Future");
      }, 0, 469, [], 468, [], "timeout"],
      $isFuture: 1,
      "<>": [542],
      static: {
        "^": "_Future__INCOMPLETE<-0,_Future__PENDING_COMPLETE<-0,_Future__CHAINED<-0,_Future__VALUE<-0,_Future__ERROR<-0",
        _Future$: [function($T) {
          return new P._Future(0, $.Zone__current, null, [$T]);
        }, null, null, 0, 0, 4, "new _Future"],
        _Future$immediate: [function(value, $T) {
          var t1 = new P._Future(0, $.Zone__current, null, [$T]);
          t1._asyncComplete$1(value);
          return t1;
        }, null, null, 2, 0, 3, 1, [], "new _Future$immediate"],
        _Future$immediateError: [function(error, stackTrace, $T) {
          var t1 = new P._Future(0, $.Zone__current, null, [$T]);
          t1._asyncCompleteError$2(error, stackTrace);
          return t1;
        }, null, null, 2, 2, 163, 0, 8, [], 12, [], "new _Future$immediateError"],
        _Future__chainForeignFuture: [function(source, target) {
          var e, s, exception, t1;
          target._setPendingComplete$0();
          try {
            source.then$2$onError(new P._Future__chainForeignFuture_closure(target), new P._Future__chainForeignFuture_closure0(target));
          } catch (exception) {
            t1 = H.unwrapException(exception);
            e = t1;
            s = H.getTraceFromException(exception);
            P.scheduleMicrotask(new P._Future__chainForeignFuture_closure1(target, e, s));
          }
        }, "call$2", "async__Future__chainForeignFuture$closure", 4, 0, 569, 19, [], 79, [], "_chainForeignFuture"],
        _Future__chainCoreFuture: [function(source, target) {
          var listeners;
          for (; source.get$_isChained();)
            source = source.get$_chainSource();
          if (source.get$_isComplete()) {
            listeners = target._removeListeners$0();
            target._cloneResult$1(source);
            P._Future__propagateToListeners(target, listeners);
          } else {
            listeners = target.get$_resultOrListeners();
            target._setChained$1(source);
            source._prependListeners$1(listeners);
          }
        }, "call$2", "async__Future__chainCoreFuture$closure", 4, 0, 570, 19, [], 79, [], "_chainCoreFuture"],
        _Future__propagateToListeners: [function(source, listeners) {
          var t1, t2, t3, hasError, asyncError, listeners0, sourceResult, zone, oldZone, t4, result;
          t1 = {};
          t1.source = source;
          for (t2 = source; true;) {
            t3 = {};
            hasError = t2.get$_hasError();
            if (listeners == null) {
              if (hasError) {
                asyncError = t1.source.get$_error();
                t1.source.get$_zone().handleUncaughtError$2(asyncError.get$error(), asyncError.get$stackTrace());
              }
              return;
            }
            for (; listeners.get$_nextListener() != null; listeners = listeners0) {
              listeners0 = listeners.get$_nextListener();
              listeners.set$_nextListener(null);
              P._Future__propagateToListeners(t1.source, listeners);
            }
            sourceResult = t1.source.get$_resultOrListeners();
            t3.listenerHasError = hasError;
            t3.listenerValueOrError = sourceResult;
            t2 = !hasError;
            if (!t2 || listeners.get$handlesValue() || listeners.get$handlesComplete()) {
              zone = listeners.get$_zone();
              if (hasError && !t1.source.get$_zone().inSameErrorZone$1(zone)) {
                asyncError = t1.source.get$_error();
                t1.source.get$_zone().handleUncaughtError$2(asyncError.get$error(), asyncError.get$stackTrace());
                return;
              }
              oldZone = $.Zone__current;
              if (oldZone == null ? zone != null : oldZone !== zone)
                $.Zone__current = zone;
              else
                oldZone = null;
              if (listeners.get$handlesComplete())
                new P._Future__propagateToListeners_handleWhenCompleteCallback(t1, t3, hasError, listeners).call$0();
              else if (t2) {
                if (listeners.get$handlesValue())
                  new P._Future__propagateToListeners_handleValueCallback(t3, listeners, sourceResult).call$0();
              } else if (listeners.get$handlesError())
                new P._Future__propagateToListeners_handleError(t1, t3, listeners).call$0();
              if (oldZone != null)
                $.Zone__current = oldZone;
              t2 = t3.listenerValueOrError;
              t4 = J.getInterceptor(t2);
              if (!!t4.$isFuture) {
                result = listeners.get$result();
                if (!!t4.$is_Future)
                  if (J.$ge$n(t2._state, 4)) {
                    listeners = result._removeListeners$0();
                    result._cloneResult$1(t2);
                    t1.source = t2;
                    continue;
                  } else
                    P._Future__chainCoreFuture(t2, result);
                else
                  P._Future__chainForeignFuture(t2, result);
                return;
              }
            }
            result = listeners.get$result();
            listeners = result._removeListeners$0();
            t2 = t3.listenerHasError;
            t3 = t3.listenerValueOrError;
            if (!t2)
              result._setValue$1(t3);
            else
              result._setErrorObject$1(t3);
            t1.source = result;
            t2 = result;
          }
        }, "call$2", "async__Future__propagateToListeners$closure", 4, 0, 571, 19, [], 315, [], "_propagateToListeners"]
      }
    },
    "+_Future": [1, 1163],
    _Future__addListener_closure: {
      "^": "Closure:4;$this,listener",
      call$0: [function() {
        P._Future__propagateToListeners(this.$this, this.listener);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _Future__addListener_closure": [2],
    _Future__prependListeners_closure: {
      "^": "Closure:4;_box_0,$this",
      call$0: [function() {
        P._Future__propagateToListeners(this.$this, this._box_0.listeners);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _Future__prependListeners_closure": [2],
    _Future__chainForeignFuture_closure: {
      "^": "Closure:3;target",
      call$1: [function(value) {
        var t1 = this.target;
        t1._clearPendingComplete$0();
        t1._complete$1(value);
      }, null, null, 2, 0, 3, 1, [], "call"]
    },
    "+ _Future__chainForeignFuture_closure": [2],
    _Future__chainForeignFuture_closure0: {
      "^": "Closure:383;target",
      call$2: [function(error, stackTrace) {
        this.target._completeError$2(error, stackTrace);
      }, function(error) {
        return this.call$2(error, null);
      }, "call$1", null, null, null, 2, 2, 383, 0, 8, [], 12, [], "call"]
    },
    "+ _Future__chainForeignFuture_closure": [2],
    _Future__chainForeignFuture_closure1: {
      "^": "Closure:4;target,e,s",
      call$0: [function() {
        this.target._completeError$2(this.e, this.s);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _Future__chainForeignFuture_closure": [2],
    _Future__asyncComplete_closure: {
      "^": "Closure:4;$this,value",
      call$0: [function() {
        P._Future__chainCoreFuture(this.value, this.$this);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _Future__asyncComplete_closure": [2],
    _Future__asyncComplete_closure0: {
      "^": "Closure:4;$this,typedValue",
      call$0: [function() {
        this.$this._completeWithValue$1(this.typedValue);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _Future__asyncComplete_closure": [2],
    _Future__asyncCompleteError_closure: {
      "^": "Closure:4;$this,error,stackTrace",
      call$0: [function() {
        this.$this._completeError$2(this.error, this.stackTrace);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _Future__asyncCompleteError_closure": [2],
    _Future__propagateToListeners_handleWhenCompleteCallback: {
      "^": "Closure:6;_box_1,_box_0,hasError,listener",
      call$0: [function() {
        var completeResult, e, s, exception, t1, t2, originalSource;
        completeResult = null;
        try {
          completeResult = this.listener.handleWhenComplete$0();
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          if (this.hasError) {
            t1 = this._box_1.source.get$_error().get$error();
            t2 = e;
            t2 = t1 == null ? t2 == null : t1 === t2;
            t1 = t2;
          } else
            t1 = false;
          t2 = this._box_0;
          if (t1)
            t2.listenerValueOrError = this._box_1.source.get$_error();
          else
            t2.listenerValueOrError = new P.AsyncError(e, s);
          t2.listenerHasError = true;
          return;
        }
        if (!!J.getInterceptor(completeResult).$isFuture) {
          if (completeResult instanceof P._Future && J.$ge$n(completeResult.get$_state(), 4)) {
            if (J.$eq$(completeResult.get$_state(), 8)) {
              t1 = this._box_0;
              t1.listenerValueOrError = completeResult.get$_resultOrListeners();
              t1.listenerHasError = true;
            }
            return;
          }
          originalSource = this._box_1.source;
          t1 = this._box_0;
          t1.listenerValueOrError = completeResult.then$1(new P._Future__propagateToListeners_handleWhenCompleteCallback_closure(originalSource));
          t1.listenerHasError = false;
        }
      }, null, null, 0, 0, 6, "call"]
    },
    "+ _Future__propagateToListeners_handleWhenCompleteCallback": [2],
    _Future__propagateToListeners_handleWhenCompleteCallback_closure: {
      "^": "Closure:3;originalSource",
      call$1: [function(_) {
        return this.originalSource;
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _Future__propagateToListeners_handleWhenCompleteCallback_closure": [2],
    _Future__propagateToListeners_handleValueCallback: {
      "^": "Closure:6;_box_0,listener,sourceResult",
      call$0: [function() {
        var e, s, exception, t1;
        try {
          this._box_0.listenerValueOrError = this.listener.handleValue$1(this.sourceResult);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          t1 = this._box_0;
          t1.listenerValueOrError = new P.AsyncError(e, s);
          t1.listenerHasError = true;
        }
      }, null, null, 0, 0, 6, "call"]
    },
    "+ _Future__propagateToListeners_handleValueCallback": [2],
    _Future__propagateToListeners_handleError: {
      "^": "Closure:6;_box_1,_box_0,listener",
      call$0: [function() {
        var asyncError, e, s, t1, t2, exception, t3, t4;
        try {
          asyncError = this._box_1.source.get$_error();
          t1 = this.listener;
          if (t1.matchesErrorTest$1(asyncError) === true && t1.get$hasErrorCallback()) {
            t2 = this._box_0;
            t2.listenerValueOrError = t1.handleError$1(asyncError);
            t2.listenerHasError = false;
          }
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          t1 = this._box_1;
          t2 = t1.source.get$_error().get$error();
          t3 = e;
          t4 = this._box_0;
          if (t2 == null ? t3 == null : t2 === t3)
            t4.listenerValueOrError = t1.source.get$_error();
          else
            t4.listenerValueOrError = new P.AsyncError(e, s);
          t4.listenerHasError = true;
        }
      }, null, null, 0, 0, 6, "call"]
    },
    "+ _Future__propagateToListeners_handleError": [2],
    _Future_timeout_closure: {
      "^": "Closure:4;timeLimit,result",
      call$0: [function() {
        this.result._completeError$1(new P.TimeoutException("Future not completed", this.timeLimit));
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _Future_timeout_closure": [2],
    _Future_timeout_closure0: {
      "^": "Closure:4;_box_0,result,zone",
      call$0: [function() {
        var e, s, exception, t1;
        try {
          this.result._complete$1(this.zone.run$1(this._box_0.onTimeout));
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          this.result._completeError$2(e, s);
        }
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _Future_timeout_closure": [2],
    _Future_timeout_closure1: {
      "^": "Closure;_box_0,$this,result",
      call$1: [function(v) {
        var t1 = this._box_0;
        if (t1.timer.get$isActive()) {
          t1.timer.cancel$0();
          this.result._completeWithValue$1(v);
        }
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$receiver, "_Future");
      }, 56, [], "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$this, "_Future");
      }
    },
    "+ _Future_timeout_closure": [2],
    _Future_timeout_closure2: {
      "^": "Closure:12;_box_0,result",
      call$2: [function(e, s) {
        var t1 = this._box_0;
        if (t1.timer.get$isActive()) {
          t1.timer.cancel$0();
          this.result._completeError$2(e, s);
        }
      }, null, null, 4, 0, 12, 47, [], 49, [], "call"]
    },
    "+ _Future_timeout_closure": [2],
    _AsyncCallbackEntry: {
      "^": "Object;callback<-1164,next@-216",
      callback$1: function(arg0) {
        return this.callback.call$1(arg0);
      },
      next$0: function() {
        return this.next.call$0();
      },
      static: {
        _AsyncCallbackEntry$: [function(callback) {
          return new P._AsyncCallbackEntry(callback, null);
        }, null, null, 2, 0, 572, 33, [], "new _AsyncCallbackEntry"]
      }
    },
    "+_AsyncCallbackEntry": [1],
    _AsyncRun: {
      "^": "Object;",
      static: {
        "^": "_AsyncRun__scheduleImmediateClosure<-29",
        _AsyncRun__initializeScheduleImmediate: [function() {
          var t1, div, span;
          t1 = {};
          if (self.scheduleImmediate != null)
            return P.async__AsyncRun__scheduleImmediateJsOverride$closure();
          if (self.MutationObserver != null && self.document != null) {
            div = self.document.createElement("div");
            span = self.document.createElement("span");
            t1.storedCallback = null;
            new self.MutationObserver(H.convertDartClosureToJS(new P._AsyncRun__initializeScheduleImmediate_internalCallback(t1), 1)).observe(div, {childList: true});
            return new P._AsyncRun__initializeScheduleImmediate_closure(t1, div, span);
          } else if (self.setImmediate != null)
            return P.async__AsyncRun__scheduleImmediateWithSetImmediate$closure();
          return P.async__AsyncRun__scheduleImmediateWithTimer$closure();
        }, "call$0", "async__AsyncRun__initializeScheduleImmediate$closure", 0, 0, 292, "_initializeScheduleImmediate"],
        _AsyncRun__scheduleImmediateJsOverride: [function(callback) {
          ++init.globalState.topEventLoop._activeJsAsyncCount;
          self.scheduleImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateJsOverride_internalCallback(callback), 0));
        }, "call$1", "async__AsyncRun__scheduleImmediateJsOverride$closure", 2, 0, 37, 33, [], "_scheduleImmediateJsOverride"],
        _AsyncRun__scheduleImmediateWithSetImmediate: [function(callback) {
          ++init.globalState.topEventLoop._activeJsAsyncCount;
          self.setImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback(callback), 0));
        }, "call$1", "async__AsyncRun__scheduleImmediateWithSetImmediate$closure", 2, 0, 37, 33, [], "_scheduleImmediateWithSetImmediate"],
        _AsyncRun__scheduleImmediateWithTimer: [function(callback) {
          P.Timer__createTimer(C.Duration_0, callback);
        }, "call$1", "async__AsyncRun__scheduleImmediateWithTimer$closure", 2, 0, 37, 33, [], "_scheduleImmediateWithTimer"],
        _AsyncRun$: [function() {
          return new P._AsyncRun();
        }, null, null, 0, 0, 574, "new _AsyncRun"],
        _AsyncRun__scheduleImmediate: [function(callback) {
          $.$get$_AsyncRun__scheduleImmediateClosure().call$1(callback);
        }, "call$1", "async__AsyncRun__scheduleImmediate$closure", 2, 0, 37, 33, [], "_scheduleImmediate"]
      }
    },
    "+_AsyncRun": [1],
    Stream: {
      "^": "Object;$ti",
      get$isBroadcast: [function() {
        return false;
      }, null, null, 1, 0, 5, "isBroadcast"],
      asBroadcastStream$2$onCancel$onListen: [function(onCancel, onListen) {
        var t1, t2;
        t1 = H.getRuntimeTypeArgument(this, "Stream", 0);
        t2 = new P._AsBroadcastStream(this, $.Zone__current.registerUnaryCallback$1(onListen), $.Zone__current.registerUnaryCallback$1(onCancel), $.Zone__current, null, null, [t1]);
        t2._async$_controller = new P._AsBroadcastStreamController(null, t2.get$_async$_onListen(), t2.get$_onCancel(), 0, null, null, null, null, [t1]);
        return t2;
      }, function() {
        return this.asBroadcastStream$2$onCancel$onListen(null, null);
      }, "asBroadcastStream$0", "call$2$onCancel$onListen", "call$0", "get$asBroadcastStream", 0, 5, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Stream, T], named: {onCancel: {func: 1, v: true, args: [[P.StreamSubscription, T]]}, onListen: {func: 1, v: true, args: [[P.StreamSubscription, T]]}}};
        }, this.$receiver, "Stream");
      }, 0, 0, 94, [], 95, [], "asBroadcastStream"],
      where$1: [function(_, test) {
        return new P._WhereStream(test, this, [H.getRuntimeTypeArgument(this, "Stream", 0)]);
      }, "call$1", "get$where", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Stream, T], args: [{func: 1, ret: P.bool, args: [T]}]};
        }, this.$receiver, "Stream");
      }, 11, [], "where"],
      map$1: [function(_, convert) {
        return new P._MapStream(convert, this, [H.getRuntimeTypeArgument(this, "Stream", 0), null]);
      }, "call$1", "get$map", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: P.Stream, args: [{func: 1, args: [T]}]};
        }, this.$receiver, "Stream");
      }, 192, [], "map"],
      asyncMap$1: [function(convert) {
        var t1, t2, controller;
        t1 = {};
        t1.controller = null;
        t1.subscription = null;
        t2 = new P.Stream_asyncMap_onListen(t1, this, convert);
        if (this.get$isBroadcast()) {
          controller = new P._SyncBroadcastStreamController(t2, new P.Stream_asyncMap_closure(t1), 0, null, null, null, null, [null]);
          t1.controller = controller;
          t1 = controller;
        } else {
          controller = new P._SyncStreamController(null, 0, null, t2, new P.Stream_asyncMap_closure0(t1), new P.Stream_asyncMap_closure1(t1), new P.Stream_asyncMap_closure2(t1), [null]);
          t1.controller = controller;
          t1 = controller;
        }
        return t1.get$stream();
      }, "call$1", "get$asyncMap", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: P.Stream, args: [{func: 1, args: [T]}]};
        }, this.$receiver, "Stream");
      }, 192, [], "asyncMap"],
      asyncExpand$1: [function(convert) {
        var t1, t2, controller;
        t1 = {};
        t1.controller = null;
        t1.subscription = null;
        t2 = new P.Stream_asyncExpand_onListen(t1, this, convert);
        if (this.get$isBroadcast()) {
          controller = new P._SyncBroadcastStreamController(t2, new P.Stream_asyncExpand_closure(t1), 0, null, null, null, null, [null]);
          t1.controller = controller;
          t1 = controller;
        } else {
          controller = new P._SyncStreamController(null, 0, null, t2, new P.Stream_asyncExpand_closure0(t1), new P.Stream_asyncExpand_closure1(t1), new P.Stream_asyncExpand_closure2(t1), [null]);
          t1.controller = controller;
          t1 = controller;
        }
        return t1.get$stream();
      }, "call$1", "get$asyncExpand", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: P.Stream, args: [{func: 1, ret: P.Stream, args: [T]}]};
        }, this.$receiver, "Stream");
      }, 192, [], "asyncExpand"],
      handleError$2$test: [function(onError, test) {
        return new P._HandleErrorStream(onError, test, this, [H.getRuntimeTypeArgument(this, "Stream", 0)]);
      }, function(onError) {
        return this.handleError$2$test(onError, null);
      }, "handleError$1", "call$2$test", "call$1", "get$handleError", 2, 3, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Stream, T], args: [P.Function], named: {test: {func: 1, ret: P.bool, args: [,]}}};
        }, this.$receiver, "Stream");
      }, 0, 20, [], 11, [], "handleError"],
      expand$1: [function(_, convert) {
        return new P._ExpandStream(convert, this, [H.getRuntimeTypeArgument(this, "Stream", 0), null]);
      }, "call$1", "get$expand", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: P.Stream, args: [{func: 1, ret: P.Iterable, args: [T]}]};
        }, this.$receiver, "Stream");
      }, 192, [], "expand"],
      pipe$1: [function(streamConsumer) {
        return streamConsumer.addStream$1(this).then$1(new P.Stream_pipe_closure(streamConsumer));
      }, "call$1", "get$pipe", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: P.Future, args: [[P.StreamConsumer, T]]};
        }, this.$receiver, "Stream");
      }, 793, [], "pipe"],
      transform$1: [function(streamTransformer) {
        return streamTransformer.bind$1(this);
      }, "call$1", "get$transform", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: P.Stream, args: [[P.StreamTransformer, T,,]]};
        }, this.$receiver, "Stream");
      }, 791, [], "transform"],
      reduce$1: [function(_, combine) {
        var t1, result;
        t1 = {};
        result = new P._Future(0, $.Zone__current, null, [H.getRuntimeTypeArgument(this, "Stream", 0)]);
        t1.seenFirst = false;
        t1.value = null;
        t1.subscription = null;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_reduce_closure(t1, this, combine, result), true, new P.Stream_reduce_closure0(t1, result), result.get$_completeError());
        return result;
      }, "call$1", "get$reduce", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Future, T], args: [{func: 1, ret: T, args: [T, T]}]};
        }, this.$receiver, "Stream");
      }, 61, [], "reduce"],
      fold$2: [function(_, initialValue, combine) {
        var t1, result;
        t1 = {};
        result = new P._Future(0, $.Zone__current, null, [null]);
        t1.value = initialValue;
        t1.subscription = null;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_fold_closure(t1, this, combine, result), true, new P.Stream_fold_closure0(t1, result), new P.Stream_fold_closure1(result));
        return result;
      }, "call$2", "get$fold", 4, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: P.Future, args: [, {func: 1, args: [, T]}]};
        }, this.$receiver, "Stream");
      }, 123, [], 61, [], "fold"],
      join$1: [function(_, separator) {
        var t1, result, buffer;
        t1 = {};
        result = new P._Future(0, $.Zone__current, null, [P.String]);
        buffer = new P.StringBuffer("");
        t1.subscription = null;
        t1.first = true;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_join_closure(t1, this, separator, result, buffer), true, new P.Stream_join_closure0(result, buffer), new P.Stream_join_closure1(result));
        return result;
      }, function($receiver) {
        return this.join$1($receiver, "");
      }, "join$0", "call$1", "call$0", "get$join", 0, 2, 568, 32, 63, [], "join"],
      contains$1: [function(_, needle) {
        var t1, future;
        t1 = {};
        future = new P._Future(0, $.Zone__current, null, [P.bool]);
        t1.subscription = null;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_contains_closure(t1, this, needle, future), true, new P.Stream_contains_closure0(future), future.get$_completeError());
        return future;
      }, "call$1", "get$contains", 2, 0, 575, 439, [], "contains"],
      forEach$1: [function(_, action) {
        var t1, future;
        t1 = {};
        future = new P._Future(0, $.Zone__current, null, [null]);
        t1.subscription = null;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_forEach_closure(t1, this, action, future), true, new P.Stream_forEach_closure0(future), future.get$_completeError());
        return future;
      }, "call$1", "get$forEach", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: P.Future, args: [{func: 1, v: true, args: [T]}]};
        }, this.$receiver, "Stream");
      }, 71, [], "forEach"],
      every$1: [function(_, test) {
        var t1, future;
        t1 = {};
        future = new P._Future(0, $.Zone__current, null, [P.bool]);
        t1.subscription = null;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_every_closure(t1, this, test, future), true, new P.Stream_every_closure0(future), future.get$_completeError());
        return future;
      }, "call$1", "get$every", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Future, P.bool], args: [{func: 1, ret: P.bool, args: [T]}]};
        }, this.$receiver, "Stream");
      }, 11, [], "every"],
      any$1: [function(_, test) {
        var t1, future;
        t1 = {};
        future = new P._Future(0, $.Zone__current, null, [P.bool]);
        t1.subscription = null;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_any_closure(t1, this, test, future), true, new P.Stream_any_closure0(future), future.get$_completeError());
        return future;
      }, "call$1", "get$any", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Future, P.bool], args: [{func: 1, ret: P.bool, args: [T]}]};
        }, this.$receiver, "Stream");
      }, 11, [], "any"],
      get$length: [function(_) {
        var t1, future;
        t1 = {};
        future = new P._Future(0, $.Zone__current, null, [P.int]);
        t1.count = 0;
        this.listen$4$cancelOnError$onDone$onError(new P.Stream_length_closure(t1), true, new P.Stream_length_closure0(t1, future), future.get$_completeError());
        return future;
      }, null, null, 1, 0, 160, "length"],
      get$isEmpty: [function(_) {
        var t1, future;
        t1 = {};
        future = new P._Future(0, $.Zone__current, null, [P.bool]);
        t1.subscription = null;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_isEmpty_closure(t1, future), true, new P.Stream_isEmpty_closure0(future), future.get$_completeError());
        return future;
      }, null, null, 1, 0, 129, "isEmpty"],
      toList$0: [function(_) {
        var t1, result, future;
        t1 = H.getRuntimeTypeArgument(this, "Stream", 0);
        result = H.setRuntimeTypeInfo([], [t1]);
        future = new P._Future(0, $.Zone__current, null, [[P.List, t1]]);
        this.listen$4$cancelOnError$onDone$onError(new P.Stream_toList_closure(this, result), true, new P.Stream_toList_closure0(result, future), future.get$_completeError());
        return future;
      }, "call$0", "get$toList", 0, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Future, [P.List, T]]};
        }, this.$receiver, "Stream");
      }, "toList"],
      toSet$0: [function(_) {
        var t1, result, future;
        t1 = H.getRuntimeTypeArgument(this, "Stream", 0);
        result = P.LinkedHashSet_LinkedHashSet(null, null, null, t1);
        future = new P._Future(0, $.Zone__current, null, [[P.Set, t1]]);
        this.listen$4$cancelOnError$onDone$onError(new P.Stream_toSet_closure(this, result), true, new P.Stream_toSet_closure0(result, future), future.get$_completeError());
        return future;
      }, "call$0", "get$toSet", 0, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Future, [P.Set, T]]};
        }, this.$receiver, "Stream");
      }, "toSet"],
      drain$1: [function(futureValue) {
        return this.listen$2$cancelOnError(null, true).asFuture$1(futureValue);
      }, function() {
        return this.drain$1(null);
      }, "drain$0", "call$1", "call$0", "get$drain", 0, 2, function() {
        return {func: 1, ret: P.Future, opt: [,]};
      }, 0, 206, [], "drain"],
      take$1: [function(_, count) {
        if (typeof count !== "number" || Math.floor(count) !== count)
          H.throwExpression(P.ArgumentError$(count));
        return new P._TakeStream(count, this, [H.getRuntimeTypeArgument(this, "Stream", 0)]);
      }, "call$1", "get$take", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Stream, T], args: [P.int]};
        }, this.$receiver, "Stream");
      }, 43, [], "take"],
      takeWhile$1: [function(_, test) {
        return new P._TakeWhileStream(test, this, [H.getRuntimeTypeArgument(this, "Stream", 0)]);
      }, "call$1", "get$takeWhile", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Stream, T], args: [{func: 1, ret: P.bool, args: [T]}]};
        }, this.$receiver, "Stream");
      }, 11, [], "takeWhile"],
      skip$1: [function(_, count) {
        if (typeof count !== "number" || Math.floor(count) !== count || count < 0)
          H.throwExpression(P.ArgumentError$(count));
        return new P._SkipStream(count, this, [H.getRuntimeTypeArgument(this, "Stream", 0)]);
      }, "call$1", "get$skip", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Stream, T], args: [P.int]};
        }, this.$receiver, "Stream");
      }, 43, [], "skip"],
      skipWhile$1: [function(_, test) {
        return new P._SkipWhileStream(test, this, [H.getRuntimeTypeArgument(this, "Stream", 0)]);
      }, "call$1", "get$skipWhile", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Stream, T], args: [{func: 1, ret: P.bool, args: [T]}]};
        }, this.$receiver, "Stream");
      }, 11, [], "skipWhile"],
      distinct$1: [function(equals) {
        return new P._DistinctStream(equals, $.$get$_DistinctStream__SENTINEL(), this, [H.getRuntimeTypeArgument(this, "Stream", 0)]);
      }, function() {
        return this.distinct$1(null);
      }, "distinct$0", "call$1", "call$0", "get$distinct", 0, 2, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Stream, T], opt: [{func: 1, ret: P.bool, args: [T, T]}]};
        }, this.$receiver, "Stream");
      }, 0, 162, [], "distinct"],
      get$first: [function(_) {
        var t1, future;
        t1 = {};
        future = new P._Future(0, $.Zone__current, null, [H.getRuntimeTypeArgument(this, "Stream", 0)]);
        t1.subscription = null;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_first_closure(t1, this, future), true, new P.Stream_first_closure0(future), future.get$_completeError());
        return future;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Future, T]};
        }, this.$receiver, "Stream");
      }, "first"],
      get$last: [function(_) {
        var t1, future;
        t1 = {};
        future = new P._Future(0, $.Zone__current, null, [H.getRuntimeTypeArgument(this, "Stream", 0)]);
        t1.result = null;
        t1.foundResult = false;
        this.listen$4$cancelOnError$onDone$onError(new P.Stream_last_closure(t1, this), true, new P.Stream_last_closure0(t1, future), future.get$_completeError());
        return future;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Future, T]};
        }, this.$receiver, "Stream");
      }, "last"],
      get$single: [function(_) {
        var t1, future;
        t1 = {};
        future = new P._Future(0, $.Zone__current, null, [H.getRuntimeTypeArgument(this, "Stream", 0)]);
        t1.result = null;
        t1.foundResult = false;
        t1.subscription = null;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_single_closure(t1, this, future), true, new P.Stream_single_closure0(t1, future), future.get$_completeError());
        return future;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Future, T]};
        }, this.$receiver, "Stream");
      }, "single"],
      firstWhere$2$defaultValue: [function(_, test, defaultValue) {
        var t1, future;
        t1 = {};
        future = new P._Future(0, $.Zone__current, null, [null]);
        t1.subscription = null;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_firstWhere_closure(t1, this, test, future), true, new P.Stream_firstWhere_closure0(defaultValue, future), future.get$_completeError());
        return future;
      }, function($receiver, test) {
        return this.firstWhere$2$defaultValue($receiver, test, null);
      }, "firstWhere$1", "call$2$defaultValue", "call$1", "get$firstWhere", 2, 3, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: P.Future, args: [{func: 1, ret: P.bool, args: [T]}], named: {defaultValue: {func: 1, ret: P.Object}}};
        }, this.$receiver, "Stream");
      }, 0, 11, [], 135, [], "firstWhere"],
      lastWhere$2$defaultValue: [function(_, test, defaultValue) {
        var t1, future;
        t1 = {};
        future = new P._Future(0, $.Zone__current, null, [null]);
        t1.result = null;
        t1.foundResult = false;
        t1.subscription = null;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_lastWhere_closure(t1, this, test, future), true, new P.Stream_lastWhere_closure0(t1, defaultValue, future), future.get$_completeError());
        return future;
      }, function($receiver, test) {
        return this.lastWhere$2$defaultValue($receiver, test, null);
      }, "lastWhere$1", "call$2$defaultValue", "call$1", "get$lastWhere", 2, 3, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: P.Future, args: [{func: 1, ret: P.bool, args: [T]}], named: {defaultValue: {func: 1, ret: P.Object}}};
        }, this.$receiver, "Stream");
      }, 0, 11, [], 135, [], "lastWhere"],
      singleWhere$1: [function(_, test) {
        var t1, future;
        t1 = {};
        future = new P._Future(0, $.Zone__current, null, [H.getRuntimeTypeArgument(this, "Stream", 0)]);
        t1.result = null;
        t1.foundResult = false;
        t1.subscription = null;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_singleWhere_closure(t1, this, test, future), true, new P.Stream_singleWhere_closure0(t1, future), future.get$_completeError());
        return future;
      }, "call$1", "get$singleWhere", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Future, T], args: [{func: 1, ret: P.bool, args: [T]}]};
        }, this.$receiver, "Stream");
      }, 11, [], "singleWhere"],
      elementAt$1: [function(_, index) {
        var t1, future;
        t1 = {};
        if (typeof index !== "number" || Math.floor(index) !== index || index < 0)
          throw H.wrapException(P.ArgumentError$(index));
        future = new P._Future(0, $.Zone__current, null, [H.getRuntimeTypeArgument(this, "Stream", 0)]);
        t1.subscription = null;
        t1.elementIndex = 0;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_elementAt_closure(t1, this, index, future), true, new P.Stream_elementAt_closure0(t1, this, index, future), future.get$_completeError());
        return future;
      }, "call$1", "get$elementAt", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Future, T], args: [P.int]};
        }, this.$receiver, "Stream");
      }, 14, [], "elementAt"],
      timeout$2$onTimeout: [function(timeLimit, onTimeout) {
        var t1, t2, t3, t4, controller;
        t1 = {};
        t1.controller = null;
        t1.subscription = null;
        t1.timer = null;
        t1.zone = null;
        t1.timeout = null;
        t2 = new P.Stream_timeout_onListen(t1, this, timeLimit, onTimeout, new P.Stream_timeout_onData(t1, this, timeLimit), new P.Stream_timeout_onError(t1, timeLimit), new P.Stream_timeout_onDone(t1));
        t3 = new P.Stream_timeout_onCancel(t1);
        t4 = H.getRuntimeTypeArgument(this, "Stream", 0);
        controller = this.get$isBroadcast() ? new P._SyncBroadcastStreamController(t2, t3, 0, null, null, null, null, [t4]) : new P._SyncStreamController(null, 0, null, t2, new P.Stream_timeout_closure(t1), new P.Stream_timeout_closure0(t1, timeLimit), t3, [t4]);
        t1.controller = controller;
        return controller.get$stream();
      }, function(timeLimit) {
        return this.timeout$2$onTimeout(timeLimit, null);
      }, "timeout$1", "call$2$onTimeout", "call$1", "get$timeout", 2, 3, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Stream, T], args: [P.Duration], named: {onTimeout: {func: 1, v: true, args: [[P.EventSink, T]]}}};
        }, this.$receiver, "Stream");
      }, 0, 469, [], 468, [], "timeout"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      "<>": [969],
      static: {
        Stream$: [function($T) {
          return new P.Stream([$T]);
        }, null, null, 0, 0, 4, "new Stream"],
        Stream$_internal: [function($T) {
          return new P.Stream([$T]);
        }, null, null, 0, 0, 4, "new Stream$_internal"],
        Stream_Stream$empty: [function($T) {
          return new P._EmptyStream([$T]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P.Stream, T]};
          }, this.$receiver, "Stream");
        }, "new Stream$empty"],
        Stream_Stream$fromFuture: [function(future, $T) {
          var controller = new P._SyncStreamController(null, 0, null, null, null, null, null, [$T]);
          future.then$2$onError(new P.closure4(controller), new P.closure5(controller));
          return new P._ControllerStream(controller, [H.getTypeArgumentByIndex(controller, 0)]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P.Stream, T], args: [[P.Future, T]]};
          }, this.$receiver, "Stream");
        }, 179, [], "new Stream$fromFuture"],
        Stream_Stream$fromFutures: [function(futures, $T) {
          var t1, controller, onValue, onError, t2, future;
          t1 = {};
          controller = new P._SyncStreamController(null, 0, null, null, null, null, null, [$T]);
          t1.count = 0;
          onValue = new P.closure6(t1, $T, controller);
          onError = new P.closure7(t1, controller);
          for (t2 = J.get$iterator$ax(futures); t2.moveNext$0();) {
            future = t2.get$current();
            ++t1.count;
            future.then$2$onError(onValue, onError);
          }
          if (t1.count === 0)
            P.scheduleMicrotask(controller.get$close());
          return new P._ControllerStream(controller, [H.getTypeArgumentByIndex(controller, 0)]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P.Stream, T], args: [[P.Iterable, [P.Future, T]]]};
          }, this.$receiver, "Stream");
        }, 310, [], "new Stream$fromFutures"],
        Stream_Stream$fromIterable: [function(data, $T) {
          return new P._GeneratedStreamImpl(new P.closure8($T, data), false, [$T]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P.Stream, T], args: [[P.Iterable, T]]};
          }, this.$receiver, "Stream");
        }, 21, [], "new Stream$fromIterable"],
        Stream_Stream$periodic: [function(period, computation, $T) {
          var t1, watch, t2, t3, controller;
          t1 = {};
          t1.timer = null;
          t1.computationCount = 0;
          t1.controller = null;
          watch = new P.Stopwatch(0, 0);
          if ($.Stopwatch__frequency == null) {
            H.Primitives_initTicker();
            $.Stopwatch__frequency = $.Primitives_timerFrequency;
          }
          t2 = new P.sendEvent(t1, computation, watch);
          t3 = new P.startPeriodicTimer(t1, period, t2);
          controller = new P._SyncStreamController(null, 0, null, new P.closure9(watch, t3), new P.closure10(t1, watch), new P.closure11(t1, period, watch, t2, t3), new P.closure12(t1), [$T]);
          t1.controller = controller;
          return new P._ControllerStream(controller, [H.getTypeArgumentByIndex(controller, 0)]);
        }, null, null, 2, 2, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P.Stream, T], args: [P.Duration], opt: [{func: 1, ret: T, args: [P.int]}]};
          }, this.$receiver, "Stream");
        }, 0, 565, [], 183, [], "new Stream$periodic"],
        Stream_Stream$eventTransformed: [function(source, mapSink, $T) {
          return new P._BoundSinkStream(mapSink, source, [null, null]);
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P.Stream, T], args: [P.Stream, {func: 1, ret: P.EventSink, args: [[P.EventSink, T]]}]};
          }, this.$receiver, "Stream");
        }, 19, [], 837, [], "new Stream$eventTransformed"]
      }
    },
    "+Stream": [1],
    closure4: {
      "^": "Closure:3;controller",
      call$1: [function(value) {
        var t1 = this.controller;
        t1._async$_add$1(value);
        t1._closeUnchecked$0();
      }, null, null, 2, 0, 3, 1, [], "call"]
    },
    "+ closure": [2],
    closure5: {
      "^": "Closure:12;controller",
      call$2: [function(error, stackTrace) {
        var t1 = this.controller;
        t1._addError$2(error, stackTrace);
        t1._closeUnchecked$0();
      }, null, null, 4, 0, 12, 8, [], 12, [], "call"]
    },
    "+ closure": [2],
    closure6: {
      "^": "Closure;_box_0,T,controller",
      call$1: [function(value) {
        var t1 = this.controller;
        if (J.$and$n(t1._state, 4) === 0) {
          t1._async$_add$1(value);
          if (--this._box_0.count === 0)
            t1._closeUnchecked$0();
        }
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$receiver, "Stream");
      }, 1, [], "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this, "Stream");
      }
    },
    "+ closure": [2],
    closure7: {
      "^": "Closure:12;_box_0,controller",
      call$2: [function(error, stack) {
        var t1 = this.controller;
        if (J.$and$n(t1._state, 4) === 0) {
          t1._addError$2(error, stack);
          if (--this._box_0.count === 0)
            t1._closeUnchecked$0();
        }
      }, null, null, 4, 0, 12, 8, [], 478, [], "call"]
    },
    "+ closure": [2],
    closure8: {
      "^": "Closure:4;T,data",
      call$0: [function() {
        return new P._IterablePendingEvents(J.get$iterator$ax(this.data), 0, [this.T]);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ closure": [2],
    sendEvent: {
      "^": "Closure:6;_box_0,computation,watch",
      call$0: [function() {
        var data, e, s, t1, t2, exception;
        t1 = this.watch;
        t2 = t1._stop;
        t1._core$_start = t2 == null ? $.Primitives_timerTicks.call$0() : t2;
        data = null;
        t1 = this.computation;
        if (t1 != null)
          try {
            data = t1.call$1(this._box_0.computationCount++);
          } catch (exception) {
            t1 = H.unwrapException(exception);
            e = t1;
            s = H.getTraceFromException(exception);
            this._box_0.controller.addError$2(e, s);
            return;
          }
        t1 = this._box_0.controller;
        t2 = data;
        if (!J.$lt$n(t1._state, 4))
          H.throwExpression(t1._badEventState$0());
        t1._async$_add$1(t2);
      }, null, null, 0, 0, 6, "call"]
    },
    "+ sendEvent": [2],
    startPeriodicTimer: {
      "^": "Closure:6;_box_0,period,sendEvent",
      call$0: [function() {
        this._box_0.timer = P.Timer_Timer$periodic(this.period, new P.startPeriodicTimer_closure(this.sendEvent));
      }, null, null, 0, 0, 6, "call"]
    },
    "+ startPeriodicTimer": [2],
    startPeriodicTimer_closure: {
      "^": "Closure:401;sendEvent",
      call$1: [function(timer) {
        this.sendEvent.call$0();
      }, null, null, 2, 0, 401, 789, [], "call"]
    },
    "+ startPeriodicTimer_closure": [2],
    closure9: {
      "^": "Closure:4;watch,startPeriodicTimer",
      call$0: [function() {
        this.watch.start$0();
        this.startPeriodicTimer.call$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ closure": [2],
    closure10: {
      "^": "Closure:4;_box_0,watch",
      call$0: [function() {
        var t1 = this._box_0;
        t1.timer.cancel$0();
        t1.timer = null;
        t1 = this.watch;
        if (t1._stop == null)
          t1._stop = $.Primitives_timerTicks.call$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ closure": [2],
    closure11: {
      "^": "Closure:4;_box_0,period,watch,sendEvent,startPeriodicTimer",
      call$0: [function() {
        var t1, t2, elapsed;
        t1 = this.watch;
        t2 = t1._stop;
        if (t2 == null)
          t2 = $.Primitives_timerTicks.call$0();
        elapsed = P.Duration$(0, 0, J.$tdiv$n(J.$mul$ns(J.$sub$n(t2, t1._core$_start), 1000000), $.Stopwatch__frequency), 0, 0, 0);
        t1.start$0();
        t1 = this._box_0;
        t1.timer = P.Timer_Timer(J.$sub$n(this.period, elapsed), new P._closure(t1, this.sendEvent, this.startPeriodicTimer));
      }, null, null, 0, 0, 4, "call"]
    },
    "+ closure": [2],
    _closure: {
      "^": "Closure:4;_box_0,sendEvent,startPeriodicTimer",
      call$0: [function() {
        this._box_0.timer = null;
        this.startPeriodicTimer.call$0();
        this.sendEvent.call$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _closure": [2],
    closure12: {
      "^": "Closure:4;_box_0",
      call$0: [function() {
        var t1, t2;
        t1 = this._box_0;
        t2 = t1.timer;
        if (t2 != null)
          t2.cancel$0();
        t1.timer = null;
        return $.$get$Future__nullFuture();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ closure": [2],
    Stream_asyncMap_onListen: {
      "^": "Closure:6;_box_0,$this,convert",
      call$0: [function() {
        var t1, t2, add, addError;
        t1 = this._box_0;
        t2 = t1.controller;
        add = t2.get$add(t2);
        addError = t1.controller.get$_addError();
        t2 = this.$this;
        t1.subscription = t2.listen$3$onDone$onError(new P.Stream_asyncMap_onListen_closure(t1, t2, this.convert, add, addError), t1.controller.get$close(), addError);
      }, null, null, 0, 0, 6, "call"]
    },
    "+ Stream_asyncMap_onListen": [2],
    Stream_asyncMap_onListen_closure: {
      "^": "Closure;_box_0,$this,convert,add,addError",
      call$1: [function($event) {
        var newValue, e, s, exception, t1;
        newValue = null;
        try {
          newValue = this.convert.call$1($event);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          this._box_0.controller.addError$2(e, s);
          return;
        }
        t1 = this._box_0;
        if (!!J.getInterceptor(newValue).$isFuture) {
          t1.subscription.pause$0();
          newValue.then$2$onError(this.add, this.addError).whenComplete$1(t1.subscription.get$resume());
        } else
          t1.controller.add$1(0, newValue);
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$receiver, "Stream");
      }, 110, [], "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$this, "Stream");
      }
    },
    "+ Stream_asyncMap_onListen_closure": [2],
    Stream_asyncMap_closure: {
      "^": "Closure:4;_box_0",
      call$0: [function() {
        this._box_0.subscription.cancel$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_asyncMap_closure": [2],
    Stream_asyncMap_closure0: {
      "^": "Closure:4;_box_0",
      call$0: [function() {
        this._box_0.subscription.pause$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_asyncMap_closure": [2],
    Stream_asyncMap_closure1: {
      "^": "Closure:4;_box_0",
      call$0: [function() {
        this._box_0.subscription.resume$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_asyncMap_closure": [2],
    Stream_asyncMap_closure2: {
      "^": "Closure:4;_box_0",
      call$0: [function() {
        return this._box_0.subscription.cancel$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_asyncMap_closure": [2],
    Stream_asyncExpand_onListen: {
      "^": "Closure:6;_box_0,$this,convert",
      call$0: [function() {
        var t1, t2, t3;
        t1 = this._box_0;
        t2 = this.$this;
        t3 = t1.controller.get$_addError();
        t1.subscription = t2.listen$3$onDone$onError(new P.Stream_asyncExpand_onListen_closure(t1, t2, this.convert), t1.controller.get$close(), t3);
      }, null, null, 0, 0, 6, "call"]
    },
    "+ Stream_asyncExpand_onListen": [2],
    Stream_asyncExpand_onListen_closure: {
      "^": "Closure;_box_0,$this,convert",
      call$1: [function($event) {
        var newStream, e, s, exception, t1;
        newStream = null;
        try {
          newStream = this.convert.call$1($event);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          this._box_0.controller.addError$2(e, s);
          return;
        }
        if (newStream != null) {
          t1 = this._box_0;
          t1.subscription.pause$0();
          t1.controller.addStream$1(newStream).whenComplete$1(t1.subscription.get$resume());
        }
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$receiver, "Stream");
      }, 110, [], "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$this, "Stream");
      }
    },
    "+ Stream_asyncExpand_onListen_closure": [2],
    Stream_asyncExpand_closure: {
      "^": "Closure:4;_box_0",
      call$0: [function() {
        this._box_0.subscription.cancel$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_asyncExpand_closure": [2],
    Stream_asyncExpand_closure0: {
      "^": "Closure:4;_box_0",
      call$0: [function() {
        this._box_0.subscription.pause$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_asyncExpand_closure": [2],
    Stream_asyncExpand_closure1: {
      "^": "Closure:4;_box_0",
      call$0: [function() {
        this._box_0.subscription.resume$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_asyncExpand_closure": [2],
    Stream_asyncExpand_closure2: {
      "^": "Closure:4;_box_0",
      call$0: [function() {
        return this._box_0.subscription.cancel$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_asyncExpand_closure": [2],
    Stream_pipe_closure: {
      "^": "Closure:3;streamConsumer",
      call$1: [function(_) {
        return this.streamConsumer.close$0();
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ Stream_pipe_closure": [2],
    Stream_reduce_closure: {
      "^": "Closure;_box_0,$this,combine,result",
      call$1: [function(element) {
        var t1 = this._box_0;
        if (t1.seenFirst)
          P._runUserCode(new P.Stream_reduce__closure(t1, this.combine, element), new P.Stream_reduce__closure0(t1, this.$this), P._cancelAndErrorClosure(t1.subscription, this.result));
        else {
          t1.value = element;
          t1.seenFirst = true;
        }
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$receiver, "Stream");
      }, 31, [], "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$this, "Stream");
      }
    },
    "+ Stream_reduce_closure": [2],
    Stream_reduce__closure: {
      "^": "Closure:4;_box_0,combine,element",
      call$0: [function() {
        return this.combine.call$2(this._box_0.value, this.element);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_reduce__closure": [2],
    Stream_reduce__closure0: {
      "^": "Closure;_box_0,$this",
      call$1: [function(newValue) {
        this._box_0.value = newValue;
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$receiver, "Stream");
      }, 451, [], "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$this, "Stream");
      }
    },
    "+ Stream_reduce__closure": [2],
    Stream_reduce_closure0: {
      "^": "Closure:4;_box_0,result",
      call$0: [function() {
        var e, s, t1, exception;
        t1 = this._box_0;
        if (!t1.seenFirst)
          try {
            t1 = H.IterableElementError_noElement();
            throw H.wrapException(t1);
          } catch (exception) {
            t1 = H.unwrapException(exception);
            e = t1;
            s = H.getTraceFromException(exception);
            P._completeWithErrorCallback(this.result, e, s);
          }
        else
          this.result._complete$1(t1.value);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_reduce_closure": [2],
    Stream_fold_closure: {
      "^": "Closure;_box_0,$this,combine,result",
      call$1: [function(element) {
        var t1 = this._box_0;
        P._runUserCode(new P.Stream_fold__closure(t1, this.combine, element), new P.Stream_fold__closure0(t1, this.$this), P._cancelAndErrorClosure(t1.subscription, this.result));
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$receiver, "Stream");
      }, 31, [], "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$this, "Stream");
      }
    },
    "+ Stream_fold_closure": [2],
    Stream_fold__closure: {
      "^": "Closure:4;_box_0,combine,element",
      call$0: [function() {
        return this.combine.call$2(this._box_0.value, this.element);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_fold__closure": [2],
    Stream_fold__closure0: {
      "^": "Closure;_box_0,$this",
      call$1: [function(newValue) {
        this._box_0.value = newValue;
      }, null, null, 2, 0, function() {
        return {func: 1, args: [,]};
      }, 451, [], "call"],
      $signature: function() {
        return {func: 1, args: [,]};
      }
    },
    "+ Stream_fold__closure": [2],
    Stream_fold_closure1: {
      "^": "Closure:12;result",
      call$2: [function(e, st) {
        this.result._completeError$2(e, st);
      }, null, null, 4, 0, 12, 47, [], 785, [], "call"]
    },
    "+ Stream_fold_closure": [2],
    Stream_fold_closure0: {
      "^": "Closure:4;_box_0,result",
      call$0: [function() {
        this.result._complete$1(this._box_0.value);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_fold_closure": [2],
    Stream_join_closure: {
      "^": "Closure;_box_0,$this,separator,result,buffer",
      call$1: [function(element) {
        var e, s, t1, exception, t2;
        t1 = this._box_0;
        if (!t1.first)
          this.buffer._contents += H.S(this.separator);
        t1.first = false;
        try {
          this.buffer._contents += H.S(element);
        } catch (exception) {
          t2 = H.unwrapException(exception);
          e = t2;
          s = H.getTraceFromException(exception);
          P._cancelAndErrorWithReplacement(t1.subscription, this.result, e, s);
        }
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$receiver, "Stream");
      }, 31, [], "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$this, "Stream");
      }
    },
    "+ Stream_join_closure": [2],
    Stream_join_closure1: {
      "^": "Closure:3;result",
      call$1: [function(e) {
        this.result._completeError$1(e);
      }, null, null, 2, 0, 3, 47, [], "call"]
    },
    "+ Stream_join_closure": [2],
    Stream_join_closure0: {
      "^": "Closure:4;result,buffer",
      call$0: [function() {
        var t1 = this.buffer._contents;
        this.result._complete$1(t1.charCodeAt(0) == 0 ? t1 : t1);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_join_closure": [2],
    Stream_contains_closure: {
      "^": "Closure;_box_0,$this,needle,future",
      call$1: [function(element) {
        var t1, t2;
        t1 = this._box_0;
        t2 = this.future;
        P._runUserCode(new P.Stream_contains__closure(this.needle, element), new P.Stream_contains__closure0(t1, t2), P._cancelAndErrorClosure(t1.subscription, t2));
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$receiver, "Stream");
      }, 31, [], "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$this, "Stream");
      }
    },
    "+ Stream_contains_closure": [2],
    Stream_contains__closure: {
      "^": "Closure:4;needle,element",
      call$0: [function() {
        return J.$eq$(this.element, this.needle);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_contains__closure": [2],
    Stream_contains__closure0: {
      "^": "Closure:33;_box_0,future",
      call$1: [function(isMatch) {
        if (isMatch === true)
          P._cancelAndValue(this._box_0.subscription, this.future, true);
      }, null, null, 2, 0, 33, 154, [], "call"]
    },
    "+ Stream_contains__closure": [2],
    Stream_contains_closure0: {
      "^": "Closure:4;future",
      call$0: [function() {
        this.future._complete$1(false);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_contains_closure": [2],
    Stream_forEach_closure: {
      "^": "Closure;_box_0,$this,action,future",
      call$1: [function(element) {
        P._runUserCode(new P.Stream_forEach__closure(this.action, element), new P.Stream_forEach__closure0(), P._cancelAndErrorClosure(this._box_0.subscription, this.future));
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$receiver, "Stream");
      }, 31, [], "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$this, "Stream");
      }
    },
    "+ Stream_forEach_closure": [2],
    Stream_forEach__closure: {
      "^": "Closure:4;action,element",
      call$0: [function() {
        return this.action.call$1(this.element);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_forEach__closure": [2],
    Stream_forEach__closure0: {
      "^": "Closure:3;",
      call$1: [function(_) {
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ Stream_forEach__closure": [2],
    Stream_forEach_closure0: {
      "^": "Closure:4;future",
      call$0: [function() {
        this.future._complete$1(null);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_forEach_closure": [2],
    Stream_every_closure: {
      "^": "Closure;_box_0,$this,test,future",
      call$1: [function(element) {
        var t1, t2;
        t1 = this._box_0;
        t2 = this.future;
        P._runUserCode(new P.Stream_every__closure(this.test, element), new P.Stream_every__closure0(t1, t2), P._cancelAndErrorClosure(t1.subscription, t2));
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$receiver, "Stream");
      }, 31, [], "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$this, "Stream");
      }
    },
    "+ Stream_every_closure": [2],
    Stream_every__closure: {
      "^": "Closure:4;test,element",
      call$0: [function() {
        return this.test.call$1(this.element);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_every__closure": [2],
    Stream_every__closure0: {
      "^": "Closure:33;_box_0,future",
      call$1: [function(isMatch) {
        if (isMatch !== true)
          P._cancelAndValue(this._box_0.subscription, this.future, false);
      }, null, null, 2, 0, 33, 154, [], "call"]
    },
    "+ Stream_every__closure": [2],
    Stream_every_closure0: {
      "^": "Closure:4;future",
      call$0: [function() {
        this.future._complete$1(true);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_every_closure": [2],
    Stream_any_closure: {
      "^": "Closure;_box_0,$this,test,future",
      call$1: [function(element) {
        var t1, t2;
        t1 = this._box_0;
        t2 = this.future;
        P._runUserCode(new P.Stream_any__closure(this.test, element), new P.Stream_any__closure0(t1, t2), P._cancelAndErrorClosure(t1.subscription, t2));
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$receiver, "Stream");
      }, 31, [], "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$this, "Stream");
      }
    },
    "+ Stream_any_closure": [2],
    Stream_any__closure: {
      "^": "Closure:4;test,element",
      call$0: [function() {
        return this.test.call$1(this.element);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_any__closure": [2],
    Stream_any__closure0: {
      "^": "Closure:33;_box_0,future",
      call$1: [function(isMatch) {
        if (isMatch === true)
          P._cancelAndValue(this._box_0.subscription, this.future, true);
      }, null, null, 2, 0, 33, 154, [], "call"]
    },
    "+ Stream_any__closure": [2],
    Stream_any_closure0: {
      "^": "Closure:4;future",
      call$0: [function() {
        this.future._complete$1(false);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_any_closure": [2],
    Stream_length_closure: {
      "^": "Closure:3;_box_0",
      call$1: [function(_) {
        ++this._box_0.count;
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ Stream_length_closure": [2],
    Stream_length_closure0: {
      "^": "Closure:4;_box_0,future",
      call$0: [function() {
        this.future._complete$1(this._box_0.count);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_length_closure": [2],
    Stream_isEmpty_closure: {
      "^": "Closure:3;_box_0,future",
      call$1: [function(_) {
        P._cancelAndValue(this._box_0.subscription, this.future, false);
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ Stream_isEmpty_closure": [2],
    Stream_isEmpty_closure0: {
      "^": "Closure:4;future",
      call$0: [function() {
        this.future._complete$1(true);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_isEmpty_closure": [2],
    Stream_toList_closure: {
      "^": "Closure;$this,result",
      call$1: [function(data) {
        this.result.push(data);
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$receiver, "Stream");
      }, 21, [], "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$this, "Stream");
      }
    },
    "+ Stream_toList_closure": [2],
    Stream_toList_closure0: {
      "^": "Closure:4;result,future",
      call$0: [function() {
        this.future._complete$1(this.result);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_toList_closure": [2],
    Stream_toSet_closure: {
      "^": "Closure;$this,result",
      call$1: [function(data) {
        this.result.add$1(0, data);
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$receiver, "Stream");
      }, 21, [], "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$this, "Stream");
      }
    },
    "+ Stream_toSet_closure": [2],
    Stream_toSet_closure0: {
      "^": "Closure:4;result,future",
      call$0: [function() {
        this.future._complete$1(this.result);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_toSet_closure": [2],
    Stream_first_closure: {
      "^": "Closure;_box_0,$this,future",
      call$1: [function(value) {
        P._cancelAndValue(this._box_0.subscription, this.future, value);
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$receiver, "Stream");
      }, 1, [], "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$this, "Stream");
      }
    },
    "+ Stream_first_closure": [2],
    Stream_first_closure0: {
      "^": "Closure:4;future",
      call$0: [function() {
        var e, s, t1, exception;
        try {
          t1 = H.IterableElementError_noElement();
          throw H.wrapException(t1);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          P._completeWithErrorCallback(this.future, e, s);
        }
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_first_closure": [2],
    Stream_last_closure: {
      "^": "Closure;_box_0,$this",
      call$1: [function(value) {
        var t1 = this._box_0;
        t1.foundResult = true;
        t1.result = value;
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$receiver, "Stream");
      }, 1, [], "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$this, "Stream");
      }
    },
    "+ Stream_last_closure": [2],
    Stream_last_closure0: {
      "^": "Closure:4;_box_0,future",
      call$0: [function() {
        var e, s, t1, exception;
        t1 = this._box_0;
        if (t1.foundResult) {
          this.future._complete$1(t1.result);
          return;
        }
        try {
          t1 = H.IterableElementError_noElement();
          throw H.wrapException(t1);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          P._completeWithErrorCallback(this.future, e, s);
        }
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_last_closure": [2],
    Stream_single_closure: {
      "^": "Closure;_box_0,$this,future",
      call$1: [function(value) {
        var e, s, t1, t2, exception;
        t1 = this._box_0;
        if (t1.foundResult) {
          try {
            t2 = H.IterableElementError_tooMany();
            throw H.wrapException(t2);
          } catch (exception) {
            t2 = H.unwrapException(exception);
            e = t2;
            s = H.getTraceFromException(exception);
            P._cancelAndErrorWithReplacement(t1.subscription, this.future, e, s);
          }
          return;
        }
        t1.foundResult = true;
        t1.result = value;
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$receiver, "Stream");
      }, 1, [], "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$this, "Stream");
      }
    },
    "+ Stream_single_closure": [2],
    Stream_single_closure0: {
      "^": "Closure:4;_box_0,future",
      call$0: [function() {
        var e, s, t1, exception;
        t1 = this._box_0;
        if (t1.foundResult) {
          this.future._complete$1(t1.result);
          return;
        }
        try {
          t1 = H.IterableElementError_noElement();
          throw H.wrapException(t1);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          P._completeWithErrorCallback(this.future, e, s);
        }
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_single_closure": [2],
    Stream_firstWhere_closure: {
      "^": "Closure;_box_0,$this,test,future",
      call$1: [function(value) {
        var t1, t2;
        t1 = this._box_0;
        t2 = this.future;
        P._runUserCode(new P.Stream_firstWhere__closure(this.test, value), new P.Stream_firstWhere__closure0(t1, t2, value), P._cancelAndErrorClosure(t1.subscription, t2));
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$receiver, "Stream");
      }, 1, [], "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$this, "Stream");
      }
    },
    "+ Stream_firstWhere_closure": [2],
    Stream_firstWhere__closure: {
      "^": "Closure:4;test,value",
      call$0: [function() {
        return this.test.call$1(this.value);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_firstWhere__closure": [2],
    Stream_firstWhere__closure0: {
      "^": "Closure:33;_box_0,future,value",
      call$1: [function(isMatch) {
        if (isMatch === true)
          P._cancelAndValue(this._box_0.subscription, this.future, this.value);
      }, null, null, 2, 0, 33, 154, [], "call"]
    },
    "+ Stream_firstWhere__closure": [2],
    Stream_firstWhere_closure0: {
      "^": "Closure:4;defaultValue,future",
      call$0: [function() {
        var e, s, t1, t2, exception;
        t1 = this.defaultValue;
        if (t1 != null) {
          t2 = this.future;
          P._runUserCode(t1, t2.get$_complete(), t2.get$_completeError());
          return;
        }
        try {
          t1 = H.IterableElementError_noElement();
          throw H.wrapException(t1);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          P._completeWithErrorCallback(this.future, e, s);
        }
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_firstWhere_closure": [2],
    Stream_lastWhere_closure: {
      "^": "Closure;_box_0,$this,test,future",
      call$1: [function(value) {
        var t1 = this._box_0;
        P._runUserCode(new P.Stream_lastWhere__closure(this.test, value), new P.Stream_lastWhere__closure0(t1, value), P._cancelAndErrorClosure(t1.subscription, this.future));
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$receiver, "Stream");
      }, 1, [], "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$this, "Stream");
      }
    },
    "+ Stream_lastWhere_closure": [2],
    Stream_lastWhere__closure: {
      "^": "Closure:4;test,value",
      call$0: [function() {
        return true === this.test.call$1(this.value);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_lastWhere__closure": [2],
    Stream_lastWhere__closure0: {
      "^": "Closure:33;_box_0,value",
      call$1: [function(isMatch) {
        var t1;
        if (isMatch === true) {
          t1 = this._box_0;
          t1.foundResult = true;
          t1.result = this.value;
        }
      }, null, null, 2, 0, 33, 154, [], "call"]
    },
    "+ Stream_lastWhere__closure": [2],
    Stream_lastWhere_closure0: {
      "^": "Closure:4;_box_0,defaultValue,future",
      call$0: [function() {
        var e, s, t1, t2, exception;
        t1 = this._box_0;
        if (t1.foundResult) {
          this.future._complete$1(t1.result);
          return;
        }
        t1 = this.defaultValue;
        if (t1 != null) {
          t2 = this.future;
          P._runUserCode(t1, t2.get$_complete(), t2.get$_completeError());
          return;
        }
        try {
          t1 = H.IterableElementError_noElement();
          throw H.wrapException(t1);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          P._completeWithErrorCallback(this.future, e, s);
        }
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_lastWhere_closure": [2],
    Stream_singleWhere_closure: {
      "^": "Closure;_box_0,$this,test,future",
      call$1: [function(value) {
        var t1, t2;
        t1 = this._box_0;
        t2 = this.future;
        P._runUserCode(new P.Stream_singleWhere__closure(this.test, value), new P.Stream_singleWhere__closure0(t1, t2, value), P._cancelAndErrorClosure(t1.subscription, t2));
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$receiver, "Stream");
      }, 1, [], "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$this, "Stream");
      }
    },
    "+ Stream_singleWhere_closure": [2],
    Stream_singleWhere__closure: {
      "^": "Closure:4;test,value",
      call$0: [function() {
        return true === this.test.call$1(this.value);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_singleWhere__closure": [2],
    Stream_singleWhere__closure0: {
      "^": "Closure:33;_box_0,future,value",
      call$1: [function(isMatch) {
        var e, s, t1, t2, exception;
        if (isMatch === true) {
          t1 = this._box_0;
          if (t1.foundResult) {
            try {
              t2 = H.IterableElementError_tooMany();
              throw H.wrapException(t2);
            } catch (exception) {
              t2 = H.unwrapException(exception);
              e = t2;
              s = H.getTraceFromException(exception);
              P._cancelAndErrorWithReplacement(t1.subscription, this.future, e, s);
            }
            return;
          }
          t1.foundResult = true;
          t1.result = this.value;
        }
      }, null, null, 2, 0, 33, 154, [], "call"]
    },
    "+ Stream_singleWhere__closure": [2],
    Stream_singleWhere_closure0: {
      "^": "Closure:4;_box_0,future",
      call$0: [function() {
        var e, s, t1, exception;
        t1 = this._box_0;
        if (t1.foundResult) {
          this.future._complete$1(t1.result);
          return;
        }
        try {
          t1 = H.IterableElementError_noElement();
          throw H.wrapException(t1);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          P._completeWithErrorCallback(this.future, e, s);
        }
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_singleWhere_closure": [2],
    Stream_elementAt_closure: {
      "^": "Closure;_box_0,$this,index,future",
      call$1: [function(value) {
        var t1 = this._box_0;
        if (J.$eq$(this.index, t1.elementIndex)) {
          P._cancelAndValue(t1.subscription, this.future, value);
          return;
        }
        ++t1.elementIndex;
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$receiver, "Stream");
      }, 1, [], "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, args: [T]};
        }, this.$this, "Stream");
      }
    },
    "+ Stream_elementAt_closure": [2],
    Stream_elementAt_closure0: {
      "^": "Closure:4;_box_0,$this,index,future",
      call$0: [function() {
        this.future._completeError$1(P.IndexError$(this.index, this.$this, "index", null, this._box_0.elementIndex));
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_elementAt_closure": [2],
    Stream_timeout_onData: {
      "^": "Closure;_box_0,$this,timeLimit",
      call$1: [function($event) {
        var t1 = this._box_0;
        t1.timer.cancel$0();
        t1.controller.add$1(0, $event);
        t1.timer = t1.zone.createTimer$2(this.timeLimit, t1.timeout);
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "Stream");
      }, 110, [], "call"],
      $signature: function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$this, "Stream");
      }
    },
    "+ Stream_timeout_onData": [2],
    Stream_timeout_onError: {
      "^": "Closure:71;_box_0,timeLimit",
      call$2: [function(error, stackTrace) {
        var t1 = this._box_0;
        t1.timer.cancel$0();
        t1.controller._addError$2(error, stackTrace);
        t1.timer = t1.zone.createTimer$2(this.timeLimit, t1.timeout);
      }, null, null, 4, 0, 71, 8, [], 12, [], "call"]
    },
    "+ Stream_timeout_onError": [2],
    Stream_timeout_onDone: {
      "^": "Closure:6;_box_0",
      call$0: [function() {
        var t1 = this._box_0;
        t1.timer.cancel$0();
        t1.controller.close$0();
      }, null, null, 0, 0, 6, "call"]
    },
    "+ Stream_timeout_onDone": [2],
    Stream_timeout_onListen: {
      "^": "Closure:6;_box_0,$this,timeLimit,onTimeout,onData,onError,onDone",
      call$0: [function() {
        var zone, t1, t2;
        zone = $.Zone__current;
        t1 = this._box_0;
        t1.zone = zone;
        t2 = this.onTimeout;
        if (t2 == null)
          t1.timeout = new P.Stream_timeout_onListen_closure(t1, this.timeLimit);
        else
          t1.timeout = new P.Stream_timeout_onListen_closure0(t1, zone.registerUnaryCallback$1(t2), new P._ControllerEventSinkWrapper(null, [null]));
        t1.subscription = this.$this.listen$3$onDone$onError(this.onData, this.onDone, this.onError);
        t1.timer = t1.zone.createTimer$2(this.timeLimit, t1.timeout);
      }, null, null, 0, 0, 6, "call"]
    },
    "+ Stream_timeout_onListen": [2],
    Stream_timeout_onListen_closure: {
      "^": "Closure:4;_box_0,timeLimit",
      call$0: [function() {
        this._box_0.controller.addError$2(new P.TimeoutException("No stream event", this.timeLimit), null);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_timeout_onListen_closure": [2],
    Stream_timeout_onListen_closure0: {
      "^": "Closure:4;_box_0,registeredOnTimeout,wrapper",
      call$0: [function() {
        var t1, t2;
        t1 = this.wrapper;
        t2 = this._box_0;
        t1._async$_sink = t2.controller;
        t2.zone.runUnaryGuarded$2(this.registeredOnTimeout, t1);
        t1._async$_sink = null;
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_timeout_onListen_closure": [2],
    Stream_timeout_onCancel: {
      "^": "Closure:18;_box_0",
      call$0: [function() {
        var t1, result;
        t1 = this._box_0;
        t1.timer.cancel$0();
        result = t1.subscription.cancel$0();
        t1.subscription = null;
        return result;
      }, null, null, 0, 0, 18, "call"]
    },
    "+ Stream_timeout_onCancel": [2],
    Stream_timeout_closure: {
      "^": "Closure:4;_box_0",
      call$0: [function() {
        var t1 = this._box_0;
        t1.timer.cancel$0();
        t1.subscription.pause$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_timeout_closure": [2],
    Stream_timeout_closure0: {
      "^": "Closure:4;_box_0,timeLimit",
      call$0: [function() {
        var t1 = this._box_0;
        t1.subscription.resume$0();
        t1.timer = t1.zone.createTimer$2(this.timeLimit, t1.timeout);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Stream_timeout_closure": [2],
    StreamSubscription: {
      "^": "Object;$ti",
      "<>": [962],
      static: {
        StreamSubscription$: [function($T) {
          return new P.StreamSubscription([$T]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P.StreamSubscription, T]};
          }, this.$receiver, "StreamSubscription");
        }, "new StreamSubscription"]
      }
    },
    "+StreamSubscription": [1],
    EventSink: {
      "^": "Object;$ti",
      "<>": [528],
      static: {
        EventSink$: [function($T) {
          return new P.EventSink([$T]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P.EventSink, T]};
          }, this.$receiver, "EventSink");
        }, "new EventSink"]
      }
    },
    "+EventSink": [1, 1166],
    StreamView: {
      "^": "Stream;_stream<-447,$ti",
      get$isBroadcast: [function() {
        return this._stream.get$isBroadcast();
      }, null, null, 1, 0, 5, "isBroadcast"],
      asBroadcastStream$2$onCancel$onListen: [function(onCancel, onListen) {
        return this._stream.asBroadcastStream$2$onCancel$onListen(onCancel, onListen);
      }, function() {
        return this.asBroadcastStream$2$onCancel$onListen(null, null);
      }, "asBroadcastStream$0", "call$2$onCancel$onListen", "call$0", "get$asBroadcastStream", 0, 5, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Stream, T], named: {onCancel: {func: 1, v: true, args: [[P.StreamSubscription, T]]}, onListen: {func: 1, v: true, args: [[P.StreamSubscription, T]]}}};
        }, this.$receiver, "StreamView");
      }, 0, 0, 94, [], 95, [], "asBroadcastStream"],
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        return this._stream.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, onError);
      }, "listen$2$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, null);
      }, "listen$2$onDone", function(onData, cancelOnError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, null, null);
      }, "listen$2$cancelOnError", "call$4$cancelOnError$onDone$onError", "call$1", "call$2$onError", "call$3$onDone$onError", "call$3$onDone$onError", "call$2$onDone", "call$2$cancelOnError", "get$listen", 2, 7, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.StreamSubscription, T], args: [{func: 1, v: true, args: [T]}], named: {cancelOnError: P.bool, onDone: {func: 1, v: true}, onError: P.Function}};
        }, this.$receiver, "StreamView");
      }, 0, 0, 0, 27, [], 20, [], 28, [], 24, [], "listen"],
      "<>": [494],
      static: {
        StreamView$: [function(stream, $T) {
          return new P.StreamView(stream, [$T]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [[P.Stream, T]]};
          }, this.$receiver, "StreamView");
        }, 37, [], "new StreamView"]
      }
    },
    "+StreamView": [447],
    StreamConsumer: {
      "^": "Object;$ti",
      "<>": [959],
      static: {
        StreamConsumer$: [function($S) {
          return new P.StreamConsumer([$S]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(S) {
            return {func: 1, ret: [P.StreamConsumer, S]};
          }, this.$receiver, "StreamConsumer");
        }, "new StreamConsumer"]
      }
    },
    "+StreamConsumer": [1],
    StreamSink: {
      "^": "Object;$ti",
      "<>": [365],
      static: {
        StreamSink$: [function($S) {
          return new P.StreamSink([$S]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(S) {
            return {func: 1, ret: [P.StreamSink, S]};
          }, this.$receiver, "StreamSink");
        }, "new StreamSink"]
      }
    },
    "+StreamSink": [1, 1168, 1169],
    StreamTransformer: {
      "^": "Object;$ti",
      "<>": [940, 939],
      static: {
        StreamTransformer_StreamTransformer: [function(transformer, $S, $T) {
          return new P._StreamSubscriptionTransformer(transformer, [$S, $T]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(S, T) {
            return {func: 1, ret: [P.StreamTransformer, S, T], args: [{func: 1, ret: [P.StreamSubscription, T], args: [[P.Stream, S], P.bool]}]};
          }, this.$receiver, "StreamTransformer");
        }, 836, [], "new StreamTransformer"],
        StreamTransformer_StreamTransformer$fromHandlers: [function(handleData, handleDone, handleError, $S, $T) {
          return P._StreamHandlerTransformer$(handleData, handleDone, handleError, $S, $T);
        }, null, null, 0, 7, function() {
          return H.computeSignature(function(S, T) {
            return {func: 1, ret: [P.StreamTransformer, S, T], named: {handleData: {func: 1, v: true, args: [S, [P.EventSink, T]]}, handleDone: {func: 1, v: true, args: [[P.EventSink, T]]}, handleError: {func: 1, v: true, args: [P.Object, P.StackTrace, [P.EventSink, T]]}}};
          }, this.$receiver, "StreamTransformer");
        }, 0, 0, 0, 175, [], 157, [], 164, [], "new StreamTransformer$fromHandlers"]
      }
    },
    "+StreamTransformer": [1],
    StreamIterator: {
      "^": "Object;$ti",
      "<>": [922],
      static: {
        StreamIterator_StreamIterator: [function(stream, $T) {
          return new P._StreamIterator(null, stream, false, [$T]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P.StreamIterator, T], args: [[P.Stream, T]]};
          }, this.$receiver, "StreamIterator");
        }, 37, [], "new StreamIterator"]
      }
    },
    "+StreamIterator": [1],
    _ControllerEventSinkWrapper: {
      "^": "Object;_async$_sink@-237,$ti",
      add$1: [function(_, data) {
        J.add$1$ax(this._async$_sink, data);
      }, "call$1", "get$add", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "_ControllerEventSinkWrapper");
      }, 21, [], "add"],
      addError$2: [function(error, stackTrace) {
        this._async$_sink.addError$2(error, stackTrace);
      }, function(error) {
        return this.addError$2(error, null);
      }, "addError$1", "call$2", "call$1", "get$addError", 2, 2, 81, 0, 8, [], 12, [], "addError"],
      close$0: [function() {
        this._async$_sink.close$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      "<>": [485],
      static: {
        _ControllerEventSinkWrapper$: [function(_sink, $T) {
          return new P._ControllerEventSinkWrapper(_sink, [$T]);
        }, null, null, 2, 0, 145, 45, [], "new _ControllerEventSinkWrapper"]
      }
    },
    "+_ControllerEventSinkWrapper": [1, 1171],
    StreamController: {
      "^": "Object;$ti",
      onListen$0: function() {
        return this.get$onListen().call$0();
      },
      onResume$0: function() {
        return this.get$onResume().call$0();
      },
      onCancel$0: function() {
        return this.get$onCancel().call$0();
      },
      "<>": [608],
      static: {
        StreamController_StreamController: [function(onCancel, onListen, onPause, onResume, sync, $T) {
          return sync === true ? new P._SyncStreamController(null, 0, null, onListen, onPause, onResume, onCancel, [$T]) : new P._AsyncStreamController(null, 0, null, onListen, onPause, onResume, onCancel, [$T]);
        }, null, null, 0, 11, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P.StreamController, T], named: {onCancel: {func: 1}, onListen: {func: 1, v: true}, onPause: {func: 1, v: true}, onResume: {func: 1, v: true}, sync: P.bool}};
          }, this.$receiver, "StreamController");
        }, 0, 0, 0, 0, 4, 94, [], 250, [], 251, [], 95, [], 558, [], "new StreamController"],
        StreamController_StreamController$broadcast: [function(onCancel, onListen, sync, $T) {
          return sync === true ? new P._SyncBroadcastStreamController(onListen, onCancel, 0, null, null, null, null, [$T]) : new P._AsyncBroadcastStreamController(onListen, onCancel, 0, null, null, null, null, [$T]);
        }, null, null, 0, 7, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P.StreamController, T], named: {onCancel: {func: 1, v: true}, onListen: {func: 1, v: true}, sync: P.bool}};
          }, this.$receiver, "StreamController");
        }, 0, 0, 4, 94, [], 95, [], 558, [], "new StreamController$broadcast"]
      }
    },
    "+StreamController": [1, 1172],
    SynchronousStreamController: {
      "^": "Object;$ti",
      "<>": [614],
      static: {
        SynchronousStreamController$: [function($T) {
          return new P.SynchronousStreamController([$T]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P.SynchronousStreamController, T]};
          }, this.$receiver, "SynchronousStreamController");
        }, "new SynchronousStreamController"]
      }
    },
    "+SynchronousStreamController": [1, 1173],
    _StreamControllerLifecycle: {
      "^": "Object;$ti",
      _recordPause$1: [function(subscription) {
      }, "call$1", "get$_recordPause", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [[P.StreamSubscription, T]]};
        }, this.$receiver, "_StreamControllerLifecycle");
      }, 50, [], "_recordPause"],
      _recordResume$1: [function(subscription) {
      }, "call$1", "get$_recordResume", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [[P.StreamSubscription, T]]};
        }, this.$receiver, "_StreamControllerLifecycle");
      }, 50, [], "_recordResume"],
      _recordCancel$1: [function(subscription) {
        return;
      }, "call$1", "get$_recordCancel", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: P.Future, args: [[P.StreamSubscription, T]]};
        }, this.$receiver, "_StreamControllerLifecycle");
      }, 50, [], "_recordCancel"],
      "<>": [956],
      static: {
        _StreamControllerLifecycle$: [function($T) {
          return new P._StreamControllerLifecycle([$T]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P._StreamControllerLifecycle, T]};
          }, this.$receiver, "_StreamControllerLifecycle");
        }, "new _StreamControllerLifecycle"]
      }
    },
    "+_StreamControllerLifecycle": [1],
    _StreamController: {
      "^": "Object;_varData@-10,_state@-0,_doneFuture@-66,onListen@-47,onPause@-47,onResume@-47,onCancel@-101,$ti",
      get$stream: [function() {
        return new P._ControllerStream(this, this.$ti);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Stream, T]};
        }, this.$receiver, "_StreamController");
      }, "stream"],
      get$sink: [function() {
        return new P._StreamSinkWrapper(this, this.$ti);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.StreamSink, T]};
        }, this.$receiver, "_StreamController");
      }, "sink"],
      get$_async$_isCanceled: [function() {
        return J.$and$n(this._state, 2) !== 0;
      }, null, null, 1, 0, 5, "_async$_isCanceled"],
      get$hasListener: [function() {
        return J.$and$n(this._state, 1) !== 0;
      }, null, null, 1, 0, 5, "hasListener"],
      get$_isInitialState: [function() {
        return J.$and$n(this._state, 3) === 0;
      }, null, null, 1, 0, 5, "_isInitialState"],
      get$isClosed: [function() {
        return J.$and$n(this._state, 4) !== 0;
      }, null, null, 1, 0, 5, "isClosed"],
      get$isPaused: [function() {
        return J.$and$n(this._state, 1) !== 0 ? this.get$_subscription().get$_isInputPaused() : J.$and$n(this._state, 2) === 0;
      }, null, null, 1, 0, 5, "isPaused"],
      get$_isAddingStream: [function() {
        return J.$and$n(this._state, 8) !== 0;
      }, null, null, 1, 0, 5, "_isAddingStream"],
      get$_mayAddEvent: [function() {
        return J.$lt$n(this._state, 4);
      }, null, null, 1, 0, 5, "_mayAddEvent"],
      get$_pendingEvents: [function() {
        if (J.$and$n(this._state, 8) === 0)
          return this._varData;
        return this._varData.get$varData();
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P._PendingEvents, T]};
        }, this.$receiver, "_StreamController");
      }, "_pendingEvents"],
      _ensurePendingEvents$0: [function() {
        var t1, state;
        if (J.$and$n(this._state, 8) === 0) {
          t1 = this._varData;
          if (t1 == null) {
            t1 = new P._StreamImplEvents(null, null, 0, this.$ti);
            this._varData = t1;
          }
          return t1;
        }
        state = this._varData;
        if (state.get$varData() == null)
          state.set$varData(new P._StreamImplEvents(null, null, 0, this.$ti));
        return state.get$varData();
      }, "call$0", "get$_ensurePendingEvents", 0, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P._StreamImplEvents, T]};
        }, this.$receiver, "_StreamController");
      }, "_ensurePendingEvents"],
      get$_subscription: [function() {
        if (J.$and$n(this._state, 8) !== 0)
          return this._varData.get$varData();
        return this._varData;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P._ControllerSubscription, T]};
        }, this.$receiver, "_StreamController");
      }, "_subscription"],
      _badEventState$0: [function() {
        if (J.$and$n(this._state, 4) !== 0)
          return new P.StateError("Cannot add event after closing");
        return new P.StateError("Cannot add event while adding a stream");
      }, "call$0", "get$_badEventState", 0, 0, 347, "_badEventState"],
      addStream$2$cancelOnError: [function(source, cancelOnError) {
        var t1, t2, t3;
        if (!J.$lt$n(this._state, 4))
          throw H.wrapException(this._badEventState$0());
        if (J.$and$n(this._state, 2) !== 0) {
          t1 = new P._Future(0, $.Zone__current, null, [null]);
          t1._asyncComplete$1(null);
          return t1;
        }
        t1 = this._varData;
        t2 = new P._Future(0, $.Zone__current, null, [null]);
        t3 = cancelOnError === true ? P._AddStreamState_makeErrorHandler(this) : this.get$_addError();
        t3 = source.listen$4$cancelOnError$onDone$onError(this.get$_async$_add(), cancelOnError, this.get$_async$_close(), t3);
        if (this.get$isPaused())
          t3.pause$0();
        this._varData = new P._StreamControllerAddStreamState(t1, t2, t3, this.$ti);
        this._state = J.$or$n(this._state, 8);
        return t2;
      }, function(source) {
        return this.addStream$2$cancelOnError(source, true);
      }, "addStream$1", "call$2$cancelOnError", "call$1", "get$addStream", 2, 3, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: P.Future, args: [[P.Stream, T]], named: {cancelOnError: P.bool}};
        }, this.$receiver, "_StreamController");
      }, 25, 19, [], 24, [], "addStream"],
      get$done: [function() {
        return this._ensureDoneFuture$0();
      }, null, null, 1, 0, 18, "done"],
      _ensureDoneFuture$0: [function() {
        var t1 = this._doneFuture;
        if (t1 == null) {
          t1 = J.$and$n(this._state, 2) !== 0 ? $.$get$Future__nullFuture() : new P._Future(0, $.Zone__current, null, [null]);
          this._doneFuture = t1;
        }
        return t1;
      }, "call$0", "get$_ensureDoneFuture", 0, 0, 18, "_ensureDoneFuture"],
      add$1: [function(_, value) {
        if (!J.$lt$n(this._state, 4))
          throw H.wrapException(this._badEventState$0());
        if (J.$and$n(this._state, 1) !== 0)
          this._sendData$1(value);
        else if (J.$and$n(this._state, 3) === 0)
          J.add$1$ax(this._ensurePendingEvents$0(), new P._DelayedData(value, null, this.$ti));
      }, "call$1", "get$add", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "_StreamController");
      }, 1, [], "add"],
      addError$2: [function(error, stackTrace) {
        var replacement;
        if (!J.$lt$n(this._state, 4))
          throw H.wrapException(this._badEventState$0());
        if (error == null)
          error = new P.NullThrownError();
        replacement = $.Zone__current.errorCallback$2(error, stackTrace);
        if (replacement != null) {
          error = replacement.get$error();
          if (error == null)
            error = new P.NullThrownError();
          stackTrace = replacement.get$stackTrace();
        }
        this._addError$2(error, stackTrace);
      }, function(error) {
        return this.addError$2(error, null);
      }, "addError$1", "call$2", "call$1", "get$addError", 2, 2, 48, 0, 8, [], 12, [], "addError"],
      close$0: [function() {
        if (J.$and$n(this._state, 4) !== 0)
          return this._ensureDoneFuture$0();
        if (!J.$lt$n(this._state, 4))
          throw H.wrapException(this._badEventState$0());
        this._closeUnchecked$0();
        return this._ensureDoneFuture$0();
      }, "call$0", "get$close", 0, 0, 18, "close"],
      _closeUnchecked$0: [function() {
        var t1 = J.$or$n(this._state, 4);
        this._state = t1;
        if (J.$and$n(t1, 1) !== 0)
          this._sendDone$0();
        else if (J.$and$n(this._state, 3) === 0)
          J.add$1$ax(this._ensurePendingEvents$0(), C.C__DelayedDone);
      }, "call$0", "get$_closeUnchecked", 0, 0, 6, "_closeUnchecked"],
      _async$_add$1: [function(value) {
        if (J.$and$n(this._state, 1) !== 0)
          this._sendData$1(value);
        else if (J.$and$n(this._state, 3) === 0)
          J.add$1$ax(this._ensurePendingEvents$0(), new P._DelayedData(value, null, this.$ti));
      }, "call$1", "get$_async$_add", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "_StreamController");
      }, 1, [], "_async$_add"],
      _addError$2: [function(error, stackTrace) {
        if (J.$and$n(this._state, 1) !== 0)
          this._sendError$2(error, stackTrace);
        else if (J.$and$n(this._state, 3) === 0)
          J.add$1$ax(this._ensurePendingEvents$0(), new P._DelayedError(error, stackTrace, null));
      }, "call$2", "get$_addError", 4, 0, 49, 8, [], 12, [], "_addError"],
      _async$_close$0: [function() {
        var addState = this._varData;
        this._varData = addState.get$varData();
        this._state = J.$and$n(this._state, 4294967287);
        addState.complete$0();
      }, "call$0", "get$_async$_close", 0, 0, 6, "_async$_close"],
      _subscribe$4: [function(onData, onError, onDone, cancelOnError) {
        var t1, t2, subscription, pendingEvents, addState;
        if (J.$and$n(this._state, 3) !== 0)
          throw H.wrapException(new P.StateError("Stream has already been listened to."));
        t1 = $.Zone__current;
        t2 = cancelOnError === true ? 1 : 0;
        subscription = new P._ControllerSubscription(this, null, null, null, t1, t2, null, null, this.$ti);
        subscription._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, H.getTypeArgumentByIndex(this, 0));
        pendingEvents = this.get$_pendingEvents();
        t2 = J.$or$n(this._state, 1);
        this._state = t2;
        if (J.$and$n(t2, 8) !== 0) {
          addState = this._varData;
          addState.set$varData(subscription);
          addState.resume$0();
        } else
          this._varData = subscription;
        subscription._setPendingEvents$1(pendingEvents);
        subscription._guardCallback$1(new P._StreamController__subscribe_closure(this));
        return subscription;
      }, "call$4", "get$_subscribe", 8, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.StreamSubscription, T], args: [{func: 1, v: true, args: [T]}, P.Function, {func: 1, v: true}, P.bool]};
        }, this.$receiver, "_StreamController");
      }, 27, [], 20, [], 28, [], 24, [], "_subscribe"],
      _recordCancel$1: [function(subscription) {
        var result, e, s, t1, exception, result0;
        result = null;
        if (J.$and$n(this._state, 8) !== 0)
          result = this._varData.cancel$0();
        this._varData = null;
        this._state = J.$or$n(J.$and$n(this._state, 4294967286), 2);
        t1 = this.onCancel;
        if (t1 != null)
          if (result == null)
            try {
              result = t1.call$0();
            } catch (exception) {
              t1 = H.unwrapException(exception);
              e = t1;
              s = H.getTraceFromException(exception);
              result0 = new P._Future(0, $.Zone__current, null, [null]);
              result0._asyncCompleteError$2(e, s);
              result = result0;
            }
          else
            result = result.whenComplete$1(t1);
        t1 = new P._StreamController__recordCancel_complete(this);
        if (result != null)
          result = result.whenComplete$1(t1);
        else
          t1.call$0();
        return result;
      }, "call$1", "get$_recordCancel", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: P.Future, args: [[P.StreamSubscription, T]]};
        }, this.$receiver, "_StreamController");
      }, 50, [], "_recordCancel"],
      _recordPause$1: [function(subscription) {
        if (J.$and$n(this._state, 8) !== 0)
          this._varData.pause$0();
        P._runGuarded(this.onPause);
      }, "call$1", "get$_recordPause", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [[P.StreamSubscription, T]]};
        }, this.$receiver, "_StreamController");
      }, 50, [], "_recordPause"],
      _recordResume$1: [function(subscription) {
        if (J.$and$n(this._state, 8) !== 0)
          this._varData.resume$0();
        P._runGuarded(this.onResume);
      }, "call$1", "get$_recordResume", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [[P.StreamSubscription, T]]};
        }, this.$receiver, "_StreamController");
      }, 50, [], "_recordResume"],
      onListen$0: function() {
        return this.onListen.call$0();
      },
      onResume$0: function() {
        return this.onResume.call$0();
      },
      onCancel$0: function() {
        return this.onCancel.call$0();
      },
      "<>": [222],
      static: {
        "^": "_StreamController__STATE_INITIAL<-0,_StreamController__STATE_SUBSCRIBED<-0,_StreamController__STATE_CANCELED<-0,_StreamController__STATE_SUBSCRIPTION_MASK<-0,_StreamController__STATE_CLOSED<-0,_StreamController__STATE_ADDSTREAM<-0",
        _StreamController$: [function(onListen, onPause, onResume, onCancel, $T) {
          return new P._StreamController(null, 0, null, onListen, onPause, onResume, onCancel, [$T]);
        }, null, null, 8, 0, 251, 94, [], 250, [], 251, [], 95, [], "new _StreamController"]
      }
    },
    "+_StreamController": [1, 1174, 1175, 1176, 1177],
    _StreamController__subscribe_closure: {
      "^": "Closure:4;$this",
      call$0: [function() {
        P._runGuarded(this.$this.onListen);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _StreamController__subscribe_closure": [2],
    _StreamController__recordCancel_complete: {
      "^": "Closure:6;$this",
      call$0: [function() {
        var t1, t2;
        t1 = this.$this;
        t2 = t1._doneFuture;
        if (t2 != null && t2.get$_mayComplete())
          t1._doneFuture._asyncComplete$1(null);
      }, null, null, 0, 0, 6, "call"]
    },
    "+ _StreamController__recordCancel_complete": [2],
    _SyncStreamControllerDispatch: {
      "^": "Object;$ti",
      _sendData$1: [function(data) {
        this.get$_subscription()._async$_add$1(data);
      }, "call$1", "get$_sendData", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "_SyncStreamControllerDispatch");
      }, 21, [], "_sendData"],
      _sendError$2: [function(error, stackTrace) {
        this.get$_subscription()._addError$2(error, stackTrace);
      }, "call$2", "get$_sendError", 4, 0, 49, 8, [], 12, [], "_sendError"],
      _sendDone$0: [function() {
        this.get$_subscription()._async$_close$0();
      }, "call$0", "get$_sendDone", 0, 0, 6, "_sendDone"],
      "<>": [412],
      static: {
        _SyncStreamControllerDispatch$: [function($T) {
          return new P._SyncStreamControllerDispatch([$T]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P._SyncStreamControllerDispatch, T]};
          }, this.$receiver, "_SyncStreamControllerDispatch");
        }, "new _SyncStreamControllerDispatch"]
      }
    },
    "+_SyncStreamControllerDispatch": [1, 1178, 1179],
    _AsyncStreamControllerDispatch: {
      "^": "Object;$ti",
      _sendData$1: [function(data) {
        this.get$_subscription()._addPending$1(new P._DelayedData(data, null, [H.getRuntimeTypeArgument(this, "_AsyncStreamControllerDispatch", 0)]));
      }, "call$1", "get$_sendData", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "_AsyncStreamControllerDispatch");
      }, 21, [], "_sendData"],
      _sendError$2: [function(error, stackTrace) {
        this.get$_subscription()._addPending$1(new P._DelayedError(error, stackTrace, null));
      }, "call$2", "get$_sendError", 4, 0, 49, 8, [], 12, [], "_sendError"],
      _sendDone$0: [function() {
        this.get$_subscription()._addPending$1(C.C__DelayedDone);
      }, "call$0", "get$_sendDone", 0, 0, 6, "_sendDone"],
      "<>": [483],
      static: {
        _AsyncStreamControllerDispatch$: [function($T) {
          return new P._AsyncStreamControllerDispatch([$T]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P._AsyncStreamControllerDispatch, T]};
          }, this.$receiver, "_AsyncStreamControllerDispatch");
        }, "new _AsyncStreamControllerDispatch"]
      }
    },
    "+_AsyncStreamControllerDispatch": [1, 1180],
    _AsyncStreamController: {
      "^": "_StreamController+_AsyncStreamControllerDispatch;_varData-10,_state-0,_doneFuture-66,onListen-47,onPause-47,onResume-47,onCancel-101,$ti",
      "<>": [401],
      static: {
        _AsyncStreamController$: [function(onListen, onPause, onResume, onCancel, $T) {
          return new P._AsyncStreamController(null, 0, null, onListen, onPause, onResume, onCancel, [$T]);
        }, null, null, 8, 0, 251, 94, [], 250, [], 251, [], 95, [], "new _AsyncStreamController"]
      }
    },
    "+_AsyncStreamController": [1181, 1182],
    _SyncStreamController: {
      "^": "_StreamController+_SyncStreamControllerDispatch;_varData-10,_state-0,_doneFuture-66,onListen-47,onPause-47,onResume-47,onCancel-101,$ti",
      "<>": [312],
      static: {
        _SyncStreamController$: [function(onListen, onPause, onResume, onCancel, $T) {
          return new P._SyncStreamController(null, 0, null, onListen, onPause, onResume, onCancel, [$T]);
        }, null, null, 8, 0, 251, 94, [], 250, [], 251, [], 95, [], "new _SyncStreamController"]
      }
    },
    "+_SyncStreamController": [1183, 1184],
    _ControllerStream: {
      "^": "_StreamImpl;_async$_controller@-443,$ti",
      _createSubscription$4: [function(onData, onError, onDone, cancelOnError) {
        return this._async$_controller._subscribe$4(onData, onError, onDone, cancelOnError);
      }, "call$4", "get$_createSubscription", 8, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.StreamSubscription, T], args: [{func: 1, v: true, args: [T]}, P.Function, {func: 1, v: true}, P.bool]};
        }, this.$receiver, "_ControllerStream");
      }, 27, [], 20, [], 28, [], 24, [], "_createSubscription"],
      get$hashCode: [function(_) {
        return J.$xor$n(J.get$hashCode$(this._async$_controller), 892482866);
      }, null, null, 1, 0, 11, "hashCode"],
      $eq: [function(_, other) {
        var t1, t2;
        if (other == null)
          return false;
        if (this === other)
          return true;
        if (!(other instanceof P._ControllerStream))
          return false;
        t1 = other._async$_controller;
        t2 = this._async$_controller;
        return t1 == null ? t2 == null : t1 === t2;
      }, null, "get$==", 2, 0, 15, 2, [], "=="],
      "<>": [381],
      static: {
        _ControllerStream$: [function(_controller, $T) {
          return new P._ControllerStream(_controller, [$T]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [[P._StreamControllerLifecycle, T]]};
          }, this.$receiver, "_ControllerStream");
        }, 551, [], "new _ControllerStream"]
      }
    },
    "+_ControllerStream": [1185],
    _ControllerSubscription: {
      "^": "_BufferingStreamSubscription;_async$_controller<-445,_onData-124,_onError-29,_onDone-90,_zone-51,_state-0,_cancelFuture-86,_pending-126,$ti",
      _onCancel$0: [function() {
        return this._async$_controller._recordCancel$1(this);
      }, "call$0", "get$_onCancel", 0, 0, 18, "_onCancel"],
      _onPause$0: [function() {
        this._async$_controller._recordPause$1(this);
      }, "call$0", "get$_onPause", 0, 0, 6, "_onPause"],
      _onResume$0: [function() {
        this._async$_controller._recordResume$1(this);
      }, "call$0", "get$_onResume", 0, 0, 6, "_onResume"],
      "<>": [305],
      static: {
        _ControllerSubscription$: [function(_controller, onData, onError, onDone, cancelOnError, $T) {
          var t1, t2;
          t1 = $.Zone__current;
          t2 = cancelOnError === true ? 1 : 0;
          t2 = new P._ControllerSubscription(_controller, null, null, null, t1, t2, null, null, [$T]);
          t2._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, $T);
          return t2;
        }, null, null, 10, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [[P._StreamControllerLifecycle, T], {func: 1, v: true, args: [T]}, P.Function, {func: 1, v: true}, P.bool]};
          }, this.$receiver, "_ControllerSubscription");
        }, 551, [], 27, [], 20, [], 28, [], 24, [], "new _ControllerSubscription"]
      }
    },
    "+_ControllerSubscription": [1186],
    _StreamSinkWrapper: {
      "^": "Object;_async$_target<-236,$ti",
      add$1: [function(_, data) {
        J.add$1$ax(this._async$_target, data);
      }, "call$1", "get$add", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "_StreamSinkWrapper");
      }, 21, [], "add"],
      addError$2: [function(error, stackTrace) {
        this._async$_target.addError$2(error, stackTrace);
      }, function(error) {
        return this.addError$2(error, null);
      }, "addError$1", "call$2", "call$1", "get$addError", 2, 2, 48, 0, 8, [], 12, [], "addError"],
      close$0: [function() {
        return this._async$_target.close$0();
      }, "call$0", "get$close", 0, 0, 18, "close"],
      addStream$2$cancelOnError: [function(source, cancelOnError) {
        return this._async$_target.addStream$2$cancelOnError(source, cancelOnError);
      }, function(source) {
        return this.addStream$2$cancelOnError(source, true);
      }, "addStream$1", "call$2$cancelOnError", "call$1", "get$addStream", 2, 3, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: P.Future, args: [[P.Stream, T]], named: {cancelOnError: P.bool}};
        }, this.$receiver, "_StreamSinkWrapper");
      }, 25, 19, [], 24, [], "addStream"],
      get$done: [function() {
        return this._async$_target.get$done();
      }, null, null, 1, 0, 18, "done"],
      "<>": [473],
      static: {
        _StreamSinkWrapper$: [function(_target, $T) {
          return new P._StreamSinkWrapper(_target, [$T]);
        }, null, null, 2, 0, 577, 547, [], "new _StreamSinkWrapper"]
      }
    },
    "+_StreamSinkWrapper": [1, 1188],
    _AddStreamState: {
      "^": "Object;addStreamFuture<-66,addSubscription<-103,$ti",
      pause$0: [function() {
        this.addSubscription.pause$0();
      }, "call$0", "get$pause", 0, 0, 6, "pause"],
      resume$0: [function() {
        this.addSubscription.resume$0();
      }, "call$0", "get$resume", 0, 0, 6, "resume"],
      cancel$0: [function() {
        var cancel = this.addSubscription.cancel$0();
        if (cancel == null) {
          this.addStreamFuture._asyncComplete$1(null);
          return;
        }
        return cancel.whenComplete$1(new P._AddStreamState_cancel_closure(this));
      }, "call$0", "get$cancel", 0, 0, 18, "cancel"],
      complete$0: [function() {
        this.addStreamFuture._asyncComplete$1(null);
      }, "call$0", "get$complete", 0, 0, 6, "complete"],
      "<>": [920],
      static: {
        _AddStreamState$: [function(controller, source, cancelOnError, $T) {
          var t1, t2, t3;
          t1 = $.Zone__current;
          t2 = controller.get$_async$_add();
          t3 = cancelOnError === true ? P._AddStreamState_makeErrorHandler(controller) : controller.get$_addError();
          return new P._AddStreamState(new P._Future(0, t1, null, [null]), source.listen$4$cancelOnError$onDone$onError(t2, cancelOnError, controller.get$_async$_close(), t3), [$T]);
        }, null, null, 6, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [[P._EventSink, T], P.Stream, P.bool]};
          }, this.$receiver, "_AddStreamState");
        }, 184, [], 19, [], 24, [], "new _AddStreamState"],
        _AddStreamState_makeErrorHandler: [function(controller) {
          return new P._AddStreamState_makeErrorHandler_closure(controller);
        }, "call$1", "async__AddStreamState_makeErrorHandler$closure", 2, 0, 385, 184, [], "makeErrorHandler"]
      }
    },
    "+_AddStreamState": [1],
    _AddStreamState_makeErrorHandler_closure: {
      "^": "Closure:80;controller",
      call$2: [function(e, s) {
        var t1 = this.controller;
        t1._addError$2(e, s);
        t1._async$_close$0();
      }, null, null, 4, 0, 80, 47, [], 49, [], "call"]
    },
    "+ _AddStreamState_makeErrorHandler_closure": [2],
    _AddStreamState_cancel_closure: {
      "^": "Closure:4;$this",
      call$0: [function() {
        this.$this.addStreamFuture._asyncComplete$1(null);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _AddStreamState_cancel_closure": [2],
    _StreamControllerAddStreamState: {
      "^": "_AddStreamState;varData@-10,addStreamFuture-66,addSubscription-103,$ti",
      "<>": [470],
      static: {
        _StreamControllerAddStreamState$: [function(controller, varData, source, cancelOnError, $T) {
          var t1, t2, t3;
          t1 = $.Zone__current;
          t2 = controller.get$_async$_add();
          t3 = cancelOnError === true ? P._AddStreamState_makeErrorHandler(controller) : controller.get$_addError();
          t3 = source.listen$4$cancelOnError$onDone$onError(t2, cancelOnError, controller.get$_async$_close(), t3);
          if (controller.get$isPaused())
            t3.pause$0();
          return new P._StreamControllerAddStreamState(varData, new P._Future(0, t1, null, [null]), t3, [$T]);
        }, null, null, 8, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [[P._StreamController, T],, P.Stream, P.bool]};
          }, this.$receiver, "_StreamControllerAddStreamState");
        }, 184, [], 834, [], 19, [], 24, [], "new _StreamControllerAddStreamState"]
      }
    },
    "+_StreamControllerAddStreamState": [1190],
    _EventSink: {
      "^": "Object;$ti",
      "<>": [963],
      static: {
        _EventSink$: [function($T) {
          return new P._EventSink([$T]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P._EventSink, T]};
          }, this.$receiver, "_EventSink");
        }, "new _EventSink"]
      }
    },
    "+_EventSink": [1],
    _EventDispatch: {
      "^": "Object;$ti",
      "<>": [964],
      static: {
        _EventDispatch$: [function($T) {
          return new P._EventDispatch([$T]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P._EventDispatch, T]};
          }, this.$receiver, "_EventDispatch");
        }, "new _EventDispatch"]
      }
    },
    "+_EventDispatch": [1],
    _BufferingStreamSubscription: {
      "^": "Object;_onData@-124,_onError@-29,_onDone@-90,_zone<-51,_state@-0,_cancelFuture@-86,_pending@-126,$ti",
      _setPendingEvents$1: [function(pendingEvents) {
        if (pendingEvents == null)
          return;
        this._pending = pendingEvents;
        if (J.get$isEmpty$asx(pendingEvents) !== true) {
          this._state = J.$or$n(this._state, 64);
          this._pending.schedule$1(this);
        }
      }, "call$1", "get$_setPendingEvents", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [[P._PendingEvents, T]]};
        }, this.$receiver, "_BufferingStreamSubscription");
      }, 784, [], "_setPendingEvents"],
      onData$1: [function(handleData) {
        if (handleData == null)
          handleData = P.async___nullDataHandler$closure();
        this._onData = this._zone.registerUnaryCallback$1(handleData);
      }, "call$1", "get$onData", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [{func: 1, v: true, args: [T]}]};
        }, this.$receiver, "_BufferingStreamSubscription");
      }, 175, [], "onData"],
      onError$1: [function(handleError) {
        if (handleError == null)
          handleError = P.async___nullErrorHandler$closure();
        this._onError = P._registerErrorHandler(handleError, this._zone);
      }, "call$1", "get$onError", 2, 0, 164, 157, [], "onError"],
      onDone$1: [function(handleDone) {
        if (handleDone == null)
          handleDone = P.async___nullDoneHandler$closure();
        this._onDone = this._zone.registerCallback$1(handleDone);
      }, "call$1", "get$onDone", 2, 0, 37, 164, [], "onDone"],
      pause$1: [function(resumeSignal) {
        var wasPaused, t1;
        if (J.$and$n(this._state, 8) !== 0)
          return;
        wasPaused = J.$ge$n(this._state, 128);
        t1 = J.$and$n(this._state, 4);
        this._state = J.$or$n(J.$add$ns(this._state, 128), 4);
        if (resumeSignal != null)
          resumeSignal.whenComplete$1(this.get$resume());
        if (!wasPaused && this._pending != null)
          this._pending.cancelSchedule$0();
        if (t1 === 0 && J.$and$n(this._state, 32) === 0)
          this._guardCallback$1(this.get$_onPause());
      }, function() {
        return this.pause$1(null);
      }, "pause$0", "call$1", "call$0", "get$pause", 0, 2, 217, 0, 221, [], "pause"],
      resume$0: [function() {
        if (J.$and$n(this._state, 8) !== 0)
          return;
        if (J.$ge$n(this._state, 128)) {
          var t1 = J.$sub$n(this._state, 128);
          this._state = t1;
          if (!J.$ge$n(t1, 128))
            if (J.$and$n(this._state, 64) !== 0 && J.get$isEmpty$asx(this._pending) !== true)
              this._pending.schedule$1(this);
            else {
              t1 = J.$and$n(this._state, 4294967291);
              this._state = t1;
              if (J.$and$n(t1, 32) === 0)
                this._guardCallback$1(this.get$_onResume());
            }
        }
      }, "call$0", "get$resume", 0, 0, 6, "resume"],
      cancel$0: [function() {
        var t1 = J.$and$n(this._state, 4294967279);
        this._state = t1;
        if (J.$and$n(t1, 8) === 0)
          this._cancel$0();
        t1 = this._cancelFuture;
        return t1 == null ? $.$get$Future__nullFuture() : t1;
      }, "call$0", "get$cancel", 0, 0, 18, "cancel"],
      asFuture$1: [function(futureValue) {
        var result = new P._Future(0, $.Zone__current, null, [null]);
        this._onDone = new P._BufferingStreamSubscription_asFuture_closure(futureValue, result);
        this._onError = new P._BufferingStreamSubscription_asFuture_closure0(this, result);
        return result;
      }, function() {
        return this.asFuture$1(null);
      }, "asFuture$0", "call$1", "call$0", "get$asFuture", 0, 2, function() {
        return {func: 1, ret: P.Future, opt: [,]};
      }, 0, 206, [], "asFuture"],
      get$_isInputPaused: [function() {
        return J.$and$n(this._state, 4) !== 0;
      }, null, null, 1, 0, 5, "_isInputPaused"],
      get$_async$_isClosed: [function() {
        return J.$and$n(this._state, 2) !== 0;
      }, null, null, 1, 0, 5, "_async$_isClosed"],
      get$_async$_isCanceled: [function() {
        return J.$and$n(this._state, 8) !== 0;
      }, null, null, 1, 0, 5, "_async$_isCanceled"],
      get$_waitsForCancel: [function() {
        return J.$and$n(this._state, 16) !== 0;
      }, null, null, 1, 0, 5, "_waitsForCancel"],
      get$_inCallback: [function() {
        return J.$and$n(this._state, 32) !== 0;
      }, null, null, 1, 0, 5, "_inCallback"],
      get$_hasPending: [function() {
        return J.$and$n(this._state, 64) !== 0;
      }, null, null, 1, 0, 5, "_hasPending"],
      get$_isPaused: [function() {
        return J.$ge$n(this._state, 128);
      }, null, null, 1, 0, 5, "_isPaused"],
      get$_canFire: [function() {
        return J.$lt$n(this._state, 32);
      }, null, null, 1, 0, 5, "_canFire"],
      get$_mayResumeInput: [function() {
        if (!J.$ge$n(this._state, 128)) {
          var t1 = this._pending;
          t1 = t1 == null || J.get$isEmpty$asx(t1) === true;
        } else
          t1 = false;
        return t1;
      }, null, null, 1, 0, 5, "_mayResumeInput"],
      get$_cancelOnError: [function() {
        return J.$and$n(this._state, 1) !== 0;
      }, null, null, 1, 0, 5, "_cancelOnError"],
      get$isPaused: [function() {
        return J.$ge$n(this._state, 128);
      }, null, null, 1, 0, 5, "isPaused"],
      _cancel$0: [function() {
        var t1 = J.$or$n(this._state, 8);
        this._state = t1;
        if (J.$and$n(t1, 64) !== 0)
          this._pending.cancelSchedule$0();
        if (J.$and$n(this._state, 32) === 0)
          this._pending = null;
        this._cancelFuture = this._onCancel$0();
      }, "call$0", "get$_cancel", 0, 0, 6, "_cancel"],
      _decrementPauseCount$0: [function() {
        this._state = J.$sub$n(this._state, 128);
      }, "call$0", "get$_decrementPauseCount", 0, 0, 6, "_decrementPauseCount"],
      _async$_add$1: ["super$_BufferingStreamSubscription$_add", function(data) {
        if (J.$and$n(this._state, 8) !== 0)
          return;
        if (J.$lt$n(this._state, 32))
          this._sendData$1(data);
        else
          this._addPending$1(new P._DelayedData(data, null, [H.getRuntimeTypeArgument(this, "_BufferingStreamSubscription", 0)]));
      }, "call$1", "get$_async$_add", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "_BufferingStreamSubscription");
      }, 21, [], "_async$_add"],
      _addError$2: ["super$_BufferingStreamSubscription$_addError", function(error, stackTrace) {
        if (J.$and$n(this._state, 8) !== 0)
          return;
        if (J.$lt$n(this._state, 32))
          this._sendError$2(error, stackTrace);
        else
          this._addPending$1(new P._DelayedError(error, stackTrace, null));
      }, "call$2", "get$_addError", 4, 0, 49, 8, [], 12, [], "_addError"],
      _async$_close$0: ["super$_BufferingStreamSubscription$_close", function() {
        if (J.$and$n(this._state, 8) !== 0)
          return;
        var t1 = J.$or$n(this._state, 2);
        this._state = t1;
        if (J.$lt$n(t1, 32))
          this._sendDone$0();
        else
          this._addPending$1(C.C__DelayedDone);
      }, "call$0", "get$_async$_close", 0, 0, 6, "_async$_close"],
      _onPause$0: [function() {
      }, "call$0", "get$_onPause", 0, 0, 6, "_onPause"],
      _onResume$0: [function() {
      }, "call$0", "get$_onResume", 0, 0, 6, "_onResume"],
      _onCancel$0: [function() {
        return;
      }, "call$0", "get$_onCancel", 0, 0, 18, "_onCancel"],
      _addPending$1: [function($event) {
        var pending, t1;
        pending = this._pending;
        if (pending == null) {
          pending = new P._StreamImplEvents(null, null, 0, [H.getRuntimeTypeArgument(this, "_BufferingStreamSubscription", 0)]);
          this._pending = pending;
        }
        J.add$1$ax(pending, $event);
        if (J.$and$n(this._state, 64) === 0) {
          t1 = J.$or$n(this._state, 64);
          this._state = t1;
          if (!J.$ge$n(t1, 128))
            this._pending.schedule$1(this);
        }
      }, "call$1", "get$_addPending", 2, 0, 201, 110, [], "_addPending"],
      _sendData$1: [function(data) {
        var t1 = J.$and$n(this._state, 4);
        this._state = J.$or$n(this._state, 32);
        this._zone.runUnaryGuarded$2(this._onData, data);
        this._state = J.$and$n(this._state, 4294967263);
        this._checkState$1(t1 !== 0);
      }, "call$1", "get$_sendData", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "_BufferingStreamSubscription");
      }, 21, [], "_sendData"],
      _sendError$2: [function(error, stackTrace) {
        var t1, t2;
        t1 = J.$and$n(this._state, 4);
        t2 = new P._BufferingStreamSubscription__sendError_sendError(this, error, stackTrace);
        if (J.$and$n(this._state, 1) !== 0) {
          this._state = J.$or$n(this._state, 16);
          this._cancel$0();
          t1 = this._cancelFuture;
          if (!!J.getInterceptor(t1).$isFuture && t1 !== $.$get$Future__nullFuture())
            t1.whenComplete$1(t2);
          else
            t2.call$0();
        } else {
          t2.call$0();
          this._checkState$1(t1 !== 0);
        }
      }, "call$2", "get$_sendError", 4, 0, 71, 8, [], 12, [], "_sendError"],
      _sendDone$0: [function() {
        var t1, t2;
        t1 = new P._BufferingStreamSubscription__sendDone_sendDone(this);
        this._cancel$0();
        this._state = J.$or$n(this._state, 16);
        t2 = this._cancelFuture;
        if (!!J.getInterceptor(t2).$isFuture && t2 !== $.$get$Future__nullFuture())
          t2.whenComplete$1(t1);
        else
          t1.call$0();
      }, "call$0", "get$_sendDone", 0, 0, 6, "_sendDone"],
      _guardCallback$1: [function(callback) {
        var t1 = J.$and$n(this._state, 4);
        this._state = J.$or$n(this._state, 32);
        callback.call$0();
        this._state = J.$and$n(this._state, 4294967263);
        this._checkState$1(t1 !== 0);
      }, "call$1", "get$_guardCallback", 2, 0, 37, 33, [], "_guardCallback"],
      _checkState$1: [function(wasInputPaused) {
        var t1, isInputPaused;
        if (J.$and$n(this._state, 64) !== 0 && J.get$isEmpty$asx(this._pending) === true) {
          t1 = J.$and$n(this._state, 4294967231);
          this._state = t1;
          if (J.$and$n(t1, 4) !== 0)
            if (!J.$ge$n(this._state, 128)) {
              t1 = this._pending;
              t1 = t1 == null || J.get$isEmpty$asx(t1) === true;
            } else
              t1 = false;
          else
            t1 = false;
          if (t1)
            this._state = J.$and$n(this._state, 4294967291);
        }
        for (; true; wasInputPaused = isInputPaused) {
          if (J.$and$n(this._state, 8) !== 0) {
            this._pending = null;
            return;
          }
          isInputPaused = J.$and$n(this._state, 4) !== 0;
          if (J.$eq$(wasInputPaused, isInputPaused))
            break;
          this._state = J.$xor$n(this._state, 32);
          if (isInputPaused)
            this._onPause$0();
          else
            this._onResume$0();
          this._state = J.$and$n(this._state, 4294967263);
        }
        if (J.$and$n(this._state, 64) !== 0 && !J.$ge$n(this._state, 128))
          this._pending.schedule$1(this);
      }, "call$1", "get$_checkState", 2, 0, 35, 783, [], "_checkState"],
      _BufferingStreamSubscription$4: function(onData, onError, onDone, cancelOnError, $T) {
        this.onData$1(onData);
        this.onError$1(onError);
        this.onDone$1(onDone);
      },
      _onData$1: function(arg0) {
        return this._onData.call$1(arg0);
      },
      _onError$2: function(arg0, arg1) {
        return this._onError.call$2(arg0, arg1);
      },
      _onDone$0: function() {
        return this._onDone.call$0();
      },
      $is_EventSink: 1,
      $isStreamSubscription: 1,
      "<>": [147],
      static: {
        "^": "_BufferingStreamSubscription__STATE_CANCEL_ON_ERROR<-0,_BufferingStreamSubscription__STATE_CLOSED<-0,_BufferingStreamSubscription__STATE_INPUT_PAUSED<-0,_BufferingStreamSubscription__STATE_CANCELED<-0,_BufferingStreamSubscription__STATE_WAIT_FOR_CANCEL<-0,_BufferingStreamSubscription__STATE_IN_CALLBACK<-0,_BufferingStreamSubscription__STATE_HAS_PENDING<-0,_BufferingStreamSubscription__STATE_PAUSE_COUNT<-0",
        _BufferingStreamSubscription$: [function(onData, onError, onDone, cancelOnError, $T) {
          var t1, t2;
          t1 = $.Zone__current;
          t2 = cancelOnError === true ? 1 : 0;
          t2 = new P._BufferingStreamSubscription(null, null, null, t1, t2, null, null, [$T]);
          t2._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, $T);
          return t2;
        }, null, null, 8, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [{func: 1, v: true, args: [T]}, P.Function, {func: 1, v: true}, P.bool]};
          }, this.$receiver, "_BufferingStreamSubscription");
        }, 27, [], 20, [], 28, [], 24, [], "new _BufferingStreamSubscription"]
      }
    },
    "+_BufferingStreamSubscription": [1, 1191, 1192, 1193],
    _BufferingStreamSubscription_asFuture_closure: {
      "^": "Closure:4;futureValue,result",
      call$0: [function() {
        this.result._complete$1(this.futureValue);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _BufferingStreamSubscription_asFuture_closure": [2],
    _BufferingStreamSubscription_asFuture_closure0: {
      "^": "Closure:12;$this,result",
      call$2: [function(error, stackTrace) {
        var cancelFuture, t1, t2;
        cancelFuture = this.$this.cancel$0();
        t1 = $.$get$Future__nullFuture();
        t2 = this.result;
        if (cancelFuture == null ? t1 != null : cancelFuture !== t1)
          cancelFuture.whenComplete$1(new P._BufferingStreamSubscription_asFuture__closure(t2, error, stackTrace));
        else
          t2._completeError$2(error, stackTrace);
      }, null, null, 4, 0, 12, 8, [], 12, [], "call"]
    },
    "+ _BufferingStreamSubscription_asFuture_closure": [2],
    _BufferingStreamSubscription_asFuture__closure: {
      "^": "Closure:4;result,error,stackTrace",
      call$0: [function() {
        this.result._completeError$2(this.error, this.stackTrace);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _BufferingStreamSubscription_asFuture__closure": [2],
    _BufferingStreamSubscription__sendError_sendError: {
      "^": "Closure:6;$this,error,stackTrace",
      call$0: [function() {
        var t1, t2, t3, t4, t5, t6;
        t1 = this.$this;
        if (J.$and$n(t1._state, 8) !== 0 && J.$and$n(t1._state, 16) === 0)
          return;
        t1._state = J.$or$n(t1._state, 32);
        t2 = t1._onError;
        t3 = H.functionTypeTest(t2, {func: 1, args: [P.Object, P.StackTrace]});
        t4 = t1._zone;
        t5 = this.error;
        t6 = t1._onError;
        if (t3)
          t4.runBinaryGuarded$3(t6, t5, this.stackTrace);
        else
          t4.runUnaryGuarded$2(t6, t5);
        t1._state = J.$and$n(t1._state, 4294967263);
      }, null, null, 0, 0, 6, "call"]
    },
    "+ _BufferingStreamSubscription__sendError_sendError": [2],
    _BufferingStreamSubscription__sendDone_sendDone: {
      "^": "Closure:6;$this",
      call$0: [function() {
        var t1 = this.$this;
        if (J.$and$n(t1._state, 16) === 0)
          return;
        t1._state = J.$or$n(t1._state, 42);
        t1._zone.runGuarded$1(t1._onDone);
        t1._state = J.$and$n(t1._state, 4294967263);
      }, null, null, 0, 0, 6, "call"]
    },
    "+ _BufferingStreamSubscription__sendDone_sendDone": [2],
    _StreamImpl: {
      "^": "Stream;$ti",
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        return this._createSubscription$4(onData, onError, onDone, true === cancelOnError);
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, onError);
      }, "listen$2$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, null);
      }, "listen$2$onDone", function(onData, cancelOnError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, null, null);
      }, "listen$2$cancelOnError", "call$4$cancelOnError$onDone$onError", "call$1", "call$2$onError", "call$3$onDone$onError", "call$3$onDone$onError", "call$2$onDone", "call$2$cancelOnError", "get$listen", 2, 7, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.StreamSubscription, T], args: [{func: 1, v: true, args: [T]}], named: {cancelOnError: P.bool, onDone: {func: 1, v: true}, onError: P.Function}};
        }, this.$receiver, "_StreamImpl");
      }, 0, 0, 0, 27, [], 20, [], 28, [], 24, [], "listen"],
      _createSubscription$4: [function(onData, onError, onDone, cancelOnError) {
        return P._BufferingStreamSubscription$(onData, onError, onDone, cancelOnError, H.getTypeArgumentByIndex(this, 0));
      }, "call$4", "get$_createSubscription", 8, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.StreamSubscription, T], args: [{func: 1, v: true, args: [T]}, P.Function, {func: 1, v: true}, P.bool]};
        }, this.$receiver, "_StreamImpl");
      }, 27, [], 20, [], 28, [], 24, [], "_createSubscription"],
      _async$_onListen$1: [function(subscription) {
      }, "call$1", "get$_async$_onListen", 2, 0, 700, 50, [], "_async$_onListen"],
      "<>": [607],
      static: {
        _StreamImpl$: [function($T) {
          return new P._StreamImpl([$T]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P._StreamImpl, T]};
          }, this.$receiver, "_StreamImpl");
        }, "new _StreamImpl"]
      }
    },
    "+_StreamImpl": [1194],
    _GeneratedStreamImpl: {
      "^": "_StreamImpl;_pending<-1195,_isUsed@-8,$ti",
      _createSubscription$4: [function(onData, onError, onDone, cancelOnError) {
        var t1;
        if (this._isUsed === true)
          throw H.wrapException(new P.StateError("Stream has already been listened to."));
        this._isUsed = true;
        t1 = P._BufferingStreamSubscription$(onData, onError, onDone, cancelOnError, H.getTypeArgumentByIndex(this, 0));
        t1._setPendingEvents$1(this._pending.call$0());
        return t1;
      }, "call$4", "get$_createSubscription", 8, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.StreamSubscription, T], args: [{func: 1, v: true, args: [T]}, P.Function, {func: 1, v: true}, P.bool]};
        }, this.$receiver, "_GeneratedStreamImpl");
      }, 27, [], 20, [], 28, [], 24, [], "_createSubscription"],
      "<>": [302],
      static: {
        _GeneratedStreamImpl$: [function(_pending, $T) {
          return new P._GeneratedStreamImpl(_pending, false, [$T]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [{func: 1, ret: [P._PendingEvents, T]}]};
          }, this.$receiver, "_GeneratedStreamImpl");
        }, 833, [], "new _GeneratedStreamImpl"]
      }
    },
    "+_GeneratedStreamImpl": [1196],
    _IterablePendingEvents: {
      "^": "_PendingEvents;_async$_iterator@-1197,_state-0,$ti",
      get$isEmpty: [function(_) {
        return this._async$_iterator == null;
      }, null, null, 1, 0, 5, "isEmpty"],
      handleNext$1: [function(dispatch) {
        var isDone, e, s, t1, exception;
        t1 = this._async$_iterator;
        if (t1 == null)
          throw H.wrapException(new P.StateError("No events pending."));
        isDone = null;
        try {
          isDone = t1.moveNext$0() !== true;
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          this._async$_iterator = null;
          dispatch._sendError$2(e, s);
          return;
        }
        if (isDone !== true)
          dispatch._sendData$1(this._async$_iterator.get$current());
        else {
          this._async$_iterator = null;
          dispatch._sendDone$0();
        }
      }, "call$1", "get$handleNext", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [[P._EventDispatch, T]]};
        }, this.$receiver, "_IterablePendingEvents");
      }, 153, [], "handleNext"],
      clear$0: [function(_) {
        if (J.$eq$(this._state, 1))
          if (J.$eq$(this._state, 1))
            this._state = 3;
        this._async$_iterator = null;
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      "<>": [409],
      static: {
        _IterablePendingEvents$: [function(data, $T) {
          return new P._IterablePendingEvents(J.get$iterator$ax(data), 0, [$T]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [[P.Iterable, T]]};
          }, this.$receiver, "_IterablePendingEvents");
        }, 21, [], "new _IterablePendingEvents"]
      }
    },
    "+_IterablePendingEvents": [1198],
    _DelayedEvent: {
      "^": "Object;next@-91,$ti",
      next$0: function() {
        return this.next.call$0();
      },
      "<>": [961],
      static: {
        _DelayedEvent$: [function($T) {
          return new P._DelayedEvent(null, [$T]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P._DelayedEvent, T]};
          }, this.$receiver, "_DelayedEvent");
        }, "new _DelayedEvent"]
      }
    },
    "+_DelayedEvent": [1],
    _DelayedData: {
      "^": "_DelayedEvent;value<-1200,next-91,$ti",
      perform$1: [function(dispatch) {
        dispatch._sendData$1(this.value);
      }, "call$1", "get$perform", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [[P._EventDispatch, T]]};
        }, this.$receiver, "_DelayedData");
      }, 153, [], "perform"],
      value$1: function(arg0) {
        return this.value.call$1(arg0);
      },
      "<>": [386],
      static: {
        _DelayedData$: [function(value, $T) {
          return new P._DelayedData(value, null, [$T]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [T]};
          }, this.$receiver, "_DelayedData");
        }, 1, [], "new _DelayedData"]
      }
    },
    "+_DelayedData": [1201],
    _DelayedError: {
      "^": "_DelayedEvent;error<-10,stackTrace<-221,next-91",
      perform$1: [function(dispatch) {
        dispatch._sendError$2(this.error, this.stackTrace);
      }, "call$1", "get$perform", 2, 0, 407, 153, [], "perform"],
      error$1: function(arg0) {
        return this.error.call$1(arg0);
      },
      $as_DelayedEvent: Isolate.functionThatReturnsNull,
      "<>": [],
      static: {
        _DelayedError$: [function(error, stackTrace) {
          return new P._DelayedError(error, stackTrace, null);
        }, null, null, 4, 0, 80, 8, [], 12, [], "new _DelayedError"]
      }
    },
    "+_DelayedError": [91],
    _DelayedDone: {
      "^": "Object;",
      perform$1: [function(dispatch) {
        dispatch._sendDone$0();
      }, "call$1", "get$perform", 2, 0, 407, 153, [], "perform"],
      get$next: [function() {
        return;
      }, null, null, 1, 0, 748, "next"],
      set$next: [function(_) {
        throw H.wrapException(new P.StateError("No events after a done."));
      }, null, null, 3, 0, 201, 16, [], "next"],
      next$0: function() {
        return this.get$next().call$0();
      },
      static: {
        _DelayedDone$: [function() {
          return new P._DelayedDone();
        }, null, null, 0, 0, 4, "new _DelayedDone"]
      }
    },
    "+_DelayedDone": [1, 91],
    _PendingEvents: {
      "^": "Object;_state@-0,$ti",
      get$isScheduled: [function() {
        return J.$eq$(this._state, 1);
      }, null, null, 1, 0, 5, "isScheduled"],
      get$_eventScheduled: [function() {
        return J.$ge$n(this._state, 1);
      }, null, null, 1, 0, 5, "_eventScheduled"],
      schedule$1: [function(dispatch) {
        if (J.$eq$(this._state, 1))
          return;
        if (J.$ge$n(this._state, 1)) {
          this._state = 1;
          return;
        }
        P.scheduleMicrotask(new P._PendingEvents_schedule_closure(this, dispatch));
        this._state = 1;
      }, "call$1", "get$schedule", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [[P._EventDispatch, T]]};
        }, this.$receiver, "_PendingEvents");
      }, 153, [], "schedule"],
      cancelSchedule$0: [function() {
        if (J.$eq$(this._state, 1))
          this._state = 3;
      }, "call$0", "get$cancelSchedule", 0, 0, 6, "cancelSchedule"],
      "<>": [960],
      static: {
        "^": "_PendingEvents__STATE_UNSCHEDULED<-0,_PendingEvents__STATE_SCHEDULED<-0,_PendingEvents__STATE_CANCELED<-0",
        _PendingEvents$: [function($T) {
          return new P._PendingEvents(0, [$T]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P._PendingEvents, T]};
          }, this.$receiver, "_PendingEvents");
        }, "new _PendingEvents"]
      }
    },
    "+_PendingEvents": [1],
    _PendingEvents_schedule_closure: {
      "^": "Closure:4;$this,dispatch",
      call$0: [function() {
        var t1, oldState;
        t1 = this.$this;
        oldState = t1._state;
        t1._state = 0;
        if (J.$eq$(oldState, 3))
          return;
        t1.handleNext$1(this.dispatch);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _PendingEvents_schedule_closure": [2],
    _StreamImplEvents: {
      "^": "_PendingEvents;firstPendingEvent@-91,lastPendingEvent@-91,_state-0,$ti",
      get$isEmpty: [function(_) {
        return this.lastPendingEvent == null;
      }, null, null, 1, 0, 5, "isEmpty"],
      add$1: [function(_, $event) {
        var t1 = this.lastPendingEvent;
        if (t1 == null) {
          this.lastPendingEvent = $event;
          this.firstPendingEvent = $event;
        } else {
          t1.set$next($event);
          this.lastPendingEvent = $event;
        }
      }, "call$1", "get$add", 2, 0, 201, 110, [], "add"],
      handleNext$1: [function(dispatch) {
        var $event, t1;
        $event = this.firstPendingEvent;
        t1 = $event.get$next();
        this.firstPendingEvent = t1;
        if (t1 == null)
          this.lastPendingEvent = null;
        $event.perform$1(dispatch);
      }, "call$1", "get$handleNext", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [[P._EventDispatch, T]]};
        }, this.$receiver, "_StreamImplEvents");
      }, 153, [], "handleNext"],
      clear$0: [function(_) {
        if (J.$eq$(this._state, 1))
          if (J.$eq$(this._state, 1))
            this._state = 3;
        this.lastPendingEvent = null;
        this.firstPendingEvent = null;
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      "<>": [592],
      static: {
        _StreamImplEvents$: [function($T) {
          return new P._StreamImplEvents(null, null, 0, [$T]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P._StreamImplEvents, T]};
          }, this.$receiver, "_StreamImplEvents");
        }, "new _StreamImplEvents"]
      }
    },
    "+_StreamImplEvents": [1203],
    _DoneStreamSubscription: {
      "^": "Object;_zone<-51,_state@-0,_onDone@-90,$ti",
      get$_isSent: [function() {
        return J.$and$n(this._state, 1) !== 0;
      }, null, null, 1, 0, 5, "_isSent"],
      get$_isScheduled: [function() {
        return J.$and$n(this._state, 2) !== 0;
      }, null, null, 1, 0, 5, "_isScheduled"],
      get$isPaused: [function() {
        return J.$ge$n(this._state, 4);
      }, null, null, 1, 0, 5, "isPaused"],
      _schedule$0: [function() {
        if (J.$and$n(this._state, 2) !== 0)
          return;
        this._zone.scheduleMicrotask$1(this.get$_sendDone());
        this._state = J.$or$n(this._state, 2);
      }, "call$0", "get$_schedule", 0, 0, 6, "_schedule"],
      onData$1: [function(handleData) {
      }, "call$1", "get$onData", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [{func: 1, v: true, args: [T]}]};
        }, this.$receiver, "_DoneStreamSubscription");
      }, 175, [], "onData"],
      onError$1: [function(handleError) {
      }, "call$1", "get$onError", 2, 0, 164, 157, [], "onError"],
      onDone$1: [function(handleDone) {
        this._onDone = handleDone;
      }, "call$1", "get$onDone", 2, 0, 37, 164, [], "onDone"],
      pause$1: [function(resumeSignal) {
        this._state = J.$add$ns(this._state, 4);
        if (resumeSignal != null)
          resumeSignal.whenComplete$1(this.get$resume());
      }, function() {
        return this.pause$1(null);
      }, "pause$0", "call$1", "call$0", "get$pause", 0, 2, 217, 0, 221, [], "pause"],
      resume$0: [function() {
        if (J.$ge$n(this._state, 4)) {
          var t1 = J.$sub$n(this._state, 4);
          this._state = t1;
          if (!J.$ge$n(t1, 4) && J.$and$n(this._state, 1) === 0)
            this._schedule$0();
        }
      }, "call$0", "get$resume", 0, 0, 6, "resume"],
      cancel$0: [function() {
        return $.$get$Future__nullFuture();
      }, "call$0", "get$cancel", 0, 0, 18, "cancel"],
      asFuture$1: [function(futureValue) {
        var result = new P._Future(0, $.Zone__current, null, [null]);
        this._onDone = new P._DoneStreamSubscription_asFuture_closure(result);
        return result;
      }, function() {
        return this.asFuture$1(null);
      }, "asFuture$0", "call$1", "call$0", "get$asFuture", 0, 2, function() {
        return {func: 1, ret: P.Future, opt: [,]};
      }, 0, 206, [], "asFuture"],
      _sendDone$0: [function() {
        var t1 = J.$and$n(this._state, 4294967293);
        this._state = t1;
        if (J.$ge$n(t1, 4))
          return;
        this._state = J.$or$n(this._state, 1);
        t1 = this._onDone;
        if (t1 != null)
          this._zone.runGuarded$1(t1);
      }, "call$0", "get$_sendDone", 0, 0, 6, "_sendDone"],
      _onDone$0: function() {
        return this._onDone.call$0();
      },
      $isStreamSubscription: 1,
      "<>": [466],
      static: {
        "^": "_DoneStreamSubscription__DONE_SENT<-0,_DoneStreamSubscription__SCHEDULED<-0,_DoneStreamSubscription__PAUSED<-0",
        _DoneStreamSubscription$: [function(_onDone, $T) {
          var t1 = new P._DoneStreamSubscription($.Zone__current, 0, _onDone, [$T]);
          t1._schedule$0();
          return t1;
        }, null, null, 2, 0, 579, 832, [], "new _DoneStreamSubscription"]
      }
    },
    "+_DoneStreamSubscription": [1, 1204],
    _DoneStreamSubscription_asFuture_closure: {
      "^": "Closure:4;result",
      call$0: [function() {
        this.result._completeWithValue$1(null);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _DoneStreamSubscription_asFuture_closure": [2],
    _AsBroadcastStream: {
      "^": "Stream;_source<-450,_onListenHandler<-451,_onCancelHandler<-451,_zone<-51,_async$_controller@-1207,_subscription@-1208,$ti",
      get$isBroadcast: [function() {
        return true;
      }, null, null, 1, 0, 5, "isBroadcast"],
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        var t1, t2;
        t1 = this._async$_controller;
        if (t1 == null || t1.get$isClosed()) {
          t1 = new P._DoneStreamSubscription($.Zone__current, 0, onDone, this.$ti);
          t1._schedule$0();
          return t1;
        }
        if (this._subscription == null) {
          t1 = J.get$add$ax(this._async$_controller);
          t2 = this._async$_controller.get$addError();
          this._subscription = this._source.listen$3$onDone$onError(t1, this._async$_controller.get$close(), t2);
        }
        return this._async$_controller._subscribe$4(onData, onError, onDone, true === cancelOnError);
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, onError);
      }, "listen$2$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, null);
      }, "listen$2$onDone", function(onData, cancelOnError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, null, null);
      }, "listen$2$cancelOnError", "call$4$cancelOnError$onDone$onError", "call$1", "call$2$onError", "call$3$onDone$onError", "call$3$onDone$onError", "call$2$onDone", "call$2$cancelOnError", "get$listen", 2, 7, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.StreamSubscription, T], args: [{func: 1, v: true, args: [T]}], named: {cancelOnError: P.bool, onDone: {func: 1, v: true}, onError: P.Function}};
        }, this.$receiver, "_AsBroadcastStream");
      }, 0, 0, 0, 27, [], 20, [], 28, [], 24, [], "listen"],
      _onCancel$0: [function() {
        var t1, shutdown;
        t1 = this._async$_controller;
        shutdown = t1 == null || t1.get$isClosed();
        t1 = this._onCancelHandler;
        if (t1 != null)
          this._zone.runUnary$2(t1, new P._BroadcastSubscriptionWrapper(this, this.$ti));
        if (shutdown) {
          t1 = this._subscription;
          if (t1 != null) {
            t1.cancel$0();
            this._subscription = null;
          }
        }
      }, "call$0", "get$_onCancel", 0, 0, 6, "_onCancel"],
      _async$_onListen$0: [function() {
        var t1 = this._onListenHandler;
        if (t1 != null)
          this._zone.runUnary$2(t1, new P._BroadcastSubscriptionWrapper(this, this.$ti));
      }, "call$0", "get$_async$_onListen", 0, 0, 6, "_async$_onListen"],
      _cancelSubscription$0: [function() {
        var t1 = this._subscription;
        if (t1 == null)
          return;
        this._subscription = null;
        this._async$_controller = null;
        t1.cancel$0();
      }, "call$0", "get$_cancelSubscription", 0, 0, 6, "_cancelSubscription"],
      _pauseSubscription$1: [function(resumeSignal) {
        var t1 = this._subscription;
        if (t1 == null)
          return;
        t1.pause$1(resumeSignal);
      }, "call$1", "get$_pauseSubscription", 2, 0, 777, 221, [], "_pauseSubscription"],
      _resumeSubscription$0: [function() {
        var t1 = this._subscription;
        if (t1 == null)
          return;
        t1.resume$0();
      }, "call$0", "get$_resumeSubscription", 0, 0, 6, "_resumeSubscription"],
      get$_isSubscriptionPaused: [function() {
        var t1 = this._subscription;
        if (t1 == null)
          return false;
        return t1.get$isPaused();
      }, null, null, 1, 0, 5, "_isSubscriptionPaused"],
      "<>": [176],
      static: {
        _AsBroadcastStream$: [function(_source, onListenHandler, onCancelHandler, $T) {
          var t1 = new P._AsBroadcastStream(_source, $.Zone__current.registerUnaryCallback$1(onListenHandler), $.Zone__current.registerUnaryCallback$1(onCancelHandler), $.Zone__current, null, null, [$T]);
          t1._async$_controller = new P._AsBroadcastStreamController(null, t1.get$_async$_onListen(), t1.get$_onCancel(), 0, null, null, null, null, [$T]);
          return t1;
        }, null, null, 6, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [[P.Stream, T], {func: 1, v: true, args: [[P.StreamSubscription, T]]}, {func: 1, v: true, args: [[P.StreamSubscription, T]]}]};
          }, this.$receiver, "_AsBroadcastStream");
        }, 537, [], 831, [], 828, [], "new _AsBroadcastStream"]
      }
    },
    "+_AsBroadcastStream": [450],
    _BroadcastSubscriptionWrapper: {
      "^": "Object;_stream<-1209,$ti",
      onData$1: [function(handleData) {
        throw H.wrapException(new P.UnsupportedError("Cannot change handlers of asBroadcastStream source subscription."));
      }, "call$1", "get$onData", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [{func: 1, v: true, args: [T]}]};
        }, this.$receiver, "_BroadcastSubscriptionWrapper");
      }, 175, [], "onData"],
      onError$1: [function(handleError) {
        throw H.wrapException(new P.UnsupportedError("Cannot change handlers of asBroadcastStream source subscription."));
      }, "call$1", "get$onError", 2, 0, 164, 157, [], "onError"],
      onDone$1: [function(handleDone) {
        throw H.wrapException(new P.UnsupportedError("Cannot change handlers of asBroadcastStream source subscription."));
      }, "call$1", "get$onDone", 2, 0, 37, 164, [], "onDone"],
      pause$1: [function(resumeSignal) {
        this._stream._pauseSubscription$1(resumeSignal);
      }, function() {
        return this.pause$1(null);
      }, "pause$0", "call$1", "call$0", "get$pause", 0, 2, 217, 0, 221, [], "pause"],
      resume$0: [function() {
        this._stream._resumeSubscription$0();
      }, "call$0", "get$resume", 0, 0, 6, "resume"],
      cancel$0: [function() {
        this._stream._cancelSubscription$0();
        return $.$get$Future__nullFuture();
      }, "call$0", "get$cancel", 0, 0, 18, "cancel"],
      get$isPaused: [function() {
        return this._stream.get$_isSubscriptionPaused();
      }, null, null, 1, 0, 5, "isPaused"],
      asFuture$1: [function(futureValue) {
        throw H.wrapException(new P.UnsupportedError("Cannot change handlers of asBroadcastStream source subscription."));
      }, function() {
        return this.asFuture$1(null);
      }, "asFuture$0", "call$1", "call$0", "get$asFuture", 0, 2, function() {
        return {func: 1, ret: P.Future, opt: [,]};
      }, 0, 206, [], "asFuture"],
      $isStreamSubscription: 1,
      "<>": [454],
      static: {
        _BroadcastSubscriptionWrapper$: [function(_stream, $T) {
          return new P._BroadcastSubscriptionWrapper(_stream, [$T]);
        }, null, null, 2, 0, 580, 163, [], "new _BroadcastSubscriptionWrapper"]
      }
    },
    "+_BroadcastSubscriptionWrapper": [1, 1210],
    _StreamIterator: {
      "^": "Object;_subscription@-103,_stateData@-1,_isPaused@-8,$ti",
      get$current: [function() {
        if (this._subscription != null && this._isPaused === true)
          return this._stateData;
        return;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: T};
        }, this.$receiver, "_StreamIterator");
      }, "current"],
      moveNext$0: [function() {
        var t1, future;
        t1 = this._subscription;
        if (t1 != null) {
          if (this._isPaused === true) {
            future = new P._Future(0, $.Zone__current, null, [P.bool]);
            this._stateData = future;
            this._isPaused = false;
            t1.resume$0();
            return future;
          }
          throw H.wrapException(new P.StateError("Already waiting for next."));
        }
        return this._initializeOrDone$0();
      }, "call$0", "get$moveNext", 0, 0, 129, "moveNext"],
      _initializeOrDone$0: [function() {
        var stateData, future, t1;
        stateData = this._stateData;
        if (stateData != null) {
          this._subscription = stateData.listen$4$cancelOnError$onDone$onError(this.get$_onData(), true, this.get$_onDone(), this.get$_onError());
          future = new P._Future(0, $.Zone__current, null, [P.bool]);
          this._stateData = future;
          return future;
        }
        t1 = new P._Future(0, $.Zone__current, null, [P.bool]);
        t1._asyncComplete$1(false);
        return t1;
      }, "call$0", "get$_initializeOrDone", 0, 0, 129, "_initializeOrDone"],
      cancel$0: [function() {
        var subscription, stateData;
        subscription = this._subscription;
        stateData = this._stateData;
        this._stateData = null;
        if (subscription != null) {
          this._subscription = null;
          if (this._isPaused !== true)
            stateData._asyncComplete$1(false);
          return subscription.cancel$0();
        }
        return $.$get$Future__nullFuture();
      }, "call$0", "get$cancel", 0, 0, 18, "cancel"],
      _onData$1: [function(data) {
        var moveNextFuture, t1;
        moveNextFuture = this._stateData;
        this._stateData = data;
        this._isPaused = true;
        moveNextFuture._complete$1(true);
        t1 = this._subscription;
        if (t1 != null && this._isPaused === true)
          t1.pause$0();
      }, "call$1", "get$_onData", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "_StreamIterator");
      }, 21, [], "_onData"],
      _onError$2: [function(error, stackTrace) {
        var moveNextFuture = this._stateData;
        this._subscription = null;
        this._stateData = null;
        moveNextFuture._completeError$2(error, stackTrace);
      }, function(error) {
        return this._onError$2(error, null);
      }, "_onError$1", "call$2", "call$1", "get$_onError", 2, 2, 48, 0, 8, [], 12, [], "_onError"],
      _onDone$0: [function() {
        var moveNextFuture = this._stateData;
        this._subscription = null;
        this._stateData = null;
        moveNextFuture._complete$1(false);
      }, "call$0", "get$_onDone", 0, 0, 6, "_onDone"],
      "<>": [448],
      static: {
        _StreamIterator$: [function(stream, $T) {
          return new P._StreamIterator(null, stream, false, [$T]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [[P.Stream, T]]};
          }, this.$receiver, "_StreamIterator");
        }, 37, [], "new _StreamIterator"]
      }
    },
    "+_StreamIterator": [1, 1211],
    _EmptyStream: {
      "^": "Stream;$ti",
      get$isBroadcast: [function() {
        return true;
      }, null, null, 1, 0, 5, "isBroadcast"],
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        var t1 = new P._DoneStreamSubscription($.Zone__current, 0, onDone, this.$ti);
        t1._schedule$0();
        return t1;
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, onError);
      }, "listen$2$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, null);
      }, "listen$2$onDone", function(onData, cancelOnError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, null, null);
      }, "listen$2$cancelOnError", "call$4$cancelOnError$onDone$onError", "call$1", "call$2$onError", "call$3$onDone$onError", "call$3$onDone$onError", "call$2$onDone", "call$2$cancelOnError", "get$listen", 2, 7, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.StreamSubscription, T], args: [{func: 1, v: true, args: [T]}], named: {cancelOnError: P.bool, onDone: {func: 1, v: true}, onError: P.Function}};
        }, this.$receiver, "_EmptyStream");
      }, 0, 0, 0, 27, [], 20, [], 28, [], 24, [], "listen"],
      "<>": [445],
      static: {
        _EmptyStream$: [function($T) {
          return new P._EmptyStream([$T]);
        }, null, null, 0, 0, 4, "new _EmptyStream"]
      }
    },
    "+_EmptyStream": [1212],
    _cancelAndError_closure: {
      "^": "Closure:4;future,error,stackTrace",
      call$0: [function() {
        return this.future._completeError$2(this.error, this.stackTrace);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _cancelAndError_closure": [2],
    _cancelAndErrorClosure_closure: {
      "^": "Closure:80;subscription,future",
      call$2: [function(error, stackTrace) {
        P._cancelAndError(this.subscription, this.future, error, stackTrace);
      }, null, null, 4, 0, 80, 8, [], 12, [], "call"]
    },
    "+ _cancelAndErrorClosure_closure": [2],
    _cancelAndValue_closure: {
      "^": "Closure:4;future,value",
      call$0: [function() {
        return this.future._complete$1(this.value);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _cancelAndValue_closure": [2],
    _ForwardingStream: {
      "^": "Stream;_source<-62,$ti",
      get$isBroadcast: [function() {
        return this._source.get$isBroadcast();
      }, null, null, 1, 0, 5, "isBroadcast"],
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        return this._createSubscription$4(onData, onError, onDone, true === cancelOnError);
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, onError);
      }, "listen$2$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, null);
      }, "listen$2$onDone", function(onData, cancelOnError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, null, null);
      }, "listen$2$cancelOnError", "call$4$cancelOnError$onDone$onError", "call$1", "call$2$onError", "call$3$onDone$onError", "call$3$onDone$onError", "call$2$onDone", "call$2$cancelOnError", "get$listen", 2, 7, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, ret: [P.StreamSubscription, T], args: [{func: 1, v: true, args: [T]}], named: {cancelOnError: P.bool, onDone: {func: 1, v: true}, onError: P.Function}};
        }, this.$receiver, "_ForwardingStream");
      }, 0, 0, 0, 27, [], 20, [], 28, [], 24, [], "listen"],
      _createSubscription$4: [function(onData, onError, onDone, cancelOnError) {
        return P._ForwardingStreamSubscription$(this, onData, onError, onDone, cancelOnError, H.getRuntimeTypeArgument(this, "_ForwardingStream", 0), H.getRuntimeTypeArgument(this, "_ForwardingStream", 1));
      }, "call$4", "get$_createSubscription", 8, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, ret: [P.StreamSubscription, T], args: [{func: 1, v: true, args: [T]}, P.Function, {func: 1, v: true}, P.bool]};
        }, this.$receiver, "_ForwardingStream");
      }, 27, [], 20, [], 28, [], 24, [], "_createSubscription"],
      _handleData$2: [function(data, sink) {
        sink._async$_add$1(data);
      }, "call$2", "get$_handleData", 4, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, v: true, args: [S, [P._EventSink, T]]};
        }, this.$receiver, "_ForwardingStream");
      }, 21, [], 22, [], "_handleData"],
      _handleError$3: [function(error, stackTrace, sink) {
        sink._addError$2(error, stackTrace);
      }, "call$3", "get$_handleError", 6, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, v: true, args: [, P.StackTrace, [P._EventSink, T]]};
        }, this.$receiver, "_ForwardingStream");
      }, 8, [], 12, [], 22, [], "_handleError"],
      _handleDone$1: [function(sink) {
        sink._async$_close$0();
      }, "call$1", "get$_handleDone", 2, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, v: true, args: [[P._EventSink, T]]};
        }, this.$receiver, "_ForwardingStream");
      }, 22, [], "_handleDone"],
      $asStream: function($S, $T) {
        return [$T];
      },
      "<>": [549, 555],
      static: {
        _ForwardingStream$: [function(_source, $S, $T) {
          return new P._ForwardingStream(_source, [$S, $T]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(S, T) {
            return {func: 1, args: [[P.Stream, S]]};
          }, this.$receiver, "_ForwardingStream");
        }, 537, [], "new _ForwardingStream"]
      }
    },
    "+_ForwardingStream": [1214],
    _ForwardingStreamSubscription: {
      "^": "_BufferingStreamSubscription;_stream<-453,_subscription@-454,_onData-124,_onError-29,_onDone-90,_zone-51,_state-0,_cancelFuture-86,_pending-126,$ti",
      _async$_add$1: [function(data) {
        if (J.$and$n(this._state, 2) !== 0)
          return;
        this.super$_BufferingStreamSubscription$_add(data);
      }, "call$1", "get$_async$_add", 2, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "_ForwardingStreamSubscription");
      }, 21, [], "_async$_add"],
      _addError$2: [function(error, stackTrace) {
        if (J.$and$n(this._state, 2) !== 0)
          return;
        this.super$_BufferingStreamSubscription$_addError(error, stackTrace);
      }, "call$2", "get$_addError", 4, 0, 49, 8, [], 12, [], "_addError"],
      _onPause$0: [function() {
        var t1 = this._subscription;
        if (t1 == null)
          return;
        t1.pause$0();
      }, "call$0", "get$_onPause", 0, 0, 6, "_onPause"],
      _onResume$0: [function() {
        var t1 = this._subscription;
        if (t1 == null)
          return;
        t1.resume$0();
      }, "call$0", "get$_onResume", 0, 0, 6, "_onResume"],
      _onCancel$0: [function() {
        var t1 = this._subscription;
        if (t1 != null) {
          this._subscription = null;
          return t1.cancel$0();
        }
        return;
      }, "call$0", "get$_onCancel", 0, 0, 18, "_onCancel"],
      _handleData$1: [function(data) {
        this._stream._handleData$2(data, this);
      }, "call$1", "get$_handleData", 2, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, v: true, args: [S]};
        }, this.$receiver, "_ForwardingStreamSubscription");
      }, 21, [], "_handleData"],
      _handleError$2: [function(error, stackTrace) {
        this._stream._handleError$3(error, stackTrace, this);
      }, "call$2", "get$_handleError", 4, 0, 71, 8, [], 12, [], "_handleError"],
      _handleDone$0: [function() {
        this._stream._handleDone$1(this);
      }, "call$0", "get$_handleDone", 0, 0, 6, "_handleDone"],
      _ForwardingStreamSubscription$5: function(_stream, onData, onError, onDone, cancelOnError, $S, $T) {
        this._subscription = this._stream.get$_source().listen$3$onDone$onError(this.get$_handleData(), this.get$_handleDone(), this.get$_handleError());
      },
      $as_BufferingStreamSubscription: function($S, $T) {
        return [$T];
      },
      $asStreamSubscription: function($S, $T) {
        return [$T];
      },
      "<>": [385, 384],
      static: {
        _ForwardingStreamSubscription$: [function(_stream, onData, onError, onDone, cancelOnError, $S, $T) {
          var t1, t2;
          t1 = $.Zone__current;
          t2 = cancelOnError === true ? 1 : 0;
          t2 = new P._ForwardingStreamSubscription(_stream, null, null, null, null, t1, t2, null, null, [$S, $T]);
          t2._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, $T);
          t2._ForwardingStreamSubscription$5(_stream, onData, onError, onDone, cancelOnError, $S, $T);
          return t2;
        }, null, null, 10, 0, function() {
          return H.computeSignature(function(S, T) {
            return {func: 1, args: [[P._ForwardingStream, S, T], {func: 1, v: true, args: [T]}, P.Function, {func: 1, v: true}, P.bool]};
          }, this.$receiver, "_ForwardingStreamSubscription");
        }, 163, [], 27, [], 20, [], 28, [], 24, [], "new _ForwardingStreamSubscription"]
      }
    },
    "+_ForwardingStreamSubscription": [1217],
    _WhereStream: {
      "^": "_ForwardingStream;_test<-1218,_source-62,$ti",
      _handleData$2: [function(inputEvent, sink) {
        var satisfies, e, s, exception, t1;
        satisfies = null;
        try {
          satisfies = this._test.call$1(inputEvent);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          P._addErrorWithReplacement(sink, e, s);
          return;
        }
        if (satisfies === true)
          sink._async$_add$1(inputEvent);
      }, "call$2", "get$_handleData", 4, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T, [P._EventSink, T]]};
        }, this.$receiver, "_WhereStream");
      }, 126, [], 22, [], "_handleData"],
      $as_ForwardingStream: function($T) {
        return [$T, $T];
      },
      $asStream: null,
      "<>": [207],
      static: {
        _WhereStream$: [function(source, test, $T) {
          return new P._WhereStream(test, source, [$T]);
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [[P.Stream, T], {func: 1, ret: P.bool, args: [T]}]};
          }, this.$receiver, "_WhereStream");
        }, 19, [], 11, [], "new _WhereStream"]
      }
    },
    "+_WhereStream": [1219],
    _MapStream: {
      "^": "_ForwardingStream;_transform<-1220,_source-62,$ti",
      _handleData$2: [function(inputEvent, sink) {
        var outputEvent, e, s, exception, t1;
        outputEvent = null;
        try {
          outputEvent = this._transform.call$1(inputEvent);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          P._addErrorWithReplacement(sink, e, s);
          return;
        }
        sink._async$_add$1(outputEvent);
      }, "call$2", "get$_handleData", 4, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, v: true, args: [S, [P._EventSink, T]]};
        }, this.$receiver, "_MapStream");
      }, 126, [], 22, [], "_handleData"],
      "<>": [233, 234],
      static: {
        _MapStream$: [function(source, transform, $S, $T) {
          return new P._MapStream(transform, source, [$S, $T]);
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(S, T) {
            return {func: 1, args: [[P.Stream, S], {func: 1, ret: T, args: [S]}]};
          }, this.$receiver, "_MapStream");
        }, 19, [], 820, [], "new _MapStream"]
      }
    },
    "+_MapStream": [1221],
    _ExpandStream: {
      "^": "_ForwardingStream;_expand<-1222,_source-62,$ti",
      _handleData$2: [function(inputEvent, sink) {
        var value, e, s, t1, exception;
        try {
          for (t1 = J.get$iterator$ax(this._expand.call$1(inputEvent)); t1.moveNext$0();) {
            value = t1.get$current();
            sink._async$_add$1(value);
          }
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          P._addErrorWithReplacement(sink, e, s);
        }
      }, "call$2", "get$_handleData", 4, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, v: true, args: [S, [P._EventSink, T]]};
        }, this.$receiver, "_ExpandStream");
      }, 126, [], 22, [], "_handleData"],
      "<>": [269, 271],
      static: {
        _ExpandStream$: [function(source, expand, $S, $T) {
          return new P._ExpandStream(expand, source, [$S, $T]);
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(S, T) {
            return {func: 1, args: [[P.Stream, S], {func: 1, ret: [P.Iterable, T], args: [S]}]};
          }, this.$receiver, "_ExpandStream");
        }, 19, [], 818, [], "new _ExpandStream"]
      }
    },
    "+_ExpandStream": [1223],
    _HandleErrorStream: {
      "^": "_ForwardingStream;_transform<-29,_test<-1224,_source-62,$ti",
      _handleError$3: [function(error, stackTrace, sink) {
        var matches, e, s, e0, s0, t1, exception;
        matches = true;
        t1 = this._test;
        if (t1 != null)
          try {
            matches = t1.call$1(error);
          } catch (exception) {
            t1 = H.unwrapException(exception);
            e = t1;
            s = H.getTraceFromException(exception);
            P._addErrorWithReplacement(sink, e, s);
            return;
          }
        if (matches === true)
          try {
            P._invokeErrorHandler(this._transform, error, stackTrace);
          } catch (exception) {
            t1 = H.unwrapException(exception);
            e0 = t1;
            s0 = H.getTraceFromException(exception);
            t1 = e0;
            if (t1 == null ? error == null : t1 === error)
              sink._addError$2(error, stackTrace);
            else
              P._addErrorWithReplacement(sink, e0, s0);
            return;
          }
        else
          sink._addError$2(error, stackTrace);
      }, "call$3", "get$_handleError", 6, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [P.Object, P.StackTrace, [P._EventSink, T]]};
        }, this.$receiver, "_HandleErrorStream");
      }, 8, [], 12, [], 22, [], "_handleError"],
      $as_ForwardingStream: function($T) {
        return [$T, $T];
      },
      $asStream: null,
      "<>": [420],
      static: {
        _HandleErrorStream$: [function(source, onError, test, $T) {
          return new P._HandleErrorStream(onError, test, source, [$T]);
        }, null, null, 6, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [[P.Stream, T], P.Function, {func: 1, ret: P.bool, args: [,]}]};
          }, this.$receiver, "_HandleErrorStream");
        }, 19, [], 20, [], 11, [], "new _HandleErrorStream"]
      }
    },
    "+_HandleErrorStream": [1225],
    _TakeStream: {
      "^": "_ForwardingStream;_count<-0,_source-62,$ti",
      _createSubscription$4: [function(onData, onError, onDone, cancelOnError) {
        var t1, t2, t3, t4;
        t1 = this._count;
        if (J.$eq$(t1, 0)) {
          this._source.listen$1(null).cancel$0();
          t1 = new P._DoneStreamSubscription($.Zone__current, 0, onDone, this.$ti);
          t1._schedule$0();
          return t1;
        }
        t2 = H.getTypeArgumentByIndex(this, 0);
        t3 = $.Zone__current;
        t4 = cancelOnError === true ? 1 : 0;
        t4 = new P._StateStreamSubscription(t1, this, null, null, null, null, t3, t4, null, null, this.$ti);
        t4._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, t2);
        t4._ForwardingStreamSubscription$5(this, onData, onError, onDone, cancelOnError, t2, t2);
        return t4;
      }, "call$4", "get$_createSubscription", 8, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.StreamSubscription, T], args: [{func: 1, v: true, args: [T]}, P.Function, {func: 1, v: true}, P.bool]};
        }, this.$receiver, "_TakeStream");
      }, 27, [], 20, [], 28, [], 24, [], "_createSubscription"],
      _handleData$2: [function(inputEvent, sink) {
        var count, t1;
        count = sink.get$_count();
        t1 = J.getInterceptor$n(count);
        if (t1.$gt(count, 0)) {
          sink._async$_add$1(inputEvent);
          count = t1.$sub(count, 1);
          sink.set$_count(count);
          if (J.$eq$(count, 0))
            sink._async$_close$0();
        }
      }, "call$2", "get$_handleData", 4, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T, [P._EventSink, T]]};
        }, this.$receiver, "_TakeStream");
      }, 126, [], 22, [], "_handleData"],
      $as_ForwardingStream: function($T) {
        return [$T, $T];
      },
      $asStream: null,
      "<>": [421],
      static: {
        _TakeStream$: [function(source, count, $T) {
          if (typeof count !== "number" || Math.floor(count) !== count)
            H.throwExpression(P.ArgumentError$(count));
          return new P._TakeStream(count, source, [$T]);
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [[P.Stream, T], P.int]};
          }, this.$receiver, "_TakeStream");
        }, 19, [], 43, [], "new _TakeStream"]
      }
    },
    "+_TakeStream": [1226],
    _StateStreamSubscription: {
      "^": "_ForwardingStreamSubscription;_sharedState@-10,_stream-453,_subscription-454,_onData-124,_onError-29,_onDone-90,_zone-51,_state-0,_cancelFuture-86,_pending-126,$ti",
      get$_flag: [function() {
        return this._sharedState;
      }, null, null, 1, 0, 5, "_flag"],
      set$_flag: [function(flag) {
        this._sharedState = flag;
      }, null, null, 3, 0, 35, 782, [], "_flag"],
      get$_count: [function() {
        return this._sharedState;
      }, null, null, 1, 0, 11, "_count"],
      set$_count: [function(count) {
        this._sharedState = count;
      }, null, null, 3, 0, 17, 43, [], "_count"],
      $as_ForwardingStreamSubscription: function($T) {
        return [$T, $T];
      },
      $as_BufferingStreamSubscription: null,
      $asStreamSubscription: null,
      "<>": [395],
      static: {
        _StateStreamSubscription$: [function(stream, onData, onError, onDone, cancelOnError, _sharedState, $T) {
          var t1, t2;
          t1 = $.Zone__current;
          t2 = cancelOnError === true ? 1 : 0;
          t2 = new P._StateStreamSubscription(_sharedState, stream, null, null, null, null, t1, t2, null, null, [$T]);
          t2._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, $T);
          t2._ForwardingStreamSubscription$5(stream, onData, onError, onDone, cancelOnError, $T, $T);
          return t2;
        }, null, null, 12, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [[P._ForwardingStream, T, T], {func: 1, v: true, args: [T]}, P.Function, {func: 1, v: true}, P.bool,,]};
          }, this.$receiver, "_StateStreamSubscription");
        }, 37, [], 27, [], 20, [], 28, [], 24, [], 817, [], "new _StateStreamSubscription"]
      }
    },
    "+_StateStreamSubscription": [1227],
    _TakeWhileStream: {
      "^": "_ForwardingStream;_test<-1228,_source-62,$ti",
      _handleData$2: [function(inputEvent, sink) {
        var satisfies, e, s, exception, t1;
        satisfies = null;
        try {
          satisfies = this._test.call$1(inputEvent);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          P._addErrorWithReplacement(sink, e, s);
          sink._async$_close$0();
          return;
        }
        if (satisfies === true)
          sink._async$_add$1(inputEvent);
        else
          sink._async$_close$0();
      }, "call$2", "get$_handleData", 4, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T, [P._EventSink, T]]};
        }, this.$receiver, "_TakeWhileStream");
      }, 126, [], 22, [], "_handleData"],
      $as_ForwardingStream: function($T) {
        return [$T, $T];
      },
      $asStream: null,
      "<>": [208],
      static: {
        _TakeWhileStream$: [function(source, test, $T) {
          return new P._TakeWhileStream(test, source, [$T]);
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [[P.Stream, T], {func: 1, ret: P.bool, args: [T]}]};
          }, this.$receiver, "_TakeWhileStream");
        }, 19, [], 11, [], "new _TakeWhileStream"]
      }
    },
    "+_TakeWhileStream": [1229],
    _SkipStream: {
      "^": "_ForwardingStream;_count<-0,_source-62,$ti",
      _createSubscription$4: [function(onData, onError, onDone, cancelOnError) {
        var t1, t2, t3;
        t1 = H.getTypeArgumentByIndex(this, 0);
        t2 = $.Zone__current;
        t3 = cancelOnError === true ? 1 : 0;
        t3 = new P._StateStreamSubscription(this._count, this, null, null, null, null, t2, t3, null, null, this.$ti);
        t3._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, t1);
        t3._ForwardingStreamSubscription$5(this, onData, onError, onDone, cancelOnError, t1, t1);
        return t3;
      }, "call$4", "get$_createSubscription", 8, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.StreamSubscription, T], args: [{func: 1, v: true, args: [T]}, P.Function, {func: 1, v: true}, P.bool]};
        }, this.$receiver, "_SkipStream");
      }, 27, [], 20, [], 28, [], 24, [], "_createSubscription"],
      _handleData$2: [function(inputEvent, sink) {
        var count, t1;
        count = sink.get$_count();
        t1 = J.getInterceptor$n(count);
        if (t1.$gt(count, 0)) {
          sink.set$_count(t1.$sub(count, 1));
          return;
        }
        sink._async$_add$1(inputEvent);
      }, "call$2", "get$_handleData", 4, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T, [P._EventSink, T]]};
        }, this.$receiver, "_SkipStream");
      }, 126, [], 22, [], "_handleData"],
      $as_ForwardingStream: function($T) {
        return [$T, $T];
      },
      $asStream: null,
      "<>": [399],
      static: {
        _SkipStream$: [function(source, count, $T) {
          if (typeof count !== "number" || Math.floor(count) !== count || count < 0)
            H.throwExpression(P.ArgumentError$(count));
          return new P._SkipStream(count, source, [$T]);
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [[P.Stream, T], P.int]};
          }, this.$receiver, "_SkipStream");
        }, 19, [], 43, [], "new _SkipStream"]
      }
    },
    "+_SkipStream": [1230],
    _SkipWhileStream: {
      "^": "_ForwardingStream;_test<-1231,_source-62,$ti",
      _createSubscription$4: [function(onData, onError, onDone, cancelOnError) {
        var t1, t2, t3;
        t1 = H.getTypeArgumentByIndex(this, 0);
        t2 = $.Zone__current;
        t3 = cancelOnError === true ? 1 : 0;
        t3 = new P._StateStreamSubscription(false, this, null, null, null, null, t2, t3, null, null, this.$ti);
        t3._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, t1);
        t3._ForwardingStreamSubscription$5(this, onData, onError, onDone, cancelOnError, t1, t1);
        return t3;
      }, "call$4", "get$_createSubscription", 8, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.StreamSubscription, T], args: [{func: 1, v: true, args: [T]}, P.Function, {func: 1, v: true}, P.bool]};
        }, this.$receiver, "_SkipWhileStream");
      }, 27, [], 20, [], 28, [], 24, [], "_createSubscription"],
      _handleData$2: [function(inputEvent, sink) {
        var subscription, satisfies, e, s, exception, t1;
        subscription = sink;
        if (subscription.get$_flag() === true) {
          sink._async$_add$1(inputEvent);
          return;
        }
        satisfies = null;
        try {
          satisfies = this._test.call$1(inputEvent);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          P._addErrorWithReplacement(sink, e, s);
          subscription.set$_flag(true);
          return;
        }
        if (satisfies !== true) {
          subscription.set$_flag(true);
          sink._async$_add$1(inputEvent);
        }
      }, "call$2", "get$_handleData", 4, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T, [P._EventSink, T]]};
        }, this.$receiver, "_SkipWhileStream");
      }, 126, [], 22, [], "_handleData"],
      $as_ForwardingStream: function($T) {
        return [$T, $T];
      },
      $asStream: null,
      "<>": [210],
      static: {
        _SkipWhileStream$: [function(source, test, $T) {
          return new P._SkipWhileStream(test, source, [$T]);
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [[P.Stream, T], {func: 1, ret: P.bool, args: [T]}]};
          }, this.$receiver, "_SkipWhileStream");
        }, 19, [], 11, [], "new _SkipWhileStream"]
      }
    },
    "+_SkipWhileStream": [1232],
    _DistinctStream: {
      "^": "_ForwardingStream;_async$_equals@-1233,_async$_previous@-10,_source-62,$ti",
      _handleData$2: [function(inputEvent, sink) {
        var isEqual, e, s, t1, t2, exception;
        t1 = this._async$_previous;
        t2 = $.$get$_DistinctStream__SENTINEL();
        if (t1 == null ? t2 == null : t1 === t2) {
          this._async$_previous = inputEvent;
          return sink._async$_add$1(inputEvent);
        } else {
          isEqual = null;
          try {
            t2 = this._async$_equals;
            if (t2 == null)
              isEqual = J.$eq$(t1, inputEvent);
            else
              isEqual = t2.call$2(t1, inputEvent);
          } catch (exception) {
            t1 = H.unwrapException(exception);
            e = t1;
            s = H.getTraceFromException(exception);
            P._addErrorWithReplacement(sink, e, s);
            return;
          }
          if (isEqual !== true) {
            sink._async$_add$1(inputEvent);
            this._async$_previous = inputEvent;
          }
        }
      }, "call$2", "get$_handleData", 4, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T, [P._EventSink, T]]};
        }, this.$receiver, "_DistinctStream");
      }, 126, [], 22, [], "_handleData"],
      $as_ForwardingStream: function($T) {
        return [$T, $T];
      },
      $asStream: null,
      "<>": [171],
      static: {
        "^": "_DistinctStream__SENTINEL@-10",
        _DistinctStream$: [function(source, equals, $T) {
          return new P._DistinctStream(equals, $.$get$_DistinctStream__SENTINEL(), source, [$T]);
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [[P.Stream, T], {func: 1, ret: P.bool, args: [T, T]}]};
          }, this.$receiver, "_DistinctStream");
        }, 19, [], 162, [], "new _DistinctStream"]
      }
    },
    "+_DistinctStream": [1234],
    _EventSinkWrapper: {
      "^": "Object;_async$_sink@-1235,$ti",
      add$1: [function(_, data) {
        this._async$_sink._async$_add$1(data);
      }, "call$1", "get$add", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "_EventSinkWrapper");
      }, 21, [], "add"],
      addError$2: [function(error, stackTrace) {
        this._async$_sink._addError$2(error, stackTrace);
      }, function(error) {
        return this.addError$2(error, null);
      }, "addError$1", "call$2", "call$1", "get$addError", 2, 2, 81, 0, 8, [], 12, [], "addError"],
      close$0: [function() {
        this._async$_sink._async$_close$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      "<>": [429],
      static: {
        _EventSinkWrapper$: [function(_sink, $T) {
          return new P._EventSinkWrapper(_sink, [$T]);
        }, null, null, 2, 0, 385, 45, [], "new _EventSinkWrapper"]
      }
    },
    "+_EventSinkWrapper": [1, 1236],
    _SinkTransformerStreamSubscription: {
      "^": "_BufferingStreamSubscription;_transformerSink@-1237,_subscription@-1704,_onData-124,_onError-29,_onDone-90,_zone-51,_state-0,_cancelFuture-86,_pending-126,$ti",
      get$_isSubscribed: [function() {
        return this._subscription != null;
      }, null, null, 1, 0, 5, "_isSubscribed"],
      _async$_add$1: [function(data) {
        if (J.$and$n(this._state, 2) !== 0)
          throw H.wrapException(new P.StateError("Stream is already closed"));
        this.super$_BufferingStreamSubscription$_add(data);
      }, "call$1", "get$_async$_add", 2, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "_SinkTransformerStreamSubscription");
      }, 21, [], "_async$_add"],
      _addError$2: [function(error, stackTrace) {
        if (J.$and$n(this._state, 2) !== 0)
          throw H.wrapException(new P.StateError("Stream is already closed"));
        this.super$_BufferingStreamSubscription$_addError(error, stackTrace);
      }, "call$2", "get$_addError", 4, 0, 49, 8, [], 12, [], "_addError"],
      _async$_close$0: [function() {
        if (J.$and$n(this._state, 2) !== 0)
          throw H.wrapException(new P.StateError("Stream is already closed"));
        this.super$_BufferingStreamSubscription$_close();
      }, "call$0", "get$_async$_close", 0, 0, 6, "_async$_close"],
      _onPause$0: [function() {
        var t1 = this._subscription;
        if (t1 != null)
          t1.pause$0();
      }, "call$0", "get$_onPause", 0, 0, 6, "_onPause"],
      _onResume$0: [function() {
        var t1 = this._subscription;
        if (t1 != null)
          t1.resume$0();
      }, "call$0", "get$_onResume", 0, 0, 6, "_onResume"],
      _onCancel$0: [function() {
        var t1 = this._subscription;
        if (t1 != null) {
          this._subscription = null;
          return t1.cancel$0();
        }
        return;
      }, "call$0", "get$_onCancel", 0, 0, 18, "_onCancel"],
      _handleData$1: [function(data) {
        var e, s, exception, t1;
        try {
          J.add$1$ax(this._transformerSink, data);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          if (J.$and$n(this._state, 2) !== 0)
            H.throwExpression(new P.StateError("Stream is already closed"));
          this.super$_BufferingStreamSubscription$_addError(e, s);
        }
      }, "call$1", "get$_handleData", 2, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, v: true, args: [S]};
        }, this.$receiver, "_SinkTransformerStreamSubscription");
      }, 21, [], "_handleData"],
      _handleError$2: [function(error, stackTrace) {
        var e, s, exception, t1;
        try {
          this._transformerSink.addError$2(error, stackTrace);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          t1 = e;
          if (t1 == null ? error == null : t1 === error) {
            if (J.$and$n(this._state, 2) !== 0)
              H.throwExpression(new P.StateError("Stream is already closed"));
            this.super$_BufferingStreamSubscription$_addError(error, stackTrace);
          } else {
            if (J.$and$n(this._state, 2) !== 0)
              H.throwExpression(new P.StateError("Stream is already closed"));
            this.super$_BufferingStreamSubscription$_addError(e, s);
          }
        }
      }, function(error) {
        return this._handleError$2(error, null);
      }, "_handleError$1", "call$2", "call$1", "get$_handleError", 2, 2, 291, 0, 8, [], 12, [], "_handleError"],
      _handleDone$0: [function() {
        var e, s, exception, t1;
        try {
          this._subscription = null;
          this._transformerSink.close$0();
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          if (J.$and$n(this._state, 2) !== 0)
            H.throwExpression(new P.StateError("Stream is already closed"));
          this.super$_BufferingStreamSubscription$_addError(e, s);
        }
      }, "call$0", "get$_handleDone", 0, 0, 6, "_handleDone"],
      $as_BufferingStreamSubscription: function($S, $T) {
        return [$T];
      },
      $asStreamSubscription: function($S, $T) {
        return [$T];
      },
      "<>": [303, 428],
      static: {
        _SinkTransformerStreamSubscription$: [function(source, mapper, onData, onError, onDone, cancelOnError, $S, $T) {
          var t1, t2;
          t1 = $.Zone__current;
          t2 = cancelOnError === true ? 1 : 0;
          t2 = new P._SinkTransformerStreamSubscription(null, null, null, null, null, t1, t2, null, null, [$S, $T]);
          t2._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, $T);
          t2._transformerSink = mapper.call$1(new P._EventSinkWrapper(t2, [$T]));
          t2._subscription = source.listen$3$onDone$onError(t2.get$_handleData(), t2.get$_handleDone(), t2.get$_handleError());
          return t2;
        }, null, null, 12, 0, function() {
          return H.computeSignature(function(S, T) {
            return {func: 1, args: [[P.Stream, S], {func: 1, ret: [P.EventSink, S], args: [[P.EventSink, T]]}, {func: 1, v: true, args: [T]}, P.Function, {func: 1, v: true}, P.bool]};
          }, this.$receiver, "_SinkTransformerStreamSubscription");
        }, 19, [], 816, [], 27, [], 20, [], 28, [], 24, [], "new _SinkTransformerStreamSubscription"]
      }
    },
    "+_SinkTransformerStreamSubscription": [1239],
    _StreamSinkTransformer: {
      "^": "Object;_sinkMapper<-455,$ti",
      bind$1: ["super$_StreamSinkTransformer$bind", function(stream) {
        return new P._BoundSinkStream(this._sinkMapper, stream, this.$ti);
      }, "call$1", "get$bind", 2, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, ret: [P.Stream, T], args: [[P.Stream, S]]};
        }, this.$receiver, "_StreamSinkTransformer");
      }, 37, [], "bind"],
      "<>": [261, 263],
      static: {
        _StreamSinkTransformer$: [function(_sinkMapper, $S, $T) {
          return new P._StreamSinkTransformer(_sinkMapper, [$S, $T]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(S, T) {
            return {func: 1, args: [{func: 1, ret: [P.EventSink, S], args: [[P.EventSink, T]]}]};
          }, this.$receiver, "_StreamSinkTransformer");
        }, 523, [], "new _StreamSinkTransformer"]
      }
    },
    "+_StreamSinkTransformer": [1, 1241],
    _BoundSinkStream: {
      "^": "Stream;_sinkMapper<-1242,_stream<-1243,$ti",
      get$isBroadcast: [function() {
        return this._stream.get$isBroadcast();
      }, null, null, 1, 0, 5, "isBroadcast"],
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        var t1, t2, t3, subscription;
        cancelOnError = true === cancelOnError;
        t1 = H.getTypeArgumentByIndex(this, 1);
        t2 = $.Zone__current;
        t3 = cancelOnError ? 1 : 0;
        subscription = new P._SinkTransformerStreamSubscription(null, null, null, null, null, t2, t3, null, null, this.$ti);
        subscription._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, t1);
        subscription._transformerSink = this._sinkMapper.call$1(new P._EventSinkWrapper(subscription, [t1]));
        subscription._subscription = this._stream.listen$3$onDone$onError(subscription.get$_handleData(), subscription.get$_handleDone(), subscription.get$_handleError());
        return subscription;
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, onError);
      }, "listen$2$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, null);
      }, "listen$2$onDone", function(onData, cancelOnError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, null, null);
      }, "listen$2$cancelOnError", "call$4$cancelOnError$onDone$onError", "call$1", "call$2$onError", "call$3$onDone$onError", "call$3$onDone$onError", "call$2$onDone", "call$2$cancelOnError", "get$listen", 2, 7, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, ret: [P.StreamSubscription, T], args: [{func: 1, v: true, args: [T]}], named: {cancelOnError: P.bool, onDone: {func: 1, v: true}, onError: P.Function}};
        }, this.$receiver, "_BoundSinkStream");
      }, 0, 0, 0, 27, [], 20, [], 28, [], 24, [], "listen"],
      $asStream: function($S, $T) {
        return [$T];
      },
      "<>": [265, 266],
      static: {
        _BoundSinkStream$: [function(_stream, _sinkMapper, $S, $T) {
          return new P._BoundSinkStream(_sinkMapper, _stream, [$S, $T]);
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(S, T) {
            return {func: 1, args: [[P.Stream, S], {func: 1, ret: [P.EventSink, S], args: [[P.EventSink, T]]}]};
          }, this.$receiver, "_BoundSinkStream");
        }, 163, [], 523, [], "new _BoundSinkStream"]
      }
    },
    "+_BoundSinkStream": [1244],
    _HandlerEventSink: {
      "^": "Object;_handleData<-1245,_handleError<-1246,_handleDone<-1247,_async$_sink<-1248,$ti",
      add$1: [function(_, data) {
        var t1, t2;
        t1 = this._handleData;
        t2 = this._async$_sink;
        if (t1 != null)
          t1.call$2(data, t2);
        else
          J.add$1$ax(t2, H.subtypeOfRuntimeTypeCast(data, H.getTypeArgumentByIndex(this, 1)));
      }, "call$1", "get$add", 2, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, v: true, args: [S]};
        }, this.$receiver, "_HandlerEventSink");
      }, 21, [], "add"],
      addError$2: [function(error, stackTrace) {
        var t1, t2;
        t1 = this._handleError;
        t2 = this._async$_sink;
        if (t1 != null)
          t1.call$3(error, stackTrace, t2);
        else
          t2.addError$2(error, stackTrace);
      }, function(error) {
        return this.addError$2(error, null);
      }, "addError$1", "call$2", "call$1", "get$addError", 2, 2, 48, 0, 8, [], 12, [], "addError"],
      close$0: [function() {
        var t1, t2;
        t1 = this._handleDone;
        t2 = this._async$_sink;
        if (t1 != null)
          t1.call$1(t2);
        else
          t2.close$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      _handleData$2: function(arg0, arg1) {
        return this._handleData.call$2(arg0, arg1);
      },
      _handleData$1: function(arg0) {
        return this._handleData.call$1(arg0);
      },
      _handleError$3: function(arg0, arg1, arg2) {
        return this._handleError.call$3(arg0, arg1, arg2);
      },
      _handleError$2: function(arg0, arg1) {
        return this._handleError.call$2(arg0, arg1);
      },
      _handleDone$1: function(arg0) {
        return this._handleDone.call$1(arg0);
      },
      _handleDone$0: function() {
        return this._handleDone.call$0();
      },
      "<>": [264, 133],
      static: {
        _HandlerEventSink$: [function(_handleData, _handleError, _handleDone, _sink, $S, $T) {
          return new P._HandlerEventSink(_handleData, _handleError, _handleDone, _sink, [$S, $T]);
        }, null, null, 8, 0, function() {
          return H.computeSignature(function(S, T) {
            return {func: 1, args: [{func: 1, v: true, args: [S, [P.EventSink, T]]}, {func: 1, v: true, args: [P.Object, P.StackTrace, [P.EventSink, T]]}, {func: 1, v: true, args: [[P.EventSink, T]]}, [P.EventSink, T]]};
          }, this.$receiver, "_HandlerEventSink");
        }, 815, [], 810, [], 808, [], 45, [], "new _HandlerEventSink"]
      }
    },
    "+_HandlerEventSink": [1, 1249],
    _StreamHandlerTransformer: {
      "^": "_StreamSinkTransformer;_sinkMapper-455,$ti",
      bind$1: [function(stream) {
        return this.super$_StreamSinkTransformer$bind(stream);
      }, "call$1", "get$bind", 2, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, ret: [P.Stream, T], args: [[P.Stream, S]]};
        }, this.$receiver, "_StreamHandlerTransformer");
      }, 37, [], "bind"],
      "<>": [464, 465],
      static: {
        _StreamHandlerTransformer$: [function(handleData, handleDone, handleError, $S, $T) {
          return new P._StreamHandlerTransformer(new P._StreamHandlerTransformer_closure($S, $T, handleData, handleError, handleDone), [$S, $T]);
        }, null, null, 0, 7, function() {
          return H.computeSignature(function(S, T) {
            return {func: 1, named: {handleData: {func: 1, v: true, args: [S, [P.EventSink, T]]}, handleDone: {func: 1, v: true, args: [[P.EventSink, T]]}, handleError: {func: 1, v: true, args: [P.Object, P.StackTrace, [P.EventSink, T]]}}};
          }, this.$receiver, "_StreamHandlerTransformer");
        }, 0, 0, 0, 175, [], 157, [], 164, [], "new _StreamHandlerTransformer"]
      }
    },
    "+_StreamHandlerTransformer": [1250],
    _StreamHandlerTransformer_closure: {
      "^": "Closure;S,T,handleData,handleError,handleDone",
      call$1: [function(outputSink) {
        return new P._HandlerEventSink(this.handleData, this.handleError, this.handleDone, outputSink, [this.S, this.T]);
      }, null, null, 2, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, args: [[P.EventSink, T]]};
        }, this.$receiver, "_StreamHandlerTransformer");
      }, 781, [], "call"],
      $signature: function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, args: [[P.EventSink, T]]};
        }, this, "_StreamHandlerTransformer");
      }
    },
    "+ _StreamHandlerTransformer_closure": [2],
    _StreamSubscriptionTransformer: {
      "^": "Object;_transformer<-1251,$ti",
      bind$1: [function(stream) {
        return new P._BoundSubscriptionStream(this._transformer, stream, this.$ti);
      }, "call$1", "get$bind", 2, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, ret: [P.Stream, T], args: [[P.Stream, S]]};
        }, this.$receiver, "_StreamSubscriptionTransformer");
      }, 37, [], "bind"],
      "<>": [259, 260],
      static: {
        _StreamSubscriptionTransformer$: [function(_transformer, $S, $T) {
          return new P._StreamSubscriptionTransformer(_transformer, [$S, $T]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(S, T) {
            return {func: 1, args: [{func: 1, ret: [P.StreamSubscription, T], args: [[P.Stream, S], P.bool]}]};
          }, this.$receiver, "_StreamSubscriptionTransformer");
        }, 515, [], "new _StreamSubscriptionTransformer"]
      }
    },
    "+_StreamSubscriptionTransformer": [1, 1252],
    _BoundSubscriptionStream: {
      "^": "Stream;_transformer<-1253,_stream<-1254,$ti",
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        var result = this._transformer.call$2(this._stream, true === cancelOnError);
        result.onData$1(onData);
        result.onError$1(onError);
        result.onDone$1(onDone);
        return result;
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, onError);
      }, "listen$2$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, null);
      }, "listen$2$onDone", function(onData, cancelOnError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, null, null);
      }, "listen$2$cancelOnError", "call$4$cancelOnError$onDone$onError", "call$1", "call$2$onError", "call$3$onDone$onError", "call$3$onDone$onError", "call$2$onDone", "call$2$cancelOnError", "get$listen", 2, 7, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, ret: [P.StreamSubscription, T], args: [{func: 1, v: true, args: [T]}], named: {cancelOnError: P.bool, onDone: {func: 1, v: true}, onError: P.Function}};
        }, this.$receiver, "_BoundSubscriptionStream");
      }, 0, 0, 0, 27, [], 20, [], 28, [], 24, [], "listen"],
      $asStream: function($S, $T) {
        return [$T];
      },
      "<>": [257, 258],
      static: {
        _BoundSubscriptionStream$: [function(_stream, _transformer, $S, $T) {
          return new P._BoundSubscriptionStream(_transformer, _stream, [$S, $T]);
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(S, T) {
            return {func: 1, args: [[P.Stream, S], {func: 1, ret: [P.StreamSubscription, T], args: [[P.Stream, S], P.bool]}]};
          }, this.$receiver, "_BoundSubscriptionStream");
        }, 163, [], 515, [], "new _BoundSubscriptionStream"]
      }
    },
    "+_BoundSubscriptionStream": [1255],
    Timer: {
      "^": "Object;",
      static: {
        Timer_Timer: [function(duration, callback) {
          var t1;
          if (J.$eq$($.Zone__current, C.C__RootZone))
            return $.Zone__current.createTimer$2(duration, callback);
          t1 = $.Zone__current;
          return t1.createTimer$2(duration, t1.bindCallback$2$runGuarded(callback, true));
        }, null, null, 4, 0, 171, 59, [], 33, [], "new Timer"],
        Timer_Timer$periodic: [function(duration, callback) {
          var boundCallback;
          if (J.$eq$($.Zone__current, C.C__RootZone))
            return $.Zone__current.createPeriodicTimer$2(duration, callback);
          boundCallback = $.Zone__current.bindUnaryCallback$2$runGuarded(callback, true);
          return $.Zone__current.createPeriodicTimer$2(duration, boundCallback);
        }, null, null, 4, 0, 204, 59, [], 33, [], "new Timer$periodic"],
        Timer_run: [function(callback) {
          P.Timer_Timer(C.Duration_0, callback);
        }, "call$1", "async_Timer_run$closure", 2, 0, 37, 33, [], "run"],
        Timer__createTimer: [function(duration, callback) {
          var milliseconds = duration.get$inMilliseconds();
          return H.TimerImpl$(J.$lt$n(milliseconds, 0) ? 0 : milliseconds, callback);
        }, "call$2", "async_Timer__createTimer$closure", 4, 0, 171, 59, [], 33, [], "_createTimer"],
        Timer__createPeriodicTimer: [function(duration, callback) {
          var milliseconds = duration.get$inMilliseconds();
          return H.TimerImpl$periodic(J.$lt$n(milliseconds, 0) ? 0 : milliseconds, callback);
        }, "call$2", "async_Timer__createPeriodicTimer$closure", 4, 0, 204, 59, [], 33, [], "_createPeriodicTimer"]
      }
    },
    "+Timer": [1],
    AsyncError: {
      "^": "Object;error<-1,stackTrace<-221",
      toString$0: [function(_) {
        return H.S(this.error);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      error$1: function(arg0) {
        return this.error.call$1(arg0);
      },
      $isError: 1,
      static: {
        AsyncError$: [function(error, stackTrace) {
          return new P.AsyncError(error, stackTrace);
        }, null, null, 4, 0, 585, 8, [], 12, [], "new AsyncError"]
      }
    },
    "+AsyncError": [1, 34],
    _ZoneFunction: {
      "^": "Object;zone<-166,$function<-1258,$ti",
      "<>": [557],
      static: {
        _ZoneFunction$: [function(zone, $function, $T) {
          return new P._ZoneFunction(zone, $function, [$T]);
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [P._Zone, T]};
          }, this.$receiver, "_ZoneFunction");
        }, 34, [], 115, [], "new _ZoneFunction"]
      }
    },
    "+_ZoneFunction": [1],
    ZoneSpecification: {
      "^": "Object;",
      handleUncaughtError$2: function(arg0, arg1) {
        return this.get$handleUncaughtError().call$2(arg0, arg1);
      },
      handleUncaughtError$3: function(arg0, arg1, arg2) {
        return this.get$handleUncaughtError().call$3(arg0, arg1, arg2);
      },
      run$1: function(arg0) {
        return this.get$run().call$1(arg0);
      },
      run$2: function(arg0, arg1) {
        return this.get$run().call$2(arg0, arg1);
      },
      runUnary$2: function(arg0, arg1) {
        return this.get$runUnary().call$2(arg0, arg1);
      },
      runUnary$3: function(arg0, arg1, arg2) {
        return this.get$runUnary().call$3(arg0, arg1, arg2);
      },
      runBinary$3: function(arg0, arg1, arg2) {
        return this.get$runBinary().call$3(arg0, arg1, arg2);
      },
      runBinary$4: function(arg0, arg1, arg2, arg3) {
        return this.get$runBinary().call$4(arg0, arg1, arg2, arg3);
      },
      registerCallback$1: function(arg0) {
        return this.get$registerCallback().call$1(arg0);
      },
      registerCallback$2: function(arg0, arg1) {
        return this.get$registerCallback().call$2(arg0, arg1);
      },
      registerUnaryCallback$1: function(arg0) {
        return this.get$registerUnaryCallback().call$1(arg0);
      },
      registerUnaryCallback$2: function(arg0, arg1) {
        return this.get$registerUnaryCallback().call$2(arg0, arg1);
      },
      registerBinaryCallback$1: function(arg0) {
        return this.get$registerBinaryCallback().call$1(arg0);
      },
      registerBinaryCallback$2: function(arg0, arg1) {
        return this.get$registerBinaryCallback().call$2(arg0, arg1);
      },
      errorCallback$2: function(arg0, arg1) {
        return this.get$errorCallback().call$2(arg0, arg1);
      },
      errorCallback$3: function(arg0, arg1, arg2) {
        return this.get$errorCallback().call$3(arg0, arg1, arg2);
      },
      scheduleMicrotask$1: function(arg0) {
        return this.get$scheduleMicrotask().call$1(arg0);
      },
      scheduleMicrotask$2: function(arg0, arg1) {
        return this.get$scheduleMicrotask().call$2(arg0, arg1);
      },
      createTimer$2: function(arg0, arg1) {
        return this.get$createTimer().call$2(arg0, arg1);
      },
      createTimer$3: function(arg0, arg1, arg2) {
        return this.get$createTimer().call$3(arg0, arg1, arg2);
      },
      createPeriodicTimer$2: function(arg0, arg1) {
        return this.get$createPeriodicTimer().call$2(arg0, arg1);
      },
      createPeriodicTimer$3: function(arg0, arg1, arg2) {
        return this.get$createPeriodicTimer().call$3(arg0, arg1, arg2);
      },
      print$1: function(arg0) {
        return this.get$print().call$1(arg0);
      },
      print$2: function(arg0, arg1) {
        return this.get$print().call$2(arg0, arg1);
      },
      fork$2$specification$zoneValues: function(arg0, arg1) {
        return this.get$fork().call$2$specification$zoneValues(arg0, arg1);
      },
      fork$3: function(arg0, arg1, arg2) {
        return this.get$fork().call$3(arg0, arg1, arg2);
      },
      static: {
        ZoneSpecification_ZoneSpecification: [function(createPeriodicTimer, createTimer, errorCallback, fork, handleUncaughtError, $print, registerBinaryCallback, registerCallback, registerUnaryCallback, run, runBinary, runUnary, scheduleMicrotask) {
          return new P._ZoneSpecification(handleUncaughtError, run, runUnary, runBinary, registerCallback, registerUnaryCallback, registerBinaryCallback, errorCallback, scheduleMicrotask, createTimer, createPeriodicTimer, $print, fork);
        }, null, null, 0, 27, 586, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 328, [], 329, [], 330, [], 331, [], 332, [], 333, [], 334, [], 181, [], 335, [], 336, [], 337, [], 338, [], 339, [], "new ZoneSpecification"],
        ZoneSpecification_ZoneSpecification$from: [function(other, createPeriodicTimer, createTimer, errorCallback, fork, handleUncaughtError, $print, registerBinaryCallback, registerCallback, registerUnaryCallback, run, runBinary, runUnary, scheduleMicrotask) {
          var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12;
          t1 = handleUncaughtError == null ? other.get$handleUncaughtError() : handleUncaughtError;
          t2 = run == null ? other.get$run() : run;
          t3 = runUnary == null ? other.get$runUnary() : runUnary;
          t4 = runBinary == null ? other.get$runBinary() : runBinary;
          t5 = registerCallback == null ? other.get$registerCallback() : registerCallback;
          t6 = registerUnaryCallback == null ? other.get$registerUnaryCallback() : registerUnaryCallback;
          t7 = registerBinaryCallback == null ? other.get$registerBinaryCallback() : registerBinaryCallback;
          t8 = errorCallback == null ? other.get$errorCallback() : errorCallback;
          t9 = scheduleMicrotask == null ? other.get$scheduleMicrotask() : scheduleMicrotask;
          t10 = createTimer == null ? other.get$createTimer() : createTimer;
          t11 = createPeriodicTimer == null ? other.get$createPeriodicTimer() : createPeriodicTimer;
          t12 = $print == null ? other.get$print() : $print;
          return new P._ZoneSpecification(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, fork == null ? other.get$fork() : fork);
        }, null, null, 2, 27, 587, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, [], 328, [], 329, [], 330, [], 331, [], 332, [], 333, [], 334, [], 181, [], 335, [], 336, [], 337, [], 338, [], 339, [], "new ZoneSpecification$from"]
      }
    },
    "+ZoneSpecification": [1],
    _ZoneSpecification: {
      "^": "Object;handleUncaughtError<-1259,run<-1260,runUnary<-1261,runBinary<-1262,registerCallback<-1263,registerUnaryCallback<-1264,registerBinaryCallback<-1265,errorCallback<-1266,scheduleMicrotask<-1267,createTimer<-1268,createPeriodicTimer<-1269,print<-1270,fork<-1271",
      handleUncaughtError$2: function(arg0, arg1) {
        return this.handleUncaughtError.call$2(arg0, arg1);
      },
      handleUncaughtError$3: function(arg0, arg1, arg2) {
        return this.handleUncaughtError.call$3(arg0, arg1, arg2);
      },
      run$1: function(arg0) {
        return this.run.call$1(arg0);
      },
      run$2: function(arg0, arg1) {
        return this.run.call$2(arg0, arg1);
      },
      runUnary$2: function(arg0, arg1) {
        return this.runUnary.call$2(arg0, arg1);
      },
      runUnary$3: function(arg0, arg1, arg2) {
        return this.runUnary.call$3(arg0, arg1, arg2);
      },
      runBinary$3: function(arg0, arg1, arg2) {
        return this.runBinary.call$3(arg0, arg1, arg2);
      },
      runBinary$4: function(arg0, arg1, arg2, arg3) {
        return this.runBinary.call$4(arg0, arg1, arg2, arg3);
      },
      registerCallback$1: function(arg0) {
        return this.registerCallback.call$1(arg0);
      },
      registerCallback$2: function(arg0, arg1) {
        return this.registerCallback.call$2(arg0, arg1);
      },
      registerUnaryCallback$1: function(arg0) {
        return this.registerUnaryCallback.call$1(arg0);
      },
      registerUnaryCallback$2: function(arg0, arg1) {
        return this.registerUnaryCallback.call$2(arg0, arg1);
      },
      registerBinaryCallback$1: function(arg0) {
        return this.registerBinaryCallback.call$1(arg0);
      },
      registerBinaryCallback$2: function(arg0, arg1) {
        return this.registerBinaryCallback.call$2(arg0, arg1);
      },
      errorCallback$2: function(arg0, arg1) {
        return this.errorCallback.call$2(arg0, arg1);
      },
      errorCallback$3: function(arg0, arg1, arg2) {
        return this.errorCallback.call$3(arg0, arg1, arg2);
      },
      scheduleMicrotask$1: function(arg0) {
        return this.scheduleMicrotask.call$1(arg0);
      },
      scheduleMicrotask$2: function(arg0, arg1) {
        return this.scheduleMicrotask.call$2(arg0, arg1);
      },
      createTimer$2: function(arg0, arg1) {
        return this.createTimer.call$2(arg0, arg1);
      },
      createTimer$3: function(arg0, arg1, arg2) {
        return this.createTimer.call$3(arg0, arg1, arg2);
      },
      createPeriodicTimer$2: function(arg0, arg1) {
        return this.createPeriodicTimer.call$2(arg0, arg1);
      },
      createPeriodicTimer$3: function(arg0, arg1, arg2) {
        return this.createPeriodicTimer.call$3(arg0, arg1, arg2);
      },
      print$1: function(arg0) {
        return this.print.call$1(arg0);
      },
      print$2: function(arg0, arg1) {
        return this.print.call$2(arg0, arg1);
      },
      fork$2$specification$zoneValues: function(arg0, arg1) {
        return this.fork.call$2$specification$zoneValues(arg0, arg1);
      },
      fork$3: function(arg0, arg1, arg2) {
        return this.fork.call$3(arg0, arg1, arg2);
      },
      static: {
        _ZoneSpecification$: [function(createPeriodicTimer, createTimer, errorCallback, fork, handleUncaughtError, $print, registerBinaryCallback, registerCallback, registerUnaryCallback, run, runBinary, runUnary, scheduleMicrotask) {
          return new P._ZoneSpecification(handleUncaughtError, run, runUnary, runBinary, registerCallback, registerUnaryCallback, registerBinaryCallback, errorCallback, scheduleMicrotask, createTimer, createPeriodicTimer, $print, fork);
        }, null, null, 0, 27, 588, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 328, [], 329, [], 330, [], 331, [], 332, [], 333, [], 334, [], 181, [], 335, [], 336, [], 337, [], 338, [], 339, [], "new _ZoneSpecification"]
      }
    },
    "+_ZoneSpecification": [1, 1272],
    ZoneDelegate: {
      "^": "Object;",
      static: {
        ZoneDelegate$: [function() {
          return new P.ZoneDelegate();
        }, null, null, 0, 0, 290, "new ZoneDelegate"]
      }
    },
    "+ZoneDelegate": [1],
    Zone: {
      "^": "Object;",
      static: {
        "^": "Zone_ROOT<-51,Zone__current@-51",
        Zone$_: [function() {
          return new P.Zone();
        }, null, null, 0, 0, 4, "new Zone$_"],
        Zone_current: [function() {
          return $.Zone__current;
        }, null, null, 1, 0, 209, "current"],
        Zone__enter: [function(zone) {
          var previous = $.Zone__current;
          $.Zone__current = zone;
          return previous;
        }, "call$1", "async_Zone__enter$closure", 2, 0, 589, 34, [], "_enter"],
        Zone__leave: [function(previous) {
          $.Zone__current = previous;
        }, "call$1", "async_Zone__leave$closure", 2, 0, 590, 340, [], "_leave"]
      }
    },
    "+Zone": [1],
    _ZoneDelegate: {
      "^": "Object;_delegationTarget<-166",
      handleUncaughtError$3: [function(zone, error, stackTrace) {
        var implementation, implZone;
        implementation = this._delegationTarget.get$_handleUncaughtError();
        implZone = implementation.get$zone();
        return implementation.get$$function().call$5(implZone, P._parentDelegate(implZone), zone, error, stackTrace);
      }, "call$3", "get$handleUncaughtError", 6, 0, function() {
        return {func: 1, args: [P.Zone,, P.StackTrace]};
      }, 34, [], 8, [], 12, [], "handleUncaughtError"],
      run$2: [function(zone, f) {
        var implementation, implZone;
        implementation = this._delegationTarget.get$_run();
        implZone = implementation.get$zone();
        return implementation.get$$function().call$4(implZone, P._parentDelegate(implZone), zone, f);
      }, "call$2", "get$run", 4, 0, function() {
        return {func: 1, args: [P.Zone, {func: 1}]};
      }, 34, [], 9, [], "run"],
      runUnary$3: [function(zone, f, arg) {
        var implementation, implZone;
        implementation = this._delegationTarget.get$_runUnary();
        implZone = implementation.get$zone();
        return implementation.get$$function().call$5(implZone, P._parentDelegate(implZone), zone, f, arg);
      }, "call$3", "get$runUnary", 6, 0, function() {
        return {func: 1, args: [P.Zone, {func: 1, args: [,]},,]};
      }, 34, [], 9, [], 68, [], "runUnary"],
      runBinary$4: [function(zone, f, arg1, arg2) {
        var implementation, implZone;
        implementation = this._delegationTarget.get$_runBinary();
        implZone = implementation.get$zone();
        return implementation.get$$function().call$6(implZone, P._parentDelegate(implZone), zone, f, arg1, arg2);
      }, "call$4", "get$runBinary", 8, 0, function() {
        return {func: 1, args: [P.Zone, {func: 1, args: [,,]},,,]};
      }, 34, [], 9, [], 91, [], 90, [], "runBinary"],
      registerCallback$2: [function(zone, f) {
        var implementation, implZone;
        implementation = this._delegationTarget.get$_registerCallback();
        implZone = implementation.get$zone();
        return implementation.get$$function().call$4(implZone, P._parentDelegate(implZone), zone, f);
      }, "call$2", "get$registerCallback", 4, 0, function() {
        return {func: 1, ret: {func: 1}, args: [P.Zone, {func: 1}]};
      }, 34, [], 9, [], "registerCallback"],
      registerUnaryCallback$2: [function(zone, f) {
        var implementation, implZone;
        implementation = this._delegationTarget.get$_registerUnaryCallback();
        implZone = implementation.get$zone();
        return implementation.get$$function().call$4(implZone, P._parentDelegate(implZone), zone, f);
      }, "call$2", "get$registerUnaryCallback", 4, 0, function() {
        return {func: 1, ret: {func: 1, args: [,]}, args: [P.Zone, {func: 1, args: [,]}]};
      }, 34, [], 9, [], "registerUnaryCallback"],
      registerBinaryCallback$2: [function(zone, f) {
        var implementation, implZone;
        implementation = this._delegationTarget.get$_registerBinaryCallback();
        implZone = implementation.get$zone();
        return implementation.get$$function().call$4(implZone, P._parentDelegate(implZone), zone, f);
      }, "call$2", "get$registerBinaryCallback", 4, 0, function() {
        return {func: 1, ret: {func: 1, args: [,,]}, args: [P.Zone, {func: 1, args: [,,]}]};
      }, 34, [], 9, [], "registerBinaryCallback"],
      errorCallback$3: [function(zone, error, stackTrace) {
        var implementation, implZone;
        implementation = this._delegationTarget.get$_errorCallback();
        implZone = implementation.get$zone();
        if (implZone === C.C__RootZone)
          return;
        return implementation.get$$function().call$5(implZone, P._parentDelegate(implZone), zone, error, stackTrace);
      }, "call$3", "get$errorCallback", 6, 0, 918, 34, [], 8, [], 12, [], "errorCallback"],
      scheduleMicrotask$2: [function(zone, f) {
        var implementation, implZone;
        implementation = this._delegationTarget.get$_scheduleMicrotask();
        implZone = implementation.get$zone();
        implementation.get$$function().call$4(implZone, P._parentDelegate(implZone), zone, f);
      }, "call$2", "get$scheduleMicrotask", 4, 0, 919, 34, [], 9, [], "scheduleMicrotask"],
      createTimer$3: [function(zone, duration, f) {
        var implementation, implZone;
        implementation = this._delegationTarget.get$_createTimer();
        implZone = implementation.get$zone();
        return implementation.get$$function().call$5(implZone, P._parentDelegate(implZone), zone, duration, f);
      }, "call$3", "get$createTimer", 6, 0, 921, 34, [], 59, [], 9, [], "createTimer"],
      createPeriodicTimer$3: [function(zone, period, f) {
        var implementation, implZone;
        implementation = this._delegationTarget.get$_createPeriodicTimer();
        implZone = implementation.get$zone();
        return implementation.get$$function().call$5(implZone, P._parentDelegate(implZone), zone, period, f);
      }, "call$3", "get$createPeriodicTimer", 6, 0, 957, 34, [], 565, [], 9, [], "createPeriodicTimer"],
      print$2: [function(zone, line) {
        var implementation, implZone;
        implementation = this._delegationTarget.get$_print();
        implZone = implementation.get$zone();
        implementation.get$$function().call$4(implZone, P._parentDelegate(implZone), zone, line);
      }, "call$2", "get$print", 4, 0, 1024, 34, [], 161, [], "print"],
      fork$3: [function(zone, specification, zoneValues) {
        var implementation, implZone;
        implementation = this._delegationTarget.get$_fork();
        implZone = implementation.get$zone();
        return implementation.get$$function().call$5(implZone, P._parentDelegate(implZone), zone, specification, zoneValues);
      }, "call$3", "get$fork", 6, 0, 1117, 34, [], 198, [], 200, [], "fork"],
      static: {
        _ZoneDelegate$: [function(_delegationTarget) {
          return new P._ZoneDelegate(_delegationTarget);
        }, null, null, 2, 0, 592, 807, [], "new _ZoneDelegate"]
      }
    },
    "+_ZoneDelegate": [1, 235],
    _Zone: {
      "^": "Object;",
      inSameErrorZone$1: [function(otherZone) {
        var t1, t2;
        if (this !== otherZone) {
          t1 = this.get$errorZone();
          t2 = otherZone.get$errorZone();
          t2 = t1 == null ? t2 == null : t1 === t2;
          t1 = t2;
        } else
          t1 = true;
        return t1;
      }, "call$1", "get$inSameErrorZone", 2, 0, 1118, 777, [], "inSameErrorZone"],
      static: {
        _Zone$: [function() {
          return new P._Zone();
        }, null, null, 0, 0, 4, "new _Zone"]
      }
    },
    "+_Zone": [1, 51],
    _CustomZone: {
      "^": "_Zone;_run@-1274,_runUnary@-1275,_runBinary@-1276,_registerCallback@-1277,_registerUnaryCallback@-1278,_registerBinaryCallback@-1279,_errorCallback@-1280,_scheduleMicrotask@-1281,_createTimer@-1282,_createPeriodicTimer@-1283,_print@-1284,_fork@-1285,_handleUncaughtError@-1286,_delegateCache@-235,parent<-166,_async$_map<-122",
      get$_delegate: [function() {
        var t1 = this._delegateCache;
        if (t1 != null)
          return t1;
        t1 = new P._ZoneDelegate(this);
        this._delegateCache = t1;
        return t1;
      }, null, null, 1, 0, 290, "_delegate"],
      get$errorZone: [function() {
        return this._handleUncaughtError.get$zone();
      }, null, null, 1, 0, 209, "errorZone"],
      runGuarded$1: [function(f) {
        var e, s, t1, exception;
        try {
          t1 = this.run$1(f);
          return t1;
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          return this.handleUncaughtError$2(e, s);
        }
      }, "call$1", "get$runGuarded", 2, 0, function() {
        return {func: 1, args: [{func: 1}]};
      }, 9, [], "runGuarded"],
      runUnaryGuarded$2: [function(f, arg) {
        var e, s, t1, exception;
        try {
          t1 = this.runUnary$2(f, arg);
          return t1;
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          return this.handleUncaughtError$2(e, s);
        }
      }, "call$2", "get$runUnaryGuarded", 4, 0, function() {
        return {func: 1, args: [{func: 1, args: [,]},,]};
      }, 9, [], 68, [], "runUnaryGuarded"],
      runBinaryGuarded$3: [function(f, arg1, arg2) {
        var e, s, t1, exception;
        try {
          t1 = this.runBinary$3(f, arg1, arg2);
          return t1;
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          return this.handleUncaughtError$2(e, s);
        }
      }, "call$3", "get$runBinaryGuarded", 6, 0, function() {
        return {func: 1, args: [{func: 1, args: [,,]},,,]};
      }, 9, [], 91, [], 90, [], "runBinaryGuarded"],
      bindCallback$2$runGuarded: [function(f, runGuarded) {
        var registered = this.registerCallback$1(f);
        if (runGuarded === true)
          return new P._CustomZone_bindCallback_closure(this, registered);
        else
          return new P._CustomZone_bindCallback_closure0(this, registered);
      }, function(f) {
        return this.bindCallback$2$runGuarded(f, true);
      }, "bindCallback$1", "call$2$runGuarded", "call$1", "get$bindCallback", 2, 3, function() {
        return {func: 1, ret: {func: 1}, args: [{func: 1}], named: {runGuarded: P.bool}};
      }, 25, 9, [], 150, [], "bindCallback"],
      bindUnaryCallback$2$runGuarded: [function(f, runGuarded) {
        var registered = this.registerUnaryCallback$1(f);
        if (runGuarded === true)
          return new P._CustomZone_bindUnaryCallback_closure(this, registered);
        else
          return new P._CustomZone_bindUnaryCallback_closure0(this, registered);
      }, function(f) {
        return this.bindUnaryCallback$2$runGuarded(f, true);
      }, "bindUnaryCallback$1", "call$2$runGuarded", "call$1", "get$bindUnaryCallback", 2, 3, function() {
        return {func: 1, ret: {func: 1, args: [,]}, args: [{func: 1, args: [,]}], named: {runGuarded: P.bool}};
      }, 25, 9, [], 150, [], "bindUnaryCallback"],
      bindBinaryCallback$2$runGuarded: [function(f, runGuarded) {
        var registered = this.registerBinaryCallback$1(f);
        if (runGuarded === true)
          return new P._CustomZone_bindBinaryCallback_closure(this, registered);
        else
          return new P._CustomZone_bindBinaryCallback_closure0(this, registered);
      }, function(f) {
        return this.bindBinaryCallback$2$runGuarded(f, true);
      }, "bindBinaryCallback$1", "call$2$runGuarded", "call$1", "get$bindBinaryCallback", 2, 3, function() {
        return {func: 1, ret: {func: 1, args: [,,]}, args: [{func: 1, args: [,,]}], named: {runGuarded: P.bool}};
      }, 25, 9, [], 150, [], "bindBinaryCallback"],
      $index: [function(_, key) {
        var t1, t2, result, t3, value;
        t1 = this._async$_map;
        t2 = J.getInterceptor$asx(t1);
        result = t2.$index(t1, key);
        if (result != null || t1.containsKey$1(key))
          return result;
        t3 = this.parent;
        if (t3 != null) {
          value = J.$index$asx(t3, key);
          if (value != null)
            t2.$indexSet(t1, key, value);
          return value;
        }
        return;
      }, null, "get$[]", 2, 0, 170, 6, [], "[]"],
      handleUncaughtError$2: [function(error, stackTrace) {
        var implementation, parentDelegate;
        implementation = this._handleUncaughtError;
        parentDelegate = P._parentDelegate(implementation.get$zone());
        return implementation.get$$function().call$5(implementation.get$zone(), parentDelegate, this, error, stackTrace);
      }, "call$2", "get$handleUncaughtError", 4, 0, function() {
        return {func: 1, args: [, P.StackTrace]};
      }, 8, [], 12, [], "handleUncaughtError"],
      fork$2$specification$zoneValues: [function(specification, zoneValues) {
        var implementation, parentDelegate;
        implementation = this._fork;
        parentDelegate = P._parentDelegate(implementation.get$zone());
        return implementation.get$$function().call$5(implementation.get$zone(), parentDelegate, this, specification, zoneValues);
      }, function() {
        return this.fork$2$specification$zoneValues(null, null);
      }, "fork$0", "call$2$specification$zoneValues", "call$0", "get$fork", 0, 5, 440, 0, 0, 198, [], 200, [], "fork"],
      run$1: [function(f) {
        var implementation, parentDelegate;
        implementation = this._run;
        parentDelegate = P._parentDelegate(implementation.get$zone());
        return implementation.get$$function().call$4(implementation.get$zone(), parentDelegate, this, f);
      }, "call$1", "get$run", 2, 0, function() {
        return {func: 1, args: [{func: 1}]};
      }, 9, [], "run"],
      runUnary$2: [function(f, arg) {
        var implementation, parentDelegate;
        implementation = this._runUnary;
        parentDelegate = P._parentDelegate(implementation.get$zone());
        return implementation.get$$function().call$5(implementation.get$zone(), parentDelegate, this, f, arg);
      }, "call$2", "get$runUnary", 4, 0, function() {
        return {func: 1, args: [{func: 1, args: [,]},,]};
      }, 9, [], 68, [], "runUnary"],
      runBinary$3: [function(f, arg1, arg2) {
        var implementation, parentDelegate;
        implementation = this._runBinary;
        parentDelegate = P._parentDelegate(implementation.get$zone());
        return implementation.get$$function().call$6(implementation.get$zone(), parentDelegate, this, f, arg1, arg2);
      }, "call$3", "get$runBinary", 6, 0, function() {
        return {func: 1, args: [{func: 1, args: [,,]},,,]};
      }, 9, [], 91, [], 90, [], "runBinary"],
      registerCallback$1: [function(callback) {
        var implementation, parentDelegate;
        implementation = this._registerCallback;
        parentDelegate = P._parentDelegate(implementation.get$zone());
        return implementation.get$$function().call$4(implementation.get$zone(), parentDelegate, this, callback);
      }, "call$1", "get$registerCallback", 2, 0, function() {
        return {func: 1, ret: {func: 1}, args: [{func: 1}]};
      }, 33, [], "registerCallback"],
      registerUnaryCallback$1: [function(callback) {
        var implementation, parentDelegate;
        implementation = this._registerUnaryCallback;
        parentDelegate = P._parentDelegate(implementation.get$zone());
        return implementation.get$$function().call$4(implementation.get$zone(), parentDelegate, this, callback);
      }, "call$1", "get$registerUnaryCallback", 2, 0, function() {
        return {func: 1, ret: {func: 1, args: [,]}, args: [{func: 1, args: [,]}]};
      }, 33, [], "registerUnaryCallback"],
      registerBinaryCallback$1: [function(callback) {
        var implementation, parentDelegate;
        implementation = this._registerBinaryCallback;
        parentDelegate = P._parentDelegate(implementation.get$zone());
        return implementation.get$$function().call$4(implementation.get$zone(), parentDelegate, this, callback);
      }, "call$1", "get$registerBinaryCallback", 2, 0, function() {
        return {func: 1, ret: {func: 1, args: [,,]}, args: [{func: 1, args: [,,]}]};
      }, 33, [], "registerBinaryCallback"],
      errorCallback$2: [function(error, stackTrace) {
        var implementation, implementationZone, parentDelegate;
        implementation = this._errorCallback;
        implementationZone = implementation.get$zone();
        if (implementationZone === C.C__RootZone)
          return;
        parentDelegate = P._parentDelegate(implementationZone);
        return implementation.get$$function().call$5(implementationZone, parentDelegate, this, error, stackTrace);
      }, "call$2", "get$errorCallback", 4, 0, 441, 8, [], 12, [], "errorCallback"],
      scheduleMicrotask$1: [function(f) {
        var implementation, parentDelegate;
        implementation = this._scheduleMicrotask;
        parentDelegate = P._parentDelegate(implementation.get$zone());
        return implementation.get$$function().call$4(implementation.get$zone(), parentDelegate, this, f);
      }, "call$1", "get$scheduleMicrotask", 2, 0, 37, 9, [], "scheduleMicrotask"],
      createTimer$2: [function(duration, f) {
        var implementation, parentDelegate;
        implementation = this._createTimer;
        parentDelegate = P._parentDelegate(implementation.get$zone());
        return implementation.get$$function().call$5(implementation.get$zone(), parentDelegate, this, duration, f);
      }, "call$2", "get$createTimer", 4, 0, 171, 59, [], 9, [], "createTimer"],
      createPeriodicTimer$2: [function(duration, f) {
        var implementation, parentDelegate;
        implementation = this._createPeriodicTimer;
        parentDelegate = P._parentDelegate(implementation.get$zone());
        return implementation.get$$function().call$5(implementation.get$zone(), parentDelegate, this, duration, f);
      }, "call$2", "get$createPeriodicTimer", 4, 0, 204, 59, [], 9, [], "createPeriodicTimer"],
      print$1: [function(line) {
        var implementation, parentDelegate;
        implementation = this._print;
        parentDelegate = P._parentDelegate(implementation.get$zone());
        return implementation.get$$function().call$4(implementation.get$zone(), parentDelegate, this, line);
      }, "call$1", "get$print", 2, 0, 19, 161, [], "print"],
      static: {
        _CustomZone$: [function($parent, specification, _map) {
          var t1 = new P._CustomZone(null, null, null, null, null, null, null, null, null, null, null, null, null, null, $parent, _map);
          t1._run = specification.get$run() != null ? new P._ZoneFunction(t1, specification.get$run(), [{func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1}]}]) : $parent.get$_run();
          t1._runUnary = specification.get$runUnary() != null ? new P._ZoneFunction(t1, specification.get$runUnary(), [{func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,]},,]}]) : $parent.get$_runUnary();
          t1._runBinary = specification.get$runBinary() != null ? new P._ZoneFunction(t1, specification.get$runBinary(), [{func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,,]},,,]}]) : $parent.get$_runBinary();
          t1._registerCallback = specification.get$registerCallback() != null ? new P._ZoneFunction(t1, specification.get$registerCallback(), [{func: 1, ret: {func: 1}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1}]}]) : $parent.get$_registerCallback();
          t1._registerUnaryCallback = specification.get$registerUnaryCallback() != null ? new P._ZoneFunction(t1, specification.get$registerUnaryCallback(), [{func: 1, ret: {func: 1, args: [,]}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,]}]}]) : $parent.get$_registerUnaryCallback();
          t1._registerBinaryCallback = specification.get$registerBinaryCallback() != null ? new P._ZoneFunction(t1, specification.get$registerBinaryCallback(), [{func: 1, ret: {func: 1, args: [,,]}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,,]}]}]) : $parent.get$_registerBinaryCallback();
          t1._errorCallback = specification.get$errorCallback() != null ? new P._ZoneFunction(t1, specification.get$errorCallback(), [{func: 1, ret: P.AsyncError, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Object, P.StackTrace]}]) : $parent.get$_errorCallback();
          t1._scheduleMicrotask = specification.get$scheduleMicrotask() != null ? new P._ZoneFunction(t1, specification.get$scheduleMicrotask(), [{func: 1, v: true, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, v: true}]}]) : $parent.get$_scheduleMicrotask();
          t1._createTimer = specification.get$createTimer() != null ? new P._ZoneFunction(t1, specification.get$createTimer(), [{func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, v: true}]}]) : $parent.get$_createTimer();
          t1._createPeriodicTimer = specification.get$createPeriodicTimer() != null ? new P._ZoneFunction(t1, specification.get$createPeriodicTimer(), [{func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, v: true, args: [P.Timer]}]}]) : $parent.get$_createPeriodicTimer();
          t1._print = specification.get$print() != null ? new P._ZoneFunction(t1, specification.get$print(), [{func: 1, v: true, args: [P.Zone, P.ZoneDelegate, P.Zone, P.String]}]) : $parent.get$_print();
          t1._fork = specification.get$fork() != null ? new P._ZoneFunction(t1, specification.get$fork(), [{func: 1, ret: P.Zone, args: [P.Zone, P.ZoneDelegate, P.Zone, P.ZoneSpecification, P.Map]}]) : $parent.get$_fork();
          t1._handleUncaughtError = specification.get$handleUncaughtError() != null ? new P._ZoneFunction(t1, specification.get$handleUncaughtError(), [{func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone,, P.StackTrace]}]) : $parent.get$_handleUncaughtError();
          return t1;
        }, null, null, 6, 0, 593, 62, [], 198, [], 341, [], "new _CustomZone"]
      }
    },
    "+_CustomZone": [166],
    _CustomZone_bindCallback_closure: {
      "^": "Closure:4;$this,registered",
      call$0: [function() {
        return this.$this.runGuarded$1(this.registered);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _CustomZone_bindCallback_closure": [2],
    _CustomZone_bindCallback_closure0: {
      "^": "Closure:4;$this,registered",
      call$0: [function() {
        return this.$this.run$1(this.registered);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _CustomZone_bindCallback_closure": [2],
    _CustomZone_bindUnaryCallback_closure: {
      "^": "Closure:3;$this,registered",
      call$1: [function(arg) {
        return this.$this.runUnaryGuarded$2(this.registered, arg);
      }, null, null, 2, 0, 3, 68, [], "call"]
    },
    "+ _CustomZone_bindUnaryCallback_closure": [2],
    _CustomZone_bindUnaryCallback_closure0: {
      "^": "Closure:3;$this,registered",
      call$1: [function(arg) {
        return this.$this.runUnary$2(this.registered, arg);
      }, null, null, 2, 0, 3, 68, [], "call"]
    },
    "+ _CustomZone_bindUnaryCallback_closure": [2],
    _CustomZone_bindBinaryCallback_closure: {
      "^": "Closure:12;$this,registered",
      call$2: [function(arg1, arg2) {
        return this.$this.runBinaryGuarded$3(this.registered, arg1, arg2);
      }, null, null, 4, 0, 12, 91, [], 90, [], "call"]
    },
    "+ _CustomZone_bindBinaryCallback_closure": [2],
    _CustomZone_bindBinaryCallback_closure0: {
      "^": "Closure:12;$this,registered",
      call$2: [function(arg1, arg2) {
        return this.$this.runBinary$3(this.registered, arg1, arg2);
      }, null, null, 4, 0, 12, 91, [], 90, [], "call"]
    },
    "+ _CustomZone_bindBinaryCallback_closure": [2],
    _rootHandleUncaughtError_closure: {
      "^": "Closure:4;_box_0,stackTrace",
      call$0: [function() {
        var t1, t2, error;
        t1 = this._box_0;
        t2 = t1.error;
        if (t2 == null) {
          error = new P.NullThrownError();
          t1.error = error;
          t1 = error;
        } else
          t1 = t2;
        t2 = this.stackTrace;
        if (t2 == null)
          throw H.wrapException(t1);
        error = H.wrapException(t1);
        error.stack = J.toString$0$(t2);
        throw error;
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _rootHandleUncaughtError_closure": [2],
    _RootZone: {
      "^": "_Zone;",
      get$_run: [function() {
        return C._ZoneFunction__RootZone__rootRun;
      }, null, null, 1, 0, 1135, "_run"],
      get$_runUnary: [function() {
        return C._ZoneFunction__RootZone__rootRunUnary;
      }, null, null, 1, 0, 1137, "_runUnary"],
      get$_runBinary: [function() {
        return C._ZoneFunction__RootZone__rootRunBinary;
      }, null, null, 1, 0, 1139, "_runBinary"],
      get$_registerCallback: [function() {
        return C._ZoneFunction__RootZone__rootRegisterCallback;
      }, null, null, 1, 0, 1140, "_registerCallback"],
      get$_registerUnaryCallback: [function() {
        return C._ZoneFunction_Eeh;
      }, null, null, 1, 0, 1141, "_registerUnaryCallback"],
      get$_registerBinaryCallback: [function() {
        return C._ZoneFunction_7G2;
      }, null, null, 1, 0, 1142, "_registerBinaryCallback"],
      get$_errorCallback: [function() {
        return C._ZoneFunction__RootZone__rootErrorCallback;
      }, null, null, 1, 0, 1143, "_errorCallback"],
      get$_scheduleMicrotask: [function() {
        return C._ZoneFunction__RootZone__rootScheduleMicrotask;
      }, null, null, 1, 0, 1154, "_scheduleMicrotask"],
      get$_createTimer: [function() {
        return C._ZoneFunction__RootZone__rootCreateTimer;
      }, null, null, 1, 0, 1155, "_createTimer"],
      get$_createPeriodicTimer: [function() {
        return C._ZoneFunction_3bB;
      }, null, null, 1, 0, 1156, "_createPeriodicTimer"],
      get$_print: [function() {
        return C._ZoneFunction__RootZone__rootPrint;
      }, null, null, 1, 0, 1162, "_print"],
      get$_fork: [function() {
        return C._ZoneFunction__RootZone__rootFork;
      }, null, null, 1, 0, 1165, "_fork"],
      get$_handleUncaughtError: [function() {
        return C._ZoneFunction_NMc;
      }, null, null, 1, 0, 1170, "_handleUncaughtError"],
      get$parent: [function() {
        return;
      }, null, null, 1, 0, 1187, "parent"],
      get$_async$_map: [function() {
        return $.$get$_RootZone__rootMap();
      }, null, null, 1, 0, 288, "_async$_map"],
      get$_delegate: [function() {
        var t1 = $._RootZone__rootDelegate;
        if (t1 != null)
          return t1;
        t1 = new P._ZoneDelegate(this);
        $._RootZone__rootDelegate = t1;
        return t1;
      }, null, null, 1, 0, 290, "_delegate"],
      get$errorZone: [function() {
        return this;
      }, null, null, 1, 0, 209, "errorZone"],
      runGuarded$1: [function(f) {
        var e, s, t1, exception;
        try {
          if (C.C__RootZone === $.Zone__current) {
            t1 = f.call$0();
            return t1;
          }
          t1 = P._rootRun(null, null, this, f);
          return t1;
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          return P._rootHandleUncaughtError(null, null, this, e, s);
        }
      }, "call$1", "get$runGuarded", 2, 0, function() {
        return {func: 1, args: [{func: 1}]};
      }, 9, [], "runGuarded"],
      runUnaryGuarded$2: [function(f, arg) {
        var e, s, t1, exception;
        try {
          if (C.C__RootZone === $.Zone__current) {
            t1 = f.call$1(arg);
            return t1;
          }
          t1 = P._rootRunUnary(null, null, this, f, arg);
          return t1;
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          return P._rootHandleUncaughtError(null, null, this, e, s);
        }
      }, "call$2", "get$runUnaryGuarded", 4, 0, function() {
        return {func: 1, args: [{func: 1, args: [,]},,]};
      }, 9, [], 68, [], "runUnaryGuarded"],
      runBinaryGuarded$3: [function(f, arg1, arg2) {
        var e, s, t1, exception;
        try {
          if (C.C__RootZone === $.Zone__current) {
            t1 = f.call$2(arg1, arg2);
            return t1;
          }
          t1 = P._rootRunBinary(null, null, this, f, arg1, arg2);
          return t1;
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          return P._rootHandleUncaughtError(null, null, this, e, s);
        }
      }, "call$3", "get$runBinaryGuarded", 6, 0, function() {
        return {func: 1, args: [{func: 1, args: [,,]},,,]};
      }, 9, [], 91, [], 90, [], "runBinaryGuarded"],
      bindCallback$2$runGuarded: [function(f, runGuarded) {
        if (runGuarded === true)
          return new P._RootZone_bindCallback_closure(this, f);
        else
          return new P._RootZone_bindCallback_closure0(this, f);
      }, function(f) {
        return this.bindCallback$2$runGuarded(f, true);
      }, "bindCallback$1", "call$2$runGuarded", "call$1", "get$bindCallback", 2, 3, function() {
        return {func: 1, ret: {func: 1}, args: [{func: 1}], named: {runGuarded: P.bool}};
      }, 25, 9, [], 150, [], "bindCallback"],
      bindUnaryCallback$2$runGuarded: [function(f, runGuarded) {
        if (runGuarded === true)
          return new P._RootZone_bindUnaryCallback_closure(this, f);
        else
          return new P._RootZone_bindUnaryCallback_closure0(this, f);
      }, function(f) {
        return this.bindUnaryCallback$2$runGuarded(f, true);
      }, "bindUnaryCallback$1", "call$2$runGuarded", "call$1", "get$bindUnaryCallback", 2, 3, function() {
        return {func: 1, ret: {func: 1, args: [,]}, args: [{func: 1, args: [,]}], named: {runGuarded: P.bool}};
      }, 25, 9, [], 150, [], "bindUnaryCallback"],
      bindBinaryCallback$2$runGuarded: [function(f, runGuarded) {
        if (runGuarded === true)
          return new P._RootZone_bindBinaryCallback_closure(this, f);
        else
          return new P._RootZone_bindBinaryCallback_closure0(this, f);
      }, function(f) {
        return this.bindBinaryCallback$2$runGuarded(f, true);
      }, "bindBinaryCallback$1", "call$2$runGuarded", "call$1", "get$bindBinaryCallback", 2, 3, function() {
        return {func: 1, ret: {func: 1, args: [,,]}, args: [{func: 1, args: [,,]}], named: {runGuarded: P.bool}};
      }, 25, 9, [], 150, [], "bindBinaryCallback"],
      $index: [function(_, key) {
        return;
      }, null, "get$[]", 2, 0, 170, 6, [], "[]"],
      handleUncaughtError$2: [function(error, stackTrace) {
        return P._rootHandleUncaughtError(null, null, this, error, stackTrace);
      }, "call$2", "get$handleUncaughtError", 4, 0, function() {
        return {func: 1, args: [, P.StackTrace]};
      }, 8, [], 12, [], "handleUncaughtError"],
      fork$2$specification$zoneValues: [function(specification, zoneValues) {
        return P._rootFork(null, null, this, specification, zoneValues);
      }, function() {
        return this.fork$2$specification$zoneValues(null, null);
      }, "fork$0", "call$2$specification$zoneValues", "call$0", "get$fork", 0, 5, 440, 0, 0, 198, [], 200, [], "fork"],
      run$1: [function(f) {
        if ($.Zone__current === C.C__RootZone)
          return f.call$0();
        return P._rootRun(null, null, this, f);
      }, "call$1", "get$run", 2, 0, function() {
        return {func: 1, args: [{func: 1}]};
      }, 9, [], "run"],
      runUnary$2: [function(f, arg) {
        if ($.Zone__current === C.C__RootZone)
          return f.call$1(arg);
        return P._rootRunUnary(null, null, this, f, arg);
      }, "call$2", "get$runUnary", 4, 0, function() {
        return {func: 1, args: [{func: 1, args: [,]},,]};
      }, 9, [], 68, [], "runUnary"],
      runBinary$3: [function(f, arg1, arg2) {
        if ($.Zone__current === C.C__RootZone)
          return f.call$2(arg1, arg2);
        return P._rootRunBinary(null, null, this, f, arg1, arg2);
      }, "call$3", "get$runBinary", 6, 0, function() {
        return {func: 1, args: [{func: 1, args: [,,]},,,]};
      }, 9, [], 91, [], 90, [], "runBinary"],
      registerCallback$1: [function(f) {
        return f;
      }, "call$1", "get$registerCallback", 2, 0, function() {
        return {func: 1, ret: {func: 1}, args: [{func: 1}]};
      }, 9, [], "registerCallback"],
      registerUnaryCallback$1: [function(f) {
        return f;
      }, "call$1", "get$registerUnaryCallback", 2, 0, function() {
        return {func: 1, ret: {func: 1, args: [,]}, args: [{func: 1, args: [,]}]};
      }, 9, [], "registerUnaryCallback"],
      registerBinaryCallback$1: [function(f) {
        return f;
      }, "call$1", "get$registerBinaryCallback", 2, 0, function() {
        return {func: 1, ret: {func: 1, args: [,,]}, args: [{func: 1, args: [,,]}]};
      }, 9, [], "registerBinaryCallback"],
      errorCallback$2: [function(error, stackTrace) {
        return;
      }, "call$2", "get$errorCallback", 4, 0, 441, 8, [], 12, [], "errorCallback"],
      scheduleMicrotask$1: [function(f) {
        P._rootScheduleMicrotask(null, null, this, f);
      }, "call$1", "get$scheduleMicrotask", 2, 0, 37, 9, [], "scheduleMicrotask"],
      createTimer$2: [function(duration, f) {
        return P.Timer__createTimer(duration, f);
      }, "call$2", "get$createTimer", 4, 0, 171, 59, [], 9, [], "createTimer"],
      createPeriodicTimer$2: [function(duration, f) {
        return P.Timer__createPeriodicTimer(duration, f);
      }, "call$2", "get$createPeriodicTimer", 4, 0, 204, 59, [], 9, [], "createPeriodicTimer"],
      print$1: [function(line) {
        H.printString(H.S(line));
      }, "call$1", "get$print", 2, 0, 19, 161, [], "print"],
      static: {
        "^": "_RootZone__rootMap@-122,_RootZone__rootDelegate@-235",
        _RootZone$: [function() {
          return new P._RootZone();
        }, null, null, 0, 0, 4, "new _RootZone"]
      }
    },
    "+_RootZone": [166],
    _RootZone_bindCallback_closure: {
      "^": "Closure:4;$this,f",
      call$0: [function() {
        return this.$this.runGuarded$1(this.f);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _RootZone_bindCallback_closure": [2],
    _RootZone_bindCallback_closure0: {
      "^": "Closure:4;$this,f",
      call$0: [function() {
        return this.$this.run$1(this.f);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _RootZone_bindCallback_closure": [2],
    _RootZone_bindUnaryCallback_closure: {
      "^": "Closure:3;$this,f",
      call$1: [function(arg) {
        return this.$this.runUnaryGuarded$2(this.f, arg);
      }, null, null, 2, 0, 3, 68, [], "call"]
    },
    "+ _RootZone_bindUnaryCallback_closure": [2],
    _RootZone_bindUnaryCallback_closure0: {
      "^": "Closure:3;$this,f",
      call$1: [function(arg) {
        return this.$this.runUnary$2(this.f, arg);
      }, null, null, 2, 0, 3, 68, [], "call"]
    },
    "+ _RootZone_bindUnaryCallback_closure": [2],
    _RootZone_bindBinaryCallback_closure: {
      "^": "Closure:12;$this,f",
      call$2: [function(arg1, arg2) {
        return this.$this.runBinaryGuarded$3(this.f, arg1, arg2);
      }, null, null, 4, 0, 12, 91, [], 90, [], "call"]
    },
    "+ _RootZone_bindBinaryCallback_closure": [2],
    _RootZone_bindBinaryCallback_closure0: {
      "^": "Closure:12;$this,f",
      call$2: [function(arg1, arg2) {
        return this.$this.runBinary$3(this.f, arg1, arg2);
      }, null, null, 4, 0, 12, 91, [], 90, [], "call"]
    },
    "+ _RootZone_bindBinaryCallback_closure": [2],
    runZoned_closure: {
      "^": "Closure:448;onError",
      call$5: [function($self, $parent, zone, error, stackTrace) {
        var e, s, t1, exception;
        try {
          t1 = this.onError;
          if (H.functionTypeTest(t1, {func: 1, args: [P.Object, P.StackTrace]})) {
            t1 = $self.get$parent().runBinary$3(t1, error, stackTrace);
            return t1;
          }
          t1 = $self.get$parent().runUnary$2(t1, error);
          return t1;
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          t1 = e;
          if (t1 == null ? error == null : t1 === error)
            return $parent.handleUncaughtError$3(zone, error, stackTrace);
          else
            return $parent.handleUncaughtError$3(zone, e, s);
        }
      }, null, null, 10, 0, 448, 72, [], 62, [], 34, [], 8, [], 12, [], "call"]
    },
    "+ runZoned_closure": [2],
    _WrappedAsyncBody: {
      "^": "",
      $typedefType: 1675,
      $$isTypedef: true
    },
    "+_WrappedAsyncBody": "",
    _FutureOnValue: {
      "^": "",
      $typedefType: 1676,
      $$isTypedef: true
    },
    "+_FutureOnValue": "",
    _FutureErrorTest: {
      "^": "",
      $typedefType: 15,
      $$isTypedef: true
    },
    "+_FutureErrorTest": "",
    _FutureAction: {
      "^": "",
      $typedefType: 4,
      $$isTypedef: true
    },
    "+_FutureAction": "",
    _AsyncCallback: {
      "^": "",
      $typedefType: 6,
      $$isTypedef: true
    },
    "+_AsyncCallback": "",
    _TimerCallback: {
      "^": "",
      $typedefType: 6,
      $$isTypedef: true
    },
    "+_TimerCallback": "",
    ControllerCallback: {
      "^": "",
      $typedefType: 6,
      $$isTypedef: true
    },
    "+ControllerCallback": "",
    ControllerCancelCallback: {
      "^": "",
      $typedefType: 4,
      $$isTypedef: true
    },
    "+ControllerCancelCallback": "",
    _NotificationHandler: {
      "^": "",
      $typedefType: 4,
      $$isTypedef: true
    },
    "+_NotificationHandler": "",
    _EventGenerator: {
      "^": "",
      $typedefType: 1677,
      $$isTypedef: true
    },
    "+_EventGenerator": "",
    _DataHandler: {
      "^": "",
      $typedefType: 1678,
      $$isTypedef: true
    },
    "+_DataHandler": "",
    _DoneHandler: {
      "^": "",
      $typedefType: 6,
      $$isTypedef: true
    },
    "+_DoneHandler": "",
    _BroadcastCallback: {
      "^": "",
      $typedefType: 1679,
      $$isTypedef: true
    },
    "+_BroadcastCallback": "",
    _ErrorCallback: {
      "^": "",
      $typedefType: 71,
      $$isTypedef: true
    },
    "+_ErrorCallback": "",
    _Predicate: {
      "^": "",
      $typedefType: 1680,
      $$isTypedef: true
    },
    "+_Predicate": "",
    _Transformation: {
      "^": "",
      $typedefType: 1681,
      $$isTypedef: true
    },
    "+_Transformation": "",
    _ErrorTest: {
      "^": "",
      $typedefType: 24,
      $$isTypedef: true
    },
    "+_ErrorTest": "",
    _Equality: {
      "^": "",
      $typedefType: 1682,
      $$isTypedef: true
    },
    "+_Equality": "",
    _SinkMapper: {
      "^": "",
      $typedefType: 1683,
      $$isTypedef: true
    },
    "+_SinkMapper": "",
    _TransformDataHandler: {
      "^": "",
      $typedefType: 1684,
      $$isTypedef: true
    },
    "+_TransformDataHandler": "",
    _TransformErrorHandler: {
      "^": "",
      $typedefType: 1685,
      $$isTypedef: true
    },
    "+_TransformErrorHandler": "",
    _TransformDoneHandler: {
      "^": "",
      $typedefType: 1686,
      $$isTypedef: true
    },
    "+_TransformDoneHandler": "",
    _SubscriptionTransformer: {
      "^": "",
      $typedefType: 1687,
      $$isTypedef: true
    },
    "+_SubscriptionTransformer": "",
    ZoneCallback: {
      "^": "",
      $typedefType: 1688,
      $$isTypedef: true
    },
    "+ZoneCallback": "",
    ZoneUnaryCallback: {
      "^": "",
      $typedefType: 1689,
      $$isTypedef: true
    },
    "+ZoneUnaryCallback": "",
    ZoneBinaryCallback: {
      "^": "",
      $typedefType: 1690,
      $$isTypedef: true
    },
    "+ZoneBinaryCallback": "",
    HandleUncaughtErrorHandler: {
      "^": "",
      $typedefType: 1691,
      $$isTypedef: true
    },
    "+HandleUncaughtErrorHandler": "",
    RunHandler: {
      "^": "",
      $typedefType: 1692,
      $$isTypedef: true
    },
    "+RunHandler": "",
    RunUnaryHandler: {
      "^": "",
      $typedefType: 1693,
      $$isTypedef: true
    },
    "+RunUnaryHandler": "",
    RunBinaryHandler: {
      "^": "",
      $typedefType: 1694,
      $$isTypedef: true
    },
    "+RunBinaryHandler": "",
    RegisterCallbackHandler: {
      "^": "",
      $typedefType: 1695,
      $$isTypedef: true
    },
    "+RegisterCallbackHandler": "",
    RegisterUnaryCallbackHandler: {
      "^": "",
      $typedefType: 1696,
      $$isTypedef: true
    },
    "+RegisterUnaryCallbackHandler": "",
    RegisterBinaryCallbackHandler: {
      "^": "",
      $typedefType: 1697,
      $$isTypedef: true
    },
    "+RegisterBinaryCallbackHandler": "",
    ErrorCallbackHandler: {
      "^": "",
      $typedefType: 387,
      $$isTypedef: true
    },
    "+ErrorCallbackHandler": "",
    ScheduleMicrotaskHandler: {
      "^": "",
      $typedefType: 1698,
      $$isTypedef: true
    },
    "+ScheduleMicrotaskHandler": "",
    CreateTimerHandler: {
      "^": "",
      $typedefType: 388,
      $$isTypedef: true
    },
    "+CreateTimerHandler": "",
    CreatePeriodicTimerHandler: {
      "^": "",
      $typedefType: 389,
      $$isTypedef: true
    },
    "+CreatePeriodicTimerHandler": "",
    PrintHandler: {
      "^": "",
      $typedefType: 390,
      $$isTypedef: true
    },
    "+PrintHandler": "",
    ForkHandler: {
      "^": "",
      $typedefType: 391,
      $$isTypedef: true
    },
    "+ForkHandler": ""
  }], ["dart.collection", "dart:collection",, P, {
    "^": "_toStringVisiting<-50",
    _defaultEquals: [function(a, b) {
      return J.$eq$(a, b);
    }, "call$2", "collection___defaultEquals$closure", 4, 0, 600, 87, [], 78, [], "_defaultEquals"],
    _defaultHashCode: [function(a) {
      return J.get$hashCode$(a);
    }, "call$1", "collection___defaultHashCode$closure", 2, 0, 601, 87, [], "_defaultHashCode"],
    _isToStringVisiting: [function(o) {
      var i, t1;
      for (i = 0; t1 = $.$get$_toStringVisiting(), i < t1.length; ++i) {
        t1 = t1[i];
        if (o == null ? t1 == null : o === t1)
          return true;
      }
      return false;
    }, "call$1", "collection___isToStringVisiting$closure", 2, 0, 15, 96, [], "_isToStringVisiting"],
    _iterablePartsToStrings: [function(iterable, parts) {
      var it, t1, $length, count, next, ultimateString, penultimateString, penultimate, ultimate, ultimate0, t2, elision;
      it = J.get$iterator$ax(iterable);
      t1 = J.getInterceptor$asx(parts);
      $length = 0;
      count = 0;
      while (true) {
        if (!($length < 80 || count < 3))
          break;
        if (!it.moveNext$0())
          return;
        next = H.S(it.get$current());
        t1.add$1(parts, next);
        $length += next.length + 2;
        ++count;
      }
      if (!it.moveNext$0()) {
        if (count <= 5)
          return;
        ultimateString = t1.removeLast$0(parts);
        penultimateString = t1.removeLast$0(parts);
      } else {
        penultimate = it.get$current();
        ++count;
        if (!it.moveNext$0()) {
          if (count <= 4) {
            t1.add$1(parts, H.S(penultimate));
            return;
          }
          ultimateString = H.S(penultimate);
          penultimateString = t1.removeLast$0(parts);
          $length += ultimateString.length + 2;
        } else {
          ultimate = it.get$current();
          ++count;
          for (; it.moveNext$0(); penultimate = ultimate, ultimate = ultimate0) {
            ultimate0 = it.get$current();
            ++count;
            if (count > 100) {
              while (true) {
                if (!($length > 75 && count > 3))
                  break;
                t2 = J.$add$ns(J.get$length$asx(t1.removeLast$0(parts)), 2);
                if (typeof t2 !== "number")
                  return H.iae(t2);
                $length -= t2;
                --count;
              }
              t1.add$1(parts, "...");
              return;
            }
          }
          penultimateString = H.S(penultimate);
          ultimateString = H.S(ultimate);
          $length += ultimateString.length + penultimateString.length + 4;
        }
      }
      t2 = J.$add$ns(t1.get$length(parts), 2);
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (count > t2) {
        $length += 5;
        elision = "...";
      } else
        elision = null;
      while (true) {
        if (!($length > 80 && J.$gt$n(t1.get$length(parts), 3)))
          break;
        t2 = J.$add$ns(J.get$length$asx(t1.removeLast$0(parts)), 2);
        if (typeof t2 !== "number")
          return H.iae(t2);
        $length -= t2;
        if (elision == null) {
          $length += 5;
          elision = "...";
        }
      }
      if (elision != null)
        t1.add$1(parts, elision);
      t1.add$1(parts, penultimateString);
      t1.add$1(parts, ultimateString);
    }, "call$2", "collection___iterablePartsToStrings$closure", 4, 0, 603, 42, [], 775, [], "_iterablePartsToStrings"],
    _HashMap: {
      "^": "Object;_collection$_length@,_collection$_strings,_collection$_nums,_collection$_rest,_keys@,$ti",
      get$length: [function(_) {
        return this._collection$_length;
      }, null, null, 1, 0, 11, "length"],
      get$isEmpty: [function(_) {
        return this._collection$_length === 0;
      }, null, null, 1, 0, 5, "isEmpty"],
      get$isNotEmpty: [function(_) {
        return this._collection$_length !== 0;
      }, null, null, 1, 0, 5, "isNotEmpty"],
      get$keys: [function() {
        return new P._HashMapKeyIterable(this, [H.getTypeArgumentByIndex(this, 0)]);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: [P.Iterable, K]};
        }, this.$receiver, "_HashMap");
      }, "keys"],
      get$values: [function() {
        var t1 = H.getTypeArgumentByIndex(this, 0);
        return H.MappedIterable_MappedIterable(new P._HashMapKeyIterable(this, [t1]), new P._HashMap_values_closure(this), t1, H.getTypeArgumentByIndex(this, 1));
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: [P.Iterable, V]};
        }, this.$receiver, "_HashMap");
      }, "values"],
      containsKey$1: [function(key) {
        var strings, nums;
        if (typeof key === "string" && key !== "__proto__") {
          strings = this._collection$_strings;
          return strings == null ? false : strings[key] != null;
        } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
          nums = this._collection$_nums;
          return nums == null ? false : nums[key] != null;
        } else
          return this._containsKey$1(key);
      }, "call$1", "get$containsKey", 2, 0, 15, 6, [], "containsKey"],
      _containsKey$1: ["super$_HashMap$_containsKey", function(key) {
        var rest = this._collection$_rest;
        if (rest == null)
          return false;
        return this._findBucketIndex$2(rest[this._computeHashCode$1(key)], key) >= 0;
      }],
      containsValue$1: [function(value) {
        var t1 = this._computeKeys$0();
        return (t1 && C.JSArray_methods).any$1(t1, new P._HashMap_containsValue_closure(this, value));
      }, "call$1", "get$containsValue", 2, 0, 15, 1, [], "containsValue"],
      addAll$1: [function(_, other) {
        J.forEach$1$ax(other, new P._HashMap_addAll_closure(this));
      }, "call$1", "get$addAll", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, v: true, args: [[P.Map, K, V]]};
        }, this.$receiver, "_HashMap");
      }, 2, [], "addAll"],
      $index: [function(_, key) {
        var strings, t1, entry, nums;
        if (typeof key === "string" && key !== "__proto__") {
          strings = this._collection$_strings;
          if (strings == null)
            t1 = null;
          else {
            entry = strings[key];
            t1 = entry === strings ? null : entry;
          }
          return t1;
        } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
          nums = this._collection$_nums;
          if (nums == null)
            t1 = null;
          else {
            entry = nums[key];
            t1 = entry === nums ? null : entry;
          }
          return t1;
        } else
          return this._get$1(key);
      }, null, "get$[]", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V, args: [P.Object]};
        }, this.$receiver, "_HashMap");
      }, 6, [], "[]"],
      _get$1: ["super$_HashMap$_get", function(key) {
        var rest, bucket, index;
        rest = this._collection$_rest;
        if (rest == null)
          return;
        bucket = rest[this._computeHashCode$1(key)];
        index = this._findBucketIndex$2(bucket, key);
        return index < 0 ? null : bucket[index + 1];
      }],
      $indexSet: [function(_, key, value) {
        var strings, table, nums;
        if (typeof key === "string" && key !== "__proto__") {
          strings = this._collection$_strings;
          if (strings == null) {
            table = Object.create(null);
            if (table == null)
              table["<non-identifier-key>"] = table;
            else
              table["<non-identifier-key>"] = table;
            delete table["<non-identifier-key>"];
            this._collection$_strings = table;
            strings = table;
          }
          if (strings[key] == null) {
            ++this._collection$_length;
            this._keys = null;
          }
          if (value == null)
            strings[key] = strings;
          else
            strings[key] = value;
        } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
          nums = this._collection$_nums;
          if (nums == null) {
            table = Object.create(null);
            if (table == null)
              table["<non-identifier-key>"] = table;
            else
              table["<non-identifier-key>"] = table;
            delete table["<non-identifier-key>"];
            this._collection$_nums = table;
            nums = table;
          }
          if (nums[key] == null) {
            ++this._collection$_length;
            this._keys = null;
          }
          if (value == null)
            nums[key] = nums;
          else
            nums[key] = value;
        } else
          this._set$2(key, value);
      }, null, "get$[]=", 4, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, v: true, args: [K, V]};
        }, this.$receiver, "_HashMap");
      }, 6, [], 1, [], "[]="],
      _set$2: ["super$_HashMap$_set", function(key, value) {
        var rest, hash, bucket, index;
        rest = this._collection$_rest;
        if (rest == null) {
          rest = P._HashMap__newHashTable();
          this._collection$_rest = rest;
        }
        hash = this._computeHashCode$1(key);
        bucket = rest[hash];
        if (bucket == null) {
          P._HashMap__setTableEntry(rest, hash, [key, value]);
          ++this._collection$_length;
          this._keys = null;
        } else {
          index = this._findBucketIndex$2(bucket, key);
          if (index >= 0)
            bucket[index + 1] = value;
          else {
            bucket.push(key, value);
            ++this._collection$_length;
            this._keys = null;
          }
        }
      }],
      putIfAbsent$2: [function(key, ifAbsent) {
        var value;
        if (this.containsKey$1(key))
          return this.$index(0, key);
        value = ifAbsent.call$0();
        this.$indexSet(0, key, value);
        return value;
      }, "call$2", "get$putIfAbsent", 4, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V, args: [K, {func: 1, ret: V}]};
        }, this.$receiver, "_HashMap");
      }, 6, [], 85, [], "putIfAbsent"],
      remove$1: [function(_, key) {
        if (typeof key === "string" && key !== "__proto__")
          return this._collection$_removeHashTableEntry$2(this._collection$_strings, key);
        else if (typeof key === "number" && (key & 0x3ffffff) === key)
          return this._collection$_removeHashTableEntry$2(this._collection$_nums, key);
        else
          return this._remove$1(key);
      }, "call$1", "get$remove", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V, args: [P.Object]};
        }, this.$receiver, "_HashMap");
      }, 6, [], "remove"],
      _remove$1: ["super$_HashMap$_remove", function(key) {
        var rest, bucket, index;
        rest = this._collection$_rest;
        if (rest == null)
          return;
        bucket = rest[this._computeHashCode$1(key)];
        index = this._findBucketIndex$2(bucket, key);
        if (index < 0)
          return;
        --this._collection$_length;
        this._keys = null;
        return bucket.splice(index, 2)[1];
      }],
      clear$0: [function(_) {
        if (this._collection$_length > 0) {
          this._keys = null;
          this._collection$_rest = null;
          this._collection$_nums = null;
          this._collection$_strings = null;
          this._collection$_length = 0;
        }
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      forEach$1: [function(_, action) {
        var keys, $length, i, key;
        keys = this._computeKeys$0();
        for ($length = keys.length, i = 0; i < $length; ++i) {
          key = keys[i];
          action.call$2(key, this.$index(0, key));
          if (keys !== this._keys)
            throw H.wrapException(new P.ConcurrentModificationError(this));
        }
      }, "call$1", "get$forEach", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, v: true, args: [{func: 1, v: true, args: [K, V]}]};
        }, this.$receiver, "_HashMap");
      }, 71, [], "forEach"],
      _computeKeys$0: function() {
        var t1, result, strings, names, entries, index, i, nums, rest, bucket, $length, i0;
        t1 = this._keys;
        if (t1 != null)
          return t1;
        result = new Array(this._collection$_length);
        result.fixed$length = Array;
        strings = this._collection$_strings;
        if (strings != null) {
          names = Object.getOwnPropertyNames(strings);
          entries = names.length;
          for (index = 0, i = 0; i < entries; ++i) {
            result[index] = names[i];
            ++index;
          }
        } else
          index = 0;
        nums = this._collection$_nums;
        if (nums != null) {
          names = Object.getOwnPropertyNames(nums);
          entries = names.length;
          for (i = 0; i < entries; ++i) {
            result[index] = +names[i];
            ++index;
          }
        }
        rest = this._collection$_rest;
        if (rest != null) {
          names = Object.getOwnPropertyNames(rest);
          entries = names.length;
          for (i = 0; i < entries; ++i) {
            bucket = rest[names[i]];
            $length = bucket.length;
            for (i0 = 0; i0 < $length; i0 += 2) {
              result[index] = bucket[i0];
              ++index;
            }
          }
        }
        this._keys = result;
        return result;
      },
      _collection$_removeHashTableEntry$2: function(table, key) {
        var value;
        if (table != null && table[key] != null) {
          value = P._HashMap__getTableEntry(table, key);
          delete table[key];
          --this._collection$_length;
          this._keys = null;
          return value;
        } else
          return;
      },
      _computeHashCode$1: function(key) {
        return J.get$hashCode$(key) & 0x3ffffff;
      },
      _findBucketIndex$2: function(bucket, key) {
        var $length, i;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (i = 0; i < $length; i += 2)
          if (J.$eq$(bucket[i], key))
            return i;
        return -1;
      },
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $isMap: 1,
      static: {
        _HashMap__getTableEntry: function(table, key) {
          var entry = table[key];
          return entry === table ? null : entry;
        },
        _HashMap__setTableEntry: function(table, key, value) {
          if (value == null)
            table[key] = table;
          else
            table[key] = value;
        },
        _HashMap__newHashTable: function() {
          var table = Object.create(null);
          P._HashMap__setTableEntry(table, "<non-identifier-key>", table);
          delete table["<non-identifier-key>"];
          return table;
        }
      }
    },
    "+_HashMap": 0,
    _HashMap_values_closure: {
      "^": "Closure:3;$this",
      call$1: [function(each) {
        return this.$this.$index(0, each);
      }, null, null, 2, 0, null, 186, [], "call"]
    },
    "+ _HashMap_values_closure": 0,
    _HashMap_containsValue_closure: {
      "^": "Closure:3;$this,value",
      call$1: [function(each) {
        return J.$eq$(this.$this.$index(0, each), this.value);
      }, null, null, 2, 0, null, 186, [], "call"]
    },
    "+ _HashMap_containsValue_closure": 0,
    _HashMap_addAll_closure: {
      "^": "Closure;$this",
      call$2: [function(key, value) {
        this.$this.$indexSet(0, key, value);
      }, null, null, 4, 0, null, 6, [], 1, [], "call"],
      $signature: function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, args: [K, V]};
        }, this.$this, "_HashMap");
      }
    },
    "+ _HashMap_addAll_closure": 0,
    _IdentityHashMap: {
      "^": "_HashMap;_collection$_length,_collection$_strings,_collection$_nums,_collection$_rest,_keys,$ti",
      _computeHashCode$1: function(key) {
        return H.objectHashCode(key) & 0x3ffffff;
      },
      _findBucketIndex$2: function(bucket, key) {
        var $length, i, t1;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (i = 0; i < $length; i += 2) {
          t1 = bucket[i];
          if (t1 == null ? key == null : t1 === key)
            return i;
        }
        return -1;
      }
    },
    "+_IdentityHashMap": 0,
    _CustomHashMap: {
      "^": "_HashMap;_equals,_hashCode,_validKey<,_collection$_length,_collection$_strings,_collection$_nums,_collection$_rest,_keys,$ti",
      $index: [function(_, key) {
        if (this._validKey.call$1(key) !== true)
          return;
        return this.super$_HashMap$_get(key);
      }, null, "get$[]", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V, args: [P.Object]};
        }, this.$receiver, "_CustomHashMap");
      }, 6, [], "[]"],
      $indexSet: [function(_, key, value) {
        this.super$_HashMap$_set(key, value);
      }, null, "get$[]=", 4, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, v: true, args: [K, V]};
        }, this.$receiver, "_CustomHashMap");
      }, 6, [], 1, [], "[]="],
      containsKey$1: [function(key) {
        if (this._validKey.call$1(key) !== true)
          return false;
        return this.super$_HashMap$_containsKey(key);
      }, "call$1", "get$containsKey", 2, 0, 15, 6, [], "containsKey"],
      remove$1: [function(_, key) {
        if (this._validKey.call$1(key) !== true)
          return;
        return this.super$_HashMap$_remove(key);
      }, "call$1", "get$remove", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V, args: [P.Object]};
        }, this.$receiver, "_CustomHashMap");
      }, 6, [], "remove"],
      _computeHashCode$1: function(key) {
        return this._hashCode.call$1(key) & 0x3ffffff;
      },
      _findBucketIndex$2: function(bucket, key) {
        var $length, t1, i;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (t1 = this._equals, i = 0; i < $length; i += 2)
          if (t1.call$2(bucket[i], key) === true)
            return i;
        return -1;
      },
      toString$0: [function(_) {
        return P.Maps_mapToString(this);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        _CustomHashMap$: function(_equals, _hashCode, validKey, $K, $V) {
          var t1 = validKey != null ? validKey : new P._CustomHashMap_closure($K);
          return new P._CustomHashMap(_equals, _hashCode, t1, 0, null, null, null, null, [$K, $V]);
        }
      }
    },
    "+_CustomHashMap": 0,
    _CustomHashMap_closure: {
      "^": "Closure:3;K",
      call$1: [function(v) {
        return H.checkSubtypeOfRuntimeType(v, this.K);
      }, null, null, 2, 0, null, 56, [], "call"]
    },
    "+ _CustomHashMap_closure": 0,
    _HashMapKeyIterable: {
      "^": "EfficientLengthIterable;_collection$_map<,$ti",
      get$length: [function(_) {
        return this._collection$_map._collection$_length;
      }, null, null, 1, 0, 11, "length"],
      get$isEmpty: [function(_) {
        return this._collection$_map._collection$_length === 0;
      }, null, null, 1, 0, 5, "isEmpty"],
      get$iterator: [function(_) {
        var t1 = this._collection$_map;
        return new P._HashMapKeyIterator(t1, t1._computeKeys$0(), 0, null, this.$ti);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterator, E]};
        }, this.$receiver, "_HashMapKeyIterable");
      }, "iterator"],
      contains$1: [function(_, element) {
        return this._collection$_map.containsKey$1(element);
      }, "call$1", "get$contains", 2, 0, 15, 31, [], "contains"],
      forEach$1: [function(_, f) {
        var t1, keys, $length, i;
        t1 = this._collection$_map;
        keys = t1._computeKeys$0();
        for ($length = keys.length, i = 0; i < $length; ++i) {
          f.call$1(keys[i]);
          if (keys !== t1._keys)
            throw H.wrapException(new P.ConcurrentModificationError(t1));
        }
      }, "call$1", "get$forEach", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, v: true, args: [E]}]};
        }, this.$receiver, "_HashMapKeyIterable");
      }, 9, [], "forEach"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      }
    },
    "+_HashMapKeyIterable": 0,
    _HashMapKeyIterator: {
      "^": "Object;_collection$_map<,_keys<,_offset,_collection$_current@,$ti",
      get$current: [function() {
        return this._collection$_current;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "_HashMapKeyIterator");
      }, "current"],
      moveNext$0: [function() {
        var keys, offset, t1;
        keys = this._keys;
        offset = this._offset;
        t1 = this._collection$_map;
        if (keys !== t1._keys)
          throw H.wrapException(new P.ConcurrentModificationError(t1));
        else if (offset >= keys.length) {
          this._collection$_current = null;
          return false;
        } else {
          this._collection$_current = keys[offset];
          this._offset = offset + 1;
          return true;
        }
      }, "call$0", "get$moveNext", 0, 0, 5, "moveNext"]
    },
    "+_HashMapKeyIterator": 0,
    _LinkedIdentityHashMap: {
      "^": "JsLinkedHashMap;_length,_strings,_nums,_rest,_first,_last,_modifications,$ti",
      internalComputeHashCode$1: function(key) {
        return H.objectHashCode(key) & 0x3ffffff;
      },
      internalFindBucketIndex$2: function(bucket, key) {
        var $length, i, t1;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (i = 0; i < $length; ++i) {
          t1 = bucket[i].get$hashMapCellKey();
          if (t1 == null ? key == null : t1 === key)
            return i;
        }
        return -1;
      },
      static: {
        _LinkedIdentityHashMap__LinkedIdentityHashMap$es6: function($K, $V) {
          return new P._LinkedIdentityHashMap(0, null, null, null, null, null, 0, [$K, $V]);
        }
      }
    },
    "+_LinkedIdentityHashMap": 0,
    _LinkedCustomHashMap: {
      "^": "JsLinkedHashMap;_equals,_hashCode,_validKey<,_length,_strings,_nums,_rest,_first,_last,_modifications,$ti",
      $index: [function(_, key) {
        if (this._validKey.call$1(key) !== true)
          return;
        return this.super$JsLinkedHashMap$internalGet(key);
      }, null, "get$[]", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V, args: [P.Object]};
        }, this.$receiver, "_LinkedCustomHashMap");
      }, 6, [], "[]"],
      $indexSet: [function(_, key, value) {
        this.super$JsLinkedHashMap$internalSet(key, value);
      }, null, "get$[]=", 4, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, v: true, args: [K, V]};
        }, this.$receiver, "_LinkedCustomHashMap");
      }, 6, [], 1, [], "[]="],
      containsKey$1: [function(key) {
        if (this._validKey.call$1(key) !== true)
          return false;
        return this.super$JsLinkedHashMap$internalContainsKey(key);
      }, "call$1", "get$containsKey", 2, 0, 15, 6, [], "containsKey"],
      remove$1: [function(_, key) {
        if (this._validKey.call$1(key) !== true)
          return;
        return this.super$JsLinkedHashMap$internalRemove(key);
      }, "call$1", "get$remove", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V, args: [P.Object]};
        }, this.$receiver, "_LinkedCustomHashMap");
      }, 6, [], "remove"],
      internalComputeHashCode$1: function(key) {
        return this._hashCode.call$1(key) & 0x3ffffff;
      },
      internalFindBucketIndex$2: function(bucket, key) {
        var $length, t1, i;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (t1 = this._equals, i = 0; i < $length; ++i)
          if (t1.call$2(bucket[i].get$hashMapCellKey(), key) === true)
            return i;
        return -1;
      },
      static: {
        _LinkedCustomHashMap$: function(_equals, _hashCode, validKey, $K, $V) {
          var t1 = validKey != null ? validKey : new P._LinkedCustomHashMap_closure($K);
          return new P._LinkedCustomHashMap(_equals, _hashCode, t1, 0, null, null, null, null, null, 0, [$K, $V]);
        }
      }
    },
    "+_LinkedCustomHashMap": 0,
    _LinkedCustomHashMap_closure: {
      "^": "Closure:3;K",
      call$1: [function(v) {
        return H.checkSubtypeOfRuntimeType(v, this.K);
      }, null, null, 2, 0, null, 56, [], "call"]
    },
    "+ _LinkedCustomHashMap_closure": 0,
    _HashSet: {
      "^": "_HashSetBase;_collection$_length@,_collection$_strings,_collection$_nums,_collection$_rest,_elements,$ti",
      _newSet$0: [function() {
        return new P._HashSet(0, null, null, null, null, this.$ti);
      }, "call$0", "get$_newSet", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Set, E]};
        }, this.$receiver, "_HashSet");
      }, "_newSet"],
      get$iterator: [function(_) {
        return new P._HashSetIterator(this, this._computeElements$0(), 0, null, this.$ti);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterator, E]};
        }, this.$receiver, "_HashSet");
      }, "iterator"],
      get$length: [function(_) {
        return this._collection$_length;
      }, null, null, 1, 0, 11, "length"],
      get$isEmpty: [function(_) {
        return this._collection$_length === 0;
      }, null, null, 1, 0, 5, "isEmpty"],
      get$isNotEmpty: [function(_) {
        return this._collection$_length !== 0;
      }, null, null, 1, 0, 5, "isNotEmpty"],
      contains$1: [function(_, object) {
        var strings, nums;
        if (typeof object === "string" && object !== "__proto__") {
          strings = this._collection$_strings;
          return strings == null ? false : strings[object] != null;
        } else if (typeof object === "number" && (object & 0x3ffffff) === object) {
          nums = this._collection$_nums;
          return nums == null ? false : nums[object] != null;
        } else
          return this._contains$1(object);
      }, "call$1", "get$contains", 2, 0, 15, 23, [], "contains"],
      _contains$1: ["super$_HashSet$_contains", function(object) {
        var rest = this._collection$_rest;
        if (rest == null)
          return false;
        return this._findBucketIndex$2(rest[this._computeHashCode$1(object)], object) >= 0;
      }],
      lookup$1: [function(object) {
        var t1;
        if (!(typeof object === "string" && object !== "__proto__"))
          t1 = typeof object === "number" && (object & 0x3ffffff) === object;
        else
          t1 = true;
        if (t1)
          return this.contains$1(0, object) ? object : null;
        return this._lookup$1(object);
      }, "call$1", "get$lookup", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [P.Object]};
        }, this.$receiver, "_HashSet");
      }, 23, [], "lookup"],
      _lookup$1: ["super$_HashSet$_lookup", function(object) {
        var rest, bucket, index;
        rest = this._collection$_rest;
        if (rest == null)
          return;
        bucket = rest[this._computeHashCode$1(object)];
        index = this._findBucketIndex$2(bucket, object);
        if (index < 0)
          return;
        return J.$index$asx(bucket, index);
      }],
      add$1: [function(_, element) {
        var strings, table, nums;
        if (typeof element === "string" && element !== "__proto__") {
          strings = this._collection$_strings;
          if (strings == null) {
            table = Object.create(null);
            table["<non-identifier-key>"] = table;
            delete table["<non-identifier-key>"];
            this._collection$_strings = table;
            strings = table;
          }
          return this._addHashTableEntry$2(strings, element);
        } else if (typeof element === "number" && (element & 0x3ffffff) === element) {
          nums = this._collection$_nums;
          if (nums == null) {
            table = Object.create(null);
            table["<non-identifier-key>"] = table;
            delete table["<non-identifier-key>"];
            this._collection$_nums = table;
            nums = table;
          }
          return this._addHashTableEntry$2(nums, element);
        } else
          return this._add$1(element);
      }, "call$1", "get$add", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.bool, args: [E]};
        }, this.$receiver, "_HashSet");
      }, 31, [], "add"],
      _add$1: ["super$_HashSet$_add", function(element) {
        var rest, hash, bucket;
        rest = this._collection$_rest;
        if (rest == null) {
          rest = P._HashSet__newHashTable();
          this._collection$_rest = rest;
        }
        hash = this._computeHashCode$1(element);
        bucket = rest[hash];
        if (bucket == null)
          rest[hash] = [element];
        else {
          if (this._findBucketIndex$2(bucket, element) >= 0)
            return false;
          bucket.push(element);
        }
        ++this._collection$_length;
        this._elements = null;
        return true;
      }],
      addAll$1: [function(_, objects) {
        var t1;
        for (t1 = J.get$iterator$ax(objects); t1.moveNext$0();)
          this.add$1(0, t1.get$current());
      }, "call$1", "get$addAll", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [[P.Iterable, E]]};
        }, this.$receiver, "_HashSet");
      }, 119, [], "addAll"],
      remove$1: [function(_, object) {
        if (typeof object === "string" && object !== "__proto__")
          return this._collection$_removeHashTableEntry$2(this._collection$_strings, object);
        else if (typeof object === "number" && (object & 0x3ffffff) === object)
          return this._collection$_removeHashTableEntry$2(this._collection$_nums, object);
        else
          return this._remove$1(object);
      }, "call$1", "get$remove", 2, 0, 15, 23, [], "remove"],
      _remove$1: ["super$_HashSet$_remove", function(object) {
        var rest, bucket, index;
        rest = this._collection$_rest;
        if (rest == null)
          return false;
        bucket = rest[this._computeHashCode$1(object)];
        index = this._findBucketIndex$2(bucket, object);
        if (index < 0)
          return false;
        --this._collection$_length;
        this._elements = null;
        bucket.splice(index, 1);
        return true;
      }],
      clear$0: [function(_) {
        if (this._collection$_length > 0) {
          this._elements = null;
          this._collection$_rest = null;
          this._collection$_nums = null;
          this._collection$_strings = null;
          this._collection$_length = 0;
        }
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      _computeElements$0: function() {
        var t1, result, strings, names, entries, index, i, nums, rest, bucket, $length, i0;
        t1 = this._elements;
        if (t1 != null)
          return t1;
        result = new Array(this._collection$_length);
        result.fixed$length = Array;
        strings = this._collection$_strings;
        if (strings != null) {
          names = Object.getOwnPropertyNames(strings);
          entries = names.length;
          for (index = 0, i = 0; i < entries; ++i) {
            result[index] = names[i];
            ++index;
          }
        } else
          index = 0;
        nums = this._collection$_nums;
        if (nums != null) {
          names = Object.getOwnPropertyNames(nums);
          entries = names.length;
          for (i = 0; i < entries; ++i) {
            result[index] = +names[i];
            ++index;
          }
        }
        rest = this._collection$_rest;
        if (rest != null) {
          names = Object.getOwnPropertyNames(rest);
          entries = names.length;
          for (i = 0; i < entries; ++i) {
            bucket = rest[names[i]];
            $length = bucket.length;
            for (i0 = 0; i0 < $length; ++i0) {
              result[index] = bucket[i0];
              ++index;
            }
          }
        }
        this._elements = result;
        return result;
      },
      _addHashTableEntry$2: function(table, element) {
        if (table[element] != null)
          return false;
        table[element] = 0;
        ++this._collection$_length;
        this._elements = null;
        return true;
      },
      _collection$_removeHashTableEntry$2: function(table, element) {
        if (table != null && table[element] != null) {
          delete table[element];
          --this._collection$_length;
          this._elements = null;
          return true;
        } else
          return false;
      },
      _computeHashCode$1: function(element) {
        return J.get$hashCode$(element) & 0x3ffffff;
      },
      _findBucketIndex$2: function(bucket, element) {
        var $length, i;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (i = 0; i < $length; ++i)
          if (J.$eq$(bucket[i], element))
            return i;
        return -1;
      },
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $isSet: 1,
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: null,
      $isIterable: 1,
      $asIterable: null,
      static: {
        _HashSet__newHashTable: function() {
          var table = Object.create(null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          return table;
        }
      }
    },
    "+_HashSet": 0,
    _IdentityHashSet: {
      "^": "_HashSet;_collection$_length,_collection$_strings,_collection$_nums,_collection$_rest,_elements,$ti",
      _newSet$0: [function() {
        return new P._IdentityHashSet(0, null, null, null, null, this.$ti);
      }, "call$0", "get$_newSet", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Set, E]};
        }, this.$receiver, "_IdentityHashSet");
      }, "_newSet"],
      _computeHashCode$1: function(key) {
        return H.objectHashCode(key) & 0x3ffffff;
      },
      _findBucketIndex$2: function(bucket, element) {
        var $length, i, t1;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (i = 0; i < $length; ++i) {
          t1 = bucket[i];
          if (t1 == null ? element == null : t1 === element)
            return i;
        }
        return -1;
      }
    },
    "+_IdentityHashSet": 0,
    _CustomHashSet: {
      "^": "_HashSet;_equality,_hasher,_validKey@,_collection$_length,_collection$_strings,_collection$_nums,_collection$_rest,_elements,$ti",
      _newSet$0: [function() {
        return P._CustomHashSet$(this._equality, this._hasher, this._validKey, H.getTypeArgumentByIndex(this, 0));
      }, "call$0", "get$_newSet", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Set, E]};
        }, this.$receiver, "_CustomHashSet");
      }, "_newSet"],
      _findBucketIndex$2: function(bucket, element) {
        var $length, i, t1;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (i = 0; i < $length; ++i) {
          t1 = bucket[i];
          if (this._equality.call$2(t1, element) === true)
            return i;
        }
        return -1;
      },
      _computeHashCode$1: function(element) {
        return this._hasher.call$1(element) & 0x3ffffff;
      },
      add$1: [function(_, object) {
        return this.super$_HashSet$_add(object);
      }, "call$1", "get$add", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.bool, args: [E]};
        }, this.$receiver, "_CustomHashSet");
      }, 23, [], "add"],
      contains$1: [function(_, object) {
        if (this._validKey.call$1(object) !== true)
          return false;
        return this.super$_HashSet$_contains(object);
      }, "call$1", "get$contains", 2, 0, 15, 23, [], "contains"],
      lookup$1: [function(object) {
        if (this._validKey.call$1(object) !== true)
          return;
        return this.super$_HashSet$_lookup(object);
      }, "call$1", "get$lookup", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [P.Object]};
        }, this.$receiver, "_CustomHashSet");
      }, 23, [], "lookup"],
      remove$1: [function(_, object) {
        if (this._validKey.call$1(object) !== true)
          return false;
        return this.super$_HashSet$_remove(object);
      }, "call$1", "get$remove", 2, 0, 15, 23, [], "remove"],
      static: {
        _CustomHashSet$: function(_equality, _hasher, validKey, $E) {
          var t1 = validKey != null ? validKey : new P._CustomHashSet_closure($E);
          return new P._CustomHashSet(_equality, _hasher, t1, 0, null, null, null, null, [$E]);
        }
      }
    },
    "+_CustomHashSet": 0,
    _CustomHashSet_closure: {
      "^": "Closure:3;E",
      call$1: [function(x) {
        return H.checkSubtypeOfRuntimeType(x, this.E);
      }, null, null, 2, 0, null, 38, [], "call"]
    },
    "+ _CustomHashSet_closure": 0,
    _HashSetIterator: {
      "^": "Object;_set,_elements,_offset,_collection$_current@,$ti",
      get$current: [function() {
        return this._collection$_current;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "_HashSetIterator");
      }, "current"],
      moveNext$0: [function() {
        var elements, offset, t1;
        elements = this._elements;
        offset = this._offset;
        t1 = this._set;
        if (elements !== t1._elements)
          throw H.wrapException(new P.ConcurrentModificationError(t1));
        else if (offset >= elements.length) {
          this._collection$_current = null;
          return false;
        } else {
          this._collection$_current = elements[offset];
          this._offset = offset + 1;
          return true;
        }
      }, "call$0", "get$moveNext", 0, 0, 5, "moveNext"]
    },
    "+_HashSetIterator": 0,
    _LinkedHashSet: {
      "^": "_HashSetBase;_collection$_length@,_collection$_strings,_collection$_nums,_collection$_rest,_collection$_first@,_collection$_last<,_collection$_modifications,$ti",
      _newSet$0: [function() {
        return new P._LinkedHashSet(0, null, null, null, null, null, 0, this.$ti);
      }, "call$0", "get$_newSet", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Set, E]};
        }, this.$receiver, "_LinkedHashSet");
      }, "_newSet"],
      get$iterator: [function(_) {
        var t1 = new P._LinkedHashSetIterator(this, this._collection$_modifications, null, null, [null]);
        t1._collection$_cell = this._collection$_first;
        return t1;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterator, E]};
        }, this.$receiver, "_LinkedHashSet");
      }, "iterator"],
      get$length: [function(_) {
        return this._collection$_length;
      }, null, null, 1, 0, 11, "length"],
      get$isEmpty: [function(_) {
        return this._collection$_length === 0;
      }, null, null, 1, 0, 5, "isEmpty"],
      get$isNotEmpty: [function(_) {
        return this._collection$_length !== 0;
      }, null, null, 1, 0, 5, "isNotEmpty"],
      contains$1: [function(_, object) {
        var strings, nums;
        if (typeof object === "string" && object !== "__proto__") {
          strings = this._collection$_strings;
          if (strings == null)
            return false;
          return strings[object] != null;
        } else if (typeof object === "number" && (object & 0x3ffffff) === object) {
          nums = this._collection$_nums;
          if (nums == null)
            return false;
          return nums[object] != null;
        } else
          return this._contains$1(object);
      }, "call$1", "get$contains", 2, 0, 15, 23, [], "contains"],
      _contains$1: ["super$_LinkedHashSet$_contains", function(object) {
        var rest = this._collection$_rest;
        if (rest == null)
          return false;
        return this._findBucketIndex$2(rest[this._computeHashCode$1(object)], object) >= 0;
      }],
      lookup$1: [function(object) {
        var t1;
        if (!(typeof object === "string" && object !== "__proto__"))
          t1 = typeof object === "number" && (object & 0x3ffffff) === object;
        else
          t1 = true;
        if (t1)
          return this.contains$1(0, object) ? object : null;
        else
          return this._lookup$1(object);
      }, "call$1", "get$lookup", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [P.Object]};
        }, this.$receiver, "_LinkedHashSet");
      }, 23, [], "lookup"],
      _lookup$1: ["super$_LinkedHashSet$_lookup", function(object) {
        var rest, bucket, index;
        rest = this._collection$_rest;
        if (rest == null)
          return;
        bucket = rest[this._computeHashCode$1(object)];
        index = this._findBucketIndex$2(bucket, object);
        if (index < 0)
          return;
        return J.$index$asx(bucket, index).get$_element();
      }],
      forEach$1: [function(_, action) {
        var cell, modifications;
        cell = this._collection$_first;
        modifications = this._collection$_modifications;
        for (; cell != null;) {
          action.call$1(cell.get$_element());
          if (modifications !== this._collection$_modifications)
            throw H.wrapException(new P.ConcurrentModificationError(this));
          cell = cell.get$_collection$_next();
        }
      }, "call$1", "get$forEach", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, v: true, args: [E]}]};
        }, this.$receiver, "_LinkedHashSet");
      }, 71, [], "forEach"],
      get$first: [function(_) {
        var t1 = this._collection$_first;
        if (t1 == null)
          throw H.wrapException(new P.StateError("No elements"));
        return t1.get$_element();
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "_LinkedHashSet");
      }, "first"],
      get$last: [function(_) {
        var t1 = this._collection$_last;
        if (t1 == null)
          throw H.wrapException(new P.StateError("No elements"));
        return t1.get$_element();
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "_LinkedHashSet");
      }, "last"],
      add$1: [function(_, element) {
        var strings, table, nums;
        if (typeof element === "string" && element !== "__proto__") {
          strings = this._collection$_strings;
          if (strings == null) {
            table = Object.create(null);
            table["<non-identifier-key>"] = table;
            delete table["<non-identifier-key>"];
            this._collection$_strings = table;
            strings = table;
          }
          return this._addHashTableEntry$2(strings, element);
        } else if (typeof element === "number" && (element & 0x3ffffff) === element) {
          nums = this._collection$_nums;
          if (nums == null) {
            table = Object.create(null);
            table["<non-identifier-key>"] = table;
            delete table["<non-identifier-key>"];
            this._collection$_nums = table;
            nums = table;
          }
          return this._addHashTableEntry$2(nums, element);
        } else
          return this._add$1(element);
      }, "call$1", "get$add", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.bool, args: [E]};
        }, this.$receiver, "_LinkedHashSet");
      }, 31, [], "add"],
      _add$1: ["super$_LinkedHashSet$_add", function(element) {
        var rest, hash, bucket;
        rest = this._collection$_rest;
        if (rest == null) {
          rest = P._LinkedHashSet__newHashTable();
          this._collection$_rest = rest;
        }
        hash = this._computeHashCode$1(element);
        bucket = rest[hash];
        if (bucket == null)
          rest[hash] = [this._collection$_newLinkedCell$1(element)];
        else {
          if (this._findBucketIndex$2(bucket, element) >= 0)
            return false;
          bucket.push(this._collection$_newLinkedCell$1(element));
        }
        return true;
      }],
      remove$1: [function(_, object) {
        if (typeof object === "string" && object !== "__proto__")
          return this._collection$_removeHashTableEntry$2(this._collection$_strings, object);
        else if (typeof object === "number" && (object & 0x3ffffff) === object)
          return this._collection$_removeHashTableEntry$2(this._collection$_nums, object);
        else
          return this._remove$1(object);
      }, "call$1", "get$remove", 2, 0, 15, 23, [], "remove"],
      _remove$1: ["super$_LinkedHashSet$_remove", function(object) {
        var rest, bucket, index;
        rest = this._collection$_rest;
        if (rest == null)
          return false;
        bucket = rest[this._computeHashCode$1(object)];
        index = this._findBucketIndex$2(bucket, object);
        if (index < 0)
          return false;
        this._collection$_unlinkCell$1(bucket.splice(index, 1)[0]);
        return true;
      }],
      removeWhere$1: [function(_, test) {
        this._filterWhere$2(test, true);
      }, "call$1", "get$removeWhere", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "_LinkedHashSet");
      }, 11, [], "removeWhere"],
      retainWhere$1: [function(_, test) {
        this._filterWhere$2(test, false);
      }, "call$1", "get$retainWhere", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "_LinkedHashSet");
      }, 11, [], "retainWhere"],
      _filterWhere$2: function(test, removeMatching) {
        var cell, element, next, modifications, t1;
        cell = this._collection$_first;
        for (; cell != null; cell = next) {
          element = cell.get$_element();
          next = cell.get$_collection$_next();
          modifications = this._collection$_modifications;
          t1 = test.call$1(element);
          if (modifications !== this._collection$_modifications)
            throw H.wrapException(new P.ConcurrentModificationError(this));
          if (removeMatching === t1)
            this.remove$1(0, element);
        }
      },
      clear$0: [function(_) {
        if (this._collection$_length > 0) {
          this._collection$_last = null;
          this._collection$_first = null;
          this._collection$_rest = null;
          this._collection$_nums = null;
          this._collection$_strings = null;
          this._collection$_length = 0;
          this._collection$_modifications = this._collection$_modifications + 1 & 67108863;
        }
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      _addHashTableEntry$2: function(table, element) {
        if (table[element] != null)
          return false;
        table[element] = this._collection$_newLinkedCell$1(element);
        return true;
      },
      _collection$_removeHashTableEntry$2: function(table, element) {
        var cell;
        if (table == null)
          return false;
        cell = table[element];
        if (cell == null)
          return false;
        this._collection$_unlinkCell$1(cell);
        delete table[element];
        return true;
      },
      _collection$_newLinkedCell$1: function(element) {
        var cell, last;
        cell = new P._LinkedHashSetCell(element, null, null);
        if (this._collection$_first == null) {
          this._collection$_last = cell;
          this._collection$_first = cell;
        } else {
          last = this._collection$_last;
          cell._collection$_previous = last;
          last.set$_collection$_next(cell);
          this._collection$_last = cell;
        }
        ++this._collection$_length;
        this._collection$_modifications = this._collection$_modifications + 1 & 67108863;
        return cell;
      },
      _collection$_unlinkCell$1: function(cell) {
        var previous, next;
        previous = cell.get$_collection$_previous();
        next = cell.get$_collection$_next();
        if (previous == null)
          this._collection$_first = next;
        else
          previous.set$_collection$_next(next);
        if (next == null)
          this._collection$_last = previous;
        else
          next.set$_collection$_previous(previous);
        --this._collection$_length;
        this._collection$_modifications = this._collection$_modifications + 1 & 67108863;
      },
      _computeHashCode$1: function(element) {
        return J.get$hashCode$(element) & 0x3ffffff;
      },
      _findBucketIndex$2: function(bucket, element) {
        var $length, i;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (i = 0; i < $length; ++i)
          if (J.$eq$(bucket[i].get$_element(), element))
            return i;
        return -1;
      },
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $isSet: 1,
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: null,
      $isIterable: 1,
      $asIterable: null,
      static: {
        _LinkedHashSet__newHashTable: function() {
          var table = Object.create(null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          return table;
        }
      }
    },
    "+_LinkedHashSet": 0,
    _LinkedIdentityHashSet: {
      "^": "_LinkedHashSet;_collection$_length,_collection$_strings,_collection$_nums,_collection$_rest,_collection$_first,_collection$_last,_collection$_modifications,$ti",
      _newSet$0: [function() {
        return new P._LinkedIdentityHashSet(0, null, null, null, null, null, 0, this.$ti);
      }, "call$0", "get$_newSet", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Set, E]};
        }, this.$receiver, "_LinkedIdentityHashSet");
      }, "_newSet"],
      _computeHashCode$1: function(key) {
        return H.objectHashCode(key) & 0x3ffffff;
      },
      _findBucketIndex$2: function(bucket, element) {
        var $length, i, t1;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (i = 0; i < $length; ++i) {
          t1 = bucket[i].get$_element();
          if (t1 == null ? element == null : t1 === element)
            return i;
        }
        return -1;
      }
    },
    "+_LinkedIdentityHashSet": 0,
    _LinkedCustomHashSet: {
      "^": "_LinkedHashSet;_equality,_hasher,_validKey@,_collection$_length,_collection$_strings,_collection$_nums,_collection$_rest,_collection$_first,_collection$_last,_collection$_modifications,$ti",
      _newSet$0: [function() {
        return P._LinkedCustomHashSet$(this._equality, this._hasher, this._validKey, H.getTypeArgumentByIndex(this, 0));
      }, "call$0", "get$_newSet", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Set, E]};
        }, this.$receiver, "_LinkedCustomHashSet");
      }, "_newSet"],
      _findBucketIndex$2: function(bucket, element) {
        var $length, i, t1;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (i = 0; i < $length; ++i) {
          t1 = bucket[i].get$_element();
          if (this._equality.call$2(t1, element) === true)
            return i;
        }
        return -1;
      },
      _computeHashCode$1: function(element) {
        return this._hasher.call$1(element) & 0x3ffffff;
      },
      add$1: [function(_, element) {
        return this.super$_LinkedHashSet$_add(element);
      }, "call$1", "get$add", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.bool, args: [E]};
        }, this.$receiver, "_LinkedCustomHashSet");
      }, 31, [], "add"],
      contains$1: [function(_, object) {
        if (this._validKey.call$1(object) !== true)
          return false;
        return this.super$_LinkedHashSet$_contains(object);
      }, "call$1", "get$contains", 2, 0, 15, 23, [], "contains"],
      lookup$1: [function(object) {
        if (this._validKey.call$1(object) !== true)
          return;
        return this.super$_LinkedHashSet$_lookup(object);
      }, "call$1", "get$lookup", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [P.Object]};
        }, this.$receiver, "_LinkedCustomHashSet");
      }, 23, [], "lookup"],
      remove$1: [function(_, object) {
        if (this._validKey.call$1(object) !== true)
          return false;
        return this.super$_LinkedHashSet$_remove(object);
      }, "call$1", "get$remove", 2, 0, 15, 23, [], "remove"],
      containsAll$1: [function(elements) {
        var t1, element;
        for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();) {
          element = t1.get$current();
          if (this._validKey.call$1(element) !== true || !this.contains$1(0, element))
            return false;
        }
        return true;
      }, "call$1", "get$containsAll", 2, 0, 449, 35, [], "containsAll"],
      removeAll$1: [function(elements) {
        var t1, element;
        for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();) {
          element = t1.get$current();
          if (this._validKey.call$1(element) === true)
            this.super$_LinkedHashSet$_remove(element);
        }
      }, "call$1", "get$removeAll", 2, 0, 152, 35, [], "removeAll"],
      static: {
        _LinkedCustomHashSet$: function(_equality, _hasher, validKey, $E) {
          var t1 = validKey != null ? validKey : new P._LinkedCustomHashSet_closure($E);
          return new P._LinkedCustomHashSet(_equality, _hasher, t1, 0, null, null, null, null, null, 0, [$E]);
        }
      }
    },
    "+_LinkedCustomHashSet": 0,
    _LinkedCustomHashSet_closure: {
      "^": "Closure:3;E",
      call$1: [function(x) {
        return H.checkSubtypeOfRuntimeType(x, this.E);
      }, null, null, 2, 0, null, 38, [], "call"]
    },
    "+ _LinkedCustomHashSet_closure": 0,
    _LinkedHashSetCell: {
      "^": "Object;_element<,_collection$_next@,_collection$_previous@"
    },
    "+_LinkedHashSetCell": 0,
    _LinkedHashSetIterator: {
      "^": "Object;_set,_collection$_modifications,_collection$_cell,_collection$_current@,$ti",
      get$current: [function() {
        return this._collection$_current;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "_LinkedHashSetIterator");
      }, "current"],
      moveNext$0: [function() {
        var t1 = this._set;
        if (this._collection$_modifications !== t1._collection$_modifications)
          throw H.wrapException(new P.ConcurrentModificationError(t1));
        else {
          t1 = this._collection$_cell;
          if (t1 == null) {
            this._collection$_current = null;
            return false;
          } else {
            this._collection$_current = t1.get$_element();
            this._collection$_cell = this._collection$_cell.get$_collection$_next();
            return true;
          }
        }
      }, "call$0", "get$moveNext", 0, 0, 5, "moveNext"]
    },
    "+_LinkedHashSetIterator": 0,
    UnmodifiableListView: {
      "^": "UnmodifiableListBase;_collection$_source<-1288,$ti",
      get$length: [function(_) {
        return J.get$length$asx(this._collection$_source);
      }, null, null, 1, 0, 11, "length"],
      $index: [function(_, index) {
        return J.elementAt$1$ax(this._collection$_source, index);
      }, null, "get$[]", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [P.int]};
        }, this.$receiver, "UnmodifiableListView");
      }, 14, [], "[]"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      "<>": [346],
      static: {
        UnmodifiableListView$: [function(source, $E) {
          return new P.UnmodifiableListView(source, [$E]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, args: [[P.Iterable, E]]};
          }, this.$receiver, "UnmodifiableListView");
        }, 19, [], "new UnmodifiableListView"]
      }
    },
    "+UnmodifiableListView": [1289],
    HashMap: {
      "^": "Object;$ti",
      $isMap: 1,
      "<>": [570, 512],
      static: {
        HashMap_HashMap: [function(equals, hashCode, isValidKey, $K, $V) {
          if (isValidKey == null)
            if (hashCode == null) {
              if (equals == null)
                return new P._HashMap(0, null, null, null, null, [$K, $V]);
              hashCode = P.collection___defaultHashCode$closure();
            } else {
              if (P.core__identityHashCode$closure() === hashCode && P.core__identical$closure() === equals)
                return new P._IdentityHashMap(0, null, null, null, null, [$K, $V]);
              if (equals == null)
                equals = P.collection___defaultEquals$closure();
            }
          else {
            if (hashCode == null)
              hashCode = P.collection___defaultHashCode$closure();
            if (equals == null)
              equals = P.collection___defaultEquals$closure();
          }
          return P._CustomHashMap$(equals, hashCode, isValidKey, $K, $V);
        }, null, null, 0, 7, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, ret: [P.HashMap, K, V], named: {equals: {func: 1, ret: P.bool, args: [K, K]}, hashCode: {func: 1, ret: P.int, args: [K]}, isValidKey: {func: 1, ret: P.bool, args: [,]}}};
          }, this.$receiver, "HashMap");
        }, 0, 0, 0, 162, [], 268, [], 101, [], "new HashMap"],
        HashMap_HashMap$identity: [function($K, $V) {
          return new P._IdentityHashMap(0, null, null, null, null, [$K, $V]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, ret: [P.HashMap, K, V]};
          }, this.$receiver, "HashMap");
        }, "new HashMap$identity"],
        HashMap_HashMap$from: [function(other, $K, $V) {
          var result = P.HashMap_HashMap(null, null, null, $K, $V);
          J.forEach$1$ax(other, new P.closure2(result));
          return result;
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, ret: [P.HashMap, K, V], args: [P.Map]};
          }, this.$receiver, "HashMap");
        }, 2, [], "new HashMap$from"],
        HashMap_HashMap$fromIterable: [function(iterable, key, value, $K, $V) {
          var map = P.HashMap_HashMap(null, null, null, $K, $V);
          P.Maps__fillMapWithMappedIterable(map, iterable, key, value);
          return map;
        }, null, null, 2, 5, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, ret: [P.HashMap, K, V], args: [P.Iterable], named: {key: {func: 1, ret: K, args: [,]}, value: {func: 1, ret: V, args: [,]}}};
          }, this.$receiver, "HashMap");
        }, 0, 0, 42, [], 6, [], 1, [], "new HashMap$fromIterable"],
        HashMap_HashMap$fromIterables: [function(keys, values, $K, $V) {
          var map = P.HashMap_HashMap(null, null, null, $K, $V);
          P.Maps__fillMapWithIterables(map, keys, values);
          return map;
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, ret: [P.HashMap, K, V], args: [[P.Iterable, K], [P.Iterable, V]]};
          }, this.$receiver, "HashMap");
        }, 177, [], 166, [], "new HashMap$fromIterables"]
      }
    },
    "+HashMap": [1, 1290],
    closure2: {
      "^": "Closure:12;result",
      call$2: [function(k, v) {
        this.result.$indexSet(0, k, v);
      }, null, null, 4, 0, 12, 274, [], 56, [], "call"]
    },
    "+ closure": [2],
    _HashSetBase: {
      "^": "SetBase;$ti",
      difference$1: [function(other) {
        var result, t1, t2, element;
        result = this._newSet$0();
        for (t1 = this.get$iterator(this), t2 = J.getInterceptor$asx(other); t1.moveNext$0();) {
          element = t1.get$current();
          if (t2.contains$1(other, element) !== true)
            result.add$1(0, element);
        }
        return result;
      }, "call$1", "get$difference", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Set, E], args: [[P.Set, P.Object]]};
        }, this.$receiver, "_HashSetBase");
      }, 2, [], "difference"],
      intersection$1: [function(other) {
        var result, t1, t2, element;
        result = this._newSet$0();
        for (t1 = this.get$iterator(this), t2 = J.getInterceptor$asx(other); t1.moveNext$0();) {
          element = t1.get$current();
          if (t2.contains$1(other, element) === true)
            result.add$1(0, element);
        }
        return result;
      }, "call$1", "get$intersection", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Set, E], args: [[P.Set, P.Object]]};
        }, this.$receiver, "_HashSetBase");
      }, 2, [], "intersection"],
      toSet$0: [function(_) {
        var t1 = this._newSet$0();
        t1.addAll$1(0, this);
        return t1;
      }, "call$0", "get$toSet", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Set, E]};
        }, this.$receiver, "_HashSetBase");
      }, "toSet"],
      "<>": [502],
      static: {
        _HashSetBase$: [function($E) {
          return new P._HashSetBase([$E]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P._HashSetBase, E]};
          }, this.$receiver, "_HashSetBase");
        }, "new _HashSetBase"]
      }
    },
    "+_HashSetBase": [1291],
    HashSet: {
      "^": "Object;$ti",
      $isSet: 1,
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: null,
      $isIterable: 1,
      $asIterable: null,
      "<>": [433],
      static: {
        HashSet_HashSet: [function(equals, hashCode, isValidKey, $E) {
          if (isValidKey == null)
            if (hashCode == null) {
              if (equals == null)
                return new P._HashSet(0, null, null, null, null, [$E]);
              hashCode = P.collection___defaultHashCode$closure();
            } else {
              if (P.core__identityHashCode$closure() === hashCode && P.core__identical$closure() === equals)
                return new P._IdentityHashSet(0, null, null, null, null, [$E]);
              if (equals == null)
                equals = P.collection___defaultEquals$closure();
            }
          else {
            if (hashCode == null)
              hashCode = P.collection___defaultHashCode$closure();
            if (equals == null)
              equals = P.collection___defaultEquals$closure();
          }
          return P._CustomHashSet$(equals, hashCode, isValidKey, $E);
        }, null, null, 0, 7, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.HashSet, E], named: {equals: {func: 1, ret: P.bool, args: [E, E]}, hashCode: {func: 1, ret: P.int, args: [E]}, isValidKey: {func: 1, ret: P.bool, args: [,]}}};
          }, this.$receiver, "HashSet");
        }, 0, 0, 0, 162, [], 268, [], 101, [], "new HashSet"],
        HashSet_HashSet$identity: [function($E) {
          return new P._IdentityHashSet(0, null, null, null, null, [$E]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.HashSet, E]};
          }, this.$receiver, "HashSet");
        }, "new HashSet$identity"],
        HashSet_HashSet$from: [function(elements, $E) {
          var result, t1;
          result = P.HashSet_HashSet(null, null, null, $E);
          for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
            result.add$1(0, t1.get$current());
          return result;
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.HashSet, E], args: [P.Iterable]};
          }, this.$receiver, "HashSet");
        }, 35, [], "new HashSet$from"]
      }
    },
    "+HashSet": [1, 1292],
    IterableMixin: {
      "^": "Object;$ti",
      map$1: [function(_, f) {
        return H.MappedIterable_MappedIterable(this, f, H.getRuntimeTypeArgument(this, "IterableMixin", 0), null);
      }, "call$1", "get$map", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.Iterable, args: [{func: 1, args: [E]}]};
        }, this.$receiver, "IterableMixin");
      }, 9, [], "map"],
      where$1: [function(_, f) {
        return new H.WhereIterable(this, f, [H.getRuntimeTypeArgument(this, "IterableMixin", 0)]);
      }, "call$1", "get$where", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "IterableMixin");
      }, 9, [], "where"],
      expand$1: [function(_, f) {
        return new H.ExpandIterable(this, f, [H.getRuntimeTypeArgument(this, "IterableMixin", 0), null]);
      }, "call$1", "get$expand", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.Iterable, args: [{func: 1, ret: P.Iterable, args: [E]}]};
        }, this.$receiver, "IterableMixin");
      }, 9, [], "expand"],
      contains$1: [function(_, element) {
        var t1;
        for (t1 = this.get$iterator(this); t1.moveNext$0();)
          if (J.$eq$(t1.get$current(), element))
            return true;
        return false;
      }, "call$1", "get$contains", 2, 0, 15, 31, [], "contains"],
      forEach$1: [function(_, f) {
        var t1;
        for (t1 = this.get$iterator(this); t1.moveNext$0();)
          f.call$1(t1.get$current());
      }, "call$1", "get$forEach", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, v: true, args: [E]}]};
        }, this.$receiver, "IterableMixin");
      }, 9, [], "forEach"],
      reduce$1: [function(_, combine) {
        var iterator, value;
        iterator = this.get$iterator(this);
        if (!iterator.moveNext$0())
          throw H.wrapException(H.IterableElementError_noElement());
        value = iterator.get$current();
        for (; iterator.moveNext$0();)
          value = combine.call$2(value, iterator.get$current());
        return value;
      }, "call$1", "get$reduce", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: E, args: [E, E]}]};
        }, this.$receiver, "IterableMixin");
      }, 61, [], "reduce"],
      fold$2: [function(_, initialValue, combine) {
        var t1, value;
        for (t1 = this.get$iterator(this), value = initialValue; t1.moveNext$0();)
          value = combine.call$2(value, t1.get$current());
        return value;
      }, "call$2", "get$fold", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, args: [, {func: 1, args: [, E]}]};
        }, this.$receiver, "IterableMixin");
      }, 123, [], 61, [], "fold"],
      every$1: [function(_, f) {
        var t1;
        for (t1 = this.get$iterator(this); t1.moveNext$0();)
          if (f.call$1(t1.get$current()) !== true)
            return false;
        return true;
      }, "call$1", "get$every", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.bool, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "IterableMixin");
      }, 9, [], "every"],
      join$1: [function(_, separator) {
        var iterator, t1;
        iterator = this.get$iterator(this);
        if (!iterator.moveNext$0())
          return "";
        if (separator == null || J.$eq$(separator, "")) {
          t1 = "";
          do
            t1 += H.S(iterator.get$current());
          while (iterator.moveNext$0());
        } else {
          t1 = H.S(iterator.get$current());
          for (; iterator.moveNext$0();)
            t1 = t1 + H.S(separator) + H.S(iterator.get$current());
        }
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, function($receiver) {
        return this.join$1($receiver, "");
      }, "join$0", "call$1", "call$0", "get$join", 0, 2, 92, 32, 63, [], "join"],
      any$1: [function(_, f) {
        var t1;
        for (t1 = this.get$iterator(this); t1.moveNext$0();)
          if (f.call$1(t1.get$current()) === true)
            return true;
        return false;
      }, "call$1", "get$any", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.bool, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "IterableMixin");
      }, 9, [], "any"],
      toList$1$growable: [function(_, growable) {
        return P.List_List$from(this, growable, H.getRuntimeTypeArgument(this, "IterableMixin", 0));
      }, function($receiver) {
        return this.toList$1$growable($receiver, true);
      }, "toList$0", "call$1$growable", "call$0", "get$toList", 0, 3, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.List, E], named: {growable: P.bool}};
        }, this.$receiver, "IterableMixin");
      }, 25, 88, [], "toList"],
      toSet$0: [function(_) {
        return P.LinkedHashSet_LinkedHashSet$from(this, H.getRuntimeTypeArgument(this, "IterableMixin", 0));
      }, "call$0", "get$toSet", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Set, E]};
        }, this.$receiver, "IterableMixin");
      }, "toSet"],
      get$length: [function(_) {
        var it, count;
        it = this.get$iterator(this);
        for (count = 0; it.moveNext$0();)
          ++count;
        return count;
      }, null, null, 1, 0, 11, "length"],
      get$isEmpty: [function(_) {
        return !this.get$iterator(this).moveNext$0();
      }, null, null, 1, 0, 5, "isEmpty"],
      get$isNotEmpty: [function(_) {
        return !this.get$isEmpty(this);
      }, null, null, 1, 0, 5, "isNotEmpty"],
      take$1: [function(_, count) {
        return H.TakeIterable_TakeIterable(this, count, H.getRuntimeTypeArgument(this, "IterableMixin", 0));
      }, "call$1", "get$take", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [P.int]};
        }, this.$receiver, "IterableMixin");
      }, 43, [], "take"],
      takeWhile$1: [function(_, test) {
        return new H.TakeWhileIterable(this, test, [H.getRuntimeTypeArgument(this, "IterableMixin", 0)]);
      }, "call$1", "get$takeWhile", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "IterableMixin");
      }, 11, [], "takeWhile"],
      skip$1: [function(_, count) {
        return H.SkipIterable_SkipIterable(this, count, H.getRuntimeTypeArgument(this, "IterableMixin", 0));
      }, "call$1", "get$skip", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [P.int]};
        }, this.$receiver, "IterableMixin");
      }, 43, [], "skip"],
      skipWhile$1: [function(_, test) {
        return new H.SkipWhileIterable(this, test, [H.getRuntimeTypeArgument(this, "IterableMixin", 0)]);
      }, "call$1", "get$skipWhile", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "IterableMixin");
      }, 11, [], "skipWhile"],
      get$first: [function(_) {
        var it = this.get$iterator(this);
        if (!it.moveNext$0())
          throw H.wrapException(H.IterableElementError_noElement());
        return it.get$current();
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "IterableMixin");
      }, "first"],
      get$last: [function(_) {
        var it, result;
        it = this.get$iterator(this);
        if (!it.moveNext$0())
          throw H.wrapException(H.IterableElementError_noElement());
        do
          result = it.get$current();
        while (it.moveNext$0());
        return result;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "IterableMixin");
      }, "last"],
      get$single: [function(_) {
        var it, result;
        it = this.get$iterator(this);
        if (!it.moveNext$0())
          throw H.wrapException(H.IterableElementError_noElement());
        result = it.get$current();
        if (it.moveNext$0())
          throw H.wrapException(H.IterableElementError_tooMany());
        return result;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "IterableMixin");
      }, "single"],
      firstWhere$2$orElse: [function(_, test, orElse) {
        var t1, element;
        for (t1 = this.get$iterator(this); t1.moveNext$0();) {
          element = t1.get$current();
          if (test.call$1(element) === true)
            return element;
        }
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      }, function($receiver, test) {
        return this.firstWhere$2$orElse($receiver, test, null);
      }, "firstWhere$1", "call$2$orElse", "call$1", "get$firstWhere", 2, 3, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: P.bool, args: [E]}], named: {orElse: {func: 1, ret: E}}};
        }, this.$receiver, "IterableMixin");
      }, 0, 11, [], 67, [], "firstWhere"],
      lastWhere$2$orElse: [function(_, test, orElse) {
        var t1, result, foundMatching, element;
        for (t1 = this.get$iterator(this), result = null, foundMatching = false; t1.moveNext$0();) {
          element = t1.get$current();
          if (test.call$1(element) === true) {
            result = element;
            foundMatching = true;
          }
        }
        if (foundMatching)
          return result;
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      }, function($receiver, test) {
        return this.lastWhere$2$orElse($receiver, test, null);
      }, "lastWhere$1", "call$2$orElse", "call$1", "get$lastWhere", 2, 3, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: P.bool, args: [E]}], named: {orElse: {func: 1, ret: E}}};
        }, this.$receiver, "IterableMixin");
      }, 0, 11, [], 67, [], "lastWhere"],
      singleWhere$1: [function(_, test) {
        var t1, result, foundMatching, element;
        for (t1 = this.get$iterator(this), result = null, foundMatching = false; t1.moveNext$0();) {
          element = t1.get$current();
          if (test.call$1(element) === true) {
            if (foundMatching)
              throw H.wrapException(H.IterableElementError_tooMany());
            result = element;
            foundMatching = true;
          }
        }
        if (foundMatching)
          return result;
        throw H.wrapException(H.IterableElementError_noElement());
      }, "call$1", "get$singleWhere", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "IterableMixin");
      }, 11, [], "singleWhere"],
      elementAt$1: [function(_, index) {
        var t1, elementIndex, element;
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(P.ArgumentError$notNull("index"));
        if (index < 0)
          H.throwExpression(P.RangeError$range(index, 0, null, "index", null));
        for (t1 = this.get$iterator(this), elementIndex = 0; t1.moveNext$0();) {
          element = t1.get$current();
          if (index === elementIndex)
            return element;
          ++elementIndex;
        }
        throw H.wrapException(P.IndexError$(index, this, "index", null, elementIndex));
      }, "call$1", "get$elementAt", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [P.int]};
        }, this.$receiver, "IterableMixin");
      }, 14, [], "elementAt"],
      toString$0: [function(_) {
        return P.IterableBase_iterableToShortString(this, "(", ")");
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $isIterable: 1,
      $asIterable: null,
      "<>": [593],
      static: {
        IterableMixin$: [function($E) {
          return new P.IterableMixin([$E]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.IterableMixin, E]};
          }, this.$receiver, "IterableMixin");
        }, "new IterableMixin"]
      }
    },
    "+IterableMixin": [1, 1293],
    IterableBase: {
      "^": "Iterable;$ti",
      "<>": [561],
      static: {
        IterableBase$: [function($E) {
          return new P.IterableBase([$E]);
        }, null, null, 0, 0, 4, "new IterableBase"],
        IterableBase_iterableToShortString: [function(iterable, leftDelimiter, rightDelimiter) {
          var parts, t1;
          if (P._isToStringVisiting(iterable)) {
            if (J.$eq$(leftDelimiter, "(") && J.$eq$(rightDelimiter, ")"))
              return "(...)";
            return H.S(leftDelimiter) + "..." + H.S(rightDelimiter);
          }
          parts = [];
          t1 = $.$get$_toStringVisiting();
          t1.push(iterable);
          try {
            P._iterablePartsToStrings(iterable, parts);
          } finally {
            if (0 >= t1.length)
              return H.ioore(t1, -1);
            t1.pop();
          }
          t1 = P.StringBuffer__writeAll(H.S(leftDelimiter), parts, ", ") + H.S(rightDelimiter);
          return t1.charCodeAt(0) == 0 ? t1 : t1;
        }, function(iterable) {
          return P.IterableBase_iterableToShortString(iterable, "(", ")");
        }, function(iterable, leftDelimiter) {
          return P.IterableBase_iterableToShortString(iterable, leftDelimiter, ")");
        }, "call$3", "call$1", "call$2", "collection_IterableBase_iterableToShortString$closure", 2, 4, 392, 435, 436, 42, [], 437, [], 438, [], "iterableToShortString"],
        IterableBase_iterableToFullString: [function(iterable, leftDelimiter, rightDelimiter) {
          var buffer, t1, t2;
          if (P._isToStringVisiting(iterable))
            return H.S(leftDelimiter) + "..." + H.S(rightDelimiter);
          buffer = new P.StringBuffer(H.S(leftDelimiter));
          t1 = $.$get$_toStringVisiting();
          t1.push(iterable);
          try {
            t2 = buffer;
            t2.set$_contents(P.StringBuffer__writeAll(t2.get$_contents(), iterable, ", "));
          } finally {
            if (0 >= t1.length)
              return H.ioore(t1, -1);
            t1.pop();
          }
          t1 = buffer;
          t2 = H.S(rightDelimiter);
          t1.set$_contents(t1.get$_contents() + t2);
          t2 = buffer.get$_contents();
          return t2.charCodeAt(0) == 0 ? t2 : t2;
        }, function(iterable) {
          return P.IterableBase_iterableToFullString(iterable, "(", ")");
        }, function(iterable, leftDelimiter) {
          return P.IterableBase_iterableToFullString(iterable, leftDelimiter, ")");
        }, "call$3", "call$1", "call$2", "collection_IterableBase_iterableToFullString$closure", 2, 4, 392, 435, 436, 42, [], 437, [], 438, [], "iterableToFullString"]
      }
    },
    "+IterableBase": [1294],
    HasNextIterator: {
      "^": "Object;_collection$_iterator@-1295,_collection$_state@-0,$ti",
      get$hasNext: [function() {
        if (J.$eq$(this._collection$_state, 2))
          this._move$0();
        return J.$eq$(this._collection$_state, 0);
      }, null, null, 1, 0, 5, "hasNext"],
      next$0: [function() {
        if (J.$eq$(this._collection$_state, 2))
          this._move$0();
        if (!J.$eq$(this._collection$_state, 0))
          throw H.wrapException(new P.StateError("No more elements"));
        var result = this._collection$_iterator.get$current();
        this._move$0();
        return result;
      }, "call$0", "get$next", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "HasNextIterator");
      }, "next"],
      _move$0: [function() {
        if (this._collection$_iterator.moveNext$0() === true)
          this._collection$_state = 0;
        else
          this._collection$_state = 1;
      }, "call$0", "get$_move", 0, 0, 6, "_move"],
      "<>": [509],
      static: {
        "^": "HasNextIterator__HAS_NEXT_AND_NEXT_IN_CURRENT<-0,HasNextIterator__NO_NEXT<-0,HasNextIterator__NOT_MOVED_YET<-0",
        HasNextIterator$: [function(_iterator, $E) {
          return new P.HasNextIterator(_iterator, 2, [$E]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, args: [[P.Iterator, E]]};
          }, this.$receiver, "HasNextIterator");
        }, 774, [], "new HasNextIterator"]
      }
    },
    "+HasNextIterator": [1],
    LinkedHashMap: {
      "^": "Object;$ti",
      $isMap: 1,
      "<>": [619, 579],
      static: {
        LinkedHashMap_LinkedHashMap$_literal: function(keyValuePairs, $K, $V) {
          return H.fillLiteralMap(keyValuePairs, new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [$K, $V]));
        },
        LinkedHashMap_LinkedHashMap$_empty: function($K, $V) {
          return new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [$K, $V]);
        },
        LinkedHashMap__makeEmpty: [function() {
          return new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [null, null]);
        }, "call$0", "collection_LinkedHashMap__makeEmpty$closure", 0, 0, 4, "_makeEmpty", 362],
        LinkedHashMap__makeLiteral: [function(keyValuePairs) {
          return H.fillLiteralMap(keyValuePairs, new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [null, null]));
        }, "call$1", "collection_LinkedHashMap__makeLiteral$closure", 2, 0, 3, 776, [], "_makeLiteral", 362],
        LinkedHashMap_LinkedHashMap: [function(equals, hashCode, isValidKey, $K, $V) {
          if (isValidKey == null)
            if (hashCode == null) {
              if (equals == null)
                return new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [$K, $V]);
              hashCode = P.collection___defaultHashCode$closure();
            } else {
              if (P.core__identityHashCode$closure() === hashCode && P.core__identical$closure() === equals)
                return P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6($K, $V);
              if (equals == null)
                equals = P.collection___defaultEquals$closure();
            }
          else {
            if (hashCode == null)
              hashCode = P.collection___defaultHashCode$closure();
            if (equals == null)
              equals = P.collection___defaultEquals$closure();
          }
          return P._LinkedCustomHashMap$(equals, hashCode, isValidKey, $K, $V);
        }, null, null, 0, 7, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, ret: [P.LinkedHashMap, K, V], named: {equals: {func: 1, ret: P.bool, args: [K, K]}, hashCode: {func: 1, ret: P.int, args: [K]}, isValidKey: {func: 1, ret: P.bool, args: [,]}}};
          }, this.$receiver, "LinkedHashMap");
        }, 0, 0, 0, 162, [], 268, [], 101, [], "new LinkedHashMap"],
        LinkedHashMap_LinkedHashMap$identity: [function($K, $V) {
          return P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6($K, $V);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, ret: [P.LinkedHashMap, K, V]};
          }, this.$receiver, "LinkedHashMap");
        }, "new LinkedHashMap$identity"],
        LinkedHashMap_LinkedHashMap$from: [function(other, $K, $V) {
          var result = P.LinkedHashMap_LinkedHashMap(null, null, null, $K, $V);
          J.forEach$1$ax(other, new P.closure0(result));
          return result;
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, ret: [P.LinkedHashMap, K, V], args: [P.Map]};
          }, this.$receiver, "LinkedHashMap");
        }, 2, [], "new LinkedHashMap$from"],
        LinkedHashMap_LinkedHashMap$fromIterable: [function(iterable, key, value, $K, $V) {
          var map = P.LinkedHashMap_LinkedHashMap(null, null, null, $K, $V);
          P.Maps__fillMapWithMappedIterable(map, iterable, key, value);
          return map;
        }, null, null, 2, 5, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, ret: [P.LinkedHashMap, K, V], args: [P.Iterable], named: {key: {func: 1, ret: K, args: [,]}, value: {func: 1, ret: V, args: [,]}}};
          }, this.$receiver, "LinkedHashMap");
        }, 0, 0, 42, [], 6, [], 1, [], "new LinkedHashMap$fromIterable"],
        LinkedHashMap_LinkedHashMap$fromIterables: [function(keys, values, $K, $V) {
          var map = P.LinkedHashMap_LinkedHashMap(null, null, null, $K, $V);
          P.Maps__fillMapWithIterables(map, keys, values);
          return map;
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, ret: [P.LinkedHashMap, K, V], args: [[P.Iterable, K], [P.Iterable, V]]};
          }, this.$receiver, "LinkedHashMap");
        }, 177, [], 166, [], "new LinkedHashMap$fromIterables"]
      }
    },
    "+LinkedHashMap": [1, 1296],
    closure0: {
      "^": "Closure:12;result",
      call$2: [function(k, v) {
        this.result.$indexSet(0, k, v);
      }, null, null, 4, 0, 12, 274, [], 56, [], "call"]
    },
    "+ closure": [2],
    LinkedHashSet: {
      "^": "Object;$ti",
      $isSet: 1,
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: null,
      $isIterable: 1,
      $asIterable: null,
      "<>": [432],
      static: {
        LinkedHashSet_LinkedHashSet: [function(equals, hashCode, isValidKey, $E) {
          if (isValidKey == null)
            if (hashCode == null) {
              if (equals == null)
                return new P._LinkedHashSet(0, null, null, null, null, null, 0, [$E]);
              hashCode = P.collection___defaultHashCode$closure();
            } else {
              if (P.core__identityHashCode$closure() === hashCode && P.core__identical$closure() === equals)
                return new P._LinkedIdentityHashSet(0, null, null, null, null, null, 0, [$E]);
              if (equals == null)
                equals = P.collection___defaultEquals$closure();
            }
          else {
            if (hashCode == null)
              hashCode = P.collection___defaultHashCode$closure();
            if (equals == null)
              equals = P.collection___defaultEquals$closure();
          }
          return P._LinkedCustomHashSet$(equals, hashCode, isValidKey, $E);
        }, null, null, 0, 7, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.LinkedHashSet, E], named: {equals: {func: 1, ret: P.bool, args: [E, E]}, hashCode: {func: 1, ret: P.int, args: [E]}, isValidKey: {func: 1, ret: P.bool, args: [,]}}};
          }, this.$receiver, "LinkedHashSet");
        }, 0, 0, 0, 162, [], 268, [], 101, [], "new LinkedHashSet"],
        LinkedHashSet_LinkedHashSet$identity: [function($E) {
          return new P._LinkedIdentityHashSet(0, null, null, null, null, null, 0, [$E]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.LinkedHashSet, E]};
          }, this.$receiver, "LinkedHashSet");
        }, "new LinkedHashSet$identity"],
        LinkedHashSet_LinkedHashSet$from: [function(elements, $E) {
          var result, t1;
          result = P.LinkedHashSet_LinkedHashSet(null, null, null, $E);
          for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
            result.add$1(0, t1.get$current());
          return result;
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.LinkedHashSet, E], args: [P.Iterable]};
          }, this.$receiver, "LinkedHashSet");
        }, 35, [], "new LinkedHashSet$from"]
      }
    },
    "+LinkedHashSet": [1, 1297],
    LinkedList: {
      "^": "Iterable;_modificationCount@-0,_collection$_length@-0,_collection$_first@-1298,$ti",
      addFirst$1: [function(entry) {
        this._insertBefore$3$updateFirst(this._collection$_first, entry, true);
        this._collection$_first = entry;
      }, "call$1", "get$addFirst", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [E]};
        }, this.$receiver, "LinkedList");
      }, 137, [], "addFirst"],
      add$1: [function(_, entry) {
        this._insertBefore$3$updateFirst(this._collection$_first, entry, false);
      }, "call$1", "get$add", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [E]};
        }, this.$receiver, "LinkedList");
      }, 137, [], "add"],
      addAll$1: [function(_, entries) {
        J.forEach$1$ax(entries, this.get$add(this));
      }, "call$1", "get$addAll", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [[P.Iterable, E]]};
        }, this.$receiver, "LinkedList");
      }, 763, [], "addAll"],
      remove$1: [function(_, entry) {
        if (!J.$eq$(entry.get$_list(), this))
          return false;
        this._unlink$1(entry);
        return true;
      }, "call$1", "get$remove", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.bool, args: [E]};
        }, this.$receiver, "LinkedList");
      }, 137, [], "remove"],
      get$iterator: [function(_) {
        return new P._LinkedListIterator(this, this._modificationCount, null, this._collection$_first, false, this.$ti);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterator, E]};
        }, this.$receiver, "LinkedList");
      }, "iterator"],
      get$length: [function(_) {
        return this._collection$_length;
      }, null, null, 1, 0, 11, "length"],
      clear$0: [function(_) {
        var next, next0, t1;
        this._modificationCount = J.$add$ns(this._modificationCount, 1);
        if (J.$eq$(this._collection$_length, 0))
          return;
        next = this._collection$_first;
        do {
          next0 = next.get$_collection$_next();
          next.set$_list(null);
          next.set$_collection$_previous(null);
          next.set$_collection$_next(null);
          if (t1 = this._collection$_first, next0 == null ? t1 != null : next0 !== t1) {
            next = next0;
            continue;
          } else
            break;
        } while (true);
        this._collection$_first = null;
        this._collection$_length = 0;
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      get$first: [function(_) {
        if (J.$eq$(this._collection$_length, 0))
          throw H.wrapException(new P.StateError("No such element"));
        return this._collection$_first;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "LinkedList");
      }, "first"],
      get$last: [function(_) {
        if (J.$eq$(this._collection$_length, 0))
          throw H.wrapException(new P.StateError("No such element"));
        return this._collection$_first.get$_collection$_previous();
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "LinkedList");
      }, "last"],
      get$single: [function(_) {
        if (J.$eq$(this._collection$_length, 0))
          throw H.wrapException(new P.StateError("No such element"));
        if (J.$gt$n(this._collection$_length, 1))
          throw H.wrapException(new P.StateError("Too many elements"));
        return this._collection$_first;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "LinkedList");
      }, "single"],
      forEach$1: [function(_, action) {
        var modificationCount, current, t1, t2;
        modificationCount = this._modificationCount;
        if (J.$eq$(this._collection$_length, 0))
          return;
        current = this._collection$_first;
        t1 = J.getInterceptor(modificationCount);
        do {
          action.call$1(current);
          if (!t1.$eq(modificationCount, this._modificationCount))
            throw H.wrapException(new P.ConcurrentModificationError(this));
          current = current.get$_collection$_next();
        } while (t2 = this._collection$_first, current == null ? t2 != null : current !== t2);
      }, "call$1", "get$forEach", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, v: true, args: [E]}]};
        }, this.$receiver, "LinkedList");
      }, 71, [], "forEach"],
      get$isEmpty: [function(_) {
        return J.$eq$(this._collection$_length, 0);
      }, null, null, 1, 0, 5, "isEmpty"],
      _insertBefore$3$updateFirst: [function(entry, newEntry, updateFirst) {
        var predecessor, t1;
        if (J.get$list$a(newEntry) != null)
          throw H.wrapException(new P.StateError("LinkedListEntry is already in a LinkedList"));
        this._modificationCount = J.$add$ns(this._modificationCount, 1);
        newEntry.set$_list(this);
        if (J.$eq$(this._collection$_length, 0)) {
          newEntry.set$_collection$_next(newEntry);
          newEntry.set$_collection$_previous(newEntry);
          this._collection$_first = newEntry;
          this._collection$_length = J.$add$ns(this._collection$_length, 1);
          return;
        }
        predecessor = entry.get$_collection$_previous();
        newEntry.set$_collection$_previous(predecessor);
        newEntry.set$_collection$_next(entry);
        predecessor.set$_collection$_next(newEntry);
        entry.set$_collection$_previous(newEntry);
        if (updateFirst === true) {
          t1 = this._collection$_first;
          t1 = entry == null ? t1 == null : entry === t1;
        } else
          t1 = false;
        if (t1)
          this._collection$_first = newEntry;
        this._collection$_length = J.$add$ns(this._collection$_length, 1);
      }, function(entry, newEntry) {
        return this._insertBefore$3$updateFirst(entry, newEntry, null);
      }, "_insertBefore$2", "call$3$updateFirst", "call$2", "get$_insertBefore", 4, 3, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [E, E], named: {updateFirst: P.bool}};
        }, this.$receiver, "LinkedList");
      }, 0, 137, [], 760, [], 759, [], "_insertBefore"],
      _unlink$1: [function(entry) {
        var t1, next;
        this._modificationCount = J.$add$ns(this._modificationCount, 1);
        entry.get$_collection$_next().set$_collection$_previous(entry.get$_collection$_previous());
        t1 = entry.get$_collection$_previous();
        next = entry.get$_collection$_next();
        t1.set$_collection$_next(next);
        this._collection$_length = J.$sub$n(this._collection$_length, 1);
        entry.set$_collection$_previous(null);
        entry.set$_collection$_next(null);
        entry.set$_list(null);
        if (J.$eq$(this._collection$_length, 0))
          this._collection$_first = null;
        else {
          t1 = this._collection$_first;
          if (entry == null ? t1 == null : entry === t1)
            this._collection$_first = next;
        }
      }, "call$1", "get$_unlink", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [E]};
        }, this.$receiver, "LinkedList");
      }, 137, [], "_unlink"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      "<>": [229],
      static: {
        LinkedList$: [function($E) {
          return new P.LinkedList(0, 0, null, [$E]);
        }, null, null, 0, 0, 4, "new LinkedList"]
      }
    },
    "+LinkedList": [1299],
    _LinkedListIterator: {
      "^": "Object;_list<-1300,_modificationCount<-0,_collection$_current@-1301,_collection$_next@-397,_visitedFirst@-8,$ti",
      get$current: [function() {
        return this._collection$_current;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "_LinkedListIterator");
      }, "current"],
      moveNext$0: [function() {
        var t1, t2, t3;
        t1 = this._list;
        if (!J.$eq$(this._modificationCount, t1.get$_modificationCount()))
          throw H.wrapException(new P.ConcurrentModificationError(this));
        t2 = J.getInterceptor$asx(t1);
        if (t2.get$isEmpty(t1) !== true)
          if (this._visitedFirst === true) {
            t3 = this._collection$_next;
            t1 = t2.get$first(t1);
            t1 = t3 == null ? t1 == null : t3 === t1;
          } else
            t1 = false;
        else
          t1 = true;
        if (t1) {
          this._collection$_current = null;
          return false;
        }
        this._visitedFirst = true;
        t1 = this._collection$_next;
        this._collection$_current = t1;
        this._collection$_next = t1.get$_collection$_next();
        return true;
      }, "call$0", "get$moveNext", 0, 0, 5, "moveNext"],
      "<>": [212],
      static: {
        _LinkedListIterator$: [function(list, $E) {
          return new P._LinkedListIterator(list, list.get$_modificationCount(), null, list.get$_collection$_first(), false, [$E]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, args: [[P.LinkedList, E]]};
          }, this.$receiver, "_LinkedListIterator");
        }, 125, [], "new _LinkedListIterator"]
      }
    },
    "+_LinkedListIterator": [1, 1302],
    LinkedListEntry: {
      "^": "Object;_list@-258,_collection$_next@-120,_collection$_previous@-120,$ti",
      get$list: [function(_) {
        return this._list;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.LinkedList, E]};
        }, this.$receiver, "LinkedListEntry");
      }, "list"],
      unlink$0: [function() {
        this._list._unlink$1(this);
      }, "call$0", "get$unlink", 0, 0, 6, "unlink"],
      get$next: [function() {
        var t1, t2;
        t1 = this._list;
        if (t1 != null) {
          t1 = J.get$first$ax(t1);
          t2 = this._collection$_next;
          t2 = t1 == null ? t2 == null : t1 === t2;
          t1 = t2;
        } else
          t1 = true;
        if (t1)
          return;
        return this._collection$_next;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "LinkedListEntry");
      }, "next"],
      get$previous: [function() {
        var t1 = this._list;
        if (t1 == null || this === J.get$first$ax(t1))
          return;
        return this._collection$_previous;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "LinkedListEntry");
      }, "previous"],
      insertAfter$1: [function(entry) {
        this._list._insertBefore$3$updateFirst(this._collection$_next, entry, false);
      }, "call$1", "get$insertAfter", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [E]};
        }, this.$receiver, "LinkedListEntry");
      }, 137, [], "insertAfter"],
      insertBefore$1: [function(entry) {
        this._list._insertBefore$3$updateFirst(this, entry, true);
      }, "call$1", "get$insertBefore", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [E]};
        }, this.$receiver, "LinkedListEntry");
      }, 137, [], "insertBefore"],
      list$2$followLinks$recursive: function($receiver, arg0, arg1) {
        return this.get$list(this).call$2$followLinks$recursive(arg0, arg1);
      },
      next$0: function() {
        return this.get$next().call$0();
      },
      "<>": [252],
      static: {
        LinkedListEntry$: [function($E) {
          return new P.LinkedListEntry(null, null, null, [$E]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.LinkedListEntry, E]};
          }, this.$receiver, "LinkedListEntry");
        }, "new LinkedListEntry"]
      }
    },
    "+LinkedListEntry": [1],
    ListBase: {
      "^": "Object_ListMixin;$ti",
      "<>": [471],
      static: {
        ListBase$: [function($E) {
          return new P.ListBase([$E]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.ListBase, E]};
          }, this.$receiver, "ListBase");
        }, "new ListBase"],
        ListBase_listToString: [function(list) {
          return P.IterableBase_iterableToFullString(list, "[", "]");
        }, "call$1", "collection_ListBase_listToString$closure", 2, 0, 604, 125, [], "listToString"]
      }
    },
    "+ListBase": [1305],
    Object_ListMixin: {
      "^": "Object+ListMixin;$ti",
      $asList: null,
      $asEfficientLengthIterable: null,
      $asIterable: null,
      $isList: 1,
      $isEfficientLengthIterable: 1,
      $isIterable: 1,
      "<>": [947],
      static: {
        "Object+ListMixin$": [function($E) {
          return new P.Object_ListMixin([$E]);
        }, null, null, 0, 0, 4, "new Object+ListMixin"]
      }
    },
    ListMixin: {
      "^": "Object;$ti",
      get$iterator: [function(receiver) {
        return new H.ListIterator(receiver, this.get$length(receiver), 0, null, [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterator, E]};
        }, this.$receiver, "ListMixin");
      }, "iterator"],
      elementAt$1: [function(receiver, index) {
        return this.$index(receiver, index);
      }, "call$1", "get$elementAt", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [P.int]};
        }, this.$receiver, "ListMixin");
      }, 14, [], "elementAt"],
      forEach$1: [function(receiver, action) {
        var $length, i;
        $length = this.get$length(receiver);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          action.call$1(this.$index(receiver, i));
          if ($length !== this.get$length(receiver))
            throw H.wrapException(new P.ConcurrentModificationError(receiver));
        }
      }, "call$1", "get$forEach", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, v: true, args: [E]}]};
        }, this.$receiver, "ListMixin");
      }, 71, [], "forEach"],
      get$isEmpty: [function(receiver) {
        return J.$eq$(this.get$length(receiver), 0);
      }, null, null, 1, 0, 5, "isEmpty"],
      get$isNotEmpty: [function(receiver) {
        return !J.$eq$(this.get$length(receiver), 0);
      }, null, null, 1, 0, 5, "isNotEmpty"],
      get$first: [function(receiver) {
        if (J.$eq$(this.get$length(receiver), 0))
          throw H.wrapException(H.IterableElementError_noElement());
        return this.$index(receiver, 0);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "ListMixin");
      }, "first"],
      get$last: [function(receiver) {
        if (J.$eq$(this.get$length(receiver), 0))
          throw H.wrapException(H.IterableElementError_noElement());
        return this.$index(receiver, J.$sub$n(this.get$length(receiver), 1));
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "ListMixin");
      }, "last"],
      get$single: [function(receiver) {
        if (J.$eq$(this.get$length(receiver), 0))
          throw H.wrapException(H.IterableElementError_noElement());
        if (J.$gt$n(this.get$length(receiver), 1))
          throw H.wrapException(H.IterableElementError_tooMany());
        return this.$index(receiver, 0);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "ListMixin");
      }, "single"],
      contains$1: [function(receiver, element) {
        var $length, t1, i, t2;
        $length = this.get$length(receiver);
        t1 = J.getInterceptor($length);
        i = 0;
        while (true) {
          t2 = this.get$length(receiver);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          if (J.$eq$(this.$index(receiver, i), element))
            return true;
          if (!t1.$eq($length, this.get$length(receiver)))
            throw H.wrapException(new P.ConcurrentModificationError(receiver));
          ++i;
        }
        return false;
      }, "call$1", "get$contains", 2, 0, 15, 31, [], "contains"],
      every$1: [function(receiver, test) {
        var $length, i;
        $length = this.get$length(receiver);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          if (test.call$1(this.$index(receiver, i)) !== true)
            return false;
          if ($length !== this.get$length(receiver))
            throw H.wrapException(new P.ConcurrentModificationError(receiver));
        }
        return true;
      }, "call$1", "get$every", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.bool, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "ListMixin");
      }, 11, [], "every"],
      any$1: [function(receiver, test) {
        var $length, i;
        $length = this.get$length(receiver);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          if (test.call$1(this.$index(receiver, i)) === true)
            return true;
          if ($length !== this.get$length(receiver))
            throw H.wrapException(new P.ConcurrentModificationError(receiver));
        }
        return false;
      }, "call$1", "get$any", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.bool, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "ListMixin");
      }, 11, [], "any"],
      firstWhere$2$orElse: [function(receiver, test, orElse) {
        var $length, i, element;
        $length = this.get$length(receiver);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          element = this.$index(receiver, i);
          if (test.call$1(element) === true)
            return element;
          if ($length !== this.get$length(receiver))
            throw H.wrapException(new P.ConcurrentModificationError(receiver));
        }
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      }, function($receiver, test) {
        return this.firstWhere$2$orElse($receiver, test, null);
      }, "firstWhere$1", "call$2$orElse", "call$1", "get$firstWhere", 2, 3, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: P.bool, args: [E]}], named: {orElse: {func: 1, ret: E}}};
        }, this.$receiver, "ListMixin");
      }, 0, 11, [], 67, [], "firstWhere"],
      lastWhere$2$orElse: [function(receiver, test, orElse) {
        var $length, t1, i, t2, element;
        $length = this.get$length(receiver);
        for (t1 = J.getInterceptor$n($length), i = t1.$sub($length, 1); t2 = J.getInterceptor$n(i), t2.$ge(i, 0); i = t2.$sub(i, 1)) {
          element = this.$index(receiver, i);
          if (test.call$1(element) === true)
            return element;
          if (!t1.$eq($length, this.get$length(receiver)))
            throw H.wrapException(new P.ConcurrentModificationError(receiver));
        }
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      }, function($receiver, test) {
        return this.lastWhere$2$orElse($receiver, test, null);
      }, "lastWhere$1", "call$2$orElse", "call$1", "get$lastWhere", 2, 3, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: P.bool, args: [E]}], named: {orElse: {func: 1, ret: E}}};
        }, this.$receiver, "ListMixin");
      }, 0, 11, [], 67, [], "lastWhere"],
      singleWhere$1: [function(receiver, test) {
        var $length, match, matchFound, i, element;
        $length = this.get$length(receiver);
        if (typeof $length !== "number")
          return H.iae($length);
        match = null;
        matchFound = false;
        i = 0;
        for (; i < $length; ++i) {
          element = this.$index(receiver, i);
          if (test.call$1(element) === true) {
            if (matchFound)
              throw H.wrapException(H.IterableElementError_tooMany());
            match = element;
            matchFound = true;
          }
          if ($length !== this.get$length(receiver))
            throw H.wrapException(new P.ConcurrentModificationError(receiver));
        }
        if (matchFound)
          return match;
        throw H.wrapException(H.IterableElementError_noElement());
      }, "call$1", "get$singleWhere", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "ListMixin");
      }, 11, [], "singleWhere"],
      join$1: [function(receiver, separator) {
        var t1;
        if (J.$eq$(this.get$length(receiver), 0))
          return "";
        t1 = P.StringBuffer__writeAll("", receiver, separator);
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, function($receiver) {
        return this.join$1($receiver, "");
      }, "join$0", "call$1", "call$0", "get$join", 0, 2, 92, 32, 63, [], "join"],
      where$1: [function(receiver, test) {
        return new H.WhereIterable(receiver, test, [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
      }, "call$1", "get$where", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "ListMixin");
      }, 11, [], "where"],
      map$1: [function(receiver, f) {
        return new H.MappedListIterable(receiver, f, [H.getRuntimeTypeArgument(receiver, "ListMixin", 0), null]);
      }, "call$1", "get$map", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.Iterable, args: [{func: 1, args: [E]}]};
        }, this.$receiver, "ListMixin");
      }, 9, [], "map"],
      expand$1: [function(receiver, f) {
        return new H.ExpandIterable(receiver, f, [H.getRuntimeTypeArgument(receiver, "ListMixin", 0), null]);
      }, "call$1", "get$expand", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.Iterable, args: [{func: 1, ret: P.Iterable, args: [E]}]};
        }, this.$receiver, "ListMixin");
      }, 9, [], "expand"],
      reduce$1: [function(receiver, combine) {
        var $length, value, i;
        $length = this.get$length(receiver);
        if (J.$eq$($length, 0))
          throw H.wrapException(H.IterableElementError_noElement());
        value = this.$index(receiver, 0);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 1;
        for (; i < $length; ++i) {
          value = combine.call$2(value, this.$index(receiver, i));
          if ($length !== this.get$length(receiver))
            throw H.wrapException(new P.ConcurrentModificationError(receiver));
        }
        return value;
      }, "call$1", "get$reduce", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: E, args: [E, E]}]};
        }, this.$receiver, "ListMixin");
      }, 61, [], "reduce"],
      fold$2: [function(receiver, initialValue, combine) {
        var $length, value, i;
        $length = this.get$length(receiver);
        if (typeof $length !== "number")
          return H.iae($length);
        value = initialValue;
        i = 0;
        for (; i < $length; ++i) {
          value = combine.call$2(value, this.$index(receiver, i));
          if ($length !== this.get$length(receiver))
            throw H.wrapException(new P.ConcurrentModificationError(receiver));
        }
        return value;
      }, "call$2", "get$fold", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, args: [, {func: 1, args: [, E]}]};
        }, this.$receiver, "ListMixin");
      }, 123, [], 61, [], "fold"],
      skip$1: [function(receiver, count) {
        return H.SubListIterable$(receiver, count, null, H.getRuntimeTypeArgument(receiver, "ListMixin", 0));
      }, "call$1", "get$skip", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [P.int]};
        }, this.$receiver, "ListMixin");
      }, 43, [], "skip"],
      skipWhile$1: [function(receiver, test) {
        return new H.SkipWhileIterable(receiver, test, [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
      }, "call$1", "get$skipWhile", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "ListMixin");
      }, 11, [], "skipWhile"],
      take$1: [function(receiver, count) {
        return H.SubListIterable$(receiver, 0, count, H.getRuntimeTypeArgument(receiver, "ListMixin", 0));
      }, "call$1", "get$take", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [P.int]};
        }, this.$receiver, "ListMixin");
      }, 43, [], "take"],
      takeWhile$1: [function(receiver, test) {
        return new H.TakeWhileIterable(receiver, test, [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
      }, "call$1", "get$takeWhile", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "ListMixin");
      }, 11, [], "takeWhile"],
      toList$1$growable: [function(receiver, growable) {
        var t1, result, t2, i;
        t1 = [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)];
        if (growable === true) {
          result = H.setRuntimeTypeInfo([], t1);
          C.JSArray_methods.set$length(result, this.get$length(receiver));
        } else {
          t2 = this.get$length(receiver);
          if (typeof t2 !== "number")
            return H.iae(t2);
          t2 = new Array(t2);
          t2.fixed$length = Array;
          result = H.setRuntimeTypeInfo(t2, t1);
        }
        i = 0;
        while (true) {
          t1 = this.get$length(receiver);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          t1 = this.$index(receiver, i);
          if (i >= result.length)
            return H.ioore(result, i);
          result[i] = t1;
          ++i;
        }
        return result;
      }, function($receiver) {
        return this.toList$1$growable($receiver, true);
      }, "toList$0", "call$1$growable", "call$0", "get$toList", 0, 3, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.List, E], named: {growable: P.bool}};
        }, this.$receiver, "ListMixin");
      }, 25, 88, [], "toList"],
      toSet$0: [function(receiver) {
        var result, i, t1;
        result = P.LinkedHashSet_LinkedHashSet(null, null, null, H.getRuntimeTypeArgument(receiver, "ListMixin", 0));
        i = 0;
        while (true) {
          t1 = this.get$length(receiver);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          result.add$1(0, this.$index(receiver, i));
          ++i;
        }
        return result;
      }, "call$0", "get$toSet", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Set, E]};
        }, this.$receiver, "ListMixin");
      }, "toSet"],
      add$1: [function(receiver, element) {
        var t1 = this.get$length(receiver);
        this.set$length(receiver, J.$add$ns(t1, 1));
        this.$indexSet(receiver, t1, element);
      }, "call$1", "get$add", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [E]};
        }, this.$receiver, "ListMixin");
      }, 31, [], "add"],
      addAll$1: [function(receiver, iterable) {
        var i, t1, element, t2;
        i = this.get$length(receiver);
        for (t1 = J.get$iterator$ax(iterable); t1.moveNext$0();) {
          element = t1.get$current();
          t2 = J.getInterceptor$ns(i);
          this.set$length(receiver, t2.$add(i, 1));
          this.$indexSet(receiver, i, element);
          i = t2.$add(i, 1);
        }
      }, "call$1", "get$addAll", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [[P.Iterable, E]]};
        }, this.$receiver, "ListMixin");
      }, 42, [], "addAll"],
      remove$1: [function(receiver, element) {
        var i, t1;
        i = 0;
        while (true) {
          t1 = this.get$length(receiver);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          if (J.$eq$(this.$index(receiver, i), element)) {
            this.setRange$4(receiver, i, J.$sub$n(this.get$length(receiver), 1), receiver, i + 1);
            this.set$length(receiver, J.$sub$n(this.get$length(receiver), 1));
            return true;
          }
          ++i;
        }
        return false;
      }, "call$1", "get$remove", 2, 0, 15, 31, [], "remove"],
      removeWhere$1: [function(receiver, test) {
        this._collection$_filter$2(receiver, test, false);
      }, "call$1", "get$removeWhere", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "ListMixin");
      }, 11, [], "removeWhere"],
      retainWhere$1: [function(receiver, test) {
        this._collection$_filter$2(receiver, test, true);
      }, "call$1", "get$retainWhere", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "ListMixin");
      }, 11, [], "retainWhere"],
      _collection$_filter$2: [function(receiver, test, retainMatching) {
        var retained, $length, i, element;
        retained = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
        $length = this.get$length(receiver);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          element = this.$index(receiver, i);
          if (J.$eq$(test.call$1(element), retainMatching))
            retained.push(element);
          if ($length !== this.get$length(receiver))
            throw H.wrapException(new P.ConcurrentModificationError(receiver));
        }
        if (retained.length !== this.get$length(receiver)) {
          this.setRange$3(receiver, 0, retained.length, retained);
          this.set$length(receiver, retained.length);
        }
      }, "call$2", "get$_collection$_filter", 4, 0, 1256, 11, [], 757, [], "_collection$_filter"],
      clear$0: [function(receiver) {
        this.set$length(receiver, 0);
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      removeLast$0: [function(receiver) {
        var result;
        if (J.$eq$(this.get$length(receiver), 0))
          throw H.wrapException(H.IterableElementError_noElement());
        result = this.$index(receiver, J.$sub$n(this.get$length(receiver), 1));
        this.set$length(receiver, J.$sub$n(this.get$length(receiver), 1));
        return result;
      }, "call$0", "get$removeLast", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "ListMixin");
      }, "removeLast"],
      sort$1: [function(receiver, compare) {
        var t1 = compare == null ? P.collection_ListMixin__compareAny$closure() : compare;
        H.Sort__doSort(receiver, 0, J.$sub$n(this.get$length(receiver), 1), t1);
      }, function($receiver) {
        return this.sort$1($receiver, null);
      }, "sort$0", "call$1", "call$0", "get$sort", 0, 2, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, opt: [{func: 1, ret: P.int, args: [E, E]}]};
        }, this.$receiver, "ListMixin");
      }, 0, 116, [], "sort"],
      shuffle$1: [function(receiver, random) {
        var $length, t1, pos, tmp;
        if (random == null)
          random = C.C__JSRandom;
        $length = this.get$length(receiver);
        for (; t1 = J.getInterceptor$n($length), t1.$gt($length, 1);) {
          pos = random.nextInt$1($length);
          $length = t1.$sub($length, 1);
          tmp = this.$index(receiver, $length);
          this.$indexSet(receiver, $length, this.$index(receiver, pos));
          this.$indexSet(receiver, pos, tmp);
        }
      }, function($receiver) {
        return this.shuffle$1($receiver, null);
      }, "shuffle$0", "call$1", "call$0", "get$shuffle", 0, 2, 304, 0, 390, [], "shuffle"],
      asMap$0: [function(receiver) {
        return new H.ListMapView(receiver, [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
      }, "call$0", "get$asMap", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Map, P.int, E]};
        }, this.$receiver, "ListMixin");
      }, "asMap"],
      sublist$2: [function(receiver, start, end) {
        var listLength, $length, result, t1, i, t2;
        listLength = this.get$length(receiver);
        if (end == null)
          end = listLength;
        P.RangeError_checkValidRange(start, end, listLength, null, null, null);
        $length = J.$sub$n(end, start);
        result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
        C.JSArray_methods.set$length(result, $length);
        if (typeof $length !== "number")
          return H.iae($length);
        t1 = J.getInterceptor$ns(start);
        i = 0;
        for (; i < $length; ++i) {
          t2 = this.$index(receiver, t1.$add(start, i));
          if (i >= result.length)
            return H.ioore(result, i);
          result[i] = t2;
        }
        return result;
      }, function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      }, "sublist$1", "call$2", "call$1", "get$sublist", 2, 2, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.List, E], args: [P.int], opt: [P.int]};
        }, this.$receiver, "ListMixin");
      }, 0, 3, [], 5, [], "sublist"],
      getRange$2: [function(receiver, start, end) {
        P.RangeError_checkValidRange(start, end, this.get$length(receiver), null, null, null);
        return H.SubListIterable$(receiver, start, end, H.getRuntimeTypeArgument(receiver, "ListMixin", 0));
      }, "call$2", "get$getRange", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [P.int, P.int]};
        }, this.$receiver, "ListMixin");
      }, 3, [], 5, [], "getRange"],
      removeRange$2: [function(receiver, start, end) {
        var $length;
        P.RangeError_checkValidRange(start, end, this.get$length(receiver), null, null, null);
        $length = J.$sub$n(end, start);
        this.setRange$4(receiver, start, J.$sub$n(this.get$length(receiver), $length), receiver, end);
        this.set$length(receiver, J.$sub$n(this.get$length(receiver), $length));
      }, "call$2", "get$removeRange", 4, 0, 76, 3, [], 5, [], "removeRange"],
      fillRange$3: [function(receiver, start, end, fill) {
        var i, t1;
        P.RangeError_checkValidRange(start, end, this.get$length(receiver), null, null, null);
        for (i = start; t1 = J.getInterceptor$n(i), t1.$lt(i, end); i = t1.$add(i, 1))
          this.$indexSet(receiver, i, fill);
      }, function($receiver, start, end) {
        return this.fillRange$3($receiver, start, end, null);
      }, "fillRange$2", "call$3", "call$2", "get$fillRange", 4, 2, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [P.int, P.int], opt: [E]};
        }, this.$receiver, "ListMixin");
      }, 0, 3, [], 5, [], 459, [], "fillRange"],
      setRange$4: ["super$ListMixin$setRange", function(receiver, start, end, iterable, skipCount) {
        var $length, t1, otherStart, otherList, t2, t3, i, t4;
        P.RangeError_checkValidRange(start, end, this.get$length(receiver), null, null, null);
        $length = J.$sub$n(end, start);
        t1 = J.getInterceptor($length);
        if (t1.$eq($length, 0))
          return;
        if (J.$lt$n(skipCount, 0))
          H.throwExpression(P.RangeError$range(skipCount, 0, null, "skipCount", null));
        if (H.checkSubtype(iterable, "$isList", [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)], "$asList")) {
          otherStart = skipCount;
          otherList = iterable;
        } else {
          otherList = J.skip$1$ax(iterable, skipCount).toList$1$growable(0, false);
          otherStart = 0;
        }
        t2 = J.getInterceptor$ns(otherStart);
        t3 = J.getInterceptor$asx(otherList);
        if (J.$gt$n(t2.$add(otherStart, $length), t3.get$length(otherList)))
          throw H.wrapException(H.IterableElementError_tooFew());
        if (t2.$lt(otherStart, start))
          for (i = t1.$sub($length, 1), t1 = J.getInterceptor$ns(start); t4 = J.getInterceptor$n(i), t4.$ge(i, 0); i = t4.$sub(i, 1))
            this.$indexSet(receiver, t1.$add(start, i), t3.$index(otherList, t2.$add(otherStart, i)));
        else {
          if (typeof $length !== "number")
            return H.iae($length);
          t1 = J.getInterceptor$ns(start);
          i = 0;
          for (; i < $length; ++i)
            this.$indexSet(receiver, t1.$add(start, i), t3.$index(otherList, t2.$add(otherStart, i)));
        }
      }, function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      }, "setRange$3", "call$4", "call$3", "get$setRange", 6, 2, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [P.int, P.int, [P.Iterable, E]], opt: [P.int]};
        }, this.$receiver, "ListMixin");
      }, 7, 3, [], 5, [], 42, [], 197, [], "setRange"],
      replaceRange$3: [function(receiver, start, end, newContents) {
        var t1, removeLength, insertLength, t2, delta, insertEnd, newLength;
        P.RangeError_checkValidRange(start, end, this.get$length(receiver), null, null, null);
        t1 = J.getInterceptor(newContents);
        if (!t1.$isEfficientLengthIterable)
          newContents = t1.toList$0(newContents);
        removeLength = J.$sub$n(end, start);
        insertLength = J.get$length$asx(newContents);
        t1 = J.getInterceptor$n(removeLength);
        t2 = J.getInterceptor$ns(start);
        if (t1.$ge(removeLength, insertLength)) {
          delta = t1.$sub(removeLength, insertLength);
          insertEnd = t2.$add(start, insertLength);
          newLength = J.$sub$n(this.get$length(receiver), delta);
          this.setRange$3(receiver, start, insertEnd, newContents);
          if (!J.$eq$(delta, 0)) {
            this.setRange$4(receiver, insertEnd, newLength, receiver, end);
            this.set$length(receiver, newLength);
          }
        } else {
          delta = J.$sub$n(insertLength, removeLength);
          newLength = J.$add$ns(this.get$length(receiver), delta);
          insertEnd = t2.$add(start, insertLength);
          this.set$length(receiver, newLength);
          this.setRange$4(receiver, insertEnd, newLength, receiver, end);
          this.setRange$3(receiver, start, insertEnd, newContents);
        }
      }, "call$3", "get$replaceRange", 6, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [P.int, P.int, [P.Iterable, E]]};
        }, this.$receiver, "ListMixin");
      }, 3, [], 5, [], 756, [], "replaceRange"],
      indexOf$2: [function(receiver, element, startIndex) {
        var t1, i;
        t1 = J.getInterceptor$n(startIndex);
        if (t1.$ge(startIndex, this.get$length(receiver)))
          return -1;
        if (t1.$lt(startIndex, 0))
          startIndex = 0;
        for (i = startIndex; t1 = J.getInterceptor$n(i), t1.$lt(i, this.get$length(receiver)); i = t1.$add(i, 1))
          if (J.$eq$(this.$index(receiver, i), element))
            return i;
        return -1;
      }, function($receiver, element) {
        return this.indexOf$2($receiver, element, 0);
      }, "indexOf$1", "call$2", "call$1", "get$indexOf", 2, 2, 222, 7, 31, [], 102, [], "indexOf"],
      lastIndexOf$2: [function(receiver, element, startIndex) {
        var t1, i;
        if (startIndex == null)
          startIndex = J.$sub$n(this.get$length(receiver), 1);
        else {
          t1 = J.getInterceptor$n(startIndex);
          if (t1.$lt(startIndex, 0))
            return -1;
          if (t1.$ge(startIndex, this.get$length(receiver)))
            startIndex = J.$sub$n(this.get$length(receiver), 1);
        }
        for (i = startIndex; t1 = J.getInterceptor$n(i), t1.$ge(i, 0); i = t1.$sub(i, 1))
          if (J.$eq$(this.$index(receiver, i), element))
            return i;
        return -1;
      }, function($receiver, element) {
        return this.lastIndexOf$2($receiver, element, null);
      }, "lastIndexOf$1", "call$2", "call$1", "get$lastIndexOf", 2, 2, 222, 0, 31, [], 102, [], "lastIndexOf"],
      insert$2: [function(receiver, index, element) {
        P.RangeError_checkValueInInterval(index, 0, this.get$length(receiver), "index", null);
        if (J.$eq$(index, this.get$length(receiver))) {
          this.add$1(receiver, element);
          return;
        }
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(P.ArgumentError$(index));
        this.set$length(receiver, J.$add$ns(this.get$length(receiver), 1));
        this.setRange$4(receiver, index + 1, this.get$length(receiver), receiver, index);
        this.$indexSet(receiver, index, element);
      }, "call$2", "get$insert", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [P.int, E]};
        }, this.$receiver, "ListMixin");
      }, 14, [], 31, [], "insert"],
      removeAt$1: [function(receiver, index) {
        var result = this.$index(receiver, index);
        this.setRange$4(receiver, index, J.$sub$n(this.get$length(receiver), 1), receiver, J.$add$ns(index, 1));
        this.set$length(receiver, J.$sub$n(this.get$length(receiver), 1));
        return result;
      }, "call$1", "get$removeAt", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [P.int]};
        }, this.$receiver, "ListMixin");
      }, 14, [], "removeAt"],
      insertAll$2: [function(receiver, index, iterable) {
        var t1, insertionLength;
        P.RangeError_checkValueInInterval(index, 0, this.get$length(receiver), "index", null);
        t1 = J.getInterceptor(iterable);
        if (!t1.$isEfficientLengthIterable || iterable === receiver)
          iterable = t1.toList$0(iterable);
        t1 = J.getInterceptor$asx(iterable);
        insertionLength = t1.get$length(iterable);
        this.set$length(receiver, J.$add$ns(this.get$length(receiver), insertionLength));
        if (!J.$eq$(t1.get$length(iterable), insertionLength)) {
          this.set$length(receiver, J.$sub$n(this.get$length(receiver), insertionLength));
          throw H.wrapException(new P.ConcurrentModificationError(iterable));
        }
        this.setRange$4(receiver, J.$add$ns(index, insertionLength), this.get$length(receiver), receiver, index);
        this.setAll$2(receiver, index, iterable);
      }, "call$2", "get$insertAll", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [P.int, [P.Iterable, E]]};
        }, this.$receiver, "ListMixin");
      }, 14, [], 42, [], "insertAll"],
      setAll$2: [function(receiver, index, iterable) {
        var t1, element, index0;
        t1 = J.getInterceptor(iterable);
        if (!!t1.$isList)
          this.setRange$3(receiver, index, J.$add$ns(index, t1.get$length(iterable)), iterable);
        else
          for (t1 = t1.get$iterator(iterable); t1.moveNext$0(); index = index0) {
            element = t1.get$current();
            index0 = J.$add$ns(index, 1);
            this.$indexSet(receiver, index, element);
          }
      }, "call$2", "get$setAll", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [P.int, [P.Iterable, E]]};
        }, this.$receiver, "ListMixin");
      }, 14, [], 42, [], "setAll"],
      get$reversed: [function(receiver) {
        return new H.ReversedListIterable(receiver, [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E]};
        }, this.$receiver, "ListMixin");
      }, "reversed"],
      toString$0: [function(receiver) {
        return P.IterableBase_iterableToFullString(receiver, "[", "]");
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isList: 1,
      $asList: null,
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: null,
      $isIterable: 1,
      $asIterable: null,
      "<>": [584],
      static: {
        ListMixin$: [function($E) {
          return new P.ListMixin([$E]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.ListMixin, E]};
          }, this.$receiver, "ListMixin");
        }, "new ListMixin"],
        ListMixin__compareAny: [function(a, b) {
          return J.compareTo$1$ns(a, b);
        }, "call$2", "collection_ListMixin__compareAny$closure", 4, 0, 393, 87, [], 78, [], "_compareAny"]
      }
    },
    "+ListMixin": [1, 1306],
    MapBase: {
      "^": "Object+MapMixin;$ti",
      $asMap: null,
      $isMap: 1,
      "<>": [527, 526],
      static: {
        MapBase$: [function($K, $V) {
          return new P.MapBase([$K, $V]);
        }, null, null, 0, 0, 4, "new MapBase"]
      }
    },
    "+MapBase": [1, 1307],
    MapMixin: {
      "^": "Object;$ti",
      forEach$1: [function(_, action) {
        var t1, key;
        for (t1 = this.get$keys(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
          key = t1.get$current();
          action.call$2(key, this.$index(0, key));
        }
      }, "call$1", "get$forEach", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, v: true, args: [{func: 1, v: true, args: [K, V]}]};
        }, this.$receiver, "MapMixin");
      }, 71, [], "forEach"],
      addAll$1: [function(_, other) {
        var t1, t2, key;
        for (t1 = other.get$keys(), t1 = t1.get$iterator(t1), t2 = J.getInterceptor$asx(other); t1.moveNext$0();) {
          key = t1.get$current();
          this.$indexSet(0, key, t2.$index(other, key));
        }
      }, "call$1", "get$addAll", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, v: true, args: [[P.Map, K, V]]};
        }, this.$receiver, "MapMixin");
      }, 2, [], "addAll"],
      containsValue$1: [function(value) {
        var t1;
        for (t1 = this.get$keys(), t1 = t1.get$iterator(t1); t1.moveNext$0();)
          this.$index(0, t1.get$current());
        return false;
      }, "call$1", "get$containsValue", 2, 0, 15, 1, [], "containsValue"],
      putIfAbsent$2: [function(key, ifAbsent) {
        var t1;
        if (this.containsKey$1(key))
          return this.$index(0, key);
        t1 = ifAbsent.call$0();
        this.$indexSet(0, key, t1);
        return t1;
      }, "call$2", "get$putIfAbsent", 4, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V, args: [K, {func: 1, ret: V}]};
        }, this.$receiver, "MapMixin");
      }, 6, [], 85, [], "putIfAbsent"],
      containsKey$1: [function(key) {
        return this.get$keys().contains$1(0, key);
      }, "call$1", "get$containsKey", 2, 0, 15, 6, [], "containsKey"],
      get$length: [function(_) {
        var t1 = this.get$keys();
        return t1.get$length(t1);
      }, null, null, 1, 0, 11, "length"],
      get$isEmpty: [function(_) {
        var t1 = this.get$keys();
        return t1.get$isEmpty(t1);
      }, null, null, 1, 0, 5, "isEmpty"],
      get$isNotEmpty: [function(_) {
        var t1 = this.get$keys();
        return t1.get$isNotEmpty(t1);
      }, null, null, 1, 0, 5, "isNotEmpty"],
      get$values: [function() {
        return new P._MapBaseValueIterable(this, [H.getRuntimeTypeArgument(this, "MapMixin", 0), H.getRuntimeTypeArgument(this, "MapMixin", 1)]);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: [P.Iterable, V]};
        }, this.$receiver, "MapMixin");
      }, "values"],
      toString$0: [function(_) {
        return P.Maps_mapToString(this);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $isMap: 1,
      "<>": [525, 522],
      static: {
        MapMixin$: [function($K, $V) {
          return new P.MapMixin([$K, $V]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, ret: [P.MapMixin, K, V]};
          }, this.$receiver, "MapMixin");
        }, "new MapMixin"]
      }
    },
    "+MapMixin": [1, 1308],
    UnmodifiableMapBase: {
      "^": "MapBase+_UnmodifiableMapMixin;$ti",
      $asMap: null,
      $isMap: 1,
      "<>": [411, 325],
      static: {
        UnmodifiableMapBase$: [function($K, $V) {
          return new P.UnmodifiableMapBase([$K, $V]);
        }, null, null, 0, 0, 4, "new UnmodifiableMapBase"]
      }
    },
    "+UnmodifiableMapBase": [1309, 1310],
    _MapBaseValueIterable: {
      "^": "EfficientLengthIterable;_collection$_map<-1311,$ti",
      get$length: [function(_) {
        return J.get$length$asx(this._collection$_map);
      }, null, null, 1, 0, 11, "length"],
      get$isEmpty: [function(_) {
        return J.get$isEmpty$asx(this._collection$_map);
      }, null, null, 1, 0, 5, "isEmpty"],
      get$isNotEmpty: [function(_) {
        return J.get$isNotEmpty$asx(this._collection$_map);
      }, null, null, 1, 0, 5, "isNotEmpty"],
      get$first: [function(_) {
        var t1, t2;
        t1 = this._collection$_map;
        t2 = t1.get$keys();
        return J.$index$asx(t1, t2.get$first(t2));
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V};
        }, this.$receiver, "_MapBaseValueIterable");
      }, "first"],
      get$single: [function(_) {
        var t1, t2;
        t1 = this._collection$_map;
        t2 = t1.get$keys();
        return J.$index$asx(t1, t2.get$single(t2));
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V};
        }, this.$receiver, "_MapBaseValueIterable");
      }, "single"],
      get$last: [function(_) {
        var t1, t2;
        t1 = this._collection$_map;
        t2 = t1.get$keys();
        return J.$index$asx(t1, t2.get$last(t2));
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V};
        }, this.$receiver, "_MapBaseValueIterable");
      }, "last"],
      get$iterator: [function(_) {
        var t1, t2;
        t1 = this._collection$_map;
        t2 = t1.get$keys();
        return new P._MapBaseValueIterator(t2.get$iterator(t2), t1, null, this.$ti);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: [P.Iterator, V]};
        }, this.$receiver, "_MapBaseValueIterable");
      }, "iterator"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $asEfficientLengthIterable: function($K, $V) {
        return [$V];
      },
      $asIterable: function($K, $V) {
        return [$V];
      },
      "<>": [554, 323],
      static: {
        _MapBaseValueIterable$: [function(_map, $K, $V) {
          return new P._MapBaseValueIterable(_map, [$K, $V]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, args: [[P.Map, K, V]]};
          }, this.$receiver, "_MapBaseValueIterable");
        }, 341, [], "new _MapBaseValueIterable"]
      }
    },
    "+_MapBaseValueIterable": [1312],
    _MapBaseValueIterator: {
      "^": "Object;_keys<-1313,_collection$_map<-1314,_collection$_current@-1315,$ti",
      moveNext$0: [function() {
        var t1 = this._keys;
        if (t1.moveNext$0() === true) {
          this._collection$_current = J.$index$asx(this._collection$_map, t1.get$current());
          return true;
        }
        this._collection$_current = null;
        return false;
      }, "call$0", "get$moveNext", 0, 0, 5, "moveNext"],
      get$current: [function() {
        return this._collection$_current;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V};
        }, this.$receiver, "_MapBaseValueIterator");
      }, "current"],
      "<>": [319, 249],
      static: {
        _MapBaseValueIterator$: [function(map, $K, $V) {
          var t1 = map.get$keys();
          return new P._MapBaseValueIterator(t1.get$iterator(t1), map, null, [$K, $V]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, args: [[P.Map, K, V]]};
          }, this.$receiver, "_MapBaseValueIterator");
        }, 55, [], "new _MapBaseValueIterator"]
      }
    },
    "+_MapBaseValueIterator": [1, 1316],
    _UnmodifiableMapMixin: {
      "^": "Object;$ti",
      $indexSet: [function(_, key, value) {
        throw H.wrapException(new P.UnsupportedError("Cannot modify unmodifiable map"));
      }, null, "get$[]=", 4, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, v: true, args: [K, V]};
        }, this.$receiver, "_UnmodifiableMapMixin");
      }, 6, [], 1, [], "[]="],
      addAll$1: [function(_, other) {
        throw H.wrapException(new P.UnsupportedError("Cannot modify unmodifiable map"));
      }, "call$1", "get$addAll", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, v: true, args: [[P.Map, K, V]]};
        }, this.$receiver, "_UnmodifiableMapMixin");
      }, 2, [], "addAll"],
      clear$0: [function(_) {
        throw H.wrapException(new P.UnsupportedError("Cannot modify unmodifiable map"));
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      remove$1: [function(_, key) {
        throw H.wrapException(new P.UnsupportedError("Cannot modify unmodifiable map"));
      }, "call$1", "get$remove", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V, args: [P.Object]};
        }, this.$receiver, "_UnmodifiableMapMixin");
      }, 6, [], "remove"],
      putIfAbsent$2: [function(key, ifAbsent) {
        throw H.wrapException(new P.UnsupportedError("Cannot modify unmodifiable map"));
      }, "call$2", "get$putIfAbsent", 4, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V, args: [K, {func: 1, ret: V}]};
        }, this.$receiver, "_UnmodifiableMapMixin");
      }, 6, [], 85, [], "putIfAbsent"],
      $isMap: 1,
      "<>": [481, 479],
      static: {
        _UnmodifiableMapMixin$: [function($K, $V) {
          return new P._UnmodifiableMapMixin([$K, $V]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, ret: [P._UnmodifiableMapMixin, K, V]};
          }, this.$receiver, "_UnmodifiableMapMixin");
        }, "new _UnmodifiableMapMixin"]
      }
    },
    "+_UnmodifiableMapMixin": [1, 1317],
    MapView: {
      "^": "Object;_collection$_map<-202,$ti",
      $index: [function(_, key) {
        return J.$index$asx(this._collection$_map, key);
      }, null, "get$[]", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V, args: [P.Object]};
        }, this.$receiver, "MapView");
      }, 6, [], "[]"],
      $indexSet: [function(_, key, value) {
        J.$indexSet$ax(this._collection$_map, key, value);
      }, null, "get$[]=", 4, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, v: true, args: [K, V]};
        }, this.$receiver, "MapView");
      }, 6, [], 1, [], "[]="],
      addAll$1: [function(_, other) {
        J.addAll$1$ax(this._collection$_map, other);
      }, "call$1", "get$addAll", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, v: true, args: [[P.Map, K, V]]};
        }, this.$receiver, "MapView");
      }, 2, [], "addAll"],
      clear$0: [function(_) {
        J.clear$0$ax(this._collection$_map);
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      putIfAbsent$2: [function(key, ifAbsent) {
        return this._collection$_map.putIfAbsent$2(key, ifAbsent);
      }, "call$2", "get$putIfAbsent", 4, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V, args: [K, {func: 1, ret: V}]};
        }, this.$receiver, "MapView");
      }, 6, [], 85, [], "putIfAbsent"],
      containsKey$1: [function(key) {
        return this._collection$_map.containsKey$1(key);
      }, "call$1", "get$containsKey", 2, 0, 15, 6, [], "containsKey"],
      containsValue$1: [function(value) {
        return this._collection$_map.containsValue$1(value);
      }, "call$1", "get$containsValue", 2, 0, 15, 1, [], "containsValue"],
      forEach$1: [function(_, action) {
        J.forEach$1$ax(this._collection$_map, action);
      }, "call$1", "get$forEach", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, v: true, args: [{func: 1, v: true, args: [K, V]}]};
        }, this.$receiver, "MapView");
      }, 71, [], "forEach"],
      get$isEmpty: [function(_) {
        return J.get$isEmpty$asx(this._collection$_map);
      }, null, null, 1, 0, 5, "isEmpty"],
      get$isNotEmpty: [function(_) {
        return J.get$isNotEmpty$asx(this._collection$_map);
      }, null, null, 1, 0, 5, "isNotEmpty"],
      get$length: [function(_) {
        return J.get$length$asx(this._collection$_map);
      }, null, null, 1, 0, 11, "length"],
      get$keys: [function() {
        return this._collection$_map.get$keys();
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: [P.Iterable, K]};
        }, this.$receiver, "MapView");
      }, "keys"],
      remove$1: [function(_, key) {
        return J.remove$1$ax(this._collection$_map, key);
      }, "call$1", "get$remove", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V, args: [P.Object]};
        }, this.$receiver, "MapView");
      }, 6, [], "remove"],
      toString$0: [function(_) {
        return J.toString$0$(this._collection$_map);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      get$values: [function() {
        return this._collection$_map.get$values();
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: [P.Iterable, V]};
        }, this.$receiver, "MapView");
      }, "values"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $isMap: 1,
      "<>": [514, 504],
      static: {
        MapView$: [function(map, $K, $V) {
          return new P.MapView(map, [$K, $V]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, args: [[P.Map, K, V]]};
          }, this.$receiver, "MapView");
        }, 55, [], "new MapView"]
      }
    },
    "+MapView": [1, 202],
    UnmodifiableMapView: {
      "^": "MapView+_UnmodifiableMapMixin;_collection$_map-202,$ti",
      $asMap: null,
      $isMap: 1,
      "<>": [320, 321],
      static: {
        UnmodifiableMapView$: [function(map, $K, $V) {
          return new P.UnmodifiableMapView(map, [$K, $V]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, args: [[P.Map, K, V]]};
          }, this.$receiver, "MapView");
        }, 55, [], "new UnmodifiableMapView"]
      }
    },
    "+UnmodifiableMapView": [1318, 1319],
    Maps: {
      "^": "Object;",
      static: {
        Maps$: [function() {
          return new P.Maps();
        }, null, null, 0, 0, 606, "new Maps"],
        Maps_containsValue: [function(map, value) {
          var t1;
          for (t1 = map.get$values(), t1 = t1.get$iterator(t1); t1.moveNext$0();)
            if (J.$eq$(t1.get$current(), value))
              return true;
          return false;
        }, "call$2", "collection_Maps_containsValue$closure", 4, 0, 394, 55, [], 1, [], "containsValue"],
        Maps_containsKey: [function(map, key) {
          var t1;
          for (t1 = map.get$keys(), t1 = t1.get$iterator(t1); t1.moveNext$0();)
            if (J.$eq$(t1.get$current(), key))
              return true;
          return false;
        }, "call$2", "collection_Maps_containsKey$closure", 4, 0, 394, 55, [], 6, [], "containsKey"],
        Maps_putIfAbsent: [function(map, key, ifAbsent) {
          var v;
          if (map.containsKey$1(key))
            return J.$index$asx(map, key);
          v = ifAbsent.call$0();
          J.$indexSet$ax(map, key, v);
          return v;
        }, "call$3", "collection_Maps_putIfAbsent$closure", 6, 0, 608, 55, [], 6, [], 85, [], "putIfAbsent"],
        Maps_clear: [function(map) {
          var t1, t2, t3, _i;
          for (t1 = map.get$keys().toList$0(0), t2 = t1.length, t3 = J.getInterceptor$ax(map), _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
            t3.remove$1(map, t1[_i]);
        }, "call$1", "collection_Maps_clear$closure", 2, 0, 367, 55, [], "clear"],
        Maps_forEach: [function(map, f) {
          var t1, t2, k;
          for (t1 = map.get$keys(), t1 = t1.get$iterator(t1), t2 = J.getInterceptor$asx(map); t1.moveNext$0();) {
            k = t1.get$current();
            f.call$2(k, t2.$index(map, k));
          }
        }, "call$2", "collection_Maps_forEach$closure", 4, 0, 609, 55, [], 9, [], "forEach"],
        Maps_getValues: [function(map) {
          return map.get$keys().map$1(0, new P.Maps_getValues_closure(map));
        }, "call$1", "collection_Maps_getValues$closure", 2, 0, 610, 55, [], "getValues"],
        Maps_length: [function(map) {
          var t1 = map.get$keys();
          return t1.get$length(t1);
        }, "call$1", "collection_Maps_length$closure", 2, 0, 611, 55, [], "length"],
        Maps_isEmpty: [function(map) {
          var t1 = map.get$keys();
          return t1.get$isEmpty(t1);
        }, "call$1", "collection_Maps_isEmpty$closure", 2, 0, 214, 55, [], "isEmpty"],
        Maps_isNotEmpty: [function(map) {
          var t1 = map.get$keys();
          return t1.get$isNotEmpty(t1);
        }, "call$1", "collection_Maps_isNotEmpty$closure", 2, 0, 214, 55, [], "isNotEmpty"],
        Maps_mapToString: [function(m) {
          var t1, result, t2;
          t1 = {};
          if (P._isToStringVisiting(m))
            return "{...}";
          result = new P.StringBuffer("");
          try {
            $.$get$_toStringVisiting().push(m);
            t2 = result;
            t2.set$_contents(t2.get$_contents() + "{");
            t1.first = true;
            J.forEach$1$ax(m, new P.Maps_mapToString_closure(t1, result));
            t1 = result;
            t1.set$_contents(t1.get$_contents() + "}");
          } finally {
            t1 = $.$get$_toStringVisiting();
            if (0 >= t1.length)
              return H.ioore(t1, -1);
            t1.pop();
          }
          t1 = result.get$_contents();
          return t1.charCodeAt(0) == 0 ? t1 : t1;
        }, "call$1", "collection_Maps_mapToString$closure", 2, 0, 395, 173, [], "mapToString"],
        Maps__id: [function(x) {
          return x;
        }, "call$1", "collection_Maps__id$closure", 2, 0, 3, 38, [], "_collection$_id"],
        Maps__fillMapWithMappedIterable: [function(map, iterable, key, value) {
          var t1, t2, element;
          if (key == null)
            key = P.collection_Maps__id$closure();
          if (value == null)
            value = P.collection_Maps__id$closure();
          for (t1 = J.get$iterator$ax(iterable), t2 = J.getInterceptor$ax(map); t1.moveNext$0();) {
            element = t1.get$current();
            t2.$indexSet(map, key.call$1(element), value.call$1(element));
          }
        }, "call$4", "collection_Maps__fillMapWithMappedIterable$closure", 8, 0, 613, 55, [], 42, [], 6, [], 1, [], "_fillMapWithMappedIterable"],
        Maps__fillMapWithIterables: [function(map, keys, values) {
          var keyIterator, valueIterator, hasNextKey, hasNextValue, t1;
          keyIterator = J.get$iterator$ax(keys);
          valueIterator = J.get$iterator$ax(values);
          hasNextKey = keyIterator.moveNext$0();
          hasNextValue = valueIterator.moveNext$0();
          t1 = J.getInterceptor$ax(map);
          while (true) {
            if (!(hasNextKey && hasNextValue))
              break;
            t1.$indexSet(map, keyIterator.get$current(), valueIterator.get$current());
            hasNextKey = keyIterator.moveNext$0();
            hasNextValue = valueIterator.moveNext$0();
          }
          if (hasNextKey || hasNextValue)
            throw H.wrapException(P.ArgumentError$("Iterables do not have same length."));
        }, "call$3", "collection_Maps__fillMapWithIterables$closure", 6, 0, 614, 55, [], 177, [], 166, [], "_fillMapWithIterables"]
      }
    },
    "+Maps": [1],
    Maps_getValues_closure: {
      "^": "Closure:3;map",
      call$1: [function(key) {
        return J.$index$asx(this.map, key);
      }, null, null, 2, 0, 3, 6, [], "call"]
    },
    "+ Maps_getValues_closure": [2],
    Maps_mapToString_closure: {
      "^": "Closure:12;_box_0,result",
      call$2: [function(k, v) {
        var t1, t2;
        t1 = this._box_0;
        if (!t1.first)
          this.result._contents += ", ";
        t1.first = false;
        t1 = this.result;
        t2 = t1._contents += H.S(k);
        t1._contents = t2 + ": ";
        t1._contents += H.S(v);
      }, null, null, 4, 0, 12, 274, [], 56, [], "call"]
    },
    "+ Maps_mapToString_closure": [2],
    Queue: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: null,
      $isIterable: 1,
      $asIterable: null,
      "<>": [626],
      static: {
        Queue_Queue: [function($E) {
          return P.ListQueue$(null, $E);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.Queue, E]};
          }, this.$receiver, "Queue");
        }, "new Queue"],
        Queue_Queue$from: [function(elements, $E) {
          return P.ListQueue_ListQueue$from(elements, $E);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.Queue, E], args: [P.Iterable]};
          }, this.$receiver, "Queue");
        }, 35, [], "new Queue$from"]
      }
    },
    "+Queue": [1, 1320],
    _DoubleLink: {
      "^": "Object;_previousLink@-67,_nextLink@-67,$ti",
      _link$2: [function(previous, next) {
        this._nextLink = next;
        this._previousLink = previous;
        if (previous != null)
          previous.set$_nextLink(this);
        if (next != null)
          next.set$_previousLink(this);
      }, "call$2", "get$_link", 4, 0, function() {
        return H.computeSignature(function(Link) {
          return {func: 1, v: true, args: [Link, Link]};
        }, this.$receiver, "_DoubleLink");
      }, 340, [], 461, [], "_link"],
      _unlink$0: [function() {
        var t1 = this._previousLink;
        if (t1 != null)
          t1.set$_nextLink(this._nextLink);
        t1 = this._nextLink;
        if (t1 != null)
          t1.set$_previousLink(this._previousLink);
        this._nextLink = null;
        this._previousLink = null;
      }, "call$0", "get$_unlink", 0, 0, 6, "_unlink"],
      "<>": [563],
      static: {
        _DoubleLink$: [function($Link) {
          return new P._DoubleLink(null, null, [$Link]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(Link) {
            return {func: 1, ret: [P._DoubleLink, Link]};
          }, this.$receiver, "_DoubleLink");
        }, "new _DoubleLink"]
      }
    },
    "+_DoubleLink": [1],
    DoubleLinkedQueueEntry: {
      "^": "_DoubleLink;element@-230,_previousLink-67,_nextLink-67,$ti",
      append$1: [function(e) {
        new P.DoubleLinkedQueueEntry(e, null, null, this.$ti)._link$2(this, this._nextLink);
      }, "call$1", "get$append", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [E]};
        }, this.$receiver, "DoubleLinkedQueueEntry");
      }, 47, [], "append"],
      prepend$1: [function(e) {
        new P.DoubleLinkedQueueEntry(e, null, null, this.$ti)._link$2(this._previousLink, this);
      }, "call$1", "get$prepend", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [E]};
        }, this.$receiver, "DoubleLinkedQueueEntry");
      }, 47, [], "prepend"],
      remove$0: [function(_) {
        this._unlink$0();
        return this.element;
      }, "call$0", "get$remove", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "DoubleLinkedQueueEntry");
      }, "remove"],
      previousEntry$0: [function() {
        return this._previousLink;
      }, "call$0", "get$previousEntry", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.DoubleLinkedQueueEntry, E]};
        }, this.$receiver, "DoubleLinkedQueueEntry");
      }, "previousEntry"],
      nextEntry$0: [function() {
        return this._nextLink;
      }, "call$0", "get$nextEntry", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.DoubleLinkedQueueEntry, E]};
        }, this.$receiver, "DoubleLinkedQueueEntry");
      }, "nextEntry"],
      $as_DoubleLink: function($E) {
        return [[P.DoubleLinkedQueueEntry, $E]];
      },
      "<>": [318],
      static: {
        DoubleLinkedQueueEntry$: [function(element, $E) {
          return new P.DoubleLinkedQueueEntry(element, null, null, [$E]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, args: [E]};
          }, this.$receiver, "DoubleLinkedQueueEntry");
        }, 31, [], "new DoubleLinkedQueueEntry"]
      }
    },
    "+DoubleLinkedQueueEntry": [1323],
    _DoubleLinkedQueueEntry: {
      "^": "DoubleLinkedQueueEntry;_queue@-282,element-230,_previousLink-67,_nextLink-67,$ti",
      _append$1: [function(e) {
        new P._DoubleLinkedQueueElement(this._queue, e, null, null, this.$ti)._link$2(this, this._nextLink);
      }, "call$1", "get$_append", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [E]};
        }, this.$receiver, "_DoubleLinkedQueueEntry");
      }, 47, [], "_append"],
      _prepend$1: [function(e) {
        new P._DoubleLinkedQueueElement(this._queue, e, null, null, this.$ti)._link$2(this._previousLink, this);
      }, "call$1", "get$_prepend", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [E]};
        }, this.$receiver, "_DoubleLinkedQueueEntry");
      }, 47, [], "_prepend"],
      get$_element: [function() {
        return this.element;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "_DoubleLinkedQueueEntry");
      }, "_element"],
      nextEntry$0: [function() {
        return this._nextLink._asNonSentinelEntry$0();
      }, "call$0", "get$nextEntry", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.DoubleLinkedQueueEntry, E]};
        }, this.$receiver, "_DoubleLinkedQueueEntry");
      }, "nextEntry"],
      previousEntry$0: [function() {
        return this._previousLink._asNonSentinelEntry$0();
      }, "call$0", "get$previousEntry", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.DoubleLinkedQueueEntry, E]};
        }, this.$receiver, "_DoubleLinkedQueueEntry");
      }, "previousEntry"],
      "<>": [317],
      static: {
        _DoubleLinkedQueueEntry$: [function(element, _queue, $E) {
          return new P._DoubleLinkedQueueEntry(_queue, element, null, null, [$E]);
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, args: [E, [P.DoubleLinkedQueue, E]]};
          }, this.$receiver, "_DoubleLinkedQueueEntry");
        }, 31, [], 773, [], "new _DoubleLinkedQueueEntry"]
      }
    },
    "+_DoubleLinkedQueueEntry": [1325],
    _DoubleLinkedQueueElement: {
      "^": "_DoubleLinkedQueueEntry;_queue-282,element-230,_previousLink-67,_nextLink-67,$ti",
      append$1: [function(e) {
        var t1;
        new P._DoubleLinkedQueueElement(this._queue, e, null, null, this.$ti)._link$2(this, this._nextLink);
        t1 = this._queue;
        if (t1 != null)
          t1.set$_elementCount(J.$add$ns(t1.get$_elementCount(), 1));
      }, "call$1", "get$append", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [E]};
        }, this.$receiver, "_DoubleLinkedQueueElement");
      }, 47, [], "append"],
      prepend$1: [function(e) {
        var t1;
        new P._DoubleLinkedQueueElement(this._queue, e, null, null, this.$ti)._link$2(this._previousLink, this);
        t1 = this._queue;
        if (t1 != null)
          t1.set$_elementCount(J.$add$ns(t1.get$_elementCount(), 1));
      }, "call$1", "get$prepend", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [E]};
        }, this.$receiver, "_DoubleLinkedQueueElement");
      }, 47, [], "prepend"],
      _remove$0: [function() {
        this._queue = null;
        this._unlink$0();
        return this.element;
      }, "call$0", "get$_remove", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "_DoubleLinkedQueueElement");
      }, "_remove"],
      remove$0: [function(_) {
        var t1 = this._queue;
        if (t1 != null)
          t1.set$_elementCount(J.$sub$n(t1.get$_elementCount(), 1));
        this._queue = null;
        this._unlink$0();
        return this.element;
      }, "call$0", "get$remove", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "_DoubleLinkedQueueElement");
      }, "remove"],
      _asNonSentinelEntry$0: [function() {
        return this;
      }, "call$0", "get$_asNonSentinelEntry", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P._DoubleLinkedQueueElement, E]};
        }, this.$receiver, "_DoubleLinkedQueueElement");
      }, "_asNonSentinelEntry"],
      "<>": [562],
      static: {
        _DoubleLinkedQueueElement$: [function(element, queue, $E) {
          return new P._DoubleLinkedQueueElement(queue, element, null, null, [$E]);
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, args: [E, [P.DoubleLinkedQueue, E]]};
          }, this.$receiver, "_DoubleLinkedQueueElement");
        }, 31, [], 417, [], "new _DoubleLinkedQueueElement"]
      }
    },
    "+_DoubleLinkedQueueElement": [1326],
    _DoubleLinkedQueueSentinel: {
      "^": "_DoubleLinkedQueueEntry;_queue-282,element-230,_previousLink-67,_nextLink-67,$ti",
      _asNonSentinelEntry$0: [function() {
        return;
      }, "call$0", "get$_asNonSentinelEntry", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.DoubleLinkedQueueEntry, E]};
        }, this.$receiver, "_DoubleLinkedQueueSentinel");
      }, "_asNonSentinelEntry"],
      _remove$0: [function() {
        throw H.wrapException(H.IterableElementError_noElement());
      }, "call$0", "get$_remove", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "_DoubleLinkedQueueSentinel");
      }, "_remove"],
      get$_element: [function() {
        throw H.wrapException(H.IterableElementError_noElement());
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "_DoubleLinkedQueueSentinel");
      }, "_element"],
      "<>": [566],
      static: {
        _DoubleLinkedQueueSentinel$: [function(queue, $E) {
          var t1 = new P._DoubleLinkedQueueSentinel(queue, null, null, null, [$E]);
          t1._previousLink = t1;
          t1._nextLink = t1;
          return t1;
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, args: [[P.DoubleLinkedQueue, E]]};
          }, this.$receiver, "_DoubleLinkedQueueSentinel");
        }, 417, [], "new _DoubleLinkedQueueSentinel"]
      }
    },
    "+_DoubleLinkedQueueSentinel": [1327],
    DoubleLinkedQueue: {
      "^": "Iterable;_sentinel@-1328,_elementCount@-0,$ti",
      get$length: [function(_) {
        return this._elementCount;
      }, null, null, 1, 0, 11, "length"],
      addLast$1: [function(value) {
        this._sentinel._prepend$1(value);
        this._elementCount = J.$add$ns(this._elementCount, 1);
      }, "call$1", "get$addLast", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [E]};
        }, this.$receiver, "DoubleLinkedQueue");
      }, 1, [], "addLast"],
      addFirst$1: [function(value) {
        this._sentinel._append$1(value);
        this._elementCount = J.$add$ns(this._elementCount, 1);
      }, "call$1", "get$addFirst", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [E]};
        }, this.$receiver, "DoubleLinkedQueue");
      }, 1, [], "addFirst"],
      add$1: [function(_, value) {
        this._sentinel._prepend$1(value);
        this._elementCount = J.$add$ns(this._elementCount, 1);
      }, "call$1", "get$add", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [E]};
        }, this.$receiver, "DoubleLinkedQueue");
      }, 1, [], "add"],
      addAll$1: [function(_, iterable) {
        var t1, value;
        for (t1 = J.get$iterator$ax(iterable); t1.moveNext$0();) {
          value = t1.get$current();
          this._sentinel._prepend$1(value);
          this._elementCount = J.$add$ns(this._elementCount, 1);
        }
      }, "call$1", "get$addAll", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [[P.Iterable, E]]};
        }, this.$receiver, "DoubleLinkedQueue");
      }, 42, [], "addAll"],
      removeLast$0: [function(_) {
        var result = this._sentinel.get$_previousLink()._remove$0();
        this._elementCount = J.$sub$n(this._elementCount, 1);
        return result;
      }, "call$0", "get$removeLast", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "DoubleLinkedQueue");
      }, "removeLast"],
      removeFirst$0: [function() {
        var result = this._sentinel.get$_nextLink()._remove$0();
        this._elementCount = J.$sub$n(this._elementCount, 1);
        return result;
      }, "call$0", "get$removeFirst", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "DoubleLinkedQueue");
      }, "removeFirst"],
      remove$1: [function(_, o) {
        var entry, t1, equals;
        entry = this._sentinel.get$_nextLink();
        for (; t1 = this._sentinel, entry == null ? t1 != null : entry !== t1;) {
          equals = J.$eq$(entry.get$_element(), o);
          if (this !== entry.get$_queue())
            throw H.wrapException(new P.ConcurrentModificationError(this));
          if (equals) {
            entry._remove$0();
            this._elementCount = J.$sub$n(this._elementCount, 1);
            return true;
          }
          entry = entry.get$_nextLink();
        }
        return false;
      }, "call$1", "get$remove", 2, 0, 15, 96, [], "remove"],
      _collection$_filter$2: [function(_, test, removeMatching) {
        var entry, t1, matches, next;
        entry = this._sentinel.get$_nextLink();
        for (; t1 = this._sentinel, entry == null ? t1 != null : entry !== t1; entry = next) {
          matches = test.call$1(entry.get$_element());
          if (this !== entry.get$_queue())
            throw H.wrapException(new P.ConcurrentModificationError(this));
          next = entry.get$_nextLink();
          if (removeMatching == null ? matches == null : removeMatching === matches) {
            entry._remove$0();
            this._elementCount = J.$sub$n(this._elementCount, 1);
          }
        }
      }, "call$2", "get$_collection$_filter", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, ret: P.bool, args: [E]}, P.bool]};
        }, this.$receiver, "DoubleLinkedQueue");
      }, 11, [], 462, [], "_collection$_filter"],
      removeWhere$1: [function(_, test) {
        this._collection$_filter$2(0, test, true);
      }, "call$1", "get$removeWhere", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "DoubleLinkedQueue");
      }, 11, [], "removeWhere"],
      retainWhere$1: [function(_, test) {
        this._collection$_filter$2(0, test, false);
      }, "call$1", "get$retainWhere", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "DoubleLinkedQueue");
      }, 11, [], "retainWhere"],
      get$first: [function(_) {
        return this._sentinel.get$_nextLink().get$_element();
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "DoubleLinkedQueue");
      }, "first"],
      get$last: [function(_) {
        return this._sentinel.get$_previousLink().get$_element();
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "DoubleLinkedQueue");
      }, "last"],
      get$single: [function(_) {
        var t1, t2;
        t1 = this._sentinel.get$_nextLink();
        t2 = this._sentinel.get$_previousLink();
        if (t1 == null ? t2 == null : t1 === t2)
          return this._sentinel.get$_nextLink().get$_element();
        throw H.wrapException(H.IterableElementError_tooMany());
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "DoubleLinkedQueue");
      }, "single"],
      firstEntry$0: [function() {
        return this._sentinel.nextEntry$0();
      }, "call$0", "get$firstEntry", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.DoubleLinkedQueueEntry, E]};
        }, this.$receiver, "DoubleLinkedQueue");
      }, "firstEntry"],
      lastEntry$0: [function() {
        return this._sentinel.previousEntry$0();
      }, "call$0", "get$lastEntry", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.DoubleLinkedQueueEntry, E]};
        }, this.$receiver, "DoubleLinkedQueue");
      }, "lastEntry"],
      get$isEmpty: [function(_) {
        var t1, t2;
        t1 = this._sentinel.get$_nextLink();
        t2 = this._sentinel;
        return t1 == null ? t2 == null : t1 === t2;
      }, null, null, 1, 0, 5, "isEmpty"],
      clear$0: [function(_) {
        var t1 = this._sentinel;
        t1.set$_nextLink(t1);
        t1 = this._sentinel;
        t1.set$_previousLink(t1);
        this._elementCount = 0;
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      forEachEntry$1: [function(action) {
        var entry, t1, next;
        entry = this._sentinel.get$_nextLink();
        for (; t1 = this._sentinel, entry == null ? t1 != null : entry !== t1; entry = next) {
          next = entry.get$_nextLink();
          action.call$1(entry);
          if (this === entry.get$_queue())
            next = entry.get$_nextLink();
          else if (this !== next.get$_queue())
            throw H.wrapException(new P.ConcurrentModificationError(this));
        }
      }, "call$1", "get$forEachEntry", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, v: true, args: [[P.DoubleLinkedQueueEntry, E]]}]};
        }, this.$receiver, "DoubleLinkedQueue");
      }, 71, [], "forEachEntry"],
      get$iterator: [function(_) {
        var t1 = this._sentinel;
        return new P._DoubleLinkedQueueIterator(t1, t1.get$_nextLink(), null, this.$ti);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P._DoubleLinkedQueueIterator, E]};
        }, this.$receiver, "DoubleLinkedQueue");
      }, "iterator"],
      toString$0: [function(_) {
        return P.IterableBase_iterableToFullString(this, "{", "}");
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: null,
      $asIterable: null,
      "<>": [248],
      static: {
        DoubleLinkedQueue$: [function($E) {
          var t1, t2;
          t1 = new P.DoubleLinkedQueue(null, 0, [$E]);
          t2 = new P._DoubleLinkedQueueSentinel(t1, null, null, null, [$E]);
          t2._previousLink = t2;
          t2._nextLink = t2;
          t1._sentinel = t2;
          return t1;
        }, null, null, 0, 0, 4, "new DoubleLinkedQueue"],
        DoubleLinkedQueue_DoubleLinkedQueue$from: [function(elements, $E) {
          var list, t1, e;
          list = new P.DoubleLinkedQueue(null, 0, [$E]);
          t1 = new P._DoubleLinkedQueueSentinel(list, null, null, null, [$E]);
          t1._previousLink = t1;
          t1._nextLink = t1;
          list._sentinel = t1;
          for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();) {
            e = t1.get$current();
            list._sentinel._prepend$1(e);
            list._elementCount = J.$add$ns(list._elementCount, 1);
          }
          return list;
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.DoubleLinkedQueue, E], args: [P.Iterable]};
          }, this.$receiver, "DoubleLinkedQueue");
        }, 35, [], "new DoubleLinkedQueue$from"]
      }
    },
    "+DoubleLinkedQueue": [1329, 1330],
    _DoubleLinkedQueueIterator: {
      "^": "Object;_sentinel@-1331,_nextEntry@-1332,_collection$_current@-1333,$ti",
      moveNext$0: [function() {
        var t1, t2, t3;
        t1 = this._nextEntry;
        t2 = this._sentinel;
        if (t1 == null ? t2 == null : t1 === t2) {
          this._collection$_current = null;
          this._nextEntry = null;
          this._sentinel = null;
          return false;
        }
        t2 = t2.get$_queue();
        t3 = t1.get$_queue();
        if (t2 == null ? t3 != null : t2 !== t3)
          throw H.wrapException(new P.ConcurrentModificationError(this._sentinel.get$_queue()));
        this._collection$_current = t1.get$_element();
        this._nextEntry = t1.get$_nextLink();
        return true;
      }, "call$0", "get$moveNext", 0, 0, 5, "moveNext"],
      get$current: [function() {
        return this._collection$_current;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "_DoubleLinkedQueueIterator");
      }, "current"],
      "<>": [214],
      static: {
        _DoubleLinkedQueueIterator$: [function(sentinel, $E) {
          return new P._DoubleLinkedQueueIterator(sentinel, sentinel.get$_nextLink(), null, [$E]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, args: [[P._DoubleLinkedQueueSentinel, E]]};
          }, this.$receiver, "_DoubleLinkedQueueIterator");
        }, 771, [], "new _DoubleLinkedQueueIterator"]
      }
    },
    "+_DoubleLinkedQueueIterator": [1, 1334],
    ListQueue: {
      "^": "ListIterable;_table@-1335,_head@-0,_tail@-0,_modificationCount@-0,$ti",
      get$iterator: [function(_) {
        return new P._ListQueueIterator(this, this._tail, this._modificationCount, this._head, null, this.$ti);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterator, E]};
        }, this.$receiver, "ListQueue");
      }, "iterator"],
      forEach$1: [function(_, action) {
        var modificationCount, i, t1, t2;
        modificationCount = this._modificationCount;
        for (i = this._head, t1 = J.getInterceptor(modificationCount); t2 = J.getInterceptor(i), !t2.$eq(i, this._tail); i = J.$and$n(t2.$add(i, 1), J.$sub$n(J.get$length$asx(this._table), 1))) {
          action.call$1(J.$index$asx(this._table, i));
          if (!t1.$eq(modificationCount, this._modificationCount))
            H.throwExpression(new P.ConcurrentModificationError(this));
        }
      }, "call$1", "get$forEach", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, v: true, args: [E]}]};
        }, this.$receiver, "ListQueue");
      }, 71, [], "forEach"],
      get$isEmpty: [function(_) {
        return J.$eq$(this._head, this._tail);
      }, null, null, 1, 0, 5, "isEmpty"],
      get$length: [function(_) {
        return J.$and$n(J.$sub$n(this._tail, this._head), J.$sub$n(J.get$length$asx(this._table), 1));
      }, null, null, 1, 0, 11, "length"],
      get$first: [function(_) {
        if (J.$eq$(this._head, this._tail))
          throw H.wrapException(H.IterableElementError_noElement());
        return J.$index$asx(this._table, this._head);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "ListQueue");
      }, "first"],
      get$last: [function(_) {
        if (J.$eq$(this._head, this._tail))
          throw H.wrapException(H.IterableElementError_noElement());
        return J.$index$asx(this._table, J.$and$n(J.$sub$n(this._tail, 1), J.$sub$n(J.get$length$asx(this._table), 1)));
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "ListQueue");
      }, "last"],
      get$single: [function(_) {
        if (J.$eq$(this._head, this._tail))
          throw H.wrapException(H.IterableElementError_noElement());
        if (J.$gt$n(this.get$length(this), 1))
          throw H.wrapException(H.IterableElementError_tooMany());
        return J.$index$asx(this._table, this._head);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "ListQueue");
      }, "single"],
      elementAt$1: [function(_, index) {
        P.RangeError_checkValidIndex(index, this, null, null, null);
        return J.$index$asx(this._table, J.$and$n(J.$add$ns(this._head, index), J.$sub$n(J.get$length$asx(this._table), 1)));
      }, "call$1", "get$elementAt", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [P.int]};
        }, this.$receiver, "ListQueue");
      }, 14, [], "elementAt"],
      toList$1$growable: [function(_, growable) {
        var t1, list, t2;
        t1 = this.$ti;
        if (growable === true) {
          list = H.setRuntimeTypeInfo([], t1);
          C.JSArray_methods.set$length(list, this.get$length(this));
        } else {
          t2 = this.get$length(this);
          if (typeof t2 !== "number")
            return H.iae(t2);
          t2 = new Array(t2);
          t2.fixed$length = Array;
          list = H.setRuntimeTypeInfo(t2, t1);
        }
        this._writeToList$1(list);
        return list;
      }, function($receiver) {
        return this.toList$1$growable($receiver, true);
      }, "toList$0", "call$1$growable", "call$0", "get$toList", 0, 3, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.List, E], named: {growable: P.bool}};
        }, this.$receiver, "ListQueue");
      }, 25, 88, [], "toList"],
      add$1: [function(_, value) {
        this._add$1(value);
      }, "call$1", "get$add", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [E]};
        }, this.$receiver, "ListQueue");
      }, 1, [], "add"],
      addAll$1: [function(_, elements) {
        var t1, addCount, $length, t2, t3, t4, newCapacity, newTable, endSpace, preSpace;
        t1 = this.$ti;
        if (H.checkSubtype(elements, "$isList", t1, "$asList")) {
          addCount = J.get$length$asx(elements);
          $length = this.get$length(this);
          t2 = J.getInterceptor$ns($length);
          if (J.$ge$n(t2.$add($length, addCount), J.get$length$asx(this._table))) {
            t3 = t2.$add($length, addCount);
            t4 = J.getInterceptor$n(t3);
            newCapacity = P.ListQueue__nextPowerOf2(t4.$add(t3, t4.$shr(t3, 1)));
            if (typeof newCapacity !== "number")
              return H.iae(newCapacity);
            t3 = new Array(newCapacity);
            t3.fixed$length = Array;
            newTable = H.setRuntimeTypeInfo(t3, t1);
            this._tail = this._writeToList$1(newTable);
            this._table = newTable;
            this._head = 0;
            C.JSArray_methods.setRange$4(newTable, $length, t2.$add($length, addCount), elements, 0);
            this._tail = J.$add$ns(this._tail, addCount);
          } else {
            endSpace = J.$sub$n(J.get$length$asx(this._table), this._tail);
            t1 = J.getInterceptor$n(addCount);
            if (t1.$lt(addCount, endSpace)) {
              t1 = this._table;
              t2 = this._tail;
              J.setRange$4$ax(t1, t2, J.$add$ns(t2, addCount), elements, 0);
              this._tail = J.$add$ns(this._tail, addCount);
            } else {
              preSpace = t1.$sub(addCount, endSpace);
              t1 = this._table;
              t2 = this._tail;
              J.setRange$4$ax(t1, t2, J.$add$ns(t2, endSpace), elements, 0);
              J.setRange$4$ax(this._table, 0, preSpace, elements, endSpace);
              this._tail = preSpace;
            }
          }
          this._modificationCount = J.$add$ns(this._modificationCount, 1);
        } else
          for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
            this._add$1(t1.get$current());
      }, "call$1", "get$addAll", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [[P.Iterable, E]]};
        }, this.$receiver, "ListQueue");
      }, 35, [], "addAll"],
      remove$1: [function(_, value) {
        var i, t1;
        for (i = this._head; t1 = J.getInterceptor(i), !t1.$eq(i, this._tail); i = J.$and$n(t1.$add(i, 1), J.$sub$n(J.get$length$asx(this._table), 1)))
          if (J.$eq$(J.$index$asx(this._table, i), value)) {
            this._remove$1(i);
            this._modificationCount = J.$add$ns(this._modificationCount, 1);
            return true;
          }
        return false;
      }, "call$1", "get$remove", 2, 0, 15, 1, [], "remove"],
      _filterWhere$2: [function(test, removeMatching) {
        var modificationCount, i, t1, t2;
        modificationCount = this._modificationCount;
        i = this._head;
        for (; t1 = J.getInterceptor(i), !t1.$eq(i, this._tail);) {
          t2 = test.call$1(J.$index$asx(this._table, i));
          if (!J.$eq$(modificationCount, this._modificationCount))
            H.throwExpression(new P.ConcurrentModificationError(this));
          if (removeMatching == null ? t2 == null : removeMatching === t2) {
            i = this._remove$1(i);
            modificationCount = J.$add$ns(this._modificationCount, 1);
            this._modificationCount = modificationCount;
          } else
            i = J.$and$n(t1.$add(i, 1), J.$sub$n(J.get$length$asx(this._table), 1));
        }
      }, "call$2", "get$_filterWhere", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, ret: P.bool, args: [E]}, P.bool]};
        }, this.$receiver, "ListQueue");
      }, 11, [], 462, [], "_filterWhere"],
      removeWhere$1: [function(_, test) {
        this._filterWhere$2(test, true);
      }, "call$1", "get$removeWhere", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "ListQueue");
      }, 11, [], "removeWhere"],
      retainWhere$1: [function(_, test) {
        this._filterWhere$2(test, false);
      }, "call$1", "get$retainWhere", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "ListQueue");
      }, 11, [], "retainWhere"],
      clear$0: [function(_) {
        var i, t1;
        if (!J.$eq$(this._head, this._tail)) {
          for (i = this._head; t1 = J.getInterceptor(i), !t1.$eq(i, this._tail); i = J.$and$n(t1.$add(i, 1), J.$sub$n(J.get$length$asx(this._table), 1)))
            J.$indexSet$ax(this._table, i, null);
          this._tail = 0;
          this._head = 0;
          this._modificationCount = J.$add$ns(this._modificationCount, 1);
        }
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      toString$0: [function(_) {
        return P.IterableBase_iterableToFullString(this, "{", "}");
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      addLast$1: [function(value) {
        this._add$1(value);
      }, "call$1", "get$addLast", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [E]};
        }, this.$receiver, "ListQueue");
      }, 1, [], "addLast"],
      addFirst$1: [function(value) {
        var t1 = J.$and$n(J.$sub$n(this._head, 1), J.$sub$n(J.get$length$asx(this._table), 1));
        this._head = t1;
        J.$indexSet$ax(this._table, t1, value);
        if (J.$eq$(this._head, this._tail))
          this._grow$0();
        this._modificationCount = J.$add$ns(this._modificationCount, 1);
      }, "call$1", "get$addFirst", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [E]};
        }, this.$receiver, "ListQueue");
      }, 1, [], "addFirst"],
      removeFirst$0: [function() {
        if (J.$eq$(this._head, this._tail))
          throw H.wrapException(H.IterableElementError_noElement());
        this._modificationCount = J.$add$ns(this._modificationCount, 1);
        var result = J.$index$asx(this._table, this._head);
        J.$indexSet$ax(this._table, this._head, null);
        this._head = J.$and$n(J.$add$ns(this._head, 1), J.$sub$n(J.get$length$asx(this._table), 1));
        return result;
      }, "call$0", "get$removeFirst", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "ListQueue");
      }, "removeFirst"],
      removeLast$0: [function(_) {
        var t1, result;
        if (J.$eq$(this._head, this._tail))
          throw H.wrapException(H.IterableElementError_noElement());
        this._modificationCount = J.$add$ns(this._modificationCount, 1);
        t1 = J.$and$n(J.$sub$n(this._tail, 1), J.$sub$n(J.get$length$asx(this._table), 1));
        this._tail = t1;
        result = J.$index$asx(this._table, t1);
        J.$indexSet$ax(this._table, this._tail, null);
        return result;
      }, "call$0", "get$removeLast", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "ListQueue");
      }, "removeLast"],
      _checkModification$1: [function(expectedModificationCount) {
        if (!J.$eq$(expectedModificationCount, this._modificationCount))
          throw H.wrapException(new P.ConcurrentModificationError(this));
      }, "call$1", "get$_checkModification", 2, 0, 17, 755, [], "_checkModification"],
      _add$1: [function(element) {
        var t1;
        J.$indexSet$ax(this._table, this._tail, element);
        t1 = J.$and$n(J.$add$ns(this._tail, 1), J.$sub$n(J.get$length$asx(this._table), 1));
        this._tail = t1;
        if (J.$eq$(this._head, t1))
          this._grow$0();
        this._modificationCount = J.$add$ns(this._modificationCount, 1);
      }, "call$1", "get$_add", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [E]};
        }, this.$receiver, "ListQueue");
      }, 31, [], "_add"],
      _remove$1: [function(offset) {
        var mask, t1, i, t2, prevOffset, t3, nextOffset;
        mask = J.$sub$n(J.get$length$asx(this._table), 1);
        t1 = J.getInterceptor$n(offset);
        if (J.$lt$n(J.$and$n(t1.$sub(offset, this._head), mask), J.$and$n(J.$sub$n(this._tail, offset), mask))) {
          for (i = offset; t2 = J.getInterceptor(i), !t2.$eq(i, this._head); i = prevOffset) {
            prevOffset = J.$and$n(t2.$sub(i, 1), mask);
            t2 = this._table;
            t3 = J.getInterceptor$asx(t2);
            t3.$indexSet(t2, i, t3.$index(t2, prevOffset));
          }
          J.$indexSet$ax(this._table, this._head, null);
          this._head = J.$and$n(J.$add$ns(this._head, 1), mask);
          return J.$and$n(t1.$add(offset, 1), mask);
        } else {
          this._tail = J.$and$n(J.$sub$n(this._tail, 1), mask);
          for (i = offset; t1 = J.getInterceptor(i), !t1.$eq(i, this._tail); i = nextOffset) {
            nextOffset = J.$and$n(t1.$add(i, 1), mask);
            t1 = this._table;
            t2 = J.getInterceptor$asx(t1);
            t2.$indexSet(t1, i, t2.$index(t1, nextOffset));
          }
          J.$indexSet$ax(this._table, this._tail, null);
          return offset;
        }
      }, "call$1", "get$_remove", 2, 0, 16, 220, [], "_remove"],
      _grow$0: [function() {
        var t1, newTable, split;
        t1 = J.$mul$ns(J.get$length$asx(this._table), 2);
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = new Array(t1);
        t1.fixed$length = Array;
        newTable = H.setRuntimeTypeInfo(t1, this.$ti);
        split = J.$sub$n(J.get$length$asx(this._table), this._head);
        C.JSArray_methods.setRange$4(newTable, 0, split, this._table, this._head);
        C.JSArray_methods.setRange$4(newTable, split, J.$add$ns(split, this._head), this._table, 0);
        this._head = 0;
        this._tail = J.get$length$asx(this._table);
        this._table = newTable;
      }, "call$0", "get$_grow", 0, 0, 6, "_grow"],
      _writeToList$1: [function(target) {
        var t1, $length, firstPartSize;
        t1 = J.getInterceptor$ax(target);
        if (J.$le$n(this._head, this._tail)) {
          $length = J.$sub$n(this._tail, this._head);
          t1.setRange$4(target, 0, $length, this._table, this._head);
          return $length;
        } else {
          firstPartSize = J.$sub$n(J.get$length$asx(this._table), this._head);
          t1.setRange$4(target, 0, firstPartSize, this._table, this._head);
          t1.setRange$4(target, firstPartSize, J.$add$ns(firstPartSize, this._tail), this._table, 0);
          return J.$add$ns(this._tail, firstPartSize);
        }
      }, "call$1", "get$_writeToList", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.int, args: [[P.List, E]]};
        }, this.$receiver, "ListQueue");
      }, 79, [], "_writeToList"],
      _preGrow$1: [function(newElementCount) {
        var t1, newCapacity, newTable;
        t1 = J.getInterceptor$n(newElementCount);
        newCapacity = P.ListQueue__nextPowerOf2(t1.$add(newElementCount, t1.$shr(newElementCount, 1)));
        if (typeof newCapacity !== "number")
          return H.iae(newCapacity);
        t1 = new Array(newCapacity);
        t1.fixed$length = Array;
        newTable = H.setRuntimeTypeInfo(t1, this.$ti);
        this._tail = this._writeToList$1(newTable);
        this._table = newTable;
        this._head = 0;
      }, "call$1", "get$_preGrow", 2, 0, 17, 753, [], "_preGrow"],
      ListQueue$1: function(initialCapacity, $E) {
        var t1;
        if (initialCapacity == null || J.$lt$n(initialCapacity, 8))
          initialCapacity = 8;
        else {
          t1 = J.getInterceptor$n(initialCapacity);
          if (t1.$and(initialCapacity, t1.$sub(initialCapacity, 1)) !== 0)
            initialCapacity = P.ListQueue__nextPowerOf2(initialCapacity);
        }
        if (typeof initialCapacity !== "number")
          return H.iae(initialCapacity);
        t1 = new Array(initialCapacity);
        t1.fixed$length = Array;
        this._table = H.setRuntimeTypeInfo(t1, [$E]);
      },
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $asEfficientLengthIterable: null,
      $asIterable: null,
      "<>": [232],
      static: {
        "^": "ListQueue__INITIAL_CAPACITY<-0",
        ListQueue$: [function(initialCapacity, $E) {
          var t1 = new P.ListQueue(null, 0, 0, 0, [$E]);
          t1.ListQueue$1(initialCapacity, $E);
          return t1;
        }, null, null, 0, 2, 396, 0, 446, [], "new ListQueue"],
        ListQueue_ListQueue$from: [function(elements, $E) {
          var t1, $length, queue, i, result;
          t1 = J.getInterceptor(elements);
          if (!!t1.$isList) {
            $length = t1.get$length(elements);
            queue = P.ListQueue$(J.$add$ns($length, 1), $E);
            if (typeof $length !== "number")
              return H.iae($length);
            i = 0;
            for (; i < $length; ++i)
              J.$indexSet$ax(queue._table, i, t1.$index(elements, i));
            queue._tail = $length;
            return queue;
          } else {
            result = P.ListQueue$(!!t1.$isEfficientLengthIterable ? t1.get$length(elements) : 8, $E);
            for (t1 = t1.get$iterator(elements); t1.moveNext$0();)
              result._add$1(t1.get$current());
            return result;
          }
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.ListQueue, E], args: [P.Iterable]};
          }, this.$receiver, "ListQueue");
        }, 35, [], "new ListQueue$from"],
        ListQueue__isPowerOf2: [function(number) {
          var t1 = J.getInterceptor$n(number);
          return t1.$and(number, t1.$sub(number, 1)) === 0;
        }, "call$1", "collection_ListQueue__isPowerOf2$closure", 2, 0, 32, 272, [], "_isPowerOf2"],
        ListQueue__nextPowerOf2: [function(number) {
          var nextNumber;
          number = J.$shl$n(number, 1) - 1;
          for (; true; number = nextNumber) {
            nextNumber = (number & number - 1) >>> 0;
            if (nextNumber === 0)
              return number;
          }
        }, "call$1", "collection_ListQueue__nextPowerOf2$closure", 2, 0, 16, 272, [], "_nextPowerOf2"]
      }
    },
    "+ListQueue": [1336, 1337],
    _ListQueueIterator: {
      "^": "Object;_queue<-1338,_end<-0,_modificationCount<-0,_position@-0,_collection$_current@-1339,$ti",
      get$current: [function() {
        return this._collection$_current;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "_ListQueueIterator");
      }, "current"],
      moveNext$0: [function() {
        var t1 = this._queue;
        t1._checkModification$1(this._modificationCount);
        if (J.$eq$(this._position, this._end)) {
          this._collection$_current = null;
          return false;
        }
        this._collection$_current = J.$index$asx(t1.get$_table(), this._position);
        this._position = J.$and$n(J.$add$ns(this._position, 1), J.$sub$n(J.get$length$asx(t1.get$_table()), 1));
        return true;
      }, "call$0", "get$moveNext", 0, 0, 5, "moveNext"],
      "<>": [278],
      static: {
        _ListQueueIterator$: [function(queue, $E) {
          return new P._ListQueueIterator(queue, queue.get$_tail(), queue.get$_modificationCount(), queue.get$_head(), null, [$E]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, args: [[P.ListQueue, E]]};
          }, this.$receiver, "_ListQueueIterator");
        }, 417, [], "new _ListQueueIterator"]
      }
    },
    "+_ListQueueIterator": [1, 1340],
    SetMixin: {
      "^": "Object;$ti",
      get$isEmpty: [function(_) {
        return J.$eq$(this.get$length(this), 0);
      }, null, null, 1, 0, 5, "isEmpty"],
      get$isNotEmpty: [function(_) {
        return !J.$eq$(this.get$length(this), 0);
      }, null, null, 1, 0, 5, "isNotEmpty"],
      clear$0: [function(_) {
        this.removeAll$1(this.toList$0(0));
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      addAll$1: [function(_, elements) {
        var t1;
        for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
          this.add$1(0, t1.get$current());
      }, "call$1", "get$addAll", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [[P.Iterable, E]]};
        }, this.$receiver, "SetMixin");
      }, 35, [], "addAll"],
      removeAll$1: [function(elements) {
        var t1;
        for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
          this.remove$1(0, t1.get$current());
      }, "call$1", "get$removeAll", 2, 0, 152, 35, [], "removeAll"],
      retainAll$1: [function(elements) {
        var toRemove, t1;
        toRemove = this.toSet$0(0);
        for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
          toRemove.remove$1(0, t1.get$current());
        this.removeAll$1(toRemove);
      }, "call$1", "get$retainAll", 2, 0, 152, 35, [], "retainAll"],
      removeWhere$1: [function(_, test) {
        var toRemove, t1, element;
        toRemove = [];
        for (t1 = this.get$iterator(this); t1.moveNext$0();) {
          element = t1.get$current();
          if (test.call$1(element) === true)
            toRemove.push(element);
        }
        this.removeAll$1(toRemove);
      }, "call$1", "get$removeWhere", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "SetMixin");
      }, 11, [], "removeWhere"],
      retainWhere$1: [function(_, test) {
        var toRemove, t1, element;
        toRemove = [];
        for (t1 = this.get$iterator(this); t1.moveNext$0();) {
          element = t1.get$current();
          if (test.call$1(element) !== true)
            toRemove.push(element);
        }
        this.removeAll$1(toRemove);
      }, "call$1", "get$retainWhere", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "SetMixin");
      }, 11, [], "retainWhere"],
      containsAll$1: [function(other) {
        var t1;
        for (t1 = J.get$iterator$ax(other); t1.moveNext$0();)
          if (!this.contains$1(0, t1.get$current()))
            return false;
        return true;
      }, "call$1", "get$containsAll", 2, 0, 449, 2, [], "containsAll"],
      union$1: [function(other) {
        var t1 = this.toSet$0(0);
        t1.addAll$1(0, other);
        return t1;
      }, "call$1", "get$union", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Set, E], args: [[P.Set, E]]};
        }, this.$receiver, "SetMixin");
      }, 2, [], "union"],
      intersection$1: [function(other) {
        var result, t1, t2, element;
        result = this.toSet$0(0);
        for (t1 = this.get$iterator(this), t2 = J.getInterceptor$asx(other); t1.moveNext$0();) {
          element = t1.get$current();
          if (t2.contains$1(other, element) !== true)
            result.remove$1(0, element);
        }
        return result;
      }, "call$1", "get$intersection", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Set, E], args: [[P.Set, P.Object]]};
        }, this.$receiver, "SetMixin");
      }, 2, [], "intersection"],
      difference$1: [function(other) {
        var result, t1, t2, element;
        result = this.toSet$0(0);
        for (t1 = this.get$iterator(this), t2 = J.getInterceptor$asx(other); t1.moveNext$0();) {
          element = t1.get$current();
          if (t2.contains$1(other, element) === true)
            result.remove$1(0, element);
        }
        return result;
      }, "call$1", "get$difference", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Set, E], args: [[P.Set, P.Object]]};
        }, this.$receiver, "SetMixin");
      }, 2, [], "difference"],
      toList$1$growable: [function(_, growable) {
        var t1, result, t2, i, element, i0;
        t1 = [H.getRuntimeTypeArgument(this, "SetMixin", 0)];
        if (growable === true) {
          result = H.setRuntimeTypeInfo([], t1);
          C.JSArray_methods.set$length(result, this.get$length(this));
        } else {
          t2 = this.get$length(this);
          if (typeof t2 !== "number")
            return H.iae(t2);
          t2 = new Array(t2);
          t2.fixed$length = Array;
          result = H.setRuntimeTypeInfo(t2, t1);
        }
        for (t1 = this.get$iterator(this), i = 0; t1.moveNext$0(); i = i0) {
          element = t1.get$current();
          i0 = i + 1;
          if (i >= result.length)
            return H.ioore(result, i);
          result[i] = element;
        }
        return result;
      }, function($receiver) {
        return this.toList$1$growable($receiver, true);
      }, "toList$0", "call$1$growable", "call$0", "get$toList", 0, 3, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.List, E], named: {growable: P.bool}};
        }, this.$receiver, "SetMixin");
      }, 25, 88, [], "toList"],
      map$1: [function(_, f) {
        return new H.EfficientLengthMappedIterable(this, f, [H.getRuntimeTypeArgument(this, "SetMixin", 0), null]);
      }, "call$1", "get$map", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.Iterable, args: [{func: 1, args: [E]}]};
        }, this.$receiver, "SetMixin");
      }, 9, [], "map"],
      get$single: [function(_) {
        var it;
        if (J.$gt$n(this.get$length(this), 1))
          throw H.wrapException(H.IterableElementError_tooMany());
        it = this.get$iterator(this);
        if (!it.moveNext$0())
          throw H.wrapException(H.IterableElementError_noElement());
        return it.get$current();
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "SetMixin");
      }, "single"],
      toString$0: [function(_) {
        return P.IterableBase_iterableToFullString(this, "{", "}");
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      where$1: [function(_, f) {
        return new H.WhereIterable(this, f, [H.getRuntimeTypeArgument(this, "SetMixin", 0)]);
      }, "call$1", "get$where", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "SetMixin");
      }, 9, [], "where"],
      expand$1: [function(_, f) {
        return new H.ExpandIterable(this, f, [H.getRuntimeTypeArgument(this, "SetMixin", 0), null]);
      }, "call$1", "get$expand", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.Iterable, args: [{func: 1, ret: P.Iterable, args: [E]}]};
        }, this.$receiver, "SetMixin");
      }, 9, [], "expand"],
      forEach$1: [function(_, f) {
        var t1;
        for (t1 = this.get$iterator(this); t1.moveNext$0();)
          f.call$1(t1.get$current());
      }, "call$1", "get$forEach", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, v: true, args: [E]}]};
        }, this.$receiver, "SetMixin");
      }, 9, [], "forEach"],
      reduce$1: [function(_, combine) {
        var iterator, value;
        iterator = this.get$iterator(this);
        if (!iterator.moveNext$0())
          throw H.wrapException(H.IterableElementError_noElement());
        value = iterator.get$current();
        for (; iterator.moveNext$0();)
          value = combine.call$2(value, iterator.get$current());
        return value;
      }, "call$1", "get$reduce", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: E, args: [E, E]}]};
        }, this.$receiver, "SetMixin");
      }, 61, [], "reduce"],
      fold$2: [function(_, initialValue, combine) {
        var t1, value;
        for (t1 = this.get$iterator(this), value = initialValue; t1.moveNext$0();)
          value = combine.call$2(value, t1.get$current());
        return value;
      }, "call$2", "get$fold", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, args: [, {func: 1, args: [, E]}]};
        }, this.$receiver, "SetMixin");
      }, 123, [], 61, [], "fold"],
      every$1: [function(_, f) {
        var t1;
        for (t1 = this.get$iterator(this); t1.moveNext$0();)
          if (f.call$1(t1.get$current()) !== true)
            return false;
        return true;
      }, "call$1", "get$every", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.bool, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "SetMixin");
      }, 9, [], "every"],
      join$1: [function(_, separator) {
        var iterator, t1;
        iterator = this.get$iterator(this);
        if (!iterator.moveNext$0())
          return "";
        if (separator == null || J.$eq$(separator, "")) {
          t1 = "";
          do
            t1 += H.S(iterator.get$current());
          while (iterator.moveNext$0());
        } else {
          t1 = H.S(iterator.get$current());
          for (; iterator.moveNext$0();)
            t1 = t1 + H.S(separator) + H.S(iterator.get$current());
        }
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, function($receiver) {
        return this.join$1($receiver, "");
      }, "join$0", "call$1", "call$0", "get$join", 0, 2, 92, 32, 63, [], "join"],
      any$1: [function(_, test) {
        var t1;
        for (t1 = this.get$iterator(this); t1.moveNext$0();)
          if (test.call$1(t1.get$current()) === true)
            return true;
        return false;
      }, "call$1", "get$any", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.bool, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "SetMixin");
      }, 11, [], "any"],
      take$1: [function(_, n) {
        return H.TakeIterable_TakeIterable(this, n, H.getRuntimeTypeArgument(this, "SetMixin", 0));
      }, "call$1", "get$take", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [P.int]};
        }, this.$receiver, "SetMixin");
      }, 89, [], "take"],
      takeWhile$1: [function(_, test) {
        return new H.TakeWhileIterable(this, test, [H.getRuntimeTypeArgument(this, "SetMixin", 0)]);
      }, "call$1", "get$takeWhile", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "SetMixin");
      }, 11, [], "takeWhile"],
      skip$1: [function(_, n) {
        return H.SkipIterable_SkipIterable(this, n, H.getRuntimeTypeArgument(this, "SetMixin", 0));
      }, "call$1", "get$skip", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [P.int]};
        }, this.$receiver, "SetMixin");
      }, 89, [], "skip"],
      skipWhile$1: [function(_, test) {
        return new H.SkipWhileIterable(this, test, [H.getRuntimeTypeArgument(this, "SetMixin", 0)]);
      }, "call$1", "get$skipWhile", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "SetMixin");
      }, 11, [], "skipWhile"],
      get$first: [function(_) {
        var it = this.get$iterator(this);
        if (!it.moveNext$0())
          throw H.wrapException(H.IterableElementError_noElement());
        return it.get$current();
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "SetMixin");
      }, "first"],
      get$last: [function(_) {
        var it, result;
        it = this.get$iterator(this);
        if (!it.moveNext$0())
          throw H.wrapException(H.IterableElementError_noElement());
        do
          result = it.get$current();
        while (it.moveNext$0());
        return result;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "SetMixin");
      }, "last"],
      firstWhere$2$orElse: [function(_, test, orElse) {
        var t1, element;
        for (t1 = this.get$iterator(this); t1.moveNext$0();) {
          element = t1.get$current();
          if (test.call$1(element) === true)
            return element;
        }
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      }, function($receiver, test) {
        return this.firstWhere$2$orElse($receiver, test, null);
      }, "firstWhere$1", "call$2$orElse", "call$1", "get$firstWhere", 2, 3, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: P.bool, args: [E]}], named: {orElse: {func: 1, ret: E}}};
        }, this.$receiver, "SetMixin");
      }, 0, 11, [], 67, [], "firstWhere"],
      lastWhere$2$orElse: [function(_, test, orElse) {
        var t1, result, foundMatching, element;
        for (t1 = this.get$iterator(this), result = null, foundMatching = false; t1.moveNext$0();) {
          element = t1.get$current();
          if (test.call$1(element) === true) {
            result = element;
            foundMatching = true;
          }
        }
        if (foundMatching)
          return result;
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      }, function($receiver, test) {
        return this.lastWhere$2$orElse($receiver, test, null);
      }, "lastWhere$1", "call$2$orElse", "call$1", "get$lastWhere", 2, 3, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: P.bool, args: [E]}], named: {orElse: {func: 1, ret: E}}};
        }, this.$receiver, "SetMixin");
      }, 0, 11, [], 67, [], "lastWhere"],
      singleWhere$1: [function(_, test) {
        var t1, result, foundMatching, element;
        for (t1 = this.get$iterator(this), result = null, foundMatching = false; t1.moveNext$0();) {
          element = t1.get$current();
          if (test.call$1(element) === true) {
            if (foundMatching)
              throw H.wrapException(H.IterableElementError_tooMany());
            result = element;
            foundMatching = true;
          }
        }
        if (foundMatching)
          return result;
        throw H.wrapException(H.IterableElementError_noElement());
      }, "call$1", "get$singleWhere", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "SetMixin");
      }, 11, [], "singleWhere"],
      elementAt$1: [function(_, index) {
        var t1, elementIndex, element;
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(P.ArgumentError$notNull("index"));
        if (index < 0)
          H.throwExpression(P.RangeError$range(index, 0, null, "index", null));
        for (t1 = this.get$iterator(this), elementIndex = 0; t1.moveNext$0();) {
          element = t1.get$current();
          if (index === elementIndex)
            return element;
          ++elementIndex;
        }
        throw H.wrapException(P.IndexError$(index, this, "index", null, elementIndex));
      }, "call$1", "get$elementAt", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [P.int]};
        }, this.$receiver, "SetMixin");
      }, 14, [], "elementAt"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $isSet: 1,
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: null,
      $isIterable: 1,
      $asIterable: null,
      "<>": [511],
      static: {
        SetMixin$: [function($E) {
          return new P.SetMixin([$E]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.SetMixin, E]};
          }, this.$receiver, "SetMixin");
        }, "new SetMixin"]
      }
    },
    "+SetMixin": [1, 1341],
    SetBase: {
      "^": "SetMixin;$ti",
      "<>": [508],
      static: {
        SetBase$: [function($E) {
          return new P.SetBase([$E]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.SetBase, E]};
          }, this.$receiver, "SetBase");
        }, "new SetBase"],
        SetBase_setToString: [function(set) {
          return P.IterableBase_iterableToFullString(set, "{", "}");
        }, "call$1", "collection_SetBase_setToString$closure", 2, 0, 616, 770, [], "setToString"]
      }
    },
    "+SetBase": [1342],
    _SplayTreeNode: {
      "^": "Object;key<-536,left@-184,right@-184,$ti",
      "<>": [314],
      static: {
        _SplayTreeNode$: [function(key, $K) {
          return new P._SplayTreeNode(key, null, null, [$K]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(K) {
            return {func: 1, args: [K]};
          }, this.$receiver, "_SplayTreeNode");
        }, 6, [], "new _SplayTreeNode"]
      }
    },
    "+_SplayTreeNode": [1],
    _SplayTreeMapNode: {
      "^": "_SplayTreeNode;value@-1345,key-536,left-184,right-184,$ti",
      value$1: function(arg0) {
        return this.value.call$1(arg0);
      },
      $as_SplayTreeNode: function($K, $V) {
        return [$K];
      },
      "<>": [574, 571],
      static: {
        _SplayTreeMapNode$: [function(key, value, $K, $V) {
          return new P._SplayTreeMapNode(value, key, null, null, [$K, $V]);
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, args: [K, V]};
          }, this.$receiver, "_SplayTreeMapNode");
        }, 6, [], 1, [], "new _SplayTreeMapNode"]
      }
    },
    "+_SplayTreeMapNode": [1346],
    _SplayTree: {
      "^": "Object;_collection$_count@-0,_modificationCount@-0,_splayCount@-0,$ti",
      _splay$1: [function(key) {
        var left, right, current, comp, t1, tmp, current0;
        if (this.get$_root() == null)
          return -1;
        left = this.get$_dummy();
        right = this.get$_dummy();
        current = this.get$_root();
        for (comp = null; true;) {
          comp = this._compare$2(current.get$key(), key);
          t1 = J.getInterceptor$n(comp);
          if (t1.$gt(comp, 0)) {
            if (current.get$left() == null)
              break;
            comp = this._compare$2(current.get$left().get$key(), key);
            if (J.$gt$n(comp, 0)) {
              tmp = current.get$left();
              current.set$left(tmp.get$right());
              tmp.set$right(current);
              if (tmp.get$left() == null) {
                current = tmp;
                break;
              }
              current = tmp;
            }
            right.set$left(current);
            current0 = current.get$left();
            right = current;
            current = current0;
          } else {
            if (t1.$lt(comp, 0)) {
              if (current.get$right() == null)
                break;
              comp = this._compare$2(current.get$right().get$key(), key);
              if (J.$lt$n(comp, 0)) {
                tmp = current.get$right();
                current.set$right(tmp.get$left());
                tmp.set$left(current);
                if (tmp.get$right() == null) {
                  current = tmp;
                  break;
                }
                current = tmp;
              }
              left.set$right(current);
              current0 = current.get$right();
            } else
              break;
            left = current;
            current = current0;
          }
        }
        left.set$right(current.get$left());
        right.set$left(current.get$right());
        current.set$left(this.get$_dummy().get$right());
        current.set$right(this.get$_dummy().get$left());
        this.set$_root(current);
        this.get$_dummy().set$right(null);
        this.get$_dummy().set$left(null);
        this._splayCount = J.$add$ns(this._splayCount, 1);
        return comp;
      }, "call$1", "get$_splay", 2, 0, function() {
        return H.computeSignature(function(K, Node) {
          return {func: 1, ret: P.int, args: [K]};
        }, this.$receiver, "_SplayTree");
      }, 6, [], "_splay"],
      _splayMin$1: [function(node) {
        var current, left;
        for (current = node; current.get$left() != null; current = left) {
          left = current.get$left();
          current.set$left(left.get$right());
          left.set$right(current);
        }
        return current;
      }, "call$1", "get$_splayMin", 2, 0, function() {
        return H.computeSignature(function(K, Node) {
          return {func: 1, ret: Node, args: [Node]};
        }, this.$receiver, "_SplayTree");
      }, 111, [], "_splayMin"],
      _splayMax$1: [function(node) {
        var current, right;
        for (current = node; current.get$right() != null; current = right) {
          right = current.get$right();
          current.set$right(right.get$left());
          right.set$left(current);
        }
        return current;
      }, "call$1", "get$_splayMax", 2, 0, function() {
        return H.computeSignature(function(K, Node) {
          return {func: 1, ret: Node, args: [Node]};
        }, this.$receiver, "_SplayTree");
      }, 111, [], "_splayMax"],
      _remove$1: [function(key) {
        var result, right;
        if (this.get$_root() == null)
          return;
        if (!J.$eq$(this._splay$1(key), 0))
          return;
        result = this.get$_root();
        this._collection$_count = J.$sub$n(this._collection$_count, 1);
        if (this.get$_root().get$left() == null)
          this.set$_root(this.get$_root().get$right());
        else {
          right = this.get$_root().get$right();
          this.set$_root(this._splayMax$1(this.get$_root().get$left()));
          this.get$_root().set$right(right);
        }
        this._modificationCount = J.$add$ns(this._modificationCount, 1);
        return result;
      }, "call$1", "get$_remove", 2, 0, function() {
        return H.computeSignature(function(K, Node) {
          return {func: 1, ret: Node, args: [K]};
        }, this.$receiver, "_SplayTree");
      }, 6, [], "_remove"],
      _addNewRoot$2: [function(node, comp) {
        this._collection$_count = J.$add$ns(this._collection$_count, 1);
        this._modificationCount = J.$add$ns(this._modificationCount, 1);
        if (this.get$_root() == null) {
          this.set$_root(node);
          return;
        }
        if (J.$lt$n(comp, 0)) {
          node.set$left(this.get$_root());
          node.set$right(this.get$_root().get$right());
          this.get$_root().set$right(null);
        } else {
          node.set$right(this.get$_root());
          node.set$left(this.get$_root().get$left());
          this.get$_root().set$left(null);
        }
        this.set$_root(node);
      }, "call$2", "get$_addNewRoot", 4, 0, function() {
        return H.computeSignature(function(K, Node) {
          return {func: 1, v: true, args: [Node, P.int]};
        }, this.$receiver, "_SplayTree");
      }, 111, [], 751, [], "_addNewRoot"],
      get$_collection$_first: [function() {
        if (this.get$_root() == null)
          return;
        this.set$_root(this._splayMin$1(this.get$_root()));
        return this.get$_root();
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(K, Node) {
          return {func: 1, ret: Node};
        }, this.$receiver, "_SplayTree");
      }, "_collection$_first"],
      get$_collection$_last: [function() {
        if (this.get$_root() == null)
          return;
        this.set$_root(this._splayMax$1(this.get$_root()));
        return this.get$_root();
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(K, Node) {
          return {func: 1, ret: Node};
        }, this.$receiver, "_SplayTree");
      }, "_collection$_last"],
      _clear$0: [function() {
        this.set$_root(null);
        this._collection$_count = 0;
        this._modificationCount = J.$add$ns(this._modificationCount, 1);
      }, "call$0", "get$_clear", 0, 0, 6, "_clear"],
      "<>": [580, 930],
      static: {
        _SplayTree$: [function($K, $Node) {
          return new P._SplayTree(0, 0, 0, [$K, $Node]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(K, Node) {
            return {func: 1, ret: [P._SplayTree, K, Node]};
          }, this.$receiver, "_SplayTree");
        }, "new _SplayTree"]
      }
    },
    "+_SplayTree": [1],
    _TypeTest: {
      "^": "Object;$ti",
      test$1: [function(v) {
        return H.checkSubtypeOfRuntimeType(v, H.getTypeArgumentByIndex(this, 0));
      }, "call$1", "get$test", 2, 0, 24, 56, [], "test"],
      "<>": [929],
      static: {
        _TypeTest$: [function($T) {
          return new P._TypeTest([$T]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P._TypeTest, T]};
          }, this.$receiver, "_TypeTest");
        }, "new _TypeTest"]
      }
    },
    "+_TypeTest": [1],
    SplayTreeMap: {
      "^": "_SplayTree;_root@-461,_dummy<-461,_comparator@-1348,_validKey@-462,_collection$_count-0,_modificationCount-0,_splayCount-0,$ti",
      _compare$2: [function(key1, key2) {
        return this._comparator.call$2(key1, key2);
      }, "call$2", "get$_compare", 4, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: P.int, args: [K, K]};
        }, this.$receiver, "SplayTreeMap");
      }, 749, [], 628, [], "_compare"],
      $index: [function(_, key) {
        if (this._validKey.call$1(key) !== true)
          return;
        if (this._root != null)
          if (J.$eq$(this._splay$1(key), 0))
            return this._root.get$value();
        return;
      }, null, "get$[]", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V, args: [P.Object]};
        }, this.$receiver, "SplayTreeMap");
      }, 6, [], "[]"],
      remove$1: [function(_, key) {
        var mapRoot;
        if (this._validKey.call$1(key) !== true)
          return;
        mapRoot = this._remove$1(key);
        if (mapRoot != null)
          return mapRoot.get$value();
        return;
      }, "call$1", "get$remove", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V, args: [P.Object]};
        }, this.$receiver, "SplayTreeMap");
      }, 6, [], "remove"],
      $indexSet: [function(_, key, value) {
        var comp;
        if (key == null)
          throw H.wrapException(P.ArgumentError$(key));
        comp = this._splay$1(key);
        if (J.$eq$(comp, 0)) {
          this._root.set$value(value);
          return;
        }
        this._addNewRoot$2(new P._SplayTreeMapNode(value, key, null, null, [null, null]), comp);
      }, null, "get$[]=", 4, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, v: true, args: [K, V]};
        }, this.$receiver, "SplayTreeMap");
      }, 6, [], 1, [], "[]="],
      putIfAbsent$2: [function(key, ifAbsent) {
        var comp, modificationCount, splayCount, value;
        if (key == null)
          throw H.wrapException(P.ArgumentError$(key));
        comp = this._splay$1(key);
        if (J.$eq$(comp, 0))
          return this._root.get$value();
        modificationCount = this._modificationCount;
        splayCount = this._splayCount;
        value = ifAbsent.call$0();
        if (!J.$eq$(modificationCount, this._modificationCount))
          throw H.wrapException(new P.ConcurrentModificationError(this));
        if (!J.$eq$(splayCount, this._splayCount))
          comp = this._splay$1(key);
        this._addNewRoot$2(new P._SplayTreeMapNode(value, key, null, null, [null, null]), comp);
        return value;
      }, "call$2", "get$putIfAbsent", 4, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V, args: [K, {func: 1, ret: V}]};
        }, this.$receiver, "SplayTreeMap");
      }, 6, [], 85, [], "putIfAbsent"],
      addAll$1: [function(_, other) {
        J.forEach$1$ax(other, new P.SplayTreeMap_addAll_closure(this));
      }, "call$1", "get$addAll", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, v: true, args: [[P.Map, K, V]]};
        }, this.$receiver, "SplayTreeMap");
      }, 2, [], "addAll"],
      get$isEmpty: [function(_) {
        return this._root == null;
      }, null, null, 1, 0, 5, "isEmpty"],
      get$isNotEmpty: [function(_) {
        return this._root != null;
      }, null, null, 1, 0, 5, "isNotEmpty"],
      forEach$1: [function(_, f) {
        var t1, t2, nodes, node;
        t1 = H.getTypeArgumentByIndex(this, 0);
        t2 = [P._SplayTreeNode, t1];
        nodes = new P._SplayTreeNodeIterator(this, H.setRuntimeTypeInfo([], [t2]), this._modificationCount, this._splayCount, null, [t1]);
        nodes._SplayTreeIterator$1(this, t1, t2);
        for (; nodes.moveNext$0();) {
          node = nodes.get$current();
          f.call$2(node.get$key(), node.get$value());
        }
      }, "call$1", "get$forEach", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, v: true, args: [{func: 1, v: true, args: [K, V]}]};
        }, this.$receiver, "SplayTreeMap");
      }, 9, [], "forEach"],
      get$length: [function(_) {
        return this._collection$_count;
      }, null, null, 1, 0, 11, "length"],
      clear$0: [function(_) {
        this._root = null;
        this._collection$_count = 0;
        this._modificationCount = J.$add$ns(this._modificationCount, 1);
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      containsKey$1: [function(key) {
        return this._validKey.call$1(key) === true && J.$eq$(this._splay$1(key), 0);
      }, "call$1", "get$containsKey", 2, 0, 15, 6, [], "containsKey"],
      containsValue$1: [function(value) {
        return new P.SplayTreeMap_containsValue_visit(this, value, this._splayCount).call$1(this._root);
      }, "call$1", "get$containsValue", 2, 0, 15, 1, [], "containsValue"],
      get$keys: [function() {
        return new P._SplayTreeKeyIterable(this, [H.getTypeArgumentByIndex(this, 0)]);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: [P.Iterable, K]};
        }, this.$receiver, "SplayTreeMap");
      }, "keys"],
      get$values: [function() {
        return new P._SplayTreeValueIterable(this, this.$ti);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: [P.Iterable, V]};
        }, this.$receiver, "SplayTreeMap");
      }, "values"],
      toString$0: [function(_) {
        return P.Maps_mapToString(this);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      firstKey$0: [function() {
        if (this._root == null)
          return;
        return this.get$_collection$_first().get$key();
      }, "call$0", "get$firstKey", 0, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: K};
        }, this.$receiver, "SplayTreeMap");
      }, "firstKey"],
      lastKey$0: [function() {
        if (this._root == null)
          return;
        return this.get$_collection$_last().get$key();
      }, "call$0", "get$lastKey", 0, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: K};
        }, this.$receiver, "SplayTreeMap");
      }, "lastKey"],
      lastKeyBefore$1: [function(key) {
        var node;
        if (key == null)
          throw H.wrapException(P.ArgumentError$(key));
        if (this._root == null)
          return;
        if (J.$lt$n(this._splay$1(key), 0))
          return this._root.get$key();
        node = this._root.get$left();
        if (node == null)
          return;
        for (; node.get$right() != null;)
          node = node.get$right();
        return node.get$key();
      }, "call$1", "get$lastKeyBefore", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: K, args: [K]};
        }, this.$receiver, "SplayTreeMap");
      }, 6, [], "lastKeyBefore"],
      firstKeyAfter$1: [function(key) {
        var node;
        if (key == null)
          throw H.wrapException(P.ArgumentError$(key));
        if (this._root == null)
          return;
        if (J.$gt$n(this._splay$1(key), 0))
          return this._root.get$key();
        node = this._root.get$right();
        if (node == null)
          return;
        for (; node.get$left() != null;)
          node = node.get$left();
        return node.get$key();
      }, "call$1", "get$firstKeyAfter", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: K, args: [K]};
        }, this.$receiver, "SplayTreeMap");
      }, 6, [], "firstKeyAfter"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $as_SplayTree: function($K, $V) {
        return [$K, [P._SplayTreeMapNode, $K, $V]];
      },
      $asMap: null,
      $isMap: 1,
      "<>": [122, 247],
      static: {
        SplayTreeMap$: [function(compare, isValidKey, $K, $V) {
          var t1, t2;
          t1 = compare == null ? H.functionTypeCast(P.core_Comparable_compare$closure(), {func: 1, ret: P.int, args: [$K, $K]}) : compare;
          t2 = isValidKey == null ? new P.SplayTreeMap_closure($K) : isValidKey;
          return new P.SplayTreeMap(null, new P._SplayTreeMapNode(null, null, null, null, [$K, $V]), t1, t2, 0, 0, 0, [$K, $V]);
        }, null, null, 0, 4, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, opt: [{func: 1, ret: P.int, args: [K, K]}, {func: 1, ret: P.bool, args: [,]}]};
          }, this.$receiver, "SplayTreeMap");
        }, 0, 0, 116, [], 101, [], "new SplayTreeMap"],
        SplayTreeMap_SplayTreeMap$from: [function(other, compare, isValidKey, $K, $V) {
          var result = P.SplayTreeMap$(compare, isValidKey, $K, $V);
          J.forEach$1$ax(other, new P.closure15(result));
          return result;
        }, null, null, 2, 4, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, ret: [P.SplayTreeMap, K, V], args: [P.Map], opt: [{func: 1, ret: P.int, args: [K, K]}, {func: 1, ret: P.bool, args: [,]}]};
          }, this.$receiver, "SplayTreeMap");
        }, 0, 0, 2, [], 116, [], 101, [], "new SplayTreeMap$from"],
        SplayTreeMap_SplayTreeMap$fromIterable: [function(iterable, compare, isValidKey, key, value, $K, $V) {
          var map = P.SplayTreeMap$(compare, isValidKey, $K, $V);
          P.Maps__fillMapWithMappedIterable(map, iterable, key, value);
          return map;
        }, null, null, 2, 9, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, ret: [P.SplayTreeMap, K, V], args: [P.Iterable], named: {compare: {func: 1, ret: P.int, args: [K, K]}, isValidKey: {func: 1, ret: P.bool, args: [,]}, key: {func: 1, ret: K, args: [,]}, value: {func: 1, ret: V, args: [,]}}};
          }, this.$receiver, "SplayTreeMap");
        }, 0, 0, 0, 0, 42, [], 6, [], 1, [], 116, [], 101, [], "new SplayTreeMap$fromIterable"],
        SplayTreeMap_SplayTreeMap$fromIterables: [function(keys, values, compare, isValidKey, $K, $V) {
          var map = P.SplayTreeMap$(compare, isValidKey, $K, $V);
          P.Maps__fillMapWithIterables(map, keys, values);
          return map;
        }, null, null, 4, 4, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, ret: [P.SplayTreeMap, K, V], args: [[P.Iterable, K], [P.Iterable, V]], opt: [{func: 1, ret: P.int, args: [K, K]}, {func: 1, ret: P.bool, args: [,]}]};
          }, this.$receiver, "SplayTreeMap");
        }, 0, 0, 177, [], 166, [], 116, [], 101, [], "new SplayTreeMap$fromIterables"],
        SplayTreeMap$_internal: [function($K, $V) {
          return new P.SplayTreeMap(null, new P._SplayTreeMapNode(null, null, null, null, [$K, $V]), null, null, 0, 0, 0, [$K, $V]);
        }, null, null, 0, 0, 4, "new SplayTreeMap$_internal"]
      }
    },
    "+SplayTreeMap": [1350, 1351],
    SplayTreeMap_closure: {
      "^": "Closure:3;K",
      call$1: [function(v) {
        return H.checkSubtypeOfRuntimeType(v, this.K);
      }, null, null, 2, 0, 3, 56, [], "call"]
    },
    "+ SplayTreeMap_closure": [2],
    closure15: {
      "^": "Closure:12;result",
      call$2: [function(k, v) {
        this.result.$indexSet(0, k, v);
      }, null, null, 4, 0, 12, 274, [], 56, [], "call"]
    },
    "+ closure": [2],
    SplayTreeMap_addAll_closure: {
      "^": "Closure;$this",
      call$2: [function(key, value) {
        this.$this.$indexSet(0, key, value);
      }, null, null, 4, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, args: [K, V]};
        }, this.$receiver, "SplayTreeMap");
      }, 6, [], 1, [], "call"],
      $signature: function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, args: [K, V]};
        }, this.$this, "SplayTreeMap");
      }
    },
    "+ SplayTreeMap_addAll_closure": [2],
    SplayTreeMap_containsValue_visit: {
      "^": "Closure:456;$this,value,initialSplayCount",
      call$1: [function(node) {
        var t1, t2, t3, t4;
        for (t1 = this.initialSplayCount, t2 = this.$this, t3 = J.getInterceptor(t1), t4 = this.value; node != null;) {
          if (J.$eq$(node.get$value(), t4))
            return true;
          if (!t3.$eq(t1, t2._splayCount))
            throw H.wrapException(new P.ConcurrentModificationError(t2));
          if (node.get$right() != null && this.call$1(node.get$right()) === true)
            return true;
          node = node.get$left();
        }
        return false;
      }, null, null, 2, 0, 456, 111, [], "call"]
    },
    "+ SplayTreeMap_containsValue_visit": [2],
    _SplayTreeIterator: {
      "^": "Object;_tree<-231,_workList<-227,_modificationCount@-0,_splayCount@-0,_currentNode@-225,$ti",
      get$current: [function() {
        var t1 = this._currentNode;
        if (t1 == null)
          return;
        return this._getValue$1(t1);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(K, T) {
          return {func: 1, ret: T};
        }, this.$receiver, "_SplayTreeIterator");
      }, "current"],
      _findLeftMostDescendent$1: [function(node) {
        var t1, t2;
        for (t1 = this._workList, t2 = J.getInterceptor$ax(t1); node != null;) {
          t2.add$1(t1, node);
          node = node.get$left();
        }
      }, "call$1", "get$_findLeftMostDescendent", 2, 0, function() {
        return H.computeSignature(function(K, T) {
          return {func: 1, v: true, args: [[P._SplayTreeNode, K]]};
        }, this.$receiver, "_SplayTreeIterator");
      }, 111, [], "_findLeftMostDescendent"],
      _rebuildWorkList$1: [function(currentNode) {
        var t1;
        J.clear$0$ax(this._workList);
        t1 = this._tree;
        if (currentNode == null)
          this._findLeftMostDescendent$1(t1.get$_root());
        else {
          t1._splay$1(currentNode.get$key());
          this._findLeftMostDescendent$1(t1.get$_root().get$right());
        }
      }, "call$1", "get$_rebuildWorkList", 2, 0, function() {
        return H.computeSignature(function(K, T) {
          return {func: 1, v: true, args: [[P._SplayTreeNode, K]]};
        }, this.$receiver, "_SplayTreeIterator");
      }, 747, [], "_rebuildWorkList"],
      moveNext$0: [function() {
        var t1, t2, t3, t4;
        t1 = this._tree;
        if (!J.$eq$(this._modificationCount, t1.get$_modificationCount()))
          throw H.wrapException(new P.ConcurrentModificationError(t1));
        t2 = this._workList;
        t3 = J.getInterceptor$asx(t2);
        if (t3.get$isEmpty(t2) === true) {
          this._currentNode = null;
          return false;
        }
        if (!J.$eq$(t1.get$_splayCount(), this._splayCount) && this._currentNode != null) {
          t4 = this._currentNode;
          t3.clear$0(t2);
          if (t4 == null)
            this._findLeftMostDescendent$1(t1.get$_root());
          else {
            t1._splay$1(t4.get$key());
            this._findLeftMostDescendent$1(t1.get$_root().get$right());
          }
        }
        t1 = t3.removeLast$0(t2);
        this._currentNode = t1;
        this._findLeftMostDescendent$1(t1.get$right());
        return true;
      }, "call$0", "get$moveNext", 0, 0, 5, "moveNext"],
      _SplayTreeIterator$startAt$2: function(tree, startKey, $K, $T) {
        var compare;
        if (tree.get$_root() == null)
          return;
        compare = tree._splay$1(startKey);
        this._splayCount = tree.get$_splayCount();
        if (J.$lt$n(compare, 0))
          this._findLeftMostDescendent$1(tree.get$_root().get$right());
        else
          J.add$1$ax(this._workList, tree.get$_root());
      },
      _SplayTreeIterator$1: function(tree, $K, $T) {
        this._findLeftMostDescendent$1(tree.get$_root());
      },
      "<>": [215, 596],
      static: {
        _SplayTreeIterator$: [function(tree, $K, $T) {
          var t1 = new P._SplayTreeIterator(tree, H.setRuntimeTypeInfo([], [[P._SplayTreeNode, $K]]), tree.get$_modificationCount(), tree.get$_splayCount(), null, [$K, $T]);
          t1._SplayTreeIterator$1(tree, $K, $T);
          return t1;
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(K, T) {
            return {func: 1, args: [[P._SplayTree, K, [P._SplayTreeNode, K]]]};
          }, this.$receiver, "_SplayTreeIterator");
        }, 273, [], "new _SplayTreeIterator"],
        _SplayTreeIterator$startAt: [function(tree, startKey, $K, $T) {
          var t1 = new P._SplayTreeIterator(tree, H.setRuntimeTypeInfo([], [[P._SplayTreeNode, $K]]), tree.get$_modificationCount(), null, null, [$K, $T]);
          t1._SplayTreeIterator$startAt$2(tree, startKey, $K, $T);
          return t1;
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(K, T) {
            return {func: 1, args: [[P._SplayTree, K, [P._SplayTreeNode, K]], K]};
          }, this.$receiver, "_SplayTreeIterator");
        }, 273, [], 450, [], "new _SplayTreeIterator$startAt"]
      }
    },
    "+_SplayTreeIterator": [1, 1355],
    _SplayTreeKeyIterable: {
      "^": "EfficientLengthIterable;_tree@-1356,$ti",
      get$length: [function(_) {
        return this._tree.get$_collection$_count();
      }, null, null, 1, 0, 11, "length"],
      get$isEmpty: [function(_) {
        return J.$eq$(this._tree.get$_collection$_count(), 0);
      }, null, null, 1, 0, 5, "isEmpty"],
      get$iterator: [function(_) {
        var t1, t2, t3;
        t1 = this._tree;
        t2 = H.getTypeArgumentByIndex(this, 0);
        t3 = new P._SplayTreeKeyIterator(t1, H.setRuntimeTypeInfo([], [[P._SplayTreeNode, t2]]), t1.get$_modificationCount(), t1.get$_splayCount(), null, this.$ti);
        t3._SplayTreeIterator$1(t1, t2, t2);
        return t3;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(K) {
          return {func: 1, ret: [P.Iterator, K]};
        }, this.$receiver, "_SplayTreeKeyIterable");
      }, "iterator"],
      toSet$0: [function(_) {
        var set = P.SplayTreeSet$(this._tree.get$_comparator(), this._tree.get$_validKey(), H.getTypeArgumentByIndex(this, 0));
        set._collection$_count = this._tree.get$_collection$_count();
        set._root = set._copyNode$1(this._tree.get$_root());
        return set;
      }, "call$0", "get$toSet", 0, 0, function() {
        return H.computeSignature(function(K) {
          return {func: 1, ret: [P.Set, K]};
        }, this.$receiver, "_SplayTreeKeyIterable");
      }, "toSet"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      "<>": [246],
      static: {
        _SplayTreeKeyIterable$: [function(_tree, $K) {
          return new P._SplayTreeKeyIterable(_tree, [$K]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(K) {
            return {func: 1, args: [[P._SplayTree, K, [P._SplayTreeNode, K]]]};
          }, this.$receiver, "_SplayTreeKeyIterable");
        }, 764, [], "new _SplayTreeKeyIterable"]
      }
    },
    "+_SplayTreeKeyIterable": [1357],
    _SplayTreeValueIterable: {
      "^": "EfficientLengthIterable;_collection$_map@-1358,$ti",
      get$length: [function(_) {
        return this._collection$_map.get$_collection$_count();
      }, null, null, 1, 0, 11, "length"],
      get$isEmpty: [function(_) {
        return J.$eq$(this._collection$_map.get$_collection$_count(), 0);
      }, null, null, 1, 0, 5, "isEmpty"],
      get$iterator: [function(_) {
        var t1, t2, t3;
        t1 = this._collection$_map;
        t2 = H.getTypeArgumentByIndex(this, 0);
        t3 = new P._SplayTreeValueIterator(t1, H.setRuntimeTypeInfo([], [[P._SplayTreeNode, t2]]), t1.get$_modificationCount(), t1.get$_splayCount(), null, this.$ti);
        t3._SplayTreeIterator$1(t1, t2, H.getTypeArgumentByIndex(this, 1));
        return t3;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: [P.Iterator, V]};
        }, this.$receiver, "_SplayTreeValueIterable");
      }, "iterator"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $asEfficientLengthIterable: function($K, $V) {
        return [$V];
      },
      $asIterable: function($K, $V) {
        return [$V];
      },
      "<>": [587, 309],
      static: {
        _SplayTreeValueIterable$: [function(_map, $K, $V) {
          return new P._SplayTreeValueIterable(_map, [$K, $V]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, args: [[P.SplayTreeMap, K, V]]};
          }, this.$receiver, "_SplayTreeValueIterable");
        }, 341, [], "new _SplayTreeValueIterable"]
      }
    },
    "+_SplayTreeValueIterable": [1359],
    _SplayTreeKeyIterator: {
      "^": "_SplayTreeIterator;_tree-231,_workList-227,_modificationCount-0,_splayCount-0,_currentNode-225,$ti",
      _getValue$1: [function(node) {
        return node.get$key();
      }, "call$1", "get$_getValue", 2, 0, function() {
        return H.computeSignature(function(K) {
          return {func: 1, ret: K, args: [[P._SplayTreeNode, K]]};
        }, this.$receiver, "_SplayTreeKeyIterator");
      }, 111, [], "_getValue"],
      $as_SplayTreeIterator: function($K) {
        return [$K, $K];
      },
      "<>": [308],
      static: {
        _SplayTreeKeyIterator$: [function(map, $K) {
          var t1 = new P._SplayTreeKeyIterator(map, H.setRuntimeTypeInfo([], [[P._SplayTreeNode, $K]]), map.get$_modificationCount(), map.get$_splayCount(), null, [$K]);
          t1._SplayTreeIterator$1(map, $K, $K);
          return t1;
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(K) {
            return {func: 1, args: [[P._SplayTree, K, [P._SplayTreeNode, K]]]};
          }, this.$receiver, "_SplayTreeKeyIterator");
        }, 55, [], "new _SplayTreeKeyIterator"]
      }
    },
    "+_SplayTreeKeyIterator": [1360],
    _SplayTreeValueIterator: {
      "^": "_SplayTreeIterator;_tree-231,_workList-227,_modificationCount-0,_splayCount-0,_currentNode-225,$ti",
      _getValue$1: [function(node) {
        return node.get$value();
      }, "call$1", "get$_getValue", 2, 0, function() {
        return H.computeSignature(function(K, V) {
          return {func: 1, ret: V, args: [[P._SplayTreeNode, K]]};
        }, this.$receiver, "_SplayTreeValueIterator");
      }, 111, [], "_getValue"],
      "<>": [594, 591],
      static: {
        _SplayTreeValueIterator$: [function(map, $K, $V) {
          var t1 = new P._SplayTreeValueIterator(map, H.setRuntimeTypeInfo([], [[P._SplayTreeNode, $K]]), map.get$_modificationCount(), map.get$_splayCount(), null, [$K, $V]);
          t1._SplayTreeIterator$1(map, $K, $V);
          return t1;
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, args: [[P.SplayTreeMap, K, V]]};
          }, this.$receiver, "_SplayTreeValueIterator");
        }, 55, [], "new _SplayTreeValueIterator"]
      }
    },
    "+_SplayTreeValueIterator": [1361],
    _SplayTreeNodeIterator: {
      "^": "_SplayTreeIterator;_tree-231,_workList-227,_modificationCount-0,_splayCount-0,_currentNode-225,$ti",
      _getValue$1: [function(node) {
        return node;
      }, "call$1", "get$_getValue", 2, 0, function() {
        return H.computeSignature(function(K) {
          return {func: 1, ret: [P._SplayTreeNode, K], args: [[P._SplayTreeNode, K]]};
        }, this.$receiver, "_SplayTreeNodeIterator");
      }, 111, [], "_getValue"],
      $as_SplayTreeIterator: function($K) {
        return [$K, [P._SplayTreeNode, $K]];
      },
      "<>": [348],
      static: {
        _SplayTreeNodeIterator$: [function(tree, $K) {
          var t1, t2;
          t1 = [P._SplayTreeNode, $K];
          t2 = new P._SplayTreeNodeIterator(tree, H.setRuntimeTypeInfo([], [t1]), tree.get$_modificationCount(), tree.get$_splayCount(), null, [$K]);
          t2._SplayTreeIterator$1(tree, $K, t1);
          return t2;
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(K) {
            return {func: 1, args: [[P._SplayTree, K, [P._SplayTreeNode, K]]]};
          }, this.$receiver, "_SplayTreeNodeIterator");
        }, 273, [], "new _SplayTreeNodeIterator"],
        _SplayTreeNodeIterator$startAt: [function(tree, startKey, $K) {
          var t1, t2;
          t1 = [P._SplayTreeNode, $K];
          t2 = new P._SplayTreeNodeIterator(tree, H.setRuntimeTypeInfo([], [t1]), tree.get$_modificationCount(), null, null, [$K]);
          t2._SplayTreeIterator$startAt$2(tree, startKey, $K, t1);
          return t2;
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(K) {
            return {func: 1, args: [[P._SplayTree, K, [P._SplayTreeNode, K]], K]};
          }, this.$receiver, "_SplayTreeNodeIterator");
        }, 273, [], 450, [], "new _SplayTreeNodeIterator$startAt"]
      }
    },
    "+_SplayTreeNodeIterator": [1362],
    SplayTreeSet: {
      "^": "_SplayTree_IterableMixin_SetMixin;_root@-464,_dummy<-464,_comparator@-1364,_validKey@-462,_collection$_count-0,_modificationCount-0,_splayCount-0,$ti",
      _compare$2: [function(e1, e2) {
        return this._comparator.call$2(e1, e2);
      }, "call$2", "get$_compare", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.int, args: [E, E]};
        }, this.$receiver, "SplayTreeSet");
      }, 746, [], 745, [], "_compare"],
      get$iterator: [function(_) {
        var t1, t2;
        t1 = H.getTypeArgumentByIndex(this, 0);
        t2 = new P._SplayTreeKeyIterator(this, H.setRuntimeTypeInfo([], [[P._SplayTreeNode, t1]]), this._modificationCount, this._splayCount, null, this.$ti);
        t2._SplayTreeIterator$1(this, t1, t1);
        return t2;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterator, E]};
        }, this.$receiver, "SplayTreeSet");
      }, "iterator"],
      get$length: [function(_) {
        return this._collection$_count;
      }, null, null, 1, 0, 11, "length"],
      get$isEmpty: [function(_) {
        return this._root == null;
      }, null, null, 1, 0, 5, "isEmpty"],
      get$isNotEmpty: [function(_) {
        return this._root != null;
      }, null, null, 1, 0, 5, "isNotEmpty"],
      get$first: [function(_) {
        if (J.$eq$(this._collection$_count, 0))
          throw H.wrapException(H.IterableElementError_noElement());
        return this.get$_collection$_first().get$key();
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "SplayTreeSet");
      }, "first"],
      get$last: [function(_) {
        if (J.$eq$(this._collection$_count, 0))
          throw H.wrapException(H.IterableElementError_noElement());
        return this.get$_collection$_last().get$key();
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "SplayTreeSet");
      }, "last"],
      get$single: [function(_) {
        if (J.$eq$(this._collection$_count, 0))
          throw H.wrapException(H.IterableElementError_noElement());
        if (J.$gt$n(this._collection$_count, 1))
          throw H.wrapException(H.IterableElementError_tooMany());
        return this._root.get$key();
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "SplayTreeSet");
      }, "single"],
      contains$1: [function(_, object) {
        return this._validKey.call$1(object) === true && J.$eq$(this._splay$1(object), 0);
      }, "call$1", "get$contains", 2, 0, 15, 23, [], "contains"],
      add$1: [function(_, element) {
        var compare = this._splay$1(element);
        if (J.$eq$(compare, 0))
          return false;
        this._addNewRoot$2(new P._SplayTreeNode(element, null, null, [null]), compare);
        return true;
      }, "call$1", "get$add", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.bool, args: [E]};
        }, this.$receiver, "SplayTreeSet");
      }, 31, [], "add"],
      remove$1: [function(_, object) {
        if (this._validKey.call$1(object) !== true)
          return false;
        return this._remove$1(object) != null;
      }, "call$1", "get$remove", 2, 0, 15, 23, [], "remove"],
      addAll$1: [function(_, elements) {
        var t1, t2, element, compare;
        for (t1 = J.get$iterator$ax(elements), t2 = [null]; t1.moveNext$0();) {
          element = t1.get$current();
          compare = this._splay$1(element);
          if (!J.$eq$(compare, 0))
            this._addNewRoot$2(new P._SplayTreeNode(element, null, null, t2), compare);
        }
      }, "call$1", "get$addAll", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [[P.Iterable, E]]};
        }, this.$receiver, "SplayTreeSet");
      }, 35, [], "addAll"],
      removeAll$1: [function(elements) {
        var t1, element;
        for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();) {
          element = t1.get$current();
          if (this._validKey.call$1(element) === true)
            this._remove$1(element);
        }
      }, "call$1", "get$removeAll", 2, 0, 152, 35, [], "removeAll"],
      retainAll$1: [function(elements) {
        var retainSet, modificationCount, t1, t2, object;
        retainSet = P.SplayTreeSet$(this._comparator, this._validKey, H.getTypeArgumentByIndex(this, 0));
        modificationCount = this._modificationCount;
        for (t1 = J.get$iterator$ax(elements), t2 = J.getInterceptor(modificationCount); t1.moveNext$0();) {
          object = t1.get$current();
          if (!t2.$eq(modificationCount, this._modificationCount))
            throw H.wrapException(new P.ConcurrentModificationError(this));
          if (this._validKey.call$1(object) === true && J.$eq$(this._splay$1(object), 0))
            retainSet.add$1(0, this._root.get$key());
        }
        if (!J.$eq$(retainSet._collection$_count, this._collection$_count)) {
          this._root = retainSet._root;
          this._collection$_count = retainSet._collection$_count;
          this._modificationCount = J.$add$ns(this._modificationCount, 1);
        }
      }, "call$1", "get$retainAll", 2, 0, 152, 35, [], "retainAll"],
      lookup$1: [function(object) {
        if (this._validKey.call$1(object) !== true)
          return;
        if (!J.$eq$(this._splay$1(object), 0))
          return;
        return this._root.get$key();
      }, "call$1", "get$lookup", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [P.Object]};
        }, this.$receiver, "SplayTreeSet");
      }, 23, [], "lookup"],
      intersection$1: [function(other) {
        var t1, result, t2, element;
        t1 = H.getTypeArgumentByIndex(this, 0);
        result = P.SplayTreeSet$(this._comparator, this._validKey, t1);
        for (t2 = new P._SplayTreeKeyIterator(this, H.setRuntimeTypeInfo([], [[P._SplayTreeNode, t1]]), this._modificationCount, this._splayCount, null, this.$ti), t2._SplayTreeIterator$1(this, t1, t1), t1 = J.getInterceptor$asx(other); t2.moveNext$0();) {
          element = t2.get$current();
          if (t1.contains$1(other, element) === true)
            result.add$1(0, element);
        }
        return result;
      }, "call$1", "get$intersection", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Set, E], args: [[P.Set, P.Object]]};
        }, this.$receiver, "SplayTreeSet");
      }, 2, [], "intersection"],
      difference$1: [function(other) {
        var t1, result, t2, element;
        t1 = H.getTypeArgumentByIndex(this, 0);
        result = P.SplayTreeSet$(this._comparator, this._validKey, t1);
        for (t2 = new P._SplayTreeKeyIterator(this, H.setRuntimeTypeInfo([], [[P._SplayTreeNode, t1]]), this._modificationCount, this._splayCount, null, this.$ti), t2._SplayTreeIterator$1(this, t1, t1), t1 = J.getInterceptor$asx(other); t2.moveNext$0();) {
          element = t2.get$current();
          if (t1.contains$1(other, element) !== true)
            result.add$1(0, element);
        }
        return result;
      }, "call$1", "get$difference", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Set, E], args: [[P.Set, P.Object]]};
        }, this.$receiver, "SplayTreeSet");
      }, 2, [], "difference"],
      union$1: [function(other) {
        var t1 = this._clone$0();
        t1.addAll$1(0, other);
        return t1;
      }, "call$1", "get$union", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Set, E], args: [[P.Set, E]]};
        }, this.$receiver, "SplayTreeSet");
      }, 2, [], "union"],
      _clone$0: [function() {
        var set = P.SplayTreeSet$(this._comparator, this._validKey, H.getTypeArgumentByIndex(this, 0));
        set._collection$_count = this._collection$_count;
        set._root = this._copyNode$1(this._root);
        return set;
      }, "call$0", "get$_clone", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.SplayTreeSet, E]};
        }, this.$receiver, "SplayTreeSet");
      }, "_clone"],
      _copyNode$1: [function(node) {
        var t1;
        if (node == null)
          return;
        t1 = new P._SplayTreeNode(node.get$key(), null, null, this.$ti);
        t1.left = this._copyNode$1(node.get$left());
        t1.right = this._copyNode$1(node.get$right());
        return t1;
      }, "call$1", "get$_copyNode", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P._SplayTreeNode, E], args: [[P._SplayTreeNode, E]]};
        }, this.$receiver, "SplayTreeSet");
      }, 111, [], "_copyNode"],
      clear$0: [function(_) {
        this._root = null;
        this._collection$_count = 0;
        this._modificationCount = J.$add$ns(this._modificationCount, 1);
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      toSet$0: [function(_) {
        return this._clone$0();
      }, "call$0", "get$toSet", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Set, E]};
        }, this.$receiver, "SplayTreeSet");
      }, "toSet"],
      toString$0: [function(_) {
        return P.IterableBase_iterableToFullString(this, "{", "}");
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      "<>": [168],
      static: {
        SplayTreeSet$: [function(compare, isValidKey, $E) {
          var t1, t2;
          t1 = compare == null ? P.core_Comparable_compare$closure() : compare;
          t2 = isValidKey == null ? new P.SplayTreeSet_closure($E) : isValidKey;
          return new P.SplayTreeSet(null, new P._SplayTreeNode(null, null, null, [$E]), t1, t2, 0, 0, 0, [$E]);
        }, null, null, 0, 4, function() {
          return H.computeSignature(function(E) {
            return {func: 1, opt: [{func: 1, ret: P.int, args: [E, E]}, {func: 1, ret: P.bool, args: [,]}]};
          }, this.$receiver, "SplayTreeSet");
        }, 0, 0, 116, [], 101, [], "new SplayTreeSet"],
        SplayTreeSet_SplayTreeSet$from: [function(elements, compare, isValidKey, $E) {
          var result, t1;
          result = P.SplayTreeSet$(compare, isValidKey, $E);
          for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
            result.add$1(0, t1.get$current());
          return result;
        }, null, null, 2, 4, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.SplayTreeSet, E], args: [P.Iterable], opt: [{func: 1, ret: P.int, args: [E, E]}, {func: 1, ret: P.bool, args: [,]}]};
          }, this.$receiver, "SplayTreeSet");
        }, 0, 0, 35, [], 116, [], 101, [], "new SplayTreeSet$from"]
      }
    },
    "+SplayTreeSet": [1365],
    _SplayTree_IterableMixin: {
      "^": "_SplayTree+IterableMixin;_collection$_count-0,_modificationCount-0,_splayCount-0,$ti",
      $as_SplayTree: function($E) {
        return [$E, [P._SplayTreeNode, $E]];
      },
      $asIterable: null,
      $isIterable: 1,
      "<>": [931],
      static: {
        "_SplayTree+IterableMixin$": [function($E) {
          return new P._SplayTree_IterableMixin(0, 0, 0, [$E]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(K, Node) {
            return {func: 1, ret: [P._SplayTree, K, Node]};
          }, this.$receiver, "_SplayTree");
        }, "new _SplayTree+IterableMixin"]
      }
    },
    _SplayTree_IterableMixin_SetMixin: {
      "^": "_SplayTree_IterableMixin+SetMixin;_collection$_count-0,_modificationCount-0,_splayCount-0,$ti",
      $asIterable: null,
      $asSet: null,
      $asEfficientLengthIterable: null,
      $isSet: 1,
      $isEfficientLengthIterable: 1,
      $isIterable: 1,
      "<>": [938],
      static: {
        "_SplayTree+IterableMixin+SetMixin$": [function($E) {
          return new P._SplayTree_IterableMixin_SetMixin(0, 0, 0, [$E]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(K, Node) {
            return {func: 1, ret: [P._SplayTree, K, Node]};
          }, this.$receiver, "_SplayTree");
        }, "new _SplayTree+IterableMixin+SetMixin"]
      }
    },
    SplayTreeSet_closure: {
      "^": "Closure:3;E",
      call$1: [function(v) {
        return H.checkSubtypeOfRuntimeType(v, this.E);
      }, null, null, 2, 0, 3, 56, [], "call"]
    },
    "+ SplayTreeSet_closure": [2],
    _Equality0: {
      "^": "",
      $typedefType: 1699,
      $$isTypedef: true
    },
    "+_Equality": "",
    _Hasher: {
      "^": "",
      $typedefType: 1700,
      $$isTypedef: true
    },
    "+_Hasher": "",
    _Predicate0: {
      "^": "",
      $typedefType: 1701,
      $$isTypedef: true
    },
    "+_Predicate": ""
  }], ["dart.convert", "dart:convert",, P, {
    "^": "_TAIL_SURROGATE_MIN<-0,_LEAD_SURROGATE_MIN<-0,_SURROGATE_VALUE_MASK<-0,_SURROGATE_TAG_MASK<-0,_SURROGATE_MASK<-0,_FOUR_BYTE_LIMIT<-0,_THREE_BYTE_LIMIT<-0,_TWO_BYTE_LIMIT<-0,_ONE_BYTE_LIMIT<-0,UTF8<-1444,UNICODE_BOM_CHARACTER_RUNE<-0,UNICODE_REPLACEMENT_CHARACTER_RUNE<-0,_CR<-0,_LF<-0,_LATIN1_MASK<-0,LATIN1<-1445,JSON<-1446,HTML_ESCAPE<-472,_paddingChar<-0,BASE64URL<-478,BASE64<-478,_ASCII_MASK<-0,ASCII<-1448",
    _convertJsonToDart: function(json, reviver) {
      return reviver.call$2(null, new P._convertJsonToDart_walk(reviver).call$1(json));
    },
    _convertJsonToDartLazy: function(object) {
      var i;
      if (object == null)
        return;
      if (typeof object != "object")
        return object;
      if (Object.getPrototypeOf(object) !== Array.prototype)
        return new P._JsonMap(object, Object.create(null), null);
      for (i = 0; i < object.length; ++i)
        object[i] = P._convertJsonToDartLazy(object[i]);
      return object;
    },
    _parseJson: [function(source, reviver) {
      var parsed, e, exception, t1;
      if (typeof source !== "string")
        throw H.wrapException(H.argumentErrorValue(source));
      parsed = null;
      try {
        parsed = JSON.parse(source);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        throw H.wrapException(new P.FormatException(String(e), null, null));
      }
      if (reviver == null)
        return P._convertJsonToDartLazy(parsed);
      else
        return P._convertJsonToDart(parsed, reviver);
    }, "call$2", "convert___parseJson$closure", 4, 0, 650, 19, [], 188, [], "_parseJson"],
    _defaultToEncodable: [function(object) {
      return object.toJson$0();
    }, "call$1", "convert___defaultToEncodable$closure", 2, 0, 3, 23, [], "_defaultToEncodable"],
    _isLeadSurrogate: [function(codeUnit) {
      return J.$and$n(codeUnit, 64512) === 55296;
    }, "call$1", "convert___isLeadSurrogate$closure", 2, 0, 32, 366, [], "_isLeadSurrogate"],
    _isTailSurrogate: [function(codeUnit) {
      return J.$and$n(codeUnit, 64512) === 56320;
    }, "call$1", "convert___isTailSurrogate$closure", 2, 0, 32, 366, [], "_isTailSurrogate"],
    _combineSurrogatePair0: [function(lead, tail) {
      var t1, t2;
      t1 = J.$shl$n(J.$and$n(lead, 1023), 10);
      t2 = J.$and$n(tail, 1023);
      if (typeof t2 !== "number")
        return H.iae(t2);
      return (65536 + t1 | t2) >>> 0;
    }, "call$2", "convert___combineSurrogatePair$closure", 4, 0, 70, 714, [], 712, [], "_combineSurrogatePair"],
    _convertJsonToDart_walk: {
      "^": "Closure:3;reviver",
      call$1: [function(e) {
        var t1, i, map, keys, t2, key;
        if (e == null || typeof e != "object")
          return e;
        if (Object.getPrototypeOf(e) === Array.prototype) {
          for (t1 = this.reviver, i = 0; i < e.length; ++i)
            e[i] = t1.call$2(i, this.call$1(e[i]));
          return e;
        }
        t1 = Object.create(null);
        map = new P._JsonMap(e, t1, null);
        keys = map._convert$_computeKeys$0();
        for (t2 = this.reviver, i = 0; i < keys.length; ++i) {
          key = keys[i];
          t1[key] = t2.call$2(key, this.call$1(e[key]));
        }
        map._original = t1;
        return map;
      }, null, null, 2, 0, 3, 47, [], "call"]
    },
    "+ _convertJsonToDart_walk": [2],
    _JsonMap: {
      "^": "Object;_original,_processed,_convert$_data",
      $index: [function(_, key) {
        var t1, result;
        t1 = this._processed;
        if (t1 == null)
          return this._convert$_data.$index(0, key);
        else if (typeof key !== "string")
          return;
        else {
          result = t1[key];
          return typeof result == "undefined" ? this._process$1(key) : result;
        }
      }, null, "get$[]", 2, 0, 3, 6, [], "[]"],
      get$length: [function(_) {
        var t1;
        if (this._processed == null) {
          t1 = this._convert$_data;
          t1 = t1.get$length(t1);
        } else
          t1 = this._convert$_computeKeys$0().length;
        return t1;
      }, null, null, 1, 0, 11, "length"],
      get$isEmpty: [function(_) {
        var t1;
        if (this._processed == null) {
          t1 = this._convert$_data;
          t1 = t1.get$length(t1);
        } else
          t1 = this._convert$_computeKeys$0().length;
        return t1 === 0;
      }, null, null, 1, 0, 5, "isEmpty"],
      get$isNotEmpty: [function(_) {
        var t1;
        if (this._processed == null) {
          t1 = this._convert$_data;
          t1 = t1.get$length(t1);
        } else
          t1 = this._convert$_computeKeys$0().length;
        return t1 > 0;
      }, null, null, 1, 0, 5, "isNotEmpty"],
      get$keys: [function() {
        if (this._processed == null)
          return this._convert$_data.get$keys();
        return new P._JsonMapKeyIterable(this);
      }, null, null, 1, 0, 220, "keys"],
      get$values: [function() {
        if (this._processed == null)
          return this._convert$_data.get$values();
        return H.MappedIterable_MappedIterable(this._convert$_computeKeys$0(), new P._JsonMap_values_closure(this), null, null);
      }, null, null, 1, 0, 220, "values"],
      $indexSet: [function(_, key, value) {
        var processed, original;
        if (this._processed == null)
          this._convert$_data.$indexSet(0, key, value);
        else if (this.containsKey$1(key)) {
          processed = this._processed;
          processed[key] = value;
          original = this._original;
          if (original == null ? processed != null : original !== processed)
            original[key] = null;
        } else
          this._upgrade$0().$indexSet(0, key, value);
      }, null, "get$[]=", 4, 0, 12, 6, [], 1, [], "[]="],
      addAll$1: [function(_, other) {
        J.forEach$1$ax(other, new P._JsonMap_addAll_closure(this));
      }, "call$1", "get$addAll", 2, 0, 287, 2, [], "addAll"],
      containsValue$1: [function(value) {
        var keys, i;
        if (this._processed == null)
          return this._convert$_data.containsValue$1(value);
        keys = this._convert$_computeKeys$0();
        for (i = 0; i < keys.length; ++i)
          if (J.$eq$(this.$index(0, keys[i]), value))
            return true;
        return false;
      }, "call$1", "get$containsValue", 2, 0, 24, 1, [], "containsValue"],
      containsKey$1: [function(key) {
        if (this._processed == null)
          return this._convert$_data.containsKey$1(key);
        if (typeof key !== "string")
          return false;
        return Object.prototype.hasOwnProperty.call(this._original, key);
      }, "call$1", "get$containsKey", 2, 0, 24, 6, [], "containsKey"],
      putIfAbsent$2: [function(key, ifAbsent) {
        var value;
        if (this.containsKey$1(key))
          return this.$index(0, key);
        value = ifAbsent.call$0();
        this.$indexSet(0, key, value);
        return value;
      }, "call$2", "get$putIfAbsent", 4, 0, 1303, 6, [], 85, [], "putIfAbsent"],
      remove$1: [function(_, key) {
        if (this._processed != null && !this.containsKey$1(key))
          return;
        return this._upgrade$0().remove$1(0, key);
      }, "call$1", "get$remove", 2, 0, 170, 6, [], "remove"],
      clear$0: [function(_) {
        var t1;
        if (this._processed == null)
          this._convert$_data.clear$0(0);
        else {
          t1 = this._convert$_data;
          if (t1 != null)
            J.clear$0$ax(t1);
          this._processed = null;
          this._original = null;
          this._convert$_data = P.LinkedHashMap__makeEmpty();
        }
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      forEach$1: [function(_, f) {
        var keys, i, key, value;
        if (this._processed == null)
          return this._convert$_data.forEach$1(0, f);
        keys = this._convert$_computeKeys$0();
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          value = this._processed[key];
          if (typeof value == "undefined") {
            value = P._convertJsonToDartLazy(this._original[key]);
            this._processed[key] = value;
          }
          f.call$2(key, value);
          if (keys !== this._convert$_data)
            throw H.wrapException(new P.ConcurrentModificationError(this));
        }
      }, "call$1", "get$forEach", 2, 0, 458, 9, [], "forEach"],
      toString$0: [function(_) {
        return P.Maps_mapToString(this);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      _convert$_computeKeys$0: function() {
        var keys = this._convert$_data;
        if (keys == null) {
          keys = Object.keys(this._original);
          this._convert$_data = keys;
        }
        return keys;
      },
      _upgrade$0: function() {
        var result, keys, i, t1, key;
        if (this._processed == null)
          return this._convert$_data;
        result = P.LinkedHashMap__makeEmpty();
        keys = this._convert$_computeKeys$0();
        for (i = 0; t1 = keys.length, i < t1; ++i) {
          key = keys[i];
          result.$indexSet(0, key, this.$index(0, key));
        }
        if (t1 === 0)
          keys.push(null);
        else
          C.JSArray_methods.set$length(keys, 0);
        this._processed = null;
        this._original = null;
        this._convert$_data = result;
        return result;
      },
      _process$1: function(key) {
        var result;
        if (!Object.prototype.hasOwnProperty.call(this._original, key))
          return;
        result = P._convertJsonToDartLazy(this._original[key]);
        return this._processed[key] = result;
      },
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $isMap: 1,
      $asMap: Isolate.functionThatReturnsNull
    },
    "+_JsonMap": 0,
    _JsonMap_values_closure: {
      "^": "Closure:3;$this",
      call$1: [function(each) {
        return this.$this.$index(0, each);
      }, null, null, 2, 0, null, 186, [], "call"]
    },
    "+ _JsonMap_values_closure": 0,
    _JsonMap_addAll_closure: {
      "^": "Closure:12;$this",
      call$2: [function(key, value) {
        this.$this.$indexSet(0, key, value);
      }, null, null, 4, 0, null, 6, [], 1, [], "call"]
    },
    "+ _JsonMap_addAll_closure": 0,
    _JsonMapKeyIterable: {
      "^": "ListIterable;_parent",
      get$length: [function(_) {
        var t1 = this._parent;
        if (t1._processed == null) {
          t1 = t1._convert$_data;
          t1 = t1.get$length(t1);
        } else
          t1 = t1._convert$_computeKeys$0().length;
        return t1;
      }, null, null, 1, 0, 11, "length"],
      elementAt$1: [function(_, index) {
        var t1 = this._parent;
        if (t1._processed == null)
          t1 = t1.get$keys().elementAt$1(0, index);
        else {
          t1 = t1._convert$_computeKeys$0();
          if (index >>> 0 !== index || index >= t1.length)
            return H.ioore(t1, index);
          t1 = t1[index];
        }
        return t1;
      }, "call$1", "get$elementAt", 2, 0, 25, 14, [], "elementAt"],
      get$iterator: [function(_) {
        var t1 = this._parent;
        if (t1._processed == null) {
          t1 = t1.get$keys();
          t1 = t1.get$iterator(t1);
        } else {
          t1 = t1._convert$_computeKeys$0();
          t1 = new J.ArrayIterator(t1, t1.length, 0, null, [H.getTypeArgumentByIndex(t1, 0)]);
        }
        return t1;
      }, null, null, 1, 0, 341, "iterator"],
      contains$1: [function(_, key) {
        return this._parent.containsKey$1(key);
      }, "call$1", "get$contains", 2, 0, 15, 6, [], "contains"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $asListIterable: Isolate.functionThatReturnsNull,
      $asEfficientLengthIterable: Isolate.functionThatReturnsNull,
      $asIterable: Isolate.functionThatReturnsNull
    },
    "+_JsonMapKeyIterable": 0,
    _JsonDecoderSink: {
      "^": "_StringSinkConversionSink;_reviver<,_convert$_sink<,_stringSink-57",
      close$0: [function() {
        var buffer, t1, accumulated;
        this.super$_StringSinkConversionSink$close();
        buffer = this._stringSink;
        t1 = J.getInterceptor(buffer);
        accumulated = t1.toString$0(buffer);
        t1.clear$0(buffer);
        t1 = this._convert$_sink;
        J.add$1$ax(t1, P._parseJson(accumulated, this._reviver));
        t1.close$0();
      }, "call$0", "get$close", 0, 0, 6, "close"]
    },
    "+_JsonDecoderSink": 0,
    AsciiCodec: {
      "^": "Encoding;_allowInvalid<-8",
      get$name: [function() {
        return "us-ascii";
      }, null, null, 1, 0, 7, "name"],
      decode$2$allowInvalid: [function(bytes, allowInvalid) {
        if ((allowInvalid == null ? this._allowInvalid : allowInvalid) === true)
          return C.AsciiDecoder_true_127.convert$1(bytes);
        else
          return C.AsciiDecoder_false_127.convert$1(bytes);
      }, function(bytes) {
        return this.decode$2$allowInvalid(bytes, null);
      }, "decode$1", "call$2$allowInvalid", "call$1", "get$decode", 2, 3, 459, 0, 30, [], 156, [], "decode"],
      get$encoder: [function() {
        return C.AsciiEncoder_127;
      }, null, null, 1, 0, 1322, "encoder"],
      get$decoder: [function() {
        return this._allowInvalid === true ? C.AsciiDecoder_true_127 : C.AsciiDecoder_false_127;
      }, null, null, 1, 0, 1324, "decoder"],
      static: {
        AsciiCodec$: [function(allowInvalid) {
          return new P.AsciiCodec(allowInvalid);
        }, null, null, 0, 3, 179, 4, 156, [], "new AsciiCodec"]
      }
    },
    "+AsciiCodec": [79],
    _UnicodeSubsetEncoder: {
      "^": "Converter;_subsetMask<-0",
      convert$3: [function(string, start, end) {
        var t1, stringLength, $length, t2, result, t3, t4, t5, i, codeUnit;
        t1 = J.getInterceptor$asx(string);
        stringLength = t1.get$length(string);
        P.RangeError_checkValidRange(start, end, stringLength, null, null, null);
        $length = J.$sub$n(end == null ? stringLength : end, start);
        t2 = H._checkLength($length);
        result = new Uint8Array(t2);
        if (typeof $length !== "number")
          return H.iae($length);
        t3 = this._subsetMask;
        t4 = J.getInterceptor$i(t3);
        t5 = J.getInterceptor$ns(start);
        i = 0;
        for (; i < $length; ++i) {
          codeUnit = t1.codeUnitAt$1(string, t5.$add(start, i));
          if ((codeUnit & t4.$not(t3)) !== 0)
            throw H.wrapException(P.ArgumentError$("String contains invalid characters."));
          if (i >= t2)
            return H.ioore(result, i);
          result[i] = codeUnit;
        }
        return result;
      }, function(string) {
        return this.convert$3(string, 0, null);
      }, "convert$1", function(string, start) {
        return this.convert$3(string, start, null);
      }, "convert$2", "call$3", "call$1", "call$2", "get$convert", 2, 4, 172, 7, 0, 39, [], 3, [], 5, [], "convert"],
      startChunkedConversion$1: [function(sink) {
        if (!(sink instanceof P.ByteConversionSink))
          sink = new P._ByteAdapterSink(sink);
        return new P._UnicodeSubsetEncoderSink(sink, this._subsetMask);
      }, "call$1", "get$startChunkedConversion", 2, 0, 173, 22, [], "startChunkedConversion"],
      bind$1: [function(stream) {
        return this.super$Converter$bind(stream);
      }, "call$1", "get$bind", 2, 0, 463, 37, [], "bind"],
      $asConverter: function() {
        return [P.String, [P.List, P.int]];
      },
      "<>": [],
      static: {
        _UnicodeSubsetEncoder$: [function(_subsetMask) {
          return new P._UnicodeSubsetEncoder(_subsetMask);
        }, null, null, 2, 0, 22, 406, [], "new _UnicodeSubsetEncoder"]
      }
    },
    "+_UnicodeSubsetEncoder": [194, 192],
    AsciiEncoder: {
      "^": "_UnicodeSubsetEncoder;_subsetMask-0",
      static: {
        AsciiEncoder$: [function() {
          return new P.AsciiEncoder(127);
        }, null, null, 0, 0, 4, "new AsciiEncoder"]
      }
    },
    "+AsciiEncoder": [467],
    _UnicodeSubsetEncoderSink: {
      "^": "StringConversionSinkBase;_convert$_sink<-39,_subsetMask<-0",
      close$0: [function() {
        this._convert$_sink.close$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      addSlice$4: [function(source, start, end, isLast) {
        var t1, t2, t3, i, t4, codeUnit;
        t1 = J.getInterceptor$asx(source);
        P.RangeError_checkValidRange(start, end, t1.get$length(source), null, null, null);
        for (t2 = this._subsetMask, t3 = J.getInterceptor$i(t2), i = start; t4 = J.getInterceptor$n(i), t4.$lt(i, end); i = t4.$add(i, 1)) {
          codeUnit = t1.codeUnitAt$1(source, i);
          if ((codeUnit & t3.$not(t2)) !== 0)
            throw H.wrapException(P.ArgumentError$("Source contains invalid character with code point: " + codeUnit + "."));
        }
        t2 = this._convert$_sink;
        t1 = t1.get$codeUnits(source);
        J.add$1$ax(t2, t1.sublist$2(t1, start, end));
        if (isLast === true)
          t2.close$0();
      }, "call$4", "get$addSlice", 8, 0, 87, 19, [], 3, [], 5, [], 46, [], "addSlice"],
      static: {
        _UnicodeSubsetEncoderSink$: [function(_subsetMask, _sink) {
          return new P._UnicodeSubsetEncoderSink(_sink, _subsetMask);
        }, null, null, 4, 0, 618, 406, [], 45, [], "new _UnicodeSubsetEncoderSink"]
      }
    },
    "+_UnicodeSubsetEncoderSink": [100],
    _UnicodeSubsetDecoder: {
      "^": "Converter;_allowInvalid<-8,_subsetMask<-0",
      convert$3: [function(bytes, start, end) {
        var t1, byteCount, t2, t3, i, t4, byte;
        t1 = J.getInterceptor$asx(bytes);
        byteCount = t1.get$length(bytes);
        P.RangeError_checkValidRange(start, end, byteCount, null, null, null);
        if (end == null)
          end = byteCount;
        for (t2 = this._subsetMask, t3 = J.getInterceptor$i(t2), i = start; t4 = J.getInterceptor$n(i), t4.$lt(i, end); i = t4.$add(i, 1)) {
          byte = t1.$index(bytes, i);
          if (J.$and$n(byte, t3.$not(t2)) !== 0) {
            if (this._allowInvalid !== true)
              throw H.wrapException(new P.FormatException("Invalid value in input: " + H.S(byte), null, null));
            return this._convertInvalid$3(bytes, start, end);
          }
        }
        return P.String_String$fromCharCodes(bytes, start, end);
      }, function(bytes) {
        return this.convert$3(bytes, 0, null);
      }, "convert$1", function(bytes, start) {
        return this.convert$3(bytes, start, null);
      }, "convert$2", "call$3", "call$1", "call$2", "get$convert", 2, 4, 465, 7, 0, 30, [], 3, [], 5, [], "convert"],
      _convertInvalid$3: [function(bytes, start, end) {
        var t1, t2, t3, i, t4, t5, value;
        for (t1 = this._subsetMask, t2 = J.getInterceptor$i(t1), t3 = J.getInterceptor$asx(bytes), i = start, t4 = ""; t5 = J.getInterceptor$n(i), t5.$lt(i, end); i = t5.$add(i, 1)) {
          value = t3.$index(bytes, i);
          t4 += H.Primitives_stringFromCharCode(J.$and$n(value, t2.$not(t1)) !== 0 ? 65533 : value);
        }
        return t4.charCodeAt(0) == 0 ? t4 : t4;
      }, "call$3", "get$_convertInvalid", 6, 0, 1367, 30, [], 3, [], 5, [], "_convertInvalid"],
      bind$1: [function(stream) {
        return this.super$Converter$bind(stream);
      }, "call$1", "get$bind", 2, 0, 466, 37, [], "bind"],
      $asConverter: function() {
        return [[P.List, P.int], P.String];
      },
      "<>": [],
      static: {
        _UnicodeSubsetDecoder$: [function(_allowInvalid, _subsetMask) {
          return new P._UnicodeSubsetDecoder(_allowInvalid, _subsetMask);
        }, null, null, 4, 0, 619, 744, [], 406, [], "new _UnicodeSubsetDecoder"]
      }
    },
    "+_UnicodeSubsetDecoder": [189, 232],
    AsciiDecoder: {
      "^": "_UnicodeSubsetDecoder;_allowInvalid-8,_subsetMask-0",
      startChunkedConversion$1: [function(sink) {
        var stringSink = !!J.getInterceptor(sink).$isStringConversionSink ? sink : new P._StringAdapterSink(sink);
        if (this._allowInvalid === true)
          return new P._ErrorHandlingAsciiDecoderSink(stringSink.asUtf8Sink$1(false));
        else
          return new P._SimpleAsciiDecoderSink(stringSink);
      }, "call$1", "get$startChunkedConversion", 2, 0, 159, 22, [], "startChunkedConversion"],
      static: {
        AsciiDecoder$: [function(allowInvalid) {
          return new P.AsciiDecoder(allowInvalid, 127);
        }, null, null, 0, 3, 179, 4, 156, [], "new AsciiDecoder"]
      }
    },
    "+AsciiDecoder": [468],
    _ErrorHandlingAsciiDecoderSink: {
      "^": "ByteConversionSinkBase;_utf8Sink@-39",
      close$0: [function() {
        this._utf8Sink.close$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      add$1: [function(_, source) {
        this.addSlice$4(source, 0, J.get$length$asx(source), false);
      }, "call$1", "get$add", 2, 0, 26, 19, [], "add"],
      addSlice$4: [function(source, start, end, isLast) {
        var t1, i, t2;
        t1 = J.getInterceptor$asx(source);
        P.RangeError_checkValidRange(start, end, t1.get$length(source), null, null, null);
        for (i = start; t2 = J.getInterceptor$n(i), t2.$lt(i, end); i = t2.$add(i, 1))
          if (J.$and$n(t1.$index(source, i), 4294967168) !== 0) {
            if (t2.$gt(i, start))
              this._utf8Sink.addSlice$4(source, start, i, false);
            J.add$1$ax(this._utf8Sink, C.List_239_191_189);
            start = t2.$add(i, 1);
          }
        if (J.$lt$n(start, end))
          this._utf8Sink.addSlice$4(source, start, end, isLast);
        else if (isLast === true)
          this._utf8Sink.close$0();
      }, "call$4", "get$addSlice", 8, 0, 44, 19, [], 3, [], 5, [], 46, [], "addSlice"],
      static: {
        _ErrorHandlingAsciiDecoderSink$: [function(_utf8Sink) {
          return new P._ErrorHandlingAsciiDecoderSink(_utf8Sink);
        }, null, null, 2, 0, 398, 743, [], "new _ErrorHandlingAsciiDecoderSink"]
      }
    },
    "+_ErrorHandlingAsciiDecoderSink": [99],
    _SimpleAsciiDecoderSink: {
      "^": "ByteConversionSinkBase;_convert$_sink@-469",
      close$0: [function() {
        this._convert$_sink.close$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      add$1: [function(_, source) {
        var t1, i, t2;
        t1 = J.getInterceptor$asx(source);
        i = 0;
        while (true) {
          t2 = t1.get$length(source);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          if (J.$and$n(t1.$index(source, i), 4294967168) !== 0)
            throw H.wrapException(new P.FormatException("Source contains non-ASCII bytes.", null, null));
          ++i;
        }
        J.add$1$ax(this._convert$_sink, P.String_String$fromCharCodes(source, 0, null));
      }, "call$1", "get$add", 2, 0, 26, 19, [], "add"],
      addSlice$4: [function(source, start, end, isLast) {
        var t1, $length, t2;
        t1 = J.getInterceptor$asx(source);
        $length = t1.get$length(source);
        P.RangeError_checkValidRange(start, end, $length, null, null, null);
        t2 = J.getInterceptor$n(start);
        if (t2.$lt(start, end))
          this.add$1(0, !t2.$eq(start, 0) || !J.$eq$(end, $length) ? t1.sublist$2(source, start, end) : source);
        if (isLast === true)
          this._convert$_sink.close$0();
      }, "call$4", "get$addSlice", 8, 0, 44, 19, [], 3, [], 5, [], 46, [], "addSlice"],
      static: {
        _SimpleAsciiDecoderSink$: [function(_sink) {
          return new P._SimpleAsciiDecoderSink(_sink);
        }, null, null, 2, 0, 621, 45, [], "new _SimpleAsciiDecoderSink"]
      }
    },
    "+_SimpleAsciiDecoderSink": [99],
    Base64Codec: {
      "^": "Codec;_encoder<-1379",
      get$encoder: [function() {
        return this._encoder;
      }, null, null, 1, 0, 1373, "encoder"],
      get$decoder: [function() {
        return C.C_Base64Decoder;
      }, null, null, 1, 0, 1374, "decoder"],
      normalize$3: [function(source, start, end) {
        var t1, inverseAlphabet, i, sliceStart, buffer, firstPadding, firstPaddingSourceIndex, paddingCount, t2, i0, char, t3, char0, value, endLength, $length;
        t1 = J.getInterceptor$asx(source);
        end = P.RangeError_checkValidRange(start, end, t1.get$length(source), null, null, null);
        inverseAlphabet = $.$get$_Base64Decoder__inverseAlphabet();
        for (i = start, sliceStart = i, buffer = null, firstPadding = -1, firstPaddingSourceIndex = -1, paddingCount = 0; t2 = J.getInterceptor$n(i), t2.$lt(i, end); i = i0) {
          i0 = t2.$add(i, 1);
          char = t1.codeUnitAt$1(source, i);
          if (char === 37) {
            t3 = J.getInterceptor$ns(i0);
            if (J.$le$n(t3.$add(i0, 2), end)) {
              char0 = H.parseHexByte(source, i0);
              i0 = t3.$add(i0, 2);
              if (char0 === 37)
                char0 = -1;
            } else
              char0 = -1;
          } else
            char0 = char;
          if (0 <= char0 && char0 <= 127) {
            if (char0 < 0 || char0 >= inverseAlphabet.length)
              return H.ioore(inverseAlphabet, char0);
            value = inverseAlphabet[char0];
            if (value >= 0) {
              char0 = C.JSString_methods.codeUnitAt$1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", value);
              if (char0 === char)
                continue;
              char = char0;
            } else {
              if (value === -1) {
                if (J.$lt$n(firstPadding, 0)) {
                  t3 = buffer == null ? buffer : J.get$length$asx(buffer._contents);
                  if (t3 == null)
                    t3 = 0;
                  firstPadding = J.$add$ns(t3, t2.$sub(i, sliceStart));
                  firstPaddingSourceIndex = i;
                }
                ++paddingCount;
                if (char === 61)
                  continue;
              }
              char = char0;
            }
            if (value !== -2) {
              if (buffer == null)
                buffer = new P.StringBuffer("");
              t2 = t1.substring$2(source, sliceStart, i);
              buffer._contents = buffer._contents + t2;
              buffer._contents += H.Primitives_stringFromCharCode(char);
              sliceStart = i0;
              continue;
            }
          }
          throw H.wrapException(new P.FormatException("Invalid base64 data", source, i));
        }
        if (buffer != null) {
          buffer._contents += t1.substring$2(source, sliceStart, end);
          t2 = J.$ge$n(firstPadding, 0);
          t3 = buffer._contents;
          if (t2)
            P.Base64Codec__checkPadding(source, firstPaddingSourceIndex, end, firstPadding, paddingCount, J.get$length$asx(t3));
          else {
            endLength = J.$mod$n(J.$sub$n(J.get$length$asx(t3), 1), 4) + 1;
            if (endLength === 1)
              throw H.wrapException(new P.FormatException("Invalid base64 encoding length ", source, end));
            for (; endLength < 4;) {
              buffer._contents += "=";
              ++endLength;
            }
          }
          t2 = buffer._contents;
          return t1.replaceRange$3(source, start, end, t2.charCodeAt(0) == 0 ? t2 : t2);
        }
        $length = J.$sub$n(end, start);
        if (J.$ge$n(firstPadding, 0))
          P.Base64Codec__checkPadding(source, firstPaddingSourceIndex, end, firstPadding, paddingCount, $length);
        else {
          endLength = J.$mod$n($length, 4);
          if (endLength === 1)
            throw H.wrapException(new P.FormatException("Invalid base64 encoding length ", source, end));
          if (endLength > 1)
            source = t1.replaceRange$3(source, end, end, endLength === 2 ? "==" : "=");
        }
        return source;
      }, function(source) {
        return this.normalize$3(source, 0, null);
      }, "normalize$1", function(source, start) {
        return this.normalize$3(source, start, null);
      }, "normalize$2", "call$3", "call$1", "call$2", "get$normalize", 2, 4, 1375, 7, 0, 19, [], 3, [], 5, [], "normalize"],
      $asCodec: function() {
        return [[P.List, P.int], P.String];
      },
      "<>": [],
      static: {
        Base64Codec$: [function() {
          return new P.Base64Codec(C.Base64Encoder_false);
        }, null, null, 0, 0, 4, "new Base64Codec"],
        Base64Codec$urlSafe: [function() {
          return new P.Base64Codec(C.Base64Encoder_true);
        }, null, null, 0, 0, 4, "new Base64Codec$urlSafe"],
        Base64Codec__checkPadding: [function(source, sourceIndex, sourceEnd, firstPadding, paddingCount, $length) {
          if (J.$mod$n($length, 4) !== 0)
            throw H.wrapException(new P.FormatException("Invalid base64 padding, padded length must be multiple of four, is " + H.S($length), source, sourceEnd));
          if (!J.$eq$(J.$add$ns(firstPadding, paddingCount), $length))
            throw H.wrapException(new P.FormatException("Invalid base64 padding, '=' not at the end", source, sourceIndex));
          if (J.$gt$n(paddingCount, 2))
            throw H.wrapException(new P.FormatException("Invalid base64 padding, more than two '=' characters", source, sourceIndex));
        }, "call$6", "convert_Base64Codec__checkPadding$closure", 12, 0, 622, 19, [], 742, [], 741, [], 740, [], 739, [], 15, [], "_checkPadding"]
      }
    },
    "+Base64Codec": [1380],
    Base64Encoder: {
      "^": "Converter;_urlSafe<-8",
      convert$1: [function(input) {
        var t1, t2;
        t1 = J.getInterceptor$asx(input);
        if (t1.get$isEmpty(input) === true)
          return "";
        t2 = this._urlSafe === true ? "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_" : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        return P.String_String$fromCharCodes(new P._Base64Encoder(0, t2).encode$4(input, 0, t1.get$length(input), true), 0, null);
      }, "call$1", "get$convert", 2, 0, 158, 58, [], "convert"],
      startChunkedConversion$1: [function(sink) {
        var t1;
        if (!!J.getInterceptor(sink).$isStringConversionSink) {
          t1 = sink.asUtf8Sink$1(false);
          return new P._Utf8Base64EncoderSink(t1, new P._Base64Encoder(0, this._urlSafe === true ? "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_" : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"));
        }
        return new P._AsciiBase64EncoderSink(sink, new P._BufferCachingBase64Encoder(null, 0, this._urlSafe === true ? "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_" : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"));
      }, "call$1", "get$startChunkedConversion", 2, 0, 159, 22, [], "startChunkedConversion"],
      $asConverter: function() {
        return [[P.List, P.int], P.String];
      },
      "<>": [],
      static: {
        Base64Encoder$: [function() {
          return new P.Base64Encoder(false);
        }, null, null, 0, 0, 4, "new Base64Encoder"],
        Base64Encoder$urlSafe: [function() {
          return new P.Base64Encoder(true);
        }, null, null, 0, 0, 4, "new Base64Encoder$urlSafe"]
      }
    },
    "+Base64Encoder": [189, 232],
    _Base64Encoder: {
      "^": "Object;_convert$_state@-0,_alphabet<-9",
      createBuffer$1: [function(bufferLength) {
        return new Uint8Array(H._checkLength(bufferLength));
      }, "call$1", "get$createBuffer", 2, 0, 229, 530, [], "createBuffer"],
      encode$4: [function(bytes, start, end, isLast) {
        var $length, byteCount, t1, fullChunks, partialChunkLength, bufferLength, output;
        $length = J.$sub$n(end, start);
        byteCount = J.$add$ns(J.$and$n(this._convert$_state, 3), $length);
        t1 = J.getInterceptor$n(byteCount);
        fullChunks = t1.$tdiv(byteCount, 3);
        partialChunkLength = t1.$sub(byteCount, fullChunks * 3);
        bufferLength = fullChunks * 4;
        if (isLast === true && J.$gt$n(partialChunkLength, 0))
          bufferLength += 4;
        output = this.createBuffer$1(bufferLength);
        this._convert$_state = P._Base64Encoder_encodeChunk(this._alphabet, bytes, start, end, isLast, output, 0, this._convert$_state);
        if (bufferLength > 0)
          return output;
        return;
      }, "call$4", "get$encode", 8, 0, 1382, 30, [], 3, [], 5, [], 46, [], "encode"],
      static: {
        "^": "_Base64Encoder__base64Alphabet<-9,_Base64Encoder__base64urlAlphabet<-9,_Base64Encoder__valueShift<-0,_Base64Encoder__countMask<-0,_Base64Encoder__sixBitMask<-0",
        _Base64Encoder$: [function(urlSafe) {
          return new P._Base64Encoder(0, urlSafe === true ? "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_" : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
        }, null, null, 2, 0, 33, 227, [], "new _Base64Encoder"],
        _Base64Encoder__encodeState: [function(count, bits) {
          var t1 = J.$shl$n(bits, 2);
          if (typeof count !== "number")
            return H.iae(count);
          return (t1 | count) >>> 0;
        }, "call$2", "convert__Base64Encoder__encodeState$closure", 4, 0, 70, 43, [], 400, [], "_encodeState"],
        _Base64Encoder__stateBits: [function(state) {
          return J.$shr$n(state, 2);
        }, "call$1", "convert__Base64Encoder__stateBits$closure", 2, 0, 16, 82, [], "_stateBits"],
        _Base64Encoder__stateCount: [function(state) {
          return J.$and$n(state, 3);
        }, "call$1", "convert__Base64Encoder__stateCount$closure", 2, 0, 16, 82, [], "_stateCount"],
        _Base64Encoder_encodeChunk: [function(alphabet, bytes, start, end, isLast, output, outputIndex, state) {
          var t1, bits, expectedChars, t2, t3, i, byteOr, t4, byte, outputIndex0;
          t1 = J.getInterceptor$n(state);
          bits = t1.$shr(state, 2);
          t1 = t1.$and(state, 3);
          if (typeof t1 !== "number")
            return H.iae(t1);
          expectedChars = 3 - t1;
          for (t1 = J.getInterceptor$asx(bytes), t2 = J.getInterceptor$s(alphabet), t3 = J.getInterceptor$ax(output), i = start, byteOr = 0; t4 = J.getInterceptor$n(i), t4.$lt(i, end); i = t4.$add(i, 1)) {
            byte = t1.$index(bytes, i);
            if (typeof byte !== "number")
              return H.iae(byte);
            byteOr = (byteOr | byte) >>> 0;
            bits = (bits << 8 | byte) & 16777215;
            --expectedChars;
            if (expectedChars === 0) {
              outputIndex0 = J.$add$ns(outputIndex, 1);
              t3.$indexSet(output, outputIndex, t2.codeUnitAt$1(alphabet, bits >>> 18 & 63));
              outputIndex = J.$add$ns(outputIndex0, 1);
              t3.$indexSet(output, outputIndex0, t2.codeUnitAt$1(alphabet, bits >>> 12 & 63));
              outputIndex0 = J.$add$ns(outputIndex, 1);
              t3.$indexSet(output, outputIndex, t2.codeUnitAt$1(alphabet, bits >>> 6 & 63));
              outputIndex = J.$add$ns(outputIndex0, 1);
              t3.$indexSet(output, outputIndex0, t2.codeUnitAt$1(alphabet, bits & 63));
              bits = 0;
              expectedChars = 3;
            }
          }
          if (byteOr >= 0 && byteOr <= 255) {
            if (isLast === true && expectedChars < 3) {
              t1 = J.getInterceptor$ns(outputIndex);
              if (3 - expectedChars === 1) {
                outputIndex0 = t1.$add(outputIndex, 1);
                t3.$indexSet(output, outputIndex, t2.codeUnitAt$1(alphabet, bits >>> 2 & 63));
                outputIndex = J.$add$ns(outputIndex0, 1);
                t3.$indexSet(output, outputIndex0, t2.codeUnitAt$1(alphabet, bits << 4 & 63));
                outputIndex0 = J.$add$ns(outputIndex, 1);
                t3.$indexSet(output, outputIndex, 61);
                J.$add$ns(outputIndex0, 1);
                t3.$indexSet(output, outputIndex0, 61);
              } else {
                outputIndex0 = t1.$add(outputIndex, 1);
                t3.$indexSet(output, outputIndex, t2.codeUnitAt$1(alphabet, bits >>> 10 & 63));
                outputIndex = J.$add$ns(outputIndex0, 1);
                t3.$indexSet(output, outputIndex0, t2.codeUnitAt$1(alphabet, bits >>> 4 & 63));
                outputIndex0 = J.$add$ns(outputIndex, 1);
                t3.$indexSet(output, outputIndex, t2.codeUnitAt$1(alphabet, bits << 2 & 63));
                J.$add$ns(outputIndex0, 1);
                t3.$indexSet(output, outputIndex0, 61);
              }
              return 0;
            }
            return (bits << 2 | 3 - expectedChars) >>> 0;
          }
          for (i = start; t2 = J.getInterceptor$n(i), t2.$lt(i, end);) {
            byte = t1.$index(bytes, i);
            t3 = J.getInterceptor$n(byte);
            if (t3.$lt(byte, 0) || t3.$gt(byte, 255))
              break;
            i = t2.$add(i, 1);
          }
          throw H.wrapException(P.ArgumentError$value(bytes, "Not a byte value at index " + H.S(i) + ": 0x" + J.toRadixString$1$n(t1.$index(bytes, i), 16), null));
        }, "call$8", "convert__Base64Encoder_encodeChunk$closure", 16, 0, 623, 484, [], 30, [], 3, [], 5, [], 46, [], 279, [], 488, [], 82, [], "encodeChunk"],
        _Base64Encoder_writeFinalChunk: [function(alphabet, output, outputIndex, count, bits) {
          var t1, t2, t3, t4, outputIndex0;
          t1 = J.getInterceptor$n(bits);
          t2 = J.getInterceptor$s(alphabet);
          t3 = J.getInterceptor$ax(output);
          t4 = J.getInterceptor$ns(outputIndex);
          if (J.$eq$(count, 1)) {
            outputIndex0 = t4.$add(outputIndex, 1);
            t3.$indexSet(output, outputIndex, t2.codeUnitAt$1(alphabet, t1.$shr(bits, 2) & 63));
            outputIndex = J.$add$ns(outputIndex0, 1);
            t3.$indexSet(output, outputIndex0, t2.codeUnitAt$1(alphabet, t1.$shl(bits, 4) & 63));
            outputIndex0 = J.$add$ns(outputIndex, 1);
            t3.$indexSet(output, outputIndex, 61);
            J.$add$ns(outputIndex0, 1);
            t3.$indexSet(output, outputIndex0, 61);
          } else {
            outputIndex0 = t4.$add(outputIndex, 1);
            t3.$indexSet(output, outputIndex, t2.codeUnitAt$1(alphabet, t1.$shr(bits, 10) & 63));
            outputIndex = J.$add$ns(outputIndex0, 1);
            t3.$indexSet(output, outputIndex0, t2.codeUnitAt$1(alphabet, t1.$shr(bits, 4) & 63));
            outputIndex0 = J.$add$ns(outputIndex, 1);
            t3.$indexSet(output, outputIndex, t2.codeUnitAt$1(alphabet, t1.$shl(bits, 2) & 63));
            J.$add$ns(outputIndex0, 1);
            t3.$indexSet(output, outputIndex0, 61);
          }
        }, "call$5", "convert__Base64Encoder_writeFinalChunk$closure", 10, 0, 624, 484, [], 279, [], 488, [], 43, [], 400, [], "writeFinalChunk"]
      }
    },
    "+_Base64Encoder": [1],
    _BufferCachingBase64Encoder: {
      "^": "_Base64Encoder;bufferCache@-89,_convert$_state-0,_alphabet-9",
      createBuffer$1: [function(bufferLength) {
        var t1 = this.bufferCache;
        if (t1 == null || J.$lt$n(J.get$length$asx(t1), bufferLength))
          this.bufferCache = new Uint8Array(H._checkLength(bufferLength));
        return J.asUint8List$2$x(J.get$buffer$x(this.bufferCache), 0, bufferLength);
      }, "call$1", "get$createBuffer", 2, 0, 229, 530, [], "createBuffer"],
      static: {
        _BufferCachingBase64Encoder$: [function(urlSafe) {
          return new P._BufferCachingBase64Encoder(null, 0, urlSafe === true ? "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_" : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
        }, null, null, 2, 0, 33, 227, [], "new _BufferCachingBase64Encoder"]
      }
    },
    "+_BufferCachingBase64Encoder": [247],
    _Base64EncoderSink: {
      "^": "ByteConversionSinkBase;",
      add$1: [function(_, source) {
        this._convert$_add$4(source, 0, J.get$length$asx(source), false);
      }, "call$1", "get$add", 2, 0, 26, 19, [], "add"],
      close$0: [function() {
        this._convert$_add$4(null, 0, 0, true);
      }, "call$0", "get$close", 0, 0, 6, "close"],
      addSlice$4: [function(source, start, end, isLast) {
        if (end == null)
          throw H.wrapException(P.ArgumentError$notNull("end"));
        P.RangeError_checkValidRange(start, end, J.get$length$asx(source), null, null, null);
        this._convert$_add$4(source, start, end, isLast);
      }, "call$4", "get$addSlice", 8, 0, 44, 19, [], 3, [], 5, [], 46, [], "addSlice"],
      static: {
        _Base64EncoderSink$: [function() {
          return new P._Base64EncoderSink();
        }, null, null, 0, 0, 625, "new _Base64EncoderSink"]
      }
    },
    "+_Base64EncoderSink": [99],
    _AsciiBase64EncoderSink: {
      "^": "_Base64EncoderSink;_convert$_sink<-248,_encoder<-247",
      _convert$_add$4: [function(source, start, end, isLast) {
        var buffer = this._encoder.encode$4(source, start, end, isLast);
        if (buffer != null)
          J.add$1$ax(this._convert$_sink, P.String_String$fromCharCodes(buffer, 0, null));
        if (isLast === true)
          this._convert$_sink.close$0();
      }, "call$4", "get$_convert$_add", 8, 0, 44, 19, [], 3, [], 5, [], 46, [], "_convert$_add"],
      static: {
        _AsciiBase64EncoderSink$: [function(_sink, urlSafe) {
          return new P._AsciiBase64EncoderSink(_sink, new P._BufferCachingBase64Encoder(null, 0, urlSafe === true ? "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_" : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"));
        }, null, null, 4, 0, 626, 45, [], 227, [], "new _AsciiBase64EncoderSink"]
      }
    },
    "+_AsciiBase64EncoderSink": [470],
    _Utf8Base64EncoderSink: {
      "^": "_Base64EncoderSink;_convert$_sink<-39,_encoder<-247",
      _convert$_add$4: [function(source, start, end, isLast) {
        var buffer = this._encoder.encode$4(source, start, end, isLast);
        if (buffer != null)
          this._convert$_sink.addSlice$4(buffer, 0, buffer.length, isLast);
      }, "call$4", "get$_convert$_add", 8, 0, 44, 19, [], 3, [], 5, [], 46, [], "_convert$_add"],
      static: {
        _Utf8Base64EncoderSink$: [function(_sink, urlSafe) {
          return new P._Utf8Base64EncoderSink(_sink, new P._Base64Encoder(0, urlSafe === true ? "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_" : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"));
        }, null, null, 4, 0, 627, 45, [], 227, [], "new _Utf8Base64EncoderSink"]
      }
    },
    "+_Utf8Base64EncoderSink": [470],
    Base64Decoder: {
      "^": "Converter;",
      convert$3: [function(input, start, end) {
        var decoder, buffer;
        end = P.RangeError_checkValidRange(start, end, J.get$length$asx(input), null, null, null);
        if (J.$eq$(start, end))
          return new Uint8Array(H._checkLength(0));
        decoder = new P._Base64Decoder(0);
        buffer = decoder.decode$3(input, start, end);
        decoder.close$2(input, end);
        return buffer;
      }, function(input) {
        return this.convert$3(input, 0, null);
      }, "convert$1", function(input, start) {
        return this.convert$3(input, start, null);
      }, "convert$2", "call$3", "call$1", "call$2", "get$convert", 2, 4, 172, 7, 0, 58, [], 3, [], 5, [], "convert"],
      startChunkedConversion$1: [function(sink) {
        return new P._Base64DecoderSink(sink, new P._Base64Decoder(0));
      }, "call$1", "get$startChunkedConversion", 2, 0, 173, 22, [], "startChunkedConversion"],
      $asConverter: function() {
        return [P.String, [P.List, P.int]];
      },
      "<>": [],
      static: {
        Base64Decoder$: [function() {
          return new P.Base64Decoder();
        }, null, null, 0, 0, 4, "new Base64Decoder"]
      }
    },
    "+Base64Decoder": [194, 192],
    _Base64Decoder: {
      "^": "Object;_convert$_state@-0",
      decode$3: [function(input, start, end) {
        var buffer;
        if (J.$lt$n(this._convert$_state, 0)) {
          this._convert$_state = P._Base64Decoder__checkPadding(input, start, end, this._convert$_state);
          return;
        }
        if (J.$eq$(start, end))
          return new Uint8Array(H._checkLength(0));
        buffer = P._Base64Decoder__allocateBuffer(input, start, end, this._convert$_state);
        this._convert$_state = P._Base64Decoder_decodeChunk(input, start, end, buffer, 0, this._convert$_state);
        return buffer;
      }, "call$3", "get$decode", 6, 0, 1383, 58, [], 3, [], 5, [], "decode"],
      close$2: [function(input, end) {
        if (J.$lt$n(this._convert$_state, -1))
          throw H.wrapException(new P.FormatException("Missing padding character", input, end));
        if (J.$gt$n(this._convert$_state, 0))
          throw H.wrapException(new P.FormatException("Invalid length, must be multiple of four", input, end));
        this._convert$_state = -1;
      }, "call$2", "get$close", 4, 0, 285, 58, [], 5, [], "close"],
      static: {
        "^": "_Base64Decoder__valueShift<-0,_Base64Decoder__countMask<-0,_Base64Decoder__invalid<-0,_Base64Decoder__padding<-0,_Base64Decoder___<-0,_Base64Decoder__p<-0,_Base64Decoder__inverseAlphabet<-14,_Base64Decoder__char_percent<-0,_Base64Decoder__char_3<-0,_Base64Decoder__char_d<-0",
        _Base64Decoder$: [function() {
          return new P._Base64Decoder(0);
        }, null, null, 0, 0, 628, "new _Base64Decoder"],
        _Base64Decoder__encodeCharacterState: [function(count, bits) {
          var t1 = J.$shl$n(bits, 2);
          if (typeof count !== "number")
            return H.iae(count);
          return (t1 | count) >>> 0;
        }, "call$2", "convert__Base64Decoder__encodeCharacterState$closure", 4, 0, 70, 43, [], 400, [], "_encodeCharacterState"],
        _Base64Decoder__stateCount: [function(state) {
          return J.$and$n(state, 3);
        }, "call$1", "convert__Base64Decoder__stateCount$closure", 2, 0, 16, 82, [], "_stateCount"],
        _Base64Decoder__stateBits: [function(state) {
          return J.$shr$n(state, 2);
        }, "call$1", "convert__Base64Decoder__stateBits$closure", 2, 0, 16, 82, [], "_stateBits"],
        _Base64Decoder__encodePaddingState: [function(expectedPadding) {
          return J.$sub$n(J.$negate$n(expectedPadding), 1);
        }, "call$1", "convert__Base64Decoder__encodePaddingState$closure", 2, 0, 16, 738, [], "_encodePaddingState"],
        _Base64Decoder__statePadding: [function(state) {
          return J.$sub$n(J.$negate$n(state), 1);
        }, "call$1", "convert__Base64Decoder__statePadding$closure", 2, 0, 16, 82, [], "_statePadding"],
        _Base64Decoder__hasSeenPadding: [function(state) {
          return J.$lt$n(state, 0);
        }, "call$1", "convert__Base64Decoder__hasSeenPadding$closure", 2, 0, 32, 82, [], "_hasSeenPadding"],
        _Base64Decoder_decodeChunk: [function(input, start, end, output, outIndex, state) {
          var t1, bits, count, t2, i, charOr, t3, char, t4, t5, code, outIndex0, expectedPadding;
          t1 = J.getInterceptor$n(state);
          bits = t1.$shr(state, 2);
          count = t1.$and(state, 3);
          for (t1 = J.getInterceptor$s(input), t2 = J.getInterceptor$ax(output), i = start, charOr = 0; t3 = J.getInterceptor$n(i), t3.$lt(i, end); i = t3.$add(i, 1)) {
            char = t1.codeUnitAt$1(input, i);
            charOr |= char;
            t4 = $.$get$_Base64Decoder__inverseAlphabet();
            t5 = char & 127;
            if (t5 >= t4.length)
              return H.ioore(t4, t5);
            code = t4[t5];
            if (code >= 0) {
              bits = (bits << 6 | code) & 16777215;
              count = J.$and$n(J.$add$ns(count, 1), 3);
              if (count === 0) {
                outIndex0 = J.$add$ns(outIndex, 1);
                t2.$indexSet(output, outIndex, bits >>> 16 & 255);
                outIndex = J.$add$ns(outIndex0, 1);
                t2.$indexSet(output, outIndex0, bits >>> 8 & 255);
                outIndex0 = J.$add$ns(outIndex, 1);
                t2.$indexSet(output, outIndex, bits & 255);
                outIndex = outIndex0;
                bits = 0;
              }
              continue;
            } else if (code === -1 && J.$gt$n(count, 1)) {
              if (charOr > 127)
                break;
              if (count === 3) {
                if ((bits & 3) !== 0)
                  throw H.wrapException(new P.FormatException("Invalid encoding before padding", input, i));
                outIndex0 = J.$add$ns(outIndex, 1);
                t2.$indexSet(output, outIndex, bits >>> 10);
                J.$add$ns(outIndex0, 1);
                t2.$indexSet(output, outIndex0, bits >>> 2);
              } else {
                if ((bits & 15) !== 0)
                  throw H.wrapException(new P.FormatException("Invalid encoding before padding", input, i));
                J.$add$ns(outIndex, 1);
                t2.$indexSet(output, outIndex, bits >>> 4);
              }
              if (typeof count !== "number")
                return H.iae(count);
              expectedPadding = (3 - count) * 3;
              if (char === 37)
                expectedPadding += 2;
              return P._Base64Decoder__checkPadding(input, t3.$add(i, 1), end, -expectedPadding - 1);
            }
            throw H.wrapException(new P.FormatException("Invalid character", input, i));
          }
          if (charOr >= 0 && charOr <= 127) {
            if (typeof count !== "number")
              return H.iae(count);
            return (bits << 2 | count) >>> 0;
          }
          for (i = start; t2 = J.getInterceptor$n(i), t2.$lt(i, end); i = t2.$add(i, 1)) {
            char = t1.codeUnitAt$1(input, i);
            if (char > 127)
              break;
          }
          throw H.wrapException(new P.FormatException("Invalid character", input, i));
        }, "call$6", "convert__Base64Decoder_decodeChunk$closure", 12, 0, 629, 58, [], 3, [], 5, [], 279, [], 737, [], 82, [], "decodeChunk"],
        _Base64Decoder__allocateBuffer: [function(input, start, end, state) {
          var paddingStart, t1, $length, t2, bufferLength, remainderLength;
          paddingStart = P._Base64Decoder__trimPaddingChars(input, start, end);
          t1 = J.getInterceptor$n(paddingStart);
          $length = J.$add$ns(J.$and$n(state, 3), t1.$sub(paddingStart, start));
          t2 = J.getInterceptor$n($length);
          bufferLength = t2.$shr($length, 2) * 3;
          remainderLength = t2.$and($length, 3);
          if (remainderLength !== 0 && t1.$lt(paddingStart, end)) {
            t1 = J.$sub$n(remainderLength, 1);
            if (typeof t1 !== "number")
              return H.iae(t1);
            bufferLength += t1;
          }
          if (bufferLength > 0)
            return new Uint8Array(H._checkLength(bufferLength));
          return;
        }, "call$4", "convert__Base64Decoder__allocateBuffer$closure", 8, 0, 630, 58, [], 3, [], 5, [], 82, [], "_allocateBuffer"],
        _Base64Decoder__trimPaddingChars: [function(input, start, end) {
          var t1, newEnd, index, padding, t2, char;
          t1 = J.getInterceptor$s(input);
          newEnd = end;
          index = newEnd;
          padding = 0;
          while (true) {
            t2 = J.getInterceptor$n(index);
            if (!(t2.$gt(index, start) && padding < 2))
              break;
            c$0: {
              index = t2.$sub(index, 1);
              char = t1.codeUnitAt$1(input, index);
              if (char === 61) {
                ++padding;
                newEnd = index;
                break c$0;
              }
              if ((char | 32) === 100) {
                t2 = J.getInterceptor(index);
                if (t2.$eq(index, start))
                  break;
                index = t2.$sub(index, 1);
                char = t1.codeUnitAt$1(input, index);
              }
              if (char === 51) {
                t2 = J.getInterceptor(index);
                if (t2.$eq(index, start))
                  break;
                index = t2.$sub(index, 1);
                char = t1.codeUnitAt$1(input, index);
              }
              if (char === 37) {
                ++padding;
                newEnd = index;
                break c$0;
              }
              break;
            }
          }
          return newEnd;
        }, "call$3", "convert__Base64Decoder__trimPaddingChars$closure", 6, 0, 512, 58, [], 3, [], 5, [], "_trimPaddingChars"],
        _Base64Decoder__checkPadding: [function(input, start, end, state) {
          var expectedPadding, t1, t2, char;
          if (J.$eq$(start, end))
            return state;
          expectedPadding = J.$sub$n(J.$negate$n(state), 1);
          for (t1 = J.getInterceptor$s(input); t2 = J.getInterceptor$n(expectedPadding), t2.$gt(expectedPadding, 0);) {
            char = t1.codeUnitAt$1(input, start);
            if (t2.$eq(expectedPadding, 3)) {
              if (char === 61) {
                expectedPadding = t2.$sub(expectedPadding, 3);
                start = J.$add$ns(start, 1);
                break;
              }
              if (char === 37) {
                expectedPadding = t2.$sub(expectedPadding, 1);
                start = J.$add$ns(start, 1);
                if (J.$eq$(start, end))
                  break;
                char = t1.codeUnitAt$1(input, start);
              } else
                break;
            }
            t2 = J.getInterceptor$n(expectedPadding);
            if (J.$eq$(t2.$gt(expectedPadding, 3) ? t2.$sub(expectedPadding, 3) : expectedPadding, 2)) {
              if (char !== 51)
                break;
              start = J.$add$ns(start, 1);
              expectedPadding = t2.$sub(expectedPadding, 1);
              if (J.$eq$(start, end))
                break;
              char = t1.codeUnitAt$1(input, start);
            }
            if ((char | 32) !== 100)
              break;
            start = J.$add$ns(start, 1);
            expectedPadding = J.$sub$n(expectedPadding, 1);
            if (J.$eq$(start, end))
              break;
          }
          if (!J.$eq$(start, end))
            throw H.wrapException(new P.FormatException("Invalid padding character", input, start));
          return J.$sub$n(J.$negate$n(expectedPadding), 1);
        }, "call$4", "convert__Base64Decoder__checkPadding$closure", 8, 0, 631, 58, [], 3, [], 5, [], 82, [], "_checkPadding"]
      }
    },
    "+_Base64Decoder": [1],
    _Base64DecoderSink: {
      "^": "StringConversionSinkBase;_convert$_sink<-250,_decoder<-1387",
      add$1: [function(_, string) {
        var t1, buffer;
        t1 = J.getInterceptor$asx(string);
        if (t1.get$isEmpty(string) === true)
          return;
        buffer = this._decoder.decode$3(string, 0, t1.get$length(string));
        if (buffer != null)
          J.add$1$ax(this._convert$_sink, buffer);
      }, "call$1", "get$add", 2, 0, 19, 39, [], "add"],
      close$0: [function() {
        this._decoder.close$2(null, null);
        this._convert$_sink.close$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      addSlice$4: [function(string, start, end, isLast) {
        var t1, buffer;
        end = P.RangeError_checkValidRange(start, end, J.get$length$asx(string), null, null, null);
        if (J.$eq$(start, end))
          return;
        t1 = this._decoder;
        buffer = t1.decode$3(string, start, end);
        if (buffer != null)
          J.add$1$ax(this._convert$_sink, buffer);
        if (isLast === true) {
          t1.close$2(string, end);
          this._convert$_sink.close$0();
        }
      }, "call$4", "get$addSlice", 8, 0, 87, 39, [], 3, [], 5, [], 46, [], "addSlice"],
      static: {
        _Base64DecoderSink$: [function(_sink) {
          return new P._Base64DecoderSink(_sink, new P._Base64Decoder(0));
        }, null, null, 2, 0, 249, 45, [], "new _Base64DecoderSink"]
      }
    },
    "+_Base64DecoderSink": [100],
    ByteConversionSink: {
      "^": "ChunkedConversionSink;",
      $asChunkedConversionSink: function() {
        return [[P.List, P.int]];
      },
      "<>": [],
      static: {
        ByteConversionSink$: [function() {
          return new P.ByteConversionSink();
        }, null, null, 0, 0, 4, "new ByteConversionSink"],
        ByteConversionSink_ByteConversionSink$withCallback: [function(callback) {
          return new P._ByteCallbackSink(callback, new Uint8Array(H._checkLength(1024)), 0);
        }, null, null, 2, 0, 633, 33, [], "new ByteConversionSink$withCallback"],
        ByteConversionSink_ByteConversionSink$from: [function(sink) {
          return new P._ByteAdapterSink(sink);
        }, null, null, 2, 0, 268, 22, [], "new ByteConversionSink$from"]
      }
    },
    "+ByteConversionSink": [1388],
    ByteConversionSinkBase: {
      "^": "ByteConversionSink;",
      addSlice$4: [function(chunk, start, end, isLast) {
        this.add$1(0, J.sublist$2$ax(chunk, start, end));
        if (isLast === true)
          this.close$0();
      }, "call$4", "get$addSlice", 8, 0, 44, 57, [], 3, [], 5, [], 46, [], "addSlice"],
      static: {
        ByteConversionSinkBase$: [function() {
          return new P.ByteConversionSinkBase();
        }, null, null, 0, 0, 634, "new ByteConversionSinkBase"]
      }
    },
    "+ByteConversionSinkBase": [39],
    _ByteAdapterSink: {
      "^": "ByteConversionSinkBase;_convert$_sink<-250",
      add$1: [function(_, chunk) {
        J.add$1$ax(this._convert$_sink, chunk);
      }, "call$1", "get$add", 2, 0, 26, 57, [], "add"],
      close$0: [function() {
        this._convert$_sink.close$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      static: {
        _ByteAdapterSink$: [function(_sink) {
          return new P._ByteAdapterSink(_sink);
        }, null, null, 2, 0, 249, 45, [], "new _ByteAdapterSink"]
      }
    },
    "+_ByteAdapterSink": [99],
    _ByteCallbackSink: {
      "^": "ByteConversionSinkBase;_callback<-1389,_buffer@-14,_bufferIndex@-0",
      add$1: [function(_, chunk) {
        var freeCount, t1, oldLength, v, t2, newLength, grown, t3;
        freeCount = J.$sub$n(J.get$length$asx(this._buffer), this._bufferIndex);
        t1 = J.getInterceptor$asx(chunk);
        if (J.$gt$n(t1.get$length(chunk), freeCount)) {
          oldLength = J.get$length$asx(this._buffer);
          v = J.$sub$n(J.$add$ns(t1.get$length(chunk), oldLength), 1);
          t2 = J.getInterceptor$n(v);
          v = t2.$or(v, t2.$shr(v, 1));
          t2 = J.getInterceptor$n(v);
          v = t2.$or(v, t2.$shr(v, 2));
          t2 = J.getInterceptor$n(v);
          v = t2.$or(v, t2.$shr(v, 4));
          t2 = J.getInterceptor$n(v);
          v = t2.$or(v, t2.$shr(v, 8));
          t2 = J.getInterceptor$n(v);
          newLength = J.$mul$ns(J.$add$ns(t2.$or(v, t2.$shr(v, 16)), 1), 2);
          if (typeof newLength !== "number" || Math.floor(newLength) !== newLength)
            H.throwExpression(P.ArgumentError$("Invalid length " + H.S(newLength)));
          grown = new Uint8Array(newLength);
          C.NativeUint8List_methods.setRange$3(grown, 0, J.get$length$asx(this._buffer), this._buffer);
          this._buffer = grown;
        }
        t2 = this._buffer;
        t3 = this._bufferIndex;
        J.setRange$3$ax(t2, t3, J.$add$ns(t3, t1.get$length(chunk)), chunk);
        this._bufferIndex = J.$add$ns(this._bufferIndex, t1.get$length(chunk));
      }, "call$1", "get$add", 2, 0, 1386, 57, [], "add"],
      close$0: [function() {
        this._callback.call$1(J.sublist$2$ax(this._buffer, 0, this._bufferIndex));
      }, "call$0", "get$close", 0, 0, 6, "close"],
      static: {
        "^": "_ByteCallbackSink__INITIAL_BUFFER_SIZE<-10",
        _ByteCallbackSink$: [function(callback) {
          return new P._ByteCallbackSink(callback, new Uint8Array(H._checkLength(1024)), 0);
        }, null, null, 2, 0, 635, 33, [], "new _ByteCallbackSink"],
        _ByteCallbackSink__roundToPowerOf2: [function(v) {
          var t1;
          v = J.$sub$n(v, 1);
          t1 = J.getInterceptor$n(v);
          v = t1.$or(v, t1.$shr(v, 1));
          t1 = J.getInterceptor$n(v);
          v = t1.$or(v, t1.$shr(v, 2));
          t1 = J.getInterceptor$n(v);
          v = t1.$or(v, t1.$shr(v, 4));
          t1 = J.getInterceptor$n(v);
          v = t1.$or(v, t1.$shr(v, 8));
          t1 = J.getInterceptor$n(v);
          return J.$add$ns(t1.$or(v, t1.$shr(v, 16)), 1);
        }, "call$1", "convert__ByteCallbackSink__roundToPowerOf2$closure", 2, 0, 16, 56, [], "_roundToPowerOf2"]
      }
    },
    "+_ByteCallbackSink": [99],
    ChunkedConverter: {
      "^": "Converter;$ti",
      bind$1: [function(other) {
        return this.super$Converter$bind(other);
      }, "call$1", "get$bind", 2, 0, 3, 2, [], "bind"],
      startChunkedConversion$1: [function(sink) {
        return this.super$Converter$startChunkedConversion(sink);
      }, "call$1", "get$startChunkedConversion", 2, 0, 3, 22, [], "startChunkedConversion"],
      $asConverter: function($S, $T, S2, T2) {
        return [$S, $T];
      },
      "@": function() {
        return [C.Deprecated_o8I];
      },
      "<>": [449, 453, 944, 941],
      static: {
        ChunkedConverter$: [function($S, $T, S2, T2) {
          return new P.ChunkedConverter([$S, $T, S2, T2]);
        }, null, null, 0, 0, 4, "new ChunkedConverter"]
      }
    },
    "+ChunkedConverter": [1390],
    ChunkedConversionSink: {
      "^": "Object;$ti",
      "<>": [507],
      static: {
        ChunkedConversionSink$: [function($T) {
          return new P.ChunkedConversionSink([$T]);
        }, null, null, 0, 0, 4, "new ChunkedConversionSink"],
        ChunkedConversionSink_ChunkedConversionSink$withCallback: [function(callback, $T) {
          return new P._SimpleCallbackSink(callback, H.setRuntimeTypeInfo([], [$T]), [$T]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P.ChunkedConversionSink, T], args: [{func: 1, v: true, args: [[P.List, T]]}]};
          }, this.$receiver, "ChunkedConversionSink");
        }, 33, [], "new ChunkedConversionSink$withCallback"]
      }
    },
    "+ChunkedConversionSink": [1, 1391],
    _SimpleCallbackSink: {
      "^": "ChunkedConversionSink;_callback<-1392,_accumulated<-1393,$ti",
      add$1: [function(_, chunk) {
        J.add$1$ax(this._accumulated, chunk);
      }, "call$1", "get$add", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "_SimpleCallbackSink");
      }, 57, [], "add"],
      close$0: [function() {
        this._callback.call$1(this._accumulated);
      }, "call$0", "get$close", 0, 0, 6, "close"],
      "<>": [202],
      static: {
        _SimpleCallbackSink$: [function(_callback, $T) {
          return new P._SimpleCallbackSink(_callback, H.setRuntimeTypeInfo([], [$T]), [$T]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [{func: 1, v: true, args: [[P.List, T]]}]};
          }, this.$receiver, "_SimpleCallbackSink");
        }, 396, [], "new _SimpleCallbackSink"]
      }
    },
    "+_SimpleCallbackSink": [1394],
    _ConverterStreamEventSink: {
      "^": "Object;_convert$_eventSink<-1395,_chunkedSink<-1396,$ti",
      add$1: [function(_, o) {
        J.add$1$ax(this._chunkedSink, o);
      }, "call$1", "get$add", 2, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, v: true, args: [S]};
        }, this.$receiver, "_ConverterStreamEventSink");
      }, 96, [], "add"],
      addError$2: [function(error, stackTrace) {
        this._convert$_eventSink.addError$2(error, stackTrace);
      }, function(error) {
        return this.addError$2(error, null);
      }, "addError$1", "call$2", "call$1", "get$addError", 2, 2, 48, 0, 8, [], 12, [], "addError"],
      close$0: [function() {
        this._chunkedSink.close$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      "<>": [356, 533],
      static: {
        _ConverterStreamEventSink$: [function(converter, sink, $S, $T) {
          return new P._ConverterStreamEventSink(sink, converter.startChunkedConversion$1(sink), [$S, $T]);
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(S, T) {
            return {func: 1, args: [[P.Converter, S, T], [P.EventSink, T]]};
          }, this.$receiver, "_ConverterStreamEventSink");
        }, 736, [], 22, [], "new _ConverterStreamEventSink"]
      }
    },
    "+_ConverterStreamEventSink": [1, 1397],
    Codec: {
      "^": "Object;$ti",
      encode$1: [function(input) {
        return this.get$encoder().convert$1(input);
      }, "call$1", "get$encode", 2, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, ret: T, args: [S]};
        }, this.$receiver, "Codec");
      }, 58, [], "encode"],
      decode$1: [function(encoded) {
        return this.get$decoder().convert$1(encoded);
      }, "call$1", "get$decode", 2, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, ret: S, args: [T]};
        }, this.$receiver, "Codec");
      }, 532, [], "decode"],
      fuse$1: [function(other) {
        return new P._FusedCodec(this, other, [H.getRuntimeTypeArgument(this, "Codec", 0), H.getRuntimeTypeArgument(this, "Codec", 1), null]);
      }, "call$1", "get$fuse", 2, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, ret: [P.Codec, S,,], args: [[P.Codec, T,,]]};
        }, this.$receiver, "Codec");
      }, 2, [], "fuse"],
      get$inverted: [function() {
        return new P._InvertedCodec(this, [H.getRuntimeTypeArgument(this, "Codec", 1), H.getRuntimeTypeArgument(this, "Codec", 0)]);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, ret: [P.Codec, T, S]};
        }, this.$receiver, "Codec");
      }, "inverted"],
      "<>": [946, 945],
      static: {
        Codec$: [function($S, $T) {
          return new P.Codec([$S, $T]);
        }, null, null, 0, 0, 4, "new Codec"]
      }
    },
    "+Codec": [1],
    _FusedCodec: {
      "^": "Codec;_convert$_first<-1398,_second<-1399,$ti",
      get$encoder: [function() {
        return this._convert$_first.get$encoder().fuse$1(this._second.get$encoder());
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(S, M, T) {
          return {func: 1, ret: [P.Converter, S, T]};
        }, this.$receiver, "_FusedCodec");
      }, "encoder"],
      get$decoder: [function() {
        return this._second.get$decoder().fuse$1(this._convert$_first.get$decoder());
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(S, M, T) {
          return {func: 1, ret: [P.Converter, T, S]};
        }, this.$receiver, "_FusedCodec");
      }, "decoder"],
      $asCodec: function($S, $M, $T) {
        return [$S, $T];
      },
      "<>": [367, 364, 359],
      static: {
        _FusedCodec$: [function(_first, _second, $S, $M, $T) {
          return new P._FusedCodec(_first, _second, [$S, $M, $T]);
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(S, M, T) {
            return {func: 1, args: [[P.Codec, S, M], [P.Codec, M, T]]};
          }, this.$receiver, "_FusedCodec");
        }, 560, [], 627, [], "new _FusedCodec"]
      }
    },
    "+_FusedCodec": [1400],
    _InvertedCodec: {
      "^": "Codec;_codec<-1401,$ti",
      get$encoder: [function() {
        return this._codec.get$decoder();
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(T, S) {
          return {func: 1, ret: [P.Converter, T, S]};
        }, this.$receiver, "_InvertedCodec");
      }, "encoder"],
      get$decoder: [function() {
        return this._codec.get$encoder();
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(T, S) {
          return {func: 1, ret: [P.Converter, S, T]};
        }, this.$receiver, "_InvertedCodec");
      }, "decoder"],
      get$inverted: [function() {
        return this._codec;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(T, S) {
          return {func: 1, ret: [P.Codec, S, T]};
        }, this.$receiver, "_InvertedCodec");
      }, "inverted"],
      "<>": [369, 368],
      static: {
        _InvertedCodec$: [function(codec, $T, $S) {
          return new P._InvertedCodec(codec, [$T, $S]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(T, S) {
            return {func: 1, args: [[P.Codec, S, T]]};
          }, this.$receiver, "_InvertedCodec");
        }, 735, [], "new _InvertedCodec"]
      }
    },
    "+_InvertedCodec": [1402],
    Converter: {
      "^": "Object;$ti",
      fuse$1: ["super$Converter$fuse", function(other) {
        return new P._FusedConverter(this, other, [H.getRuntimeTypeArgument(this, "Converter", 0), H.getRuntimeTypeArgument(this, "Converter", 1), null]);
      }, "call$1", "get$fuse", 2, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, ret: [P.Converter, S,,], args: [[P.Converter, T,,]]};
        }, this.$receiver, "Converter");
      }, 2, [], "fuse"],
      startChunkedConversion$1: ["super$Converter$startChunkedConversion", function(sink) {
        throw H.wrapException(new P.UnsupportedError("This converter does not support chunked conversions: " + this.toString$0(0)));
      }, "call$1", "get$startChunkedConversion", 2, 0, 471, 22, [], "startChunkedConversion"],
      bind$1: ["super$Converter$bind", function(stream) {
        return new P._BoundSinkStream(new P.Converter_bind_closure(this), stream, [null, null]);
      }, "call$1", "get$bind", 2, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, ret: [P.Stream, T], args: [[P.Stream, S]]};
        }, this.$receiver, "Converter");
      }, 37, [], "bind"],
      "<>": [425, 441],
      static: {
        Converter$: [function($S, $T) {
          return new P.Converter([$S, $T]);
        }, null, null, 0, 0, 4, "new Converter"]
      }
    },
    "+Converter": [1, 1403],
    Converter_bind_closure: {
      "^": "Closure:145;$this",
      call$1: [function(sink) {
        return new P._ConverterStreamEventSink(sink, this.$this.startChunkedConversion$1(sink), [null, null]);
      }, null, null, 2, 0, 145, 22, [], "call"]
    },
    "+ Converter_bind_closure": [2],
    _FusedConverter: {
      "^": "Converter;_convert$_first<-1404,_second<-1405,$ti",
      convert$1: [function(input) {
        return this._second.convert$1(this._convert$_first.convert$1(input));
      }, "call$1", "get$convert", 2, 0, function() {
        return H.computeSignature(function(S, M, T) {
          return {func: 1, ret: T, args: [S]};
        }, this.$receiver, "_FusedConverter");
      }, 58, [], "convert"],
      startChunkedConversion$1: [function(sink) {
        return this._convert$_first.startChunkedConversion$1(this._second.startChunkedConversion$1(sink));
      }, "call$1", "get$startChunkedConversion", 2, 0, 471, 22, [], "startChunkedConversion"],
      $asConverter: function($S, $M, $T) {
        return [$S, $T];
      },
      "<>": [205, 391, 203],
      static: {
        _FusedConverter$: [function(_first, _second, $S, $M, $T) {
          return new P._FusedConverter(_first, _second, [$S, $M, $T]);
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(S, M, T) {
            return {func: 1, args: [[P.Converter, S, M], [P.Converter, M, T]]};
          }, this.$receiver, "_FusedConverter");
        }, 560, [], 627, [], "new _FusedConverter"]
      }
    },
    "+_FusedConverter": [1406, 1407],
    Encoding: {
      "^": "Codec;",
      decodeStream$1: [function(byteStream) {
        return byteStream.transform$1(this.get$decoder()).fold$2(0, new P.StringBuffer(""), new P.Encoding_decodeStream_closure()).then$1(new P.Encoding_decodeStream_closure0());
      }, "call$1", "get$decodeStream", 2, 0, 1417, 710, [], "decodeStream"],
      $asCodec: function() {
        return [P.String, [P.List, P.int]];
      },
      "<>": [],
      static: {
        "^": "Encoding__nameToEncoding@-1408",
        Encoding$: [function() {
          return new P.Encoding();
        }, null, null, 0, 0, 4, "new Encoding"],
        Encoding_getByName: [function($name) {
          if ($name == null)
            return;
          $name = J.toLowerCase$0$s($name);
          return J.$index$asx($.$get$Encoding__nameToEncoding(), $name);
        }, "call$1", "convert_Encoding_getByName$closure", 2, 0, 636, 13, [], "getByName"]
      }
    },
    "+Encoding": [1409],
    Encoding_decodeStream_closure: {
      "^": "Closure:12;",
      call$2: [function(buffer, string) {
        buffer.write$1(string);
        return buffer;
      }, null, null, 4, 0, 12, 41, [], 39, [], "call"]
    },
    "+ Encoding_decodeStream_closure": [2],
    Encoding_decodeStream_closure0: {
      "^": "Closure:3;",
      call$1: [function(buffer) {
        return J.toString$0$(buffer);
      }, null, null, 2, 0, 3, 41, [], "call"]
    },
    "+ Encoding_decodeStream_closure": [2],
    HtmlEscapeMode: {
      "^": "Object;_convert$_name<-9,escapeLtGt<-8,escapeQuot<-8,escapeApos<-8,escapeSlash<-8",
      toString$0: [function(_) {
        return this._convert$_name;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        "^": "HtmlEscapeMode_UNKNOWN<-144,HtmlEscapeMode_ATTRIBUTE<-144,HtmlEscapeMode_SQ_ATTRIBUTE<-144,HtmlEscapeMode_ELEMENT<-144",
        HtmlEscapeMode$_: [function(_name, escapeLtGt, escapeQuot, escapeApos, escapeSlash) {
          return new P.HtmlEscapeMode(_name, escapeLtGt, escapeQuot, escapeApos, escapeSlash);
        }, null, null, 10, 0, 637, 281, [], 497, [], 498, [], 499, [], 500, [], "new HtmlEscapeMode$_"],
        HtmlEscapeMode$: [function(escapeApos, escapeLtGt, escapeQuot, escapeSlash, $name) {
          return new P.HtmlEscapeMode($name, escapeLtGt, escapeQuot, escapeApos, escapeSlash);
        }, null, null, 0, 11, 638, 734, 4, 4, 4, 4, 13, [], 497, [], 498, [], 499, [], 500, [], "new HtmlEscapeMode"]
      }
    },
    "+HtmlEscapeMode": [1],
    HtmlEscape: {
      "^": "Converter;mode<-144",
      convert$1: [function(text) {
        var val = this._convert$3(text, 0, J.get$length$asx(text));
        return val == null ? text : val;
      }, "call$1", "get$convert", 2, 0, 28, 106, [], "convert"],
      _convert$3: [function(text, start, end) {
        var t1, t2, i, result, t3, replacement, t4;
        for (t1 = J.getInterceptor$asx(text), t2 = this.mode, i = start, result = null; t3 = J.getInterceptor$n(i), t3.$lt(i, end); i = t3.$add(i, 1)) {
          switch (t1.$index(text, i)) {
            case "&":
              replacement = "&amp;";
              break;
            case '"':
              replacement = t2.get$escapeQuot() === true ? "&quot;" : null;
              break;
            case "'":
              replacement = t2.get$escapeApos() === true ? "&#39;" : null;
              break;
            case "<":
              replacement = t2.get$escapeLtGt() === true ? "&lt;" : null;
              break;
            case ">":
              replacement = t2.get$escapeLtGt() === true ? "&gt;" : null;
              break;
            case "/":
              replacement = t2.get$escapeSlash() === true ? "&#47;" : null;
              break;
            default:
              replacement = null;
          }
          if (replacement != null) {
            if (result == null)
              result = new P.StringBuffer("");
            if (t3.$gt(i, start)) {
              t4 = t1.substring$2(text, start, i);
              result._contents = result._contents + t4;
            }
            result._contents = result._contents + replacement;
            start = t3.$add(i, 1);
          }
        }
        if (result == null)
          return;
        if (J.$gt$n(end, start))
          result._contents += t1.substring$2(text, start, end);
        t1 = result._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, "call$3", "get$_convert", 6, 0, 149, 106, [], 3, [], 5, [], "_convert"],
      startChunkedConversion$1: [function(sink) {
        return new P._HtmlEscapeSink(this, !J.getInterceptor(sink).$isStringConversionSink ? new P._StringAdapterSink(sink) : sink);
      }, "call$1", "get$startChunkedConversion", 2, 0, 284, 22, [], "startChunkedConversion"],
      $asConverter: function() {
        return [P.String, P.String];
      },
      "<>": [],
      static: {
        HtmlEscape$: [function(mode) {
          return new P.HtmlEscape(mode);
        }, null, null, 0, 2, 639, 733, 70, [], "new HtmlEscape"]
      }
    },
    "+HtmlEscape": [1411, 1412],
    _HtmlEscapeSink: {
      "^": "StringConversionSinkBase;_escape<-472,_convert$_sink<-73",
      addSlice$4: [function(chunk, start, end, isLast) {
        var val, t1;
        val = this._escape._convert$3(chunk, start, end);
        t1 = this._convert$_sink;
        if (val == null)
          t1.addSlice$4(chunk, start, end, isLast);
        else {
          J.add$1$ax(t1, val);
          if (isLast === true)
            t1.close$0();
        }
      }, "call$4", "get$addSlice", 8, 0, 87, 57, [], 3, [], 5, [], 46, [], "addSlice"],
      close$0: [function() {
        this._convert$_sink.close$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      static: {
        _HtmlEscapeSink$: [function(_escape, _sink) {
          return new P._HtmlEscapeSink(_escape, _sink);
        }, null, null, 4, 0, 640, 732, [], 45, [], "new _HtmlEscapeSink"]
      }
    },
    "+_HtmlEscapeSink": [100],
    JsonUnsupportedObjectError: {
      "^": "Error;unsupportedObject<-10,cause<-10",
      toString$0: [function(_) {
        if (this.cause != null)
          return "Converting object to an encodable object failed.";
        else
          return "Converting object did not return an encodable object.";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        JsonUnsupportedObjectError$: [function(unsupportedObject, cause) {
          return new P.JsonUnsupportedObjectError(unsupportedObject, cause);
        }, null, null, 2, 3, 641, 0, 731, [], 728, [], "new JsonUnsupportedObjectError"]
      }
    },
    "+JsonUnsupportedObjectError": [34],
    JsonCyclicError: {
      "^": "JsonUnsupportedObjectError;unsupportedObject-10,cause-10",
      toString$0: [function(_) {
        return "Cyclic error in JSON stringify";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        JsonCyclicError$: [function(object) {
          return new P.JsonCyclicError(object, null);
        }, null, null, 2, 0, 170, 23, [], "new JsonCyclicError"]
      }
    },
    "+JsonCyclicError": [1415],
    JsonCodec: {
      "^": "Codec;_reviver<-473,_toEncodable<-55",
      decode$2$reviver: [function(source, reviver) {
        if (reviver == null)
          reviver = this._reviver;
        if (reviver == null)
          return P._parseJson(source, this.get$decoder()._reviver);
        return P._parseJson(source, reviver);
      }, function(source) {
        return this.decode$2$reviver(source, null);
      }, "decode$1", "call$2$reviver", "call$1", "get$decode", 2, 3, 1438, 0, 19, [], 188, [], "decode"],
      encode$2$toEncodable: [function(value, toEncodable) {
        var t1;
        if (toEncodable == null)
          toEncodable = this._toEncodable;
        if (toEncodable == null) {
          t1 = this.get$encoder();
          return P._JsonStringStringifier_stringify(value, t1._toEncodable, t1.indent);
        }
        return P._JsonStringStringifier_stringify(value, toEncodable, null);
      }, function(value) {
        return this.encode$2$toEncodable(value, null);
      }, "encode$1", "call$2$toEncodable", "call$1", "get$encode", 2, 3, 1467, 0, 1, [], 80, [], "encode"],
      get$encoder: [function() {
        var t1 = this._toEncodable;
        if (t1 == null)
          return C.JsonEncoder_null_null;
        return new P.JsonEncoder(null, t1);
      }, null, null, 1, 0, 1468, "encoder"],
      get$decoder: [function() {
        var t1 = this._reviver;
        if (t1 == null)
          return C.JsonDecoder_null;
        return new P.JsonDecoder(t1);
      }, null, null, 1, 0, 1469, "decoder"],
      $asCodec: function() {
        return [P.Object, P.String];
      },
      "<>": [],
      static: {
        JsonCodec$: [function(reviver, toEncodable) {
          return new P.JsonCodec(reviver, toEncodable);
        }, null, null, 0, 5, 642, 0, 0, 188, [], 80, [], "new JsonCodec"],
        JsonCodec$withReviver: [function(reviver) {
          return new P.JsonCodec(reviver, null);
        }, null, null, 2, 0, 643, 188, [], "new JsonCodec$withReviver"]
      }
    },
    "+JsonCodec": [1418],
    JsonEncoder: {
      "^": "Converter;indent<-9,_toEncodable<-55",
      convert$1: [function(object) {
        return P._JsonStringStringifier_stringify(object, this._toEncodable, this.indent);
      }, "call$1", "get$convert", 2, 0, 283, 23, [], "convert"],
      startChunkedConversion$1: [function(sink) {
        var t1 = J.getInterceptor(sink);
        if (!t1.$isStringConversionSink)
          sink = new P._StringAdapterSink(sink);
        else if (!!t1.$is_Utf8EncoderSink)
          return new P._JsonUtf8EncoderSink(sink._convert$_sink, P.JsonUtf8Encoder__utf8Encode(this.indent), this._toEncodable, 256, false);
        return new P._JsonEncoderSink(this.indent, this._toEncodable, sink, false);
      }, "call$1", "get$startChunkedConversion", 2, 0, 1471, 22, [], "startChunkedConversion"],
      bind$1: [function(stream) {
        return this.super$Converter$bind(stream);
      }, "call$1", "get$bind", 2, 0, 1480, 37, [], "bind"],
      fuse$1: [function(other) {
        if (other instanceof P.Utf8Encoder)
          return new P.JsonUtf8Encoder(P.JsonUtf8Encoder__utf8Encode(this.indent), this._toEncodable, 256);
        return this.super$Converter$fuse(other);
      }, "call$1", "get$fuse", 2, 0, function() {
        return {func: 1, ret: [P.Converter, P.Object,,], args: [[P.Converter, P.String,,]]};
      }, 2, [], "fuse"],
      $asConverter: function() {
        return [P.Object, P.String];
      },
      "<>": [],
      static: {
        JsonEncoder$: [function(toEncodable) {
          return new P.JsonEncoder(null, toEncodable);
        }, null, null, 0, 2, 644, 0, 80, [], "new JsonEncoder"],
        JsonEncoder$withIndent: [function(indent, toEncodable) {
          return new P.JsonEncoder(indent, toEncodable);
        }, null, null, 2, 2, 645, 0, 165, [], 80, [], "new JsonEncoder$withIndent"]
      }
    },
    "+JsonEncoder": [1419, 1420],
    JsonUtf8Encoder: {
      "^": "Converter;_indent<-14,_toEncodable<-55,_bufferSize<-0",
      convert$1: [function(object) {
        var bytes, t1, $length, i, result, offset, byteList, end;
        bytes = [];
        P._JsonUtf8Stringifier_stringify(object, this._indent, this._toEncodable, this._bufferSize, new P.JsonUtf8Encoder_convert_addChunk(bytes));
        t1 = bytes.length;
        if (t1 === 1) {
          if (0 >= t1)
            return H.ioore(bytes, 0);
          return bytes[0];
        }
        for ($length = 0, i = 0; i < bytes.length; ++i) {
          t1 = J.get$length$asx(bytes[i]);
          if (typeof t1 !== "number")
            return H.iae(t1);
          $length += t1;
        }
        result = new Uint8Array(H._checkLength($length));
        for (i = 0, offset = 0; i < bytes.length; ++i, offset = end) {
          byteList = bytes[i];
          t1 = J.get$length$asx(byteList);
          if (typeof t1 !== "number")
            return H.iae(t1);
          end = offset + t1;
          C.NativeUint8List_methods.setRange$3(result, offset, end, byteList);
        }
        return result;
      }, "call$1", "get$convert", 2, 0, 1485, 23, [], "convert"],
      startChunkedConversion$1: [function(sink) {
        var byteSink = sink instanceof P.ByteConversionSink ? sink : new P._ByteAdapterSink(sink);
        return new P._JsonUtf8EncoderSink(byteSink, this._indent, this._toEncodable, this._bufferSize, false);
      }, "call$1", "get$startChunkedConversion", 2, 0, 1487, 22, [], "startChunkedConversion"],
      bind$1: [function(stream) {
        return this.super$Converter$bind(stream);
      }, "call$1", "get$bind", 2, 0, 1491, 37, [], "bind"],
      $asConverter: function() {
        return [P.Object, [P.List, P.int]];
      },
      "<>": [],
      static: {
        "^": "JsonUtf8Encoder_DEFAULT_BUFFER_SIZE<-0",
        JsonUtf8Encoder$: [function(indent, toEncodable, bufferSize) {
          return new P.JsonUtf8Encoder(P.JsonUtf8Encoder__utf8Encode(indent), toEncodable, bufferSize);
        }, null, null, 0, 6, 646, 0, 0, 727, 165, [], 80, [], 138, [], "new JsonUtf8Encoder"],
        JsonUtf8Encoder__utf8Encode: [function(string) {
          var t1, i, t2;
          if (string == null)
            return;
          t1 = J.getInterceptor$asx(string);
          if (t1.get$isEmpty(string) === true)
            return new Uint8Array(H._checkLength(0));
          $checkAscii$0: {
            i = 0;
            while (true) {
              t2 = t1.get$length(string);
              if (typeof t2 !== "number")
                return H.iae(t2);
              if (!(i < t2))
                break;
              if (t1.codeUnitAt$1(string, i) >= 128)
                break $checkAscii$0;
              ++i;
            }
            return t1.get$codeUnits(string);
          }
          return C.Utf8Codec_false.get$encoder().convert$1(string);
        }, "call$1", "convert_JsonUtf8Encoder__utf8Encode$closure", 2, 0, 141, 39, [], "_utf8Encode"]
      }
    },
    "+JsonUtf8Encoder": [1421, 1422],
    JsonUtf8Encoder_convert_addChunk: {
      "^": "Closure:188;bytes",
      call$3: [function(chunk, start, end) {
        var $length, t1;
        if (J.$gt$n(start, 0) || J.$lt$n(end, J.get$length$asx(chunk))) {
          $length = J.$sub$n(end, start);
          t1 = J.getInterceptor$x(chunk);
          chunk = J.asUint8List$2$x(t1.get$buffer(chunk), J.$add$ns(t1.get$offsetInBytes(chunk), start), $length);
        }
        this.bytes.push(chunk);
      }, null, null, 6, 0, 188, 57, [], 3, [], 5, [], "call"]
    },
    "+ JsonUtf8Encoder_convert_addChunk": [2],
    _JsonEncoderSink: {
      "^": "ChunkedConversionSink;_indent<-9,_toEncodable<-55,_convert$_sink<-73,_isDone@-8",
      add$1: [function(_, o) {
        var stringSink, t1, t2, stringifier;
        if (this._isDone === true)
          throw H.wrapException(new P.StateError("Only one call to add allowed"));
        this._isDone = true;
        stringSink = this._convert$_sink.asStringSink$0();
        t1 = this._toEncodable;
        t2 = this._indent;
        if (t2 == null) {
          if (t1 == null)
            t1 = P.convert___defaultToEncodable$closure();
          stringifier = new P._JsonStringStringifier(stringSink, [], t1);
        } else {
          if (t1 == null)
            t1 = P.convert___defaultToEncodable$closure();
          stringifier = new P._JsonStringStringifierPretty(t2, 0, stringSink, [], t1);
        }
        stringifier.writeObject$1(o);
        stringSink.close$0();
      }, "call$1", "get$add", 2, 0, 64, 96, [], "add"],
      close$0: [function() {
      }, "call$0", "get$close", 0, 0, 6, "close"],
      $asChunkedConversionSink: function() {
        return [P.Object];
      },
      "<>": [],
      static: {
        _JsonEncoderSink$: [function(_sink, _toEncodable, _indent) {
          return new P._JsonEncoderSink(_indent, _toEncodable, _sink, false);
        }, null, null, 6, 0, 647, 45, [], 282, [], 387, [], "new _JsonEncoderSink"]
      }
    },
    "+_JsonEncoderSink": [474],
    _JsonUtf8EncoderSink: {
      "^": "ChunkedConversionSink;_convert$_sink<-39,_indent<-14,_toEncodable<-55,_bufferSize<-0,_isDone@-8",
      _convert$_addChunk$3: [function(chunk, start, end) {
        this._convert$_sink.addSlice$4(chunk, start, end, false);
      }, "call$3", "get$_convert$_addChunk", 6, 0, 188, 57, [], 3, [], 5, [], "_convert$_addChunk"],
      add$1: [function(_, object) {
        if (this._isDone === true)
          throw H.wrapException(new P.StateError("Only one call to add allowed"));
        this._isDone = true;
        P._JsonUtf8Stringifier_stringify(object, this._indent, this._toEncodable, this._bufferSize, this.get$_convert$_addChunk());
        this._convert$_sink.close$0();
      }, "call$1", "get$add", 2, 0, 64, 23, [], "add"],
      close$0: [function() {
        if (this._isDone !== true) {
          this._isDone = true;
          this._convert$_sink.close$0();
        }
      }, "call$0", "get$close", 0, 0, 6, "close"],
      $asChunkedConversionSink: function() {
        return [P.Object];
      },
      "<>": [],
      static: {
        _JsonUtf8EncoderSink$: [function(_sink, _toEncodable, _indent, _bufferSize) {
          return new P._JsonUtf8EncoderSink(_sink, _indent, _toEncodable, _bufferSize, false);
        }, null, null, 8, 0, 648, 45, [], 282, [], 387, [], 726, [], "new _JsonUtf8EncoderSink"]
      }
    },
    "+_JsonUtf8EncoderSink": [474],
    JsonDecoder: {
      "^": "Converter;_reviver<-473",
      convert$1: [function(input) {
        return P._parseJson(input, this._reviver);
      }, "call$1", "get$convert", 2, 0, 13, 58, [], "convert"],
      startChunkedConversion$1: [function(sink) {
        return new P._JsonDecoderSink(this._reviver, sink, new P.StringBuffer(""));
      }, "call$1", "get$startChunkedConversion", 2, 0, 1495, 22, [], "startChunkedConversion"],
      bind$1: [function(stream) {
        return this.super$Converter$bind(stream);
      }, "call$1", "get$bind", 2, 0, 1498, 37, [], "bind"],
      $asConverter: function() {
        return [P.String, P.Object];
      },
      "<>": [],
      static: {
        JsonDecoder$: [function(reviver) {
          return new P.JsonDecoder(reviver);
        }, null, null, 0, 2, 649, 0, 188, [], "new JsonDecoder"]
      }
    },
    "+JsonDecoder": [1424, 1425],
    _JsonStringifier: {
      "^": "Object;_seen<-50,_toEncodable<-55",
      writeStringContent$1: [function(s) {
        var t1, $length, offset, i, charCode, t2;
        t1 = J.getInterceptor$asx(s);
        $length = t1.get$length(s);
        if (typeof $length !== "number")
          return H.iae($length);
        offset = 0;
        i = 0;
        for (; i < $length; ++i) {
          charCode = t1.codeUnitAt$1(s, i);
          if (charCode > 92)
            continue;
          if (charCode < 32) {
            if (i > offset)
              this.writeStringSlice$3(s, offset, i);
            offset = i + 1;
            this.writeCharCode$1(92);
            switch (charCode) {
              case 8:
                this.writeCharCode$1(98);
                break;
              case 9:
                this.writeCharCode$1(116);
                break;
              case 10:
                this.writeCharCode$1(110);
                break;
              case 12:
                this.writeCharCode$1(102);
                break;
              case 13:
                this.writeCharCode$1(114);
                break;
              default:
                this.writeCharCode$1(117);
                this.writeCharCode$1(48);
                this.writeCharCode$1(48);
                t2 = charCode >>> 4 & 15;
                this.writeCharCode$1(t2 < 10 ? 48 + t2 : 87 + t2);
                t2 = charCode & 15;
                this.writeCharCode$1(t2 < 10 ? 48 + t2 : 87 + t2);
                break;
            }
          } else if (charCode === 34 || charCode === 92) {
            if (i > offset)
              this.writeStringSlice$3(s, offset, i);
            offset = i + 1;
            this.writeCharCode$1(92);
            this.writeCharCode$1(charCode);
          }
        }
        if (offset === 0)
          this.writeString$1(s);
        else if (offset < $length)
          this.writeStringSlice$3(s, offset, $length);
      }, "call$1", "get$writeStringContent", 2, 0, 19, 49, [], "writeStringContent"],
      _checkCycle$1: [function(object) {
        var t1, t2, i, t3;
        t1 = this._seen;
        t2 = J.getInterceptor$asx(t1);
        i = 0;
        while (true) {
          t3 = t2.get$length(t1);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          t3 = t2.$index(t1, i);
          if (object == null ? t3 == null : object === t3)
            throw H.wrapException(new P.JsonCyclicError(object, null));
          ++i;
        }
        t2.add$1(t1, object);
      }, "call$1", "get$_checkCycle", 2, 0, 27, 23, [], "_checkCycle"],
      _removeSeen$1: [function(object) {
        J.removeLast$0$ax(this._seen);
      }, "call$1", "get$_removeSeen", 2, 0, 27, 23, [], "_removeSeen"],
      writeObject$1: [function(object) {
        var customJson, e, exception, t1;
        if (this.writeJsonValue$1(object))
          return;
        this._checkCycle$1(object);
        try {
          customJson = this._toEncodable.call$1(object);
          if (!this.writeJsonValue$1(customJson))
            throw H.wrapException(new P.JsonUnsupportedObjectError(object, null));
          J.removeLast$0$ax(this._seen);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          throw H.wrapException(new P.JsonUnsupportedObjectError(object, e));
        }
      }, "call$1", "get$writeObject", 2, 0, 27, 23, [], "writeObject"],
      writeJsonValue$1: [function(object) {
        var t1, success;
        if (typeof object === "number") {
          if (!C.JSNumber_methods.get$isFinite(object))
            return false;
          this.writeNumber$1(object);
          return true;
        } else if (object === true) {
          this.writeString$1("true");
          return true;
        } else if (object === false) {
          this.writeString$1("false");
          return true;
        } else if (object == null) {
          this.writeString$1("null");
          return true;
        } else if (typeof object === "string") {
          this.writeString$1('"');
          this.writeStringContent$1(object);
          this.writeString$1('"');
          return true;
        } else {
          t1 = J.getInterceptor(object);
          if (!!t1.$isList) {
            this._checkCycle$1(object);
            this.writeList$1(object);
            J.removeLast$0$ax(this._seen);
            return true;
          } else if (!!t1.$isMap) {
            this._checkCycle$1(object);
            success = this.writeMap$1(object);
            J.removeLast$0$ax(this._seen);
            return success;
          } else
            return false;
        }
      }, "call$1", "get$writeJsonValue", 2, 0, 24, 23, [], "writeJsonValue"],
      writeList$1: [function(list) {
        var t1, i, t2;
        this.writeString$1("[");
        t1 = J.getInterceptor$asx(list);
        if (J.$gt$n(t1.get$length(list), 0)) {
          this.writeObject$1(t1.$index(list, 0));
          i = 1;
          while (true) {
            t2 = t1.get$length(list);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            this.writeString$1(",");
            this.writeObject$1(t1.$index(list, i));
            ++i;
          }
        }
        this.writeString$1("]");
      }, "call$1", "get$writeList", 2, 0, 490, 125, [], "writeList"],
      writeMap$1: [function(map) {
        var t1, t2, t3, keyValueList, separator, i;
        t1 = {};
        t2 = J.getInterceptor$asx(map);
        if (t2.get$isEmpty(map) === true) {
          this.writeString$1("{}");
          return true;
        }
        t3 = J.$mul$ns(t2.get$length(map), 2);
        if (typeof t3 !== "number")
          return H.iae(t3);
        keyValueList = new Array(t3);
        t1.i = 0;
        t1.allStringKeys = true;
        t2.forEach$1(map, new P._JsonStringifier_writeMap_closure(t1, keyValueList));
        if (!t1.allStringKeys)
          return false;
        this.writeString$1("{");
        for (t1 = keyValueList.length, separator = '"', i = 0; i < t1; i += 2, separator = ',"') {
          this.writeString$1(separator);
          this.writeStringContent$1(keyValueList[i]);
          this.writeString$1('":');
          t2 = i + 1;
          if (t2 >= t1)
            return H.ioore(keyValueList, t2);
          this.writeObject$1(keyValueList[t2]);
        }
        this.writeString$1("}");
        return true;
      }, "call$1", "get$writeMap", 2, 0, 214, 55, [], "writeMap"],
      static: {
        "^": "_JsonStringifier_BACKSPACE<-0,_JsonStringifier_TAB<-0,_JsonStringifier_NEWLINE<-0,_JsonStringifier_CARRIAGE_RETURN<-0,_JsonStringifier_FORM_FEED<-0,_JsonStringifier_QUOTE<-0,_JsonStringifier_CHAR_0<-0,_JsonStringifier_BACKSLASH<-0,_JsonStringifier_CHAR_b<-0,_JsonStringifier_CHAR_f<-0,_JsonStringifier_CHAR_n<-0,_JsonStringifier_CHAR_r<-0,_JsonStringifier_CHAR_t<-0,_JsonStringifier_CHAR_u<-0",
        _JsonStringifier$: [function(toEncodable) {
          var t1 = toEncodable == null ? P.convert___defaultToEncodable$closure() : toEncodable;
          return new P._JsonStringifier([], t1);
        }, null, null, 2, 0, 651, 80, [], "new _JsonStringifier"],
        _JsonStringifier_hexDigit: [function(x) {
          var t1;
          if (J.$lt$n(x, 10)) {
            if (typeof x !== "number")
              return H.iae(x);
            t1 = 48 + x;
          } else {
            if (typeof x !== "number")
              return H.iae(x);
            t1 = 87 + x;
          }
          return t1;
        }, "call$1", "convert__JsonStringifier_hexDigit$closure", 2, 0, 16, 38, [], "hexDigit"]
      }
    },
    "+_JsonStringifier": [1],
    _JsonStringifier_writeMap_closure: {
      "^": "Closure:12;_box_0,keyValueList",
      call$2: [function(key, value) {
        var t1, t2, t3, i, t4;
        if (typeof key !== "string")
          this._box_0.allStringKeys = false;
        t1 = this.keyValueList;
        t2 = this._box_0;
        t3 = t2.i;
        i = t3 + 1;
        t2.i = i;
        t4 = t1.length;
        if (t3 >= t4)
          return H.ioore(t1, t3);
        t1[t3] = key;
        t2.i = i + 1;
        if (i >= t4)
          return H.ioore(t1, i);
        t1[i] = value;
      }, null, null, 4, 0, 12, 6, [], 1, [], "call"]
    },
    "+ _JsonStringifier_writeMap_closure": [2],
    _JsonPrettyPrintMixin: {
      "^": "Object;_indentLevel:_JsonPrettyPrintMixin__indentLevel@-0",
      writeList$1: [function(list) {
        var t1, t2, i;
        t1 = J.getInterceptor$asx(list);
        if (t1.get$isEmpty(list) === true)
          this.writeString$1("[]");
        else {
          this.writeString$1("[\n");
          t2 = J.$add$ns(this._JsonPrettyPrintMixin__indentLevel, 1);
          this._JsonPrettyPrintMixin__indentLevel = t2;
          this.writeIndentation$1(t2);
          this.writeObject$1(t1.$index(list, 0));
          i = 1;
          while (true) {
            t2 = t1.get$length(list);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            this.writeString$1(",\n");
            this.writeIndentation$1(this._JsonPrettyPrintMixin__indentLevel);
            this.writeObject$1(t1.$index(list, i));
            ++i;
          }
          this.writeString$1("\n");
          t1 = J.$sub$n(this._JsonPrettyPrintMixin__indentLevel, 1);
          this._JsonPrettyPrintMixin__indentLevel = t1;
          this.writeIndentation$1(t1);
          this.writeString$1("]");
        }
      }, "call$1", "get$writeList", 2, 0, 490, 125, [], "writeList"],
      writeMap$1: [function(map) {
        var t1, t2, t3, keyValueList, separator, i;
        t1 = {};
        t2 = J.getInterceptor$asx(map);
        if (t2.get$isEmpty(map) === true) {
          this.writeString$1("{}");
          return true;
        }
        t3 = J.$mul$ns(t2.get$length(map), 2);
        if (typeof t3 !== "number")
          return H.iae(t3);
        keyValueList = new Array(t3);
        t1.i = 0;
        t1.allStringKeys = true;
        t2.forEach$1(map, new P._JsonPrettyPrintMixin_writeMap_closure(t1, keyValueList));
        if (!t1.allStringKeys)
          return false;
        this.writeString$1("{\n");
        this._JsonPrettyPrintMixin__indentLevel = J.$add$ns(this._JsonPrettyPrintMixin__indentLevel, 1);
        for (t1 = keyValueList.length, separator = "", i = 0; i < t1; i += 2, separator = ",\n") {
          this.writeString$1(separator);
          this.writeIndentation$1(this._JsonPrettyPrintMixin__indentLevel);
          this.writeString$1('"');
          this.writeStringContent$1(keyValueList[i]);
          this.writeString$1('": ');
          t2 = i + 1;
          if (t2 >= t1)
            return H.ioore(keyValueList, t2);
          this.writeObject$1(keyValueList[t2]);
        }
        this.writeString$1("\n");
        t1 = J.$sub$n(this._JsonPrettyPrintMixin__indentLevel, 1);
        this._JsonPrettyPrintMixin__indentLevel = t1;
        this.writeIndentation$1(t1);
        this.writeString$1("}");
        return true;
      }, "call$1", "get$writeMap", 2, 0, 214, 55, [], "writeMap"],
      static: {
        _JsonPrettyPrintMixin$: [function() {
          return new P._JsonPrettyPrintMixin(0);
        }, null, null, 0, 0, 652, "new _JsonPrettyPrintMixin"]
      }
    },
    "+_JsonPrettyPrintMixin": [1, 254],
    _JsonPrettyPrintMixin_writeMap_closure: {
      "^": "Closure:12;_box_0,keyValueList",
      call$2: [function(key, value) {
        var t1, t2, t3, i, t4;
        if (typeof key !== "string")
          this._box_0.allStringKeys = false;
        t1 = this.keyValueList;
        t2 = this._box_0;
        t3 = t2.i;
        i = t3 + 1;
        t2.i = i;
        t4 = t1.length;
        if (t3 >= t4)
          return H.ioore(t1, t3);
        t1[t3] = key;
        t2.i = i + 1;
        if (i >= t4)
          return H.ioore(t1, i);
        t1[i] = value;
      }, null, null, 4, 0, 12, 6, [], 1, [], "call"]
    },
    "+ _JsonPrettyPrintMixin_writeMap_closure": [2],
    _JsonStringStringifier: {
      "^": "_JsonStringifier;_convert$_sink<-57,_seen-50,_toEncodable-55",
      writeNumber$1: [function(number) {
        this._convert$_sink.write$1(J.toString$0$(number));
      }, "call$1", "get$writeNumber", 2, 0, 493, 272, [], "writeNumber"],
      writeString$1: [function(string) {
        this._convert$_sink.write$1(string);
      }, "call$1", "get$writeString", 2, 0, 19, 39, [], "writeString"],
      writeStringSlice$3: [function(string, start, end) {
        this._convert$_sink.write$1(J.substring$2$s(string, start, end));
      }, "call$3", "get$writeStringSlice", 6, 0, 307, 39, [], 3, [], 5, [], "writeStringSlice"],
      writeCharCode$1: [function(charCode) {
        this._convert$_sink.writeCharCode$1(charCode);
      }, "call$1", "get$writeCharCode", 2, 0, 17, 84, [], "writeCharCode"],
      static: {
        _JsonStringStringifier$: [function(_sink, _toEncodable) {
          var t1 = _toEncodable == null ? P.convert___defaultToEncodable$closure() : _toEncodable;
          return new P._JsonStringStringifier(_sink, [], t1);
        }, null, null, 4, 0, 399, 45, [], 282, [], "new _JsonStringStringifier"],
        _JsonStringStringifier_stringify: [function(object, toEncodable, indent) {
          var output, t1;
          output = new P.StringBuffer("");
          P._JsonStringStringifier_printOn(object, output, toEncodable, indent);
          t1 = output._contents;
          return t1.charCodeAt(0) == 0 ? t1 : t1;
        }, "call$3", "convert__JsonStringStringifier_stringify$closure", 6, 0, 654, 23, [], 80, [], 165, [], "stringify"],
        _JsonStringStringifier_printOn: [function(object, output, toEncodable, indent) {
          var t1, stringifier;
          if (indent == null) {
            t1 = toEncodable == null ? P.convert___defaultToEncodable$closure() : toEncodable;
            stringifier = new P._JsonStringStringifier(output, [], t1);
          } else {
            t1 = toEncodable == null ? P.convert___defaultToEncodable$closure() : toEncodable;
            stringifier = new P._JsonStringStringifierPretty(indent, 0, output, [], t1);
          }
          stringifier.writeObject$1(object);
        }, "call$4", "convert__JsonStringStringifier_printOn$closure", 8, 0, 655, 23, [], 279, [], 80, [], 165, [], "printOn"]
      }
    },
    "+_JsonStringStringifier": [254],
    _JsonStringStringifierPretty: {
      "^": "_JsonStringStringifier__JsonPrettyPrintMixin;_indent<-9,_JsonPrettyPrintMixin__indentLevel-0,_convert$_sink-57,_seen-50,_toEncodable-55",
      writeIndentation$1: [function(count) {
        var t1, t2, i;
        if (typeof count !== "number")
          return H.iae(count);
        t1 = this._indent;
        t2 = this._convert$_sink;
        i = 0;
        for (; i < count; ++i)
          t2.write$1(t1);
      }, "call$1", "get$writeIndentation", 2, 0, 17, 43, [], "writeIndentation"],
      static: {
        _JsonStringStringifierPretty$: [function(sink, toEncodable, _indent) {
          var t1 = toEncodable == null ? P.convert___defaultToEncodable$closure() : toEncodable;
          return new P._JsonStringStringifierPretty(_indent, 0, sink, [], t1);
        }, null, null, 6, 0, 656, 22, [], 80, [], 387, [], "new _JsonStringStringifierPretty"]
      }
    },
    "+_JsonStringStringifierPretty": [1427],
    _JsonStringStringifier__JsonPrettyPrintMixin: {
      "^": "_JsonStringStringifier+_JsonPrettyPrintMixin;_indentLevel:_JsonPrettyPrintMixin__indentLevel@-0,_convert$_sink-57,_seen-50,_toEncodable-55",
      static: {
        "_JsonStringStringifier+_JsonPrettyPrintMixin$": [function(_sink, _toEncodable) {
          var t1 = _toEncodable == null ? P.convert___defaultToEncodable$closure() : _toEncodable;
          return new P._JsonStringStringifier__JsonPrettyPrintMixin(0, _sink, [], t1);
        }, null, null, 4, 0, 399, 45, [], 282, [], "new _JsonStringStringifier+_JsonPrettyPrintMixin"]
      }
    },
    _JsonUtf8Stringifier: {
      "^": "_JsonStringifier;bufferSize<-0,addChunk<-255,buffer*-89,index@-0,_seen-50,_toEncodable-55",
      flush$0: [function() {
        if (J.$gt$n(this.index, 0))
          this.addChunk.call$3(this.buffer, 0, this.index);
        this.buffer = null;
        this.index = 0;
      }, "call$0", "get$flush", 0, 0, 6, "flush"],
      writeNumber$1: [function(number) {
        this.writeAsciiString$1(J.toString$0$(number));
      }, "call$1", "get$writeNumber", 2, 0, 493, 272, [], "writeNumber"],
      writeAsciiString$1: [function(string) {
        var t1, i, t2;
        t1 = J.getInterceptor$asx(string);
        i = 0;
        while (true) {
          t2 = t1.get$length(string);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          this.writeByte$1(t1.codeUnitAt$1(string, i));
          ++i;
        }
      }, "call$1", "get$writeAsciiString", 2, 0, 19, 39, [], "writeAsciiString"],
      writeString$1: [function(string) {
        this.writeStringSlice$3(string, 0, J.get$length$asx(string));
      }, "call$1", "get$writeString", 2, 0, 19, 39, [], "writeString"],
      writeStringSlice$3: [function(string, start, end) {
        var t1, i, t2, char, nextChar;
        for (t1 = J.getInterceptor$s(string), i = start; t2 = J.getInterceptor$n(i), t2.$lt(i, end); i = J.$add$ns(i, 1)) {
          char = t1.codeUnitAt$1(string, i);
          if (char <= 127)
            this.writeByte$1(char);
          else {
            if ((char & 64512) === 55296 && J.$lt$n(t2.$add(i, 1), end)) {
              nextChar = t1.codeUnitAt$1(string, t2.$add(i, 1));
              if ((nextChar & 64512) === 56320) {
                this.writeFourByteCharCode$1(65536 + ((char & 1023) << 10) + (nextChar & 1023));
                i = t2.$add(i, 1);
                continue;
              }
            }
            this.writeMultiByteCharCode$1(char);
          }
        }
      }, "call$3", "get$writeStringSlice", 6, 0, 307, 39, [], 3, [], 5, [], "writeStringSlice"],
      writeCharCode$1: [function(charCode) {
        if (J.$le$n(charCode, 127)) {
          this.writeByte$1(charCode);
          return;
        }
        this.writeMultiByteCharCode$1(charCode);
      }, "call$1", "get$writeCharCode", 2, 0, 17, 84, [], "writeCharCode"],
      writeMultiByteCharCode$1: [function(charCode) {
        var t1 = J.getInterceptor$n(charCode);
        if (t1.$le(charCode, 2047)) {
          this.writeByte$1((192 | t1.$shr(charCode, 6)) >>> 0);
          t1 = t1.$and(charCode, 63);
          if (typeof t1 !== "number")
            return H.iae(t1);
          this.writeByte$1((128 | t1) >>> 0);
          return;
        }
        if (t1.$le(charCode, 65535)) {
          this.writeByte$1((224 | t1.$shr(charCode, 12)) >>> 0);
          this.writeByte$1(128 | t1.$shr(charCode, 6) & 63);
          t1 = t1.$and(charCode, 63);
          if (typeof t1 !== "number")
            return H.iae(t1);
          this.writeByte$1((128 | t1) >>> 0);
          return;
        }
        this.writeFourByteCharCode$1(charCode);
      }, "call$1", "get$writeMultiByteCharCode", 2, 0, 17, 84, [], "writeMultiByteCharCode"],
      writeFourByteCharCode$1: [function(charCode) {
        var t1 = J.getInterceptor$n(charCode);
        this.writeByte$1((240 | t1.$shr(charCode, 18)) >>> 0);
        this.writeByte$1(128 | t1.$shr(charCode, 12) & 63);
        this.writeByte$1(128 | t1.$shr(charCode, 6) & 63);
        t1 = t1.$and(charCode, 63);
        if (typeof t1 !== "number")
          return H.iae(t1);
        this.writeByte$1((128 | t1) >>> 0);
      }, "call$1", "get$writeFourByteCharCode", 2, 0, 17, 84, [], "writeFourByteCharCode"],
      writeByte$1: [function(byte) {
        var t1, t2;
        if (J.$eq$(this.index, J.get$length$asx(this.buffer))) {
          this.addChunk.call$3(this.buffer, 0, this.index);
          t1 = this.bufferSize;
          if (typeof t1 !== "number" || Math.floor(t1) !== t1)
            H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t1)));
          this.buffer = new Uint8Array(t1);
          this.index = 0;
        }
        t1 = this.buffer;
        t2 = this.index;
        this.index = J.$add$ns(t2, 1);
        J.$indexSet$ax(t1, t2, byte);
      }, "call$1", "get$writeByte", 2, 0, 17, 149, [], "writeByte"],
      static: {
        _JsonUtf8Stringifier$: [function(toEncodable, bufferSize, addChunk) {
          var t1, t2;
          t1 = new Uint8Array(H._checkLength(bufferSize));
          t2 = toEncodable == null ? P.convert___defaultToEncodable$closure() : toEncodable;
          return new P._JsonUtf8Stringifier(bufferSize, addChunk, t1, 0, [], t2);
        }, null, null, 6, 0, 400, 80, [], 138, [], 283, [], "new _JsonUtf8Stringifier"],
        _JsonUtf8Stringifier_stringify: [function(object, indent, toEncodable, bufferSize, addChunk) {
          var t1, t2, stringifier;
          if (indent != null) {
            t1 = new Uint8Array(H._checkLength(bufferSize));
            t2 = toEncodable == null ? P.convert___defaultToEncodable$closure() : toEncodable;
            stringifier = new P._JsonUtf8StringifierPretty(indent, 0, bufferSize, addChunk, t1, 0, [], t2);
          } else {
            t1 = new Uint8Array(H._checkLength(bufferSize));
            t2 = toEncodable == null ? P.convert___defaultToEncodable$closure() : toEncodable;
            stringifier = new P._JsonUtf8Stringifier(bufferSize, addChunk, t1, 0, [], t2);
          }
          stringifier.writeObject$1(object);
          stringifier.flush$0();
        }, "call$5", "convert__JsonUtf8Stringifier_stringify$closure", 10, 0, 658, 23, [], 165, [], 80, [], 138, [], 283, [], "stringify"]
      }
    },
    "+_JsonUtf8Stringifier": [254],
    _JsonUtf8StringifierPretty: {
      "^": "_JsonUtf8Stringifier__JsonPrettyPrintMixin;indent<-14,_JsonPrettyPrintMixin__indentLevel-0,bufferSize-0,addChunk-255,buffer-89,index-0,_seen-50,_toEncodable-55",
      writeIndentation$1: [function(count) {
        var indent, t1, indentLength, char, t2, end, i;
        indent = this.indent;
        t1 = J.getInterceptor$asx(indent);
        indentLength = t1.get$length(indent);
        if (J.$eq$(indentLength, 1)) {
          char = t1.$index(indent, 0);
          for (; t1 = J.getInterceptor$n(count), t1.$gt(count, 0);) {
            this.writeByte$1(char);
            count = t1.$sub(count, 1);
          }
          return;
        }
        for (; t2 = J.getInterceptor$n(count), t2.$gt(count, 0);) {
          count = t2.$sub(count, 1);
          end = J.$add$ns(this.index, indentLength);
          if (J.$le$n(end, J.get$length$asx(this.buffer))) {
            J.setRange$3$ax(this.buffer, this.index, end, indent);
            this.index = end;
          } else {
            if (typeof indentLength !== "number")
              return H.iae(indentLength);
            i = 0;
            for (; i < indentLength; ++i)
              this.writeByte$1(t1.$index(indent, i));
          }
        }
      }, "call$1", "get$writeIndentation", 2, 0, 17, 43, [], "writeIndentation"],
      static: {
        _JsonUtf8StringifierPretty$: [function(toEncodable, indent, bufferSize, addChunk) {
          var t1, t2;
          t1 = new Uint8Array(H._checkLength(bufferSize));
          t2 = toEncodable == null ? P.convert___defaultToEncodable$closure() : toEncodable;
          return new P._JsonUtf8StringifierPretty(indent, 0, bufferSize, addChunk, t1, 0, [], t2);
        }, null, null, 8, 0, 659, 80, [], 165, [], 138, [], 283, [], "new _JsonUtf8StringifierPretty"]
      }
    },
    "+_JsonUtf8StringifierPretty": [1429],
    _JsonUtf8Stringifier__JsonPrettyPrintMixin: {
      "^": "_JsonUtf8Stringifier+_JsonPrettyPrintMixin;_indentLevel:_JsonPrettyPrintMixin__indentLevel@-0,bufferSize-0,addChunk-255,buffer-89,index-0,_seen-50,_toEncodable-55",
      static: {
        "_JsonUtf8Stringifier+_JsonPrettyPrintMixin$": [function(toEncodable, bufferSize, addChunk) {
          var t1, t2;
          t1 = new Uint8Array(H._checkLength(bufferSize));
          t2 = toEncodable == null ? P.convert___defaultToEncodable$closure() : toEncodable;
          return new P._JsonUtf8Stringifier__JsonPrettyPrintMixin(0, bufferSize, addChunk, t1, 0, [], t2);
        }, null, null, 6, 0, 400, 80, [], 138, [], 283, [], "new _JsonUtf8Stringifier+_JsonPrettyPrintMixin"]
      }
    },
    Latin1Codec: {
      "^": "Encoding;_allowInvalid<-8",
      get$name: [function() {
        return "iso-8859-1";
      }, null, null, 1, 0, 7, "name"],
      decode$2$allowInvalid: [function(bytes, allowInvalid) {
        if ((allowInvalid == null ? this._allowInvalid : allowInvalid) === true)
          return C.Latin1Decoder_true_255.convert$1(bytes);
        else
          return C.Latin1Decoder_false_255.convert$1(bytes);
      }, function(bytes) {
        return this.decode$2$allowInvalid(bytes, null);
      }, "decode$1", "call$2$allowInvalid", "call$1", "get$decode", 2, 3, 459, 0, 30, [], 156, [], "decode"],
      get$encoder: [function() {
        return C.Latin1Encoder_255;
      }, null, null, 1, 0, 1512, "encoder"],
      get$decoder: [function() {
        return this._allowInvalid === true ? C.Latin1Decoder_true_255 : C.Latin1Decoder_false_255;
      }, null, null, 1, 0, 1518, "decoder"],
      static: {
        Latin1Codec$: [function(allowInvalid) {
          return new P.Latin1Codec(allowInvalid);
        }, null, null, 0, 3, 179, 4, 156, [], "new Latin1Codec"]
      }
    },
    "+Latin1Codec": [79],
    Latin1Encoder: {
      "^": "_UnicodeSubsetEncoder;_subsetMask-0",
      static: {
        Latin1Encoder$: [function() {
          return new P.Latin1Encoder(255);
        }, null, null, 0, 0, 4, "new Latin1Encoder"]
      }
    },
    "+Latin1Encoder": [467],
    Latin1Decoder: {
      "^": "_UnicodeSubsetDecoder;_allowInvalid-8,_subsetMask-0",
      startChunkedConversion$1: [function(sink) {
        var stringSink = !!J.getInterceptor(sink).$isStringConversionSink ? sink : new P._StringAdapterSink(sink);
        if (this._allowInvalid !== true)
          return new P._Latin1DecoderSink(stringSink);
        return new P._Latin1AllowInvalidDecoderSink(stringSink);
      }, "call$1", "get$startChunkedConversion", 2, 0, 159, 22, [], "startChunkedConversion"],
      static: {
        Latin1Decoder$: [function(allowInvalid) {
          return new P.Latin1Decoder(allowInvalid, 255);
        }, null, null, 0, 3, 179, 4, 156, [], "new Latin1Decoder"]
      }
    },
    "+Latin1Decoder": [468],
    _Latin1DecoderSink: {
      "^": "ByteConversionSinkBase;_convert$_sink@-73",
      close$0: [function() {
        this._convert$_sink.close$0();
        this._convert$_sink = null;
      }, "call$0", "get$close", 0, 0, 6, "close"],
      add$1: [function(_, source) {
        this.addSlice$4(source, 0, J.get$length$asx(source), false);
      }, "call$1", "get$add", 2, 0, 26, 19, [], "add"],
      _addSliceToSink$4: [function(source, start, end, isLast) {
        J.add$1$ax(this._convert$_sink, P.String_String$fromCharCodes(source, start, end));
        if (isLast === true) {
          this._convert$_sink.close$0();
          this._convert$_sink = null;
        }
      }, "call$4", "get$_addSliceToSink", 8, 0, 44, 19, [], 3, [], 5, [], 46, [], "_addSliceToSink"],
      addSlice$4: [function(source, start, end, isLast) {
        var t1 = J.getInterceptor$asx(source);
        end = P.RangeError_checkValidRange(start, end, t1.get$length(source), null, null, null);
        if (J.$eq$(start, end))
          return;
        if (!t1.$isUint8List)
          P._Latin1DecoderSink__checkValidLatin1(source, start, end);
        J.add$1$ax(this._convert$_sink, P.String_String$fromCharCodes(source, start, end));
        if (isLast === true) {
          this._convert$_sink.close$0();
          this._convert$_sink = null;
        }
      }, "call$4", "get$addSlice", 8, 0, 44, 19, [], 3, [], 5, [], 46, [], "addSlice"],
      static: {
        _Latin1DecoderSink$: [function(_sink) {
          return new P._Latin1DecoderSink(_sink);
        }, null, null, 2, 0, 181, 45, [], "new _Latin1DecoderSink"],
        _Latin1DecoderSink__checkValidLatin1: [function(source, start, end) {
          var t1, i, mask, t2, t3;
          for (t1 = J.getInterceptor$asx(source), i = start, mask = 0; t2 = J.getInterceptor$n(i), t2.$lt(i, end); i = t2.$add(i, 1)) {
            t3 = t1.$index(source, i);
            if (typeof t3 !== "number")
              return H.iae(t3);
            mask = (mask | t3) >>> 0;
          }
          if (mask >= 0 && mask <= 255)
            return;
          P._Latin1DecoderSink__reportInvalidLatin1(source, start, end);
        }, "call$3", "convert__Latin1DecoderSink__checkValidLatin1$closure", 6, 0, 276, 19, [], 3, [], 5, [], "_checkValidLatin1"],
        _Latin1DecoderSink__reportInvalidLatin1: [function(source, start, end) {
          var t1, i, t2, char, t3;
          for (t1 = J.getInterceptor$asx(source), i = start; t2 = J.getInterceptor$n(i), t2.$lt(i, end); i = t2.$add(i, 1)) {
            char = t1.$index(source, i);
            t3 = J.getInterceptor$n(char);
            if (t3.$lt(char, 0) || t3.$gt(char, 255))
              throw H.wrapException(new P.FormatException("Source contains non-Latin-1 characters.", source, i));
          }
        }, "call$3", "convert__Latin1DecoderSink__reportInvalidLatin1$closure", 6, 0, 276, 19, [], 3, [], 5, [], "_reportInvalidLatin1"]
      }
    },
    "+_Latin1DecoderSink": [99],
    _Latin1AllowInvalidDecoderSink: {
      "^": "_Latin1DecoderSink;_convert$_sink-73",
      addSlice$4: [function(source, start, end, isLast) {
        var t1, i, t2, char, t3;
        t1 = J.getInterceptor$asx(source);
        P.RangeError_checkValidRange(start, end, t1.get$length(source), null, null, null);
        for (i = start; t2 = J.getInterceptor$n(i), t2.$lt(i, end); i = t2.$add(i, 1)) {
          char = t1.$index(source, i);
          t3 = J.getInterceptor$n(char);
          if (t3.$gt(char, 255) || t3.$lt(char, 0)) {
            if (t2.$gt(i, start))
              J.add$1$ax(this._convert$_sink, P.String_String$fromCharCodes(source, start, i));
            J.add$1$ax(this._convert$_sink, P.String_String$fromCharCodes(C.List_65533, 0, 1));
            start = t2.$add(i, 1);
          }
        }
        if (J.$lt$n(start, end)) {
          J.add$1$ax(this._convert$_sink, P.String_String$fromCharCodes(source, start, end));
          if (isLast === true) {
            this._convert$_sink.close$0();
            this._convert$_sink = null;
          }
        }
        if (isLast === true) {
          this._convert$_sink.close$0();
          this._convert$_sink = null;
        }
      }, "call$4", "get$addSlice", 8, 0, 44, 19, [], 3, [], 5, [], 46, [], "addSlice"],
      static: {
        _Latin1AllowInvalidDecoderSink$: [function(sink) {
          return new P._Latin1AllowInvalidDecoderSink(sink);
        }, null, null, 2, 0, 181, 22, [], "new _Latin1AllowInvalidDecoderSink"]
      }
    },
    "+_Latin1AllowInvalidDecoderSink": [1430],
    LineSplitter: {
      "^": "Converter;",
      convert$1: [function(data) {
        var lines, t1, end, sliceStart, char, i, char0;
        lines = H.setRuntimeTypeInfo([], [P.String]);
        t1 = J.getInterceptor$asx(data);
        end = t1.get$length(data);
        if (typeof end !== "number")
          return H.iae(end);
        sliceStart = 0;
        char = 0;
        i = 0;
        for (; i < end; ++i, char = char0) {
          char0 = t1.codeUnitAt$1(data, i);
          if (char0 !== 13) {
            if (char0 !== 10)
              continue;
            if (char === 13) {
              sliceStart = i + 1;
              continue;
            }
          }
          lines.push(t1.substring$2(data, sliceStart, i));
          sliceStart = i + 1;
        }
        if (sliceStart < end)
          lines.push(t1.substring$2(data, sliceStart, end));
        return lines;
      }, "call$1", "get$convert", 2, 0, 281, 21, [], "convert"],
      startChunkedConversion$1: [function(sink) {
        return new P._LineSplitterSink(!J.getInterceptor(sink).$isStringConversionSink ? new P._StringAdapterSink(sink) : sink, null, false);
      }, "call$1", "get$startChunkedConversion", 2, 0, 284, 22, [], "startChunkedConversion"],
      bind$1: [function(stream) {
        return new P._BoundSinkStream(new P.LineSplitter_bind_closure(), stream, [null, null]);
      }, "call$1", "get$bind", 2, 0, 1520, 37, [], "bind"],
      $asConverter: function() {
        return [P.String, [P.List, P.String]];
      },
      "<>": [],
      static: {
        LineSplitter$: [function() {
          return new P.LineSplitter();
        }, null, null, 0, 0, 4, "new LineSplitter"],
        LineSplitter_split: [function($async$lines, $async$start, $async$end) {
          return new P._SyncStarIterable$(function() {
            var lines = $async$lines, start = $async$start, end = $async$end;
            var $async$goto = 0, $async$handler = 1, $async$currentError, t1, i, sliceStart, char, t2, char0;
            return function $async$LineSplitter_split($async$errorCode, $async$result) {
              if ($async$errorCode === 1) {
                $async$currentError = $async$result;
                $async$goto = $async$handler;
              }
              while (true)
                switch ($async$goto) {
                  case 0:
                    // Function start
                    t1 = J.getInterceptor$asx(lines);
                    end = P.RangeError_checkValidRange(start, end, t1.get$length(lines), null, null, null);
                    i = start, sliceStart = i, char = 0;
                  case 2:
                    // for condition
                    if (!(t2 = J.getInterceptor$n(i), t2.$lt(i, end))) {
                      // goto after for
                      $async$goto = 4;
                      break;
                    }
                    char0 = t1.codeUnitAt$1(lines, i);
                    if (char0 !== 13) {
                      if (char0 !== 10) {
                        // goto for update
                        $async$goto = 3;
                        break;
                      }
                      if (char === 13) {
                        sliceStart = t2.$add(i, 1);
                        // goto for update
                        $async$goto = 3;
                        break;
                      }
                    }
                    $async$goto = 5;
                    return t1.substring$2(lines, sliceStart, i);
                  case 5:
                    // after yield
                    sliceStart = t2.$add(i, 1);
                  case 3:
                    // for update
                    i = t2.$add(i, 1), char = char0;
                    // goto for condition
                    $async$goto = 2;
                    break;
                  case 4:
                    // after for
                    $async$goto = J.$lt$n(sliceStart, end) ? 6 : 7;
                    break;
                  case 6:
                    // then
                    $async$goto = 8;
                    return t1.substring$2(lines, sliceStart, end);
                  case 8:
                    // after yield
                  case 7:
                    // join
                    // implicit return
                    return P._IterationMarker_endOfIteration();
                  case 1:
                    // rethrow
                    return P._IterationMarker_uncaughtError($async$currentError);
                }
            };
          });
        }, function(lines) {
          return P.LineSplitter_split(lines, 0, null);
        }, function(lines, start) {
          return P.LineSplitter_split(lines, start, null);
        }, "call$3", "call$1", "call$2", "convert_LineSplitter_split$closure", 2, 4, 661, 7, 0, 516, [], 3, [], 5, [], "split"]
      }
    },
    "+LineSplitter": [1431, 1432],
    LineSplitter_bind_closure: {
      "^": "Closure:278;",
      call$1: [function(sink) {
        return new P._LineSplitterEventSink(sink, new P._StringAdapterSink(sink), null, false);
      }, null, null, 2, 0, 278, 22, [], "call"]
    },
    "+ LineSplitter_bind_closure": [2],
    _LineSplitterSink: {
      "^": "StringConversionSinkBase;_convert$_sink<-73,_carry@-9,_skipLeadingLF@-8",
      addSlice$4: [function(chunk, start, end, isLast) {
        var t1, t2, t3;
        t1 = J.getInterceptor$asx(chunk);
        end = P.RangeError_checkValidRange(start, end, t1.get$length(chunk), null, null, null);
        t2 = J.getInterceptor$n(start);
        if (t2.$ge(start, end)) {
          if (isLast === true)
            this.close$0();
          return;
        }
        t3 = this._carry;
        if (t3 != null) {
          chunk = J.$add$ns(t3, t1.substring$2(chunk, start, end));
          end = J.get$length$asx(chunk);
          this._carry = null;
          start = 0;
        } else if (this._skipLeadingLF === true) {
          if (t1.codeUnitAt$1(chunk, start) === 10)
            start = t2.$add(start, 1);
          this._skipLeadingLF = false;
        }
        this._addLines$3(chunk, start, end);
        if (isLast === true)
          this.close$0();
      }, "call$4", "get$addSlice", 8, 0, 87, 57, [], 3, [], 5, [], 46, [], "addSlice"],
      close$0: [function() {
        var t1 = this._carry;
        if (t1 != null) {
          J.add$1$ax(this._convert$_sink, t1);
          this._carry = null;
        }
        this._convert$_sink.close$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      _addLines$3: [function(lines, start, end) {
        var t1, t2, t3, i, sliceStart, char, t4, char0;
        for (t1 = this._convert$_sink, t2 = J.getInterceptor$s(lines), t3 = J.getInterceptor$ax(t1), i = start, sliceStart = i, char = 0; t4 = J.getInterceptor$n(i), t4.$lt(i, end); i = t4.$add(i, 1), char = char0) {
          char0 = t2.codeUnitAt$1(lines, i);
          if (char0 !== 13) {
            if (char0 !== 10)
              continue;
            if (char === 13) {
              sliceStart = t4.$add(i, 1);
              continue;
            }
          }
          t3.add$1(t1, t2.substring$2(lines, sliceStart, i));
          sliceStart = t4.$add(i, 1);
        }
        if (J.$lt$n(sliceStart, end))
          this._carry = t2.substring$2(lines, sliceStart, end);
        else
          this._skipLeadingLF = char === 13;
      }, "call$3", "get$_addLines", 6, 0, 307, 516, [], 3, [], 5, [], "_addLines"],
      static: {
        _LineSplitterSink$: [function(_sink) {
          return new P._LineSplitterSink(_sink, null, false);
        }, null, null, 2, 0, 181, 45, [], "new _LineSplitterSink"]
      }
    },
    "+_LineSplitterSink": [100],
    _LineSplitterEventSink: {
      "^": "_LineSplitterSink;_convert$_eventSink<-475,_convert$_sink-73,_carry-9,_skipLeadingLF-8",
      addError$2: [function(o, stackTrace) {
        this._convert$_eventSink.addError$2(o, stackTrace);
      }, function(o) {
        return this.addError$2(o, null);
      }, "addError$1", "call$2", "call$1", "get$addError", 2, 2, 48, 0, 96, [], 12, [], "addError"],
      static: {
        _LineSplitterEventSink$: [function(eventSink) {
          return new P._LineSplitterEventSink(eventSink, new P._StringAdapterSink(eventSink), null, false);
        }, null, null, 2, 0, 278, 304, [], "new _LineSplitterEventSink"]
      }
    },
    "+_LineSplitterEventSink": [1434, 475],
    StringConversionSink: {
      "^": "ChunkedConversionSink;",
      $asChunkedConversionSink: function() {
        return [P.String];
      },
      "<>": [],
      static: {
        StringConversionSink$: [function() {
          return new P.StringConversionSink();
        }, null, null, 0, 0, 4, "new StringConversionSink"],
        StringConversionSink_StringConversionSink$withCallback: [function(callback) {
          return new P._StringCallbackSink(callback, new P.StringBuffer(""));
        }, null, null, 2, 0, 662, 33, [], "new StringConversionSink$withCallback"],
        StringConversionSink_StringConversionSink$from: [function(sink) {
          return new P._StringAdapterSink(sink);
        }, null, null, 2, 0, 284, 22, [], "new StringConversionSink$from"],
        StringConversionSink_StringConversionSink$fromStringSink: [function(sink) {
          return new P._StringSinkConversionSink(sink);
        }, null, null, 2, 0, 663, 22, [], "new StringConversionSink$fromStringSink"]
      }
    },
    "+StringConversionSink": [1435],
    ClosableStringSink: {
      "^": "StringSink;",
      static: {
        ClosableStringSink_ClosableStringSink$fromStringSink: [function(sink, onClose) {
          return new P._ClosableStringSink(onClose, sink);
        }, null, null, 4, 0, 664, 22, [], 721, [], "new ClosableStringSink$fromStringSink"]
      }
    },
    "+ClosableStringSink": [57],
    _ClosableStringSink: {
      "^": "Object;_callback<-1436,_convert$_sink<-57",
      close$0: [function() {
        this._callback.call$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      writeCharCode$1: [function(charCode) {
        this._convert$_sink.writeCharCode$1(charCode);
      }, "call$1", "get$writeCharCode", 2, 0, 17, 84, [], "writeCharCode"],
      write$1: [function(o) {
        this._convert$_sink.write$1(o);
      }, "call$1", "get$write", 2, 0, 64, 96, [], "write"],
      writeln$1: [function(o) {
        this._convert$_sink.writeln$1(o);
      }, function() {
        return this.writeln$1("");
      }, "writeln$0", "call$1", "call$0", "get$writeln", 0, 2, 134, 32, 96, [], "writeln"],
      writeAll$2: [function(objects, separator) {
        this._convert$_sink.writeAll$2(objects, separator);
      }, function(objects) {
        return this.writeAll$2(objects, "");
      }, "writeAll$1", "call$2", "call$1", "get$writeAll", 2, 2, 135, 32, 119, [], 63, [], "writeAll"],
      static: {
        _ClosableStringSink$: [function(_sink, _callback) {
          return new P._ClosableStringSink(_callback, _sink);
        }, null, null, 4, 0, 665, 45, [], 396, [], "new _ClosableStringSink"]
      }
    },
    "+_ClosableStringSink": [1, 476],
    _StringConversionSinkAsStringSinkAdapter: {
      "^": "Object;_buffer@-256,_chunkedSink@-73",
      close$0: [function() {
        if (J.get$isNotEmpty$asx(this._buffer))
          this._flush$0();
        this._chunkedSink.close$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      writeCharCode$1: [function(charCode) {
        var accumulated;
        this._buffer.writeCharCode$1(charCode);
        if (J.$gt$n(J.get$length$asx(this._buffer), 16)) {
          accumulated = J.toString$0$(this._buffer);
          J.clear$0$ax(this._buffer);
          J.add$1$ax(this._chunkedSink, accumulated);
        }
      }, "call$1", "get$writeCharCode", 2, 0, 17, 84, [], "writeCharCode"],
      write$1: [function(o) {
        var accumulated;
        if (J.get$isNotEmpty$asx(this._buffer)) {
          accumulated = J.toString$0$(this._buffer);
          J.clear$0$ax(this._buffer);
          J.add$1$ax(this._chunkedSink, accumulated);
        }
        J.add$1$ax(this._chunkedSink, J.toString$0$(o));
      }, "call$1", "get$write", 2, 0, 64, 96, [], "write"],
      writeln$1: [function(o) {
        this._buffer.writeln$1(o);
        if (J.$gt$n(J.get$length$asx(this._buffer), 16))
          this._flush$0();
      }, function() {
        return this.writeln$1("");
      }, "writeln$0", "call$1", "call$0", "get$writeln", 0, 2, 134, 32, 96, [], "writeln"],
      writeAll$2: [function(objects, separator) {
        var iterator, t1, accumulated;
        if (J.get$isNotEmpty$asx(this._buffer))
          this._flush$0();
        iterator = J.get$iterator$ax(objects);
        if (!iterator.moveNext$0())
          return;
        t1 = J.getInterceptor$asx(separator);
        if (t1.get$isEmpty(separator) === true) {
          do
            J.add$1$ax(this._chunkedSink, J.toString$0$(iterator.get$current()));
          while (iterator.moveNext$0());
        } else {
          J.add$1$ax(this._chunkedSink, J.toString$0$(iterator.get$current()));
          for (; iterator.moveNext$0();) {
            if (J.get$isNotEmpty$asx(this._buffer)) {
              accumulated = J.toString$0$(this._buffer);
              J.clear$0$ax(this._buffer);
              J.add$1$ax(this._chunkedSink, accumulated);
            }
            J.add$1$ax(this._chunkedSink, t1.toString$0(separator));
            J.add$1$ax(this._chunkedSink, J.toString$0$(iterator.get$current()));
          }
        }
      }, function(objects) {
        return this.writeAll$2(objects, "");
      }, "writeAll$1", "call$2", "call$1", "get$writeAll", 2, 2, 135, 32, 119, [], 63, [], "writeAll"],
      _flush$0: [function() {
        var accumulated = J.toString$0$(this._buffer);
        J.clear$0$ax(this._buffer);
        J.add$1$ax(this._chunkedSink, accumulated);
      }, "call$0", "get$_flush", 0, 0, 6, "_flush"],
      static: {
        "^": "_StringConversionSinkAsStringSinkAdapter__MIN_STRING_SIZE<-10",
        _StringConversionSinkAsStringSinkAdapter$: [function(_chunkedSink) {
          return new P._StringConversionSinkAsStringSinkAdapter(new P.StringBuffer(""), _chunkedSink);
        }, null, null, 2, 0, 181, 519, [], "new _StringConversionSinkAsStringSinkAdapter"]
      }
    },
    "+_StringConversionSinkAsStringSinkAdapter": [1, 476],
    StringConversionSinkBase: {
      "^": "StringConversionSinkMixin;",
      static: {
        StringConversionSinkBase$: [function() {
          return new P.StringConversionSinkBase();
        }, null, null, 0, 0, 666, "new StringConversionSinkBase"]
      }
    },
    "+StringConversionSinkBase": [1439],
    StringConversionSinkMixin: {
      "^": "Object;",
      add$1: [function(_, str) {
        this.addSlice$4(str, 0, J.get$length$asx(str), false);
      }, "call$1", "get$add", 2, 0, 19, 120, [], "add"],
      asUtf8Sink$1: [function(allowMalformed) {
        var t1 = new P.StringBuffer("");
        return new P._Utf8ConversionSink(new P._Utf8Decoder(allowMalformed, t1, true, 0, 0, 0), this, t1);
      }, "call$1", "get$asUtf8Sink", 2, 0, 277, 104, [], "asUtf8Sink"],
      asStringSink$0: [function() {
        return new P._StringConversionSinkAsStringSinkAdapter(new P.StringBuffer(""), this);
      }, "call$0", "get$asStringSink", 0, 0, 503, "asStringSink"],
      $isStringConversionSink: 1,
      static: {
        StringConversionSinkMixin$: [function() {
          return new P.StringConversionSinkMixin();
        }, null, null, 0, 0, 667, "new StringConversionSinkMixin"]
      }
    },
    "+StringConversionSinkMixin": [1, 73],
    _StringSinkConversionSink: {
      "^": "StringConversionSinkBase;_stringSink@-57",
      close$0: ["super$_StringSinkConversionSink$close", function() {
      }, "call$0", "get$close", 0, 0, 6, "close"],
      addSlice$4: [function(str, start, end, isLast) {
        var t1, i, t2;
        if (!J.$eq$(start, 0) || !J.$eq$(end, J.get$length$asx(str)))
          for (t1 = J.getInterceptor$s(str), i = start; t2 = J.getInterceptor$n(i), t2.$lt(i, end); i = t2.$add(i, 1))
            this._stringSink.writeCharCode$1(t1.codeUnitAt$1(str, i));
        else
          this._stringSink.write$1(str);
        if (isLast === true)
          this.close$0();
      }, "call$4", "get$addSlice", 8, 0, 87, 120, [], 3, [], 5, [], 46, [], "addSlice"],
      add$1: [function(_, str) {
        this._stringSink.write$1(str);
      }, "call$1", "get$add", 2, 0, 19, 120, [], "add"],
      asUtf8Sink$1: [function(allowMalformed) {
        return new P._Utf8StringSinkAdapter(new P._Utf8Decoder(allowMalformed, this._stringSink, true, 0, 0, 0), this);
      }, "call$1", "get$asUtf8Sink", 2, 0, 277, 104, [], "asUtf8Sink"],
      asStringSink$0: [function() {
        var t1 = this._stringSink;
        return new P._ClosableStringSink(this.get$close(), t1);
      }, "call$0", "get$asStringSink", 0, 0, 503, "asStringSink"],
      static: {
        _StringSinkConversionSink$: [function(_stringSink) {
          return new P._StringSinkConversionSink(_stringSink);
        }, null, null, 2, 0, 668, 520, [], "new _StringSinkConversionSink"]
      }
    },
    "+_StringSinkConversionSink": [100],
    _StringCallbackSink: {
      "^": "_StringSinkConversionSink;_callback<-1440,_stringSink-57",
      close$0: [function() {
        var buffer, t1, accumulated;
        buffer = this._stringSink;
        t1 = J.getInterceptor(buffer);
        accumulated = t1.toString$0(buffer);
        t1.clear$0(buffer);
        this._callback.call$1(accumulated);
      }, "call$0", "get$close", 0, 0, 6, "close"],
      asUtf8Sink$1: [function(allowMalformed) {
        return new P._Utf8StringSinkAdapter(new P._Utf8Decoder(allowMalformed, this._stringSink, true, 0, 0, 0), this);
      }, "call$1", "get$asUtf8Sink", 2, 0, 277, 104, [], "asUtf8Sink"],
      static: {
        _StringCallbackSink$: [function(_callback) {
          return new P._StringCallbackSink(_callback, new P.StringBuffer(""));
        }, null, null, 2, 0, 669, 396, [], "new _StringCallbackSink"]
      }
    },
    "+_StringCallbackSink": [1441],
    _StringAdapterSink: {
      "^": "StringConversionSinkBase;_convert$_sink<-248",
      add$1: [function(_, str) {
        J.add$1$ax(this._convert$_sink, str);
      }, "call$1", "get$add", 2, 0, 19, 120, [], "add"],
      addSlice$4: [function(str, start, end, isLast) {
        var t1, t2;
        t1 = J.$eq$(start, 0) && J.$eq$(end, J.get$length$asx(str));
        t2 = this._convert$_sink;
        if (t1)
          J.add$1$ax(t2, str);
        else
          J.add$1$ax(t2, J.substring$2$s(str, start, end));
        if (isLast === true)
          t2.close$0();
      }, "call$4", "get$addSlice", 8, 0, 87, 120, [], 3, [], 5, [], 46, [], "addSlice"],
      close$0: [function() {
        this._convert$_sink.close$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      static: {
        _StringAdapterSink$: [function(_sink) {
          return new P._StringAdapterSink(_sink);
        }, null, null, 2, 0, 402, 45, [], "new _StringAdapterSink"]
      }
    },
    "+_StringAdapterSink": [100],
    _Utf8StringSinkAdapter: {
      "^": "ByteConversionSink;_decoder<-477,_convert$_sink<-469",
      close$0: [function() {
        this._decoder.close$0();
        var t1 = this._convert$_sink;
        if (t1 != null)
          t1.close$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      add$1: [function(_, chunk) {
        this._decoder.convert$3(chunk, 0, J.get$length$asx(chunk));
      }, "call$1", "get$add", 2, 0, 26, 57, [], "add"],
      addSlice$4: [function(codeUnits, startIndex, endIndex, isLast) {
        this._decoder.convert$3(codeUnits, startIndex, endIndex);
        if (isLast === true)
          this.close$0();
      }, "call$4", "get$addSlice", 8, 0, 44, 180, [], 102, [], 231, [], 46, [], "addSlice"],
      static: {
        _Utf8StringSinkAdapter$: [function(_sink, stringSink, allowMalformed) {
          return new P._Utf8StringSinkAdapter(new P._Utf8Decoder(allowMalformed, stringSink, true, 0, 0, 0), _sink);
        }, null, null, 6, 0, 671, 45, [], 720, [], 104, [], "new _Utf8StringSinkAdapter"]
      }
    },
    "+_Utf8StringSinkAdapter": [39],
    _Utf8ConversionSink: {
      "^": "ByteConversionSink;_decoder<-477,_chunkedSink<-73,_buffer<-256",
      close$0: [function() {
        var t1, t2, t3, accumulated;
        this._decoder.close$0();
        t1 = this._buffer;
        t2 = J.getInterceptor$asx(t1);
        t3 = this._chunkedSink;
        if (t2.get$isNotEmpty(t1)) {
          accumulated = t2.toString$0(t1);
          t2.clear$0(t1);
          t3.addSlice$4(accumulated, 0, J.get$length$asx(accumulated), true);
        } else
          t3.close$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      add$1: [function(_, chunk) {
        this.addSlice$4(chunk, 0, J.get$length$asx(chunk), false);
      }, "call$1", "get$add", 2, 0, 26, 57, [], "add"],
      addSlice$4: [function(chunk, startIndex, endIndex, isLast) {
        var t1, t2, accumulated;
        this._decoder.convert$3(chunk, startIndex, endIndex);
        t1 = this._buffer;
        t2 = J.getInterceptor$asx(t1);
        if (t2.get$isNotEmpty(t1)) {
          accumulated = t2.toString$0(t1);
          this._chunkedSink.addSlice$4(accumulated, 0, J.get$length$asx(accumulated), isLast);
          t2.clear$0(t1);
          return;
        }
        if (isLast === true)
          this.close$0();
      }, "call$4", "get$addSlice", 8, 0, 44, 57, [], 102, [], 231, [], 46, [], "addSlice"],
      static: {
        _Utf8ConversionSink$: [function(sink, allowMalformed) {
          var t1 = new P.StringBuffer("");
          return new P._Utf8ConversionSink(new P._Utf8Decoder(allowMalformed, t1, true, 0, 0, 0), sink, t1);
        }, null, null, 4, 0, 672, 22, [], 104, [], "new _Utf8ConversionSink"],
        _Utf8ConversionSink$_: [function(_chunkedSink, stringBuffer, allowMalformed) {
          return new P._Utf8ConversionSink(new P._Utf8Decoder(allowMalformed, stringBuffer, true, 0, 0, 0), _chunkedSink, stringBuffer);
        }, null, null, 6, 0, 673, 519, [], 719, [], 104, [], "new _Utf8ConversionSink$_"]
      }
    },
    "+_Utf8ConversionSink": [39],
    Utf8Codec: {
      "^": "Encoding;_allowMalformed<-8",
      get$name: [function() {
        return "utf-8";
      }, null, null, 1, 0, 7, "name"],
      decode$2$allowMalformed: [function(codeUnits, allowMalformed) {
        return new P.Utf8Decoder(allowMalformed == null ? this._allowMalformed : allowMalformed).convert$1(codeUnits);
      }, function(codeUnits) {
        return this.decode$2$allowMalformed(codeUnits, null);
      }, "decode$1", "call$2$allowMalformed", "call$1", "get$decode", 2, 3, 1535, 0, 180, [], 104, [], "decode"],
      get$encoder: [function() {
        return C.C_Utf8Encoder;
      }, null, null, 1, 0, 1705, "encoder"],
      get$decoder: [function() {
        return new P.Utf8Decoder(this._allowMalformed);
      }, null, null, 1, 0, 1547, "decoder"],
      static: {
        Utf8Codec$: [function(allowMalformed) {
          return new P.Utf8Codec(allowMalformed);
        }, null, null, 0, 3, 403, 4, 104, [], "new Utf8Codec"]
      }
    },
    "+Utf8Codec": [79],
    Utf8Encoder: {
      "^": "Converter;",
      convert$3: [function(string, start, end) {
        var t1, stringLength, t2, $length, t3, encoder;
        t1 = J.getInterceptor$asx(string);
        stringLength = t1.get$length(string);
        P.RangeError_checkValidRange(start, end, stringLength, null, null, null);
        if (end == null)
          end = stringLength;
        t2 = J.getInterceptor$n(end);
        $length = t2.$sub(end, start);
        t3 = J.getInterceptor($length);
        if (t3.$eq($length, 0))
          return new Uint8Array(H._checkLength(0));
        t3 = new Uint8Array(H._checkLength(t3.$mul($length, 3)));
        encoder = new P._Utf8Encoder(0, 0, t3);
        if (!J.$eq$(encoder._fillBuffer$3(string, start, end), end))
          encoder._writeSurrogate$2(t1.codeUnitAt$1(string, t2.$sub(end, 1)), 0);
        return C.NativeUint8List_methods.sublist$2(t3, 0, encoder._bufferIndex);
      }, function(string) {
        return this.convert$3(string, 0, null);
      }, "convert$1", function(string, start) {
        return this.convert$3(string, start, null);
      }, "convert$2", "call$3", "call$1", "call$2", "get$convert", 2, 4, 172, 7, 0, 39, [], 3, [], 5, [], "convert"],
      startChunkedConversion$1: [function(sink) {
        if (!(sink instanceof P.ByteConversionSink))
          sink = new P._ByteAdapterSink(sink);
        return new P._Utf8EncoderSink(sink, 0, 0, new Uint8Array(H._checkLength(1024)));
      }, "call$1", "get$startChunkedConversion", 2, 0, 173, 22, [], "startChunkedConversion"],
      bind$1: [function(stream) {
        return this.super$Converter$bind(stream);
      }, "call$1", "get$bind", 2, 0, 463, 37, [], "bind"],
      $asConverter: function() {
        return [P.String, [P.List, P.int]];
      },
      "<>": [],
      static: {
        Utf8Encoder$: [function() {
          return new P.Utf8Encoder();
        }, null, null, 0, 0, 4, "new Utf8Encoder"]
      }
    },
    "+Utf8Encoder": [194, 192],
    _Utf8Encoder: {
      "^": "Object;_carry@-0,_bufferIndex@-0,_buffer<-14",
      _writeSurrogate$2: [function(leadingSurrogate, nextCodeUnit) {
        var t1, t2, t3, t4, rune;
        t1 = J.getInterceptor$n(nextCodeUnit);
        t2 = J.getInterceptor$n(leadingSurrogate);
        t3 = this._buffer;
        t4 = J.getInterceptor$ax(t3);
        if (t1.$and(nextCodeUnit, 64512) === 56320) {
          t2 = J.$shl$n(t2.$and(leadingSurrogate, 1023), 10);
          t1 = t1.$and(nextCodeUnit, 1023);
          if (typeof t1 !== "number")
            return H.iae(t1);
          rune = 65536 + t2 | t1;
          t1 = this._bufferIndex;
          this._bufferIndex = J.$add$ns(t1, 1);
          t4.$indexSet(t3, t1, (240 | rune >>> 18) >>> 0);
          t1 = this._bufferIndex;
          this._bufferIndex = J.$add$ns(t1, 1);
          t4.$indexSet(t3, t1, 128 | rune >>> 12 & 63);
          t1 = this._bufferIndex;
          this._bufferIndex = J.$add$ns(t1, 1);
          t4.$indexSet(t3, t1, 128 | rune >>> 6 & 63);
          t1 = this._bufferIndex;
          this._bufferIndex = J.$add$ns(t1, 1);
          t4.$indexSet(t3, t1, 128 | rune & 63);
          return true;
        } else {
          t1 = this._bufferIndex;
          this._bufferIndex = J.$add$ns(t1, 1);
          t4.$indexSet(t3, t1, (224 | t2.$shr(leadingSurrogate, 12)) >>> 0);
          t1 = this._bufferIndex;
          this._bufferIndex = J.$add$ns(t1, 1);
          t4.$indexSet(t3, t1, 128 | t2.$shr(leadingSurrogate, 6) & 63);
          t1 = this._bufferIndex;
          this._bufferIndex = J.$add$ns(t1, 1);
          t2 = t2.$and(leadingSurrogate, 63);
          if (typeof t2 !== "number")
            return H.iae(t2);
          t4.$indexSet(t3, t1, (128 | t2) >>> 0);
          return false;
        }
      }, "call$2", "get$_writeSurrogate", 4, 0, 1567, 709, [], 707, [], "_writeSurrogate"],
      _fillBuffer$3: [function(str, start, end) {
        var t1, t2, t3, stringIndex, t4, codeUnit;
        if (!J.$eq$(start, end) && (J.codeUnitAt$1$s(str, J.$sub$n(end, 1)) & 64512) === 55296)
          end = J.$sub$n(end, 1);
        for (t1 = this._buffer, t2 = J.getInterceptor$asx(t1), t3 = J.getInterceptor$s(str), stringIndex = start; t4 = J.getInterceptor$n(stringIndex), t4.$lt(stringIndex, end); stringIndex = J.$add$ns(stringIndex, 1)) {
          codeUnit = t3.codeUnitAt$1(str, stringIndex);
          if (codeUnit <= 127) {
            if (J.$ge$n(this._bufferIndex, t2.get$length(t1)))
              break;
            t4 = this._bufferIndex;
            this._bufferIndex = J.$add$ns(t4, 1);
            t2.$indexSet(t1, t4, codeUnit);
          } else if ((codeUnit & 64512) === 55296) {
            if (J.$ge$n(J.$add$ns(this._bufferIndex, 3), t2.get$length(t1)))
              break;
            if (this._writeSurrogate$2(codeUnit, t3.codeUnitAt$1(str, t4.$add(stringIndex, 1))))
              stringIndex = t4.$add(stringIndex, 1);
          } else if (codeUnit <= 2047) {
            if (J.$ge$n(J.$add$ns(this._bufferIndex, 1), t2.get$length(t1)))
              break;
            t4 = this._bufferIndex;
            this._bufferIndex = J.$add$ns(t4, 1);
            t2.$indexSet(t1, t4, 192 | codeUnit >>> 6);
            t4 = this._bufferIndex;
            this._bufferIndex = J.$add$ns(t4, 1);
            t2.$indexSet(t1, t4, 128 | codeUnit & 63);
          } else {
            if (J.$ge$n(J.$add$ns(this._bufferIndex, 2), t2.get$length(t1)))
              break;
            t4 = this._bufferIndex;
            this._bufferIndex = J.$add$ns(t4, 1);
            t2.$indexSet(t1, t4, 224 | codeUnit >>> 12);
            t4 = this._bufferIndex;
            this._bufferIndex = J.$add$ns(t4, 1);
            t2.$indexSet(t1, t4, 128 | codeUnit >>> 6 & 63);
            t4 = this._bufferIndex;
            this._bufferIndex = J.$add$ns(t4, 1);
            t2.$indexSet(t1, t4, 128 | codeUnit & 63);
          }
        }
        return stringIndex;
      }, "call$3", "get$_fillBuffer", 6, 0, 512, 120, [], 3, [], 5, [], "_fillBuffer"],
      static: {
        "^": "_Utf8Encoder__DEFAULT_BYTE_BUFFER_SIZE<-10",
        _Utf8Encoder$: [function() {
          return new P._Utf8Encoder(0, 0, new Uint8Array(H._checkLength(1024)));
        }, null, null, 0, 0, 4, "new _Utf8Encoder"],
        _Utf8Encoder$withBufferSize: [function(bufferSize) {
          return new P._Utf8Encoder(0, 0, new Uint8Array(H._checkLength(bufferSize)));
        }, null, null, 2, 0, 22, 138, [], "new _Utf8Encoder$withBufferSize"],
        _Utf8Encoder__createBuffer: [function(size) {
          return new Uint8Array(H._checkLength(size));
        }, "call$1", "convert__Utf8Encoder__createBuffer$closure", 2, 0, 105, 284, [], "_createBuffer"]
      }
    },
    "+_Utf8Encoder": [1],
    _Utf8EncoderSink: {
      "^": "_Utf8Encoder_StringConversionSinkMixin;_convert$_sink<-39,_carry-0,_bufferIndex-0,_buffer-14",
      close$0: [function() {
        if (!J.$eq$(this._carry, 0)) {
          this.addSlice$4("", 0, 0, true);
          return;
        }
        this._convert$_sink.close$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      addSlice$4: [function(str, start, end, isLast) {
        var t1, nextCodeUnit, t2, t3, t4, t5, t6, isLastSlice, t7;
        this._bufferIndex = 0;
        t1 = J.getInterceptor(start);
        if (t1.$eq(start, end) && isLast !== true)
          return;
        if (!J.$eq$(this._carry, 0)) {
          nextCodeUnit = !t1.$eq(start, end) ? J.codeUnitAt$1$s(str, start) : 0;
          if (this._writeSurrogate$2(this._carry, nextCodeUnit))
            start = t1.$add(start, 1);
          this._carry = 0;
        }
        t1 = this._convert$_sink;
        t2 = this._buffer;
        t3 = J.getInterceptor$n(end);
        t4 = isLast === true;
        t5 = J.getInterceptor$s(str);
        t6 = J.getInterceptor$asx(t2);
        do {
          start = this._fillBuffer$3(str, start, end);
          isLastSlice = t4 && J.$eq$(start, end);
          t7 = J.getInterceptor(start);
          if (t7.$eq(start, t3.$sub(end, 1)) && (t5.codeUnitAt$1(str, start) & 64512) === 55296) {
            if (t4 && J.$lt$n(this._bufferIndex, J.$sub$n(t6.get$length(t2), 3)))
              this._writeSurrogate$2(t5.codeUnitAt$1(str, start), 0);
            else
              this._carry = t5.codeUnitAt$1(str, start);
            start = t7.$add(start, 1);
          }
          t1.addSlice$4(t2, 0, this._bufferIndex, isLastSlice);
          this._bufferIndex = 0;
        } while (J.$lt$n(start, end));
        if (t4)
          this.close$0();
      }, "call$4", "get$addSlice", 8, 0, 87, 120, [], 3, [], 5, [], 46, [], "addSlice"],
      static: {
        _Utf8EncoderSink$: [function(_sink) {
          return new P._Utf8EncoderSink(_sink, 0, 0, new Uint8Array(H._checkLength(1024)));
        }, null, null, 2, 0, 398, 45, [], "new _Utf8EncoderSink"]
      }
    },
    "+_Utf8EncoderSink": [1443],
    _Utf8Encoder_StringConversionSinkMixin: {
      "^": "_Utf8Encoder+StringConversionSinkMixin;_carry-0,_bufferIndex-0,_buffer-14",
      $isStringConversionSink: 1,
      static: {
        "_Utf8Encoder+StringConversionSinkMixin$": [function() {
          return new P._Utf8Encoder_StringConversionSinkMixin(0, 0, new Uint8Array(H._checkLength(1024)));
        }, null, null, 0, 0, 4, "new _Utf8Encoder+StringConversionSinkMixin"],
        "_Utf8Encoder+StringConversionSinkMixin$withBufferSize": [function(bufferSize) {
          return new P._Utf8Encoder_StringConversionSinkMixin(0, 0, new Uint8Array(H._checkLength(bufferSize)));
        }, null, null, 2, 0, 22, 138, [], "new _Utf8Encoder+StringConversionSinkMixin$withBufferSize"]
      }
    },
    Utf8Decoder: {
      "^": "Converter;_allowMalformed<-8",
      convert$3: [function(codeUnits, start, end) {
        var $length, buffer, decoder, t1;
        $length = J.get$length$asx(codeUnits);
        P.RangeError_checkValidRange(start, end, $length, null, null, null);
        if (end == null)
          end = $length;
        buffer = new P.StringBuffer("");
        decoder = new P._Utf8Decoder(this._allowMalformed, buffer, true, 0, 0, 0);
        decoder.convert$3(codeUnits, start, end);
        decoder.flush$2(codeUnits, end);
        t1 = buffer._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, function(codeUnits) {
        return this.convert$3(codeUnits, 0, null);
      }, "convert$1", function(codeUnits, start) {
        return this.convert$3(codeUnits, start, null);
      }, "convert$2", "call$3", "call$1", "call$2", "get$convert", 2, 4, 465, 7, 0, 180, [], 3, [], 5, [], "convert"],
      startChunkedConversion$1: [function(sink) {
        var stringSink = !!J.getInterceptor(sink).$isStringConversionSink ? sink : new P._StringAdapterSink(sink);
        return stringSink.asUtf8Sink$1(this._allowMalformed);
      }, "call$1", "get$startChunkedConversion", 2, 0, 159, 22, [], "startChunkedConversion"],
      bind$1: [function(stream) {
        return this.super$Converter$bind(stream);
      }, "call$1", "get$bind", 2, 0, 466, 37, [], "bind"],
      fuse$1: [function(next) {
        return this.super$Converter$fuse(next);
      }, "call$1", "get$fuse", 2, 0, function() {
        return {func: 1, ret: [P.Converter, [P.List, P.int],,], args: [[P.Converter, P.String,,]]};
      }, 461, [], "fuse"],
      $asConverter: function() {
        return [[P.List, P.int], P.String];
      },
      "<>": [],
      static: {
        Utf8Decoder$: [function(allowMalformed) {
          return new P.Utf8Decoder(allowMalformed);
        }, null, null, 0, 3, 403, 4, 104, [], "new Utf8Decoder"],
        Utf8Decoder__convertIntercepted: [function(allowMalformed, codeUnits, start, end) {
          return;
        }, "call$4", "convert_Utf8Decoder__convertIntercepted$closure", 8, 0, 675, 104, [], 180, [], 3, [], 5, [], "_convertIntercepted"]
      }
    },
    "+Utf8Decoder": [189, 232],
    _Utf8Decoder: {
      "^": "Object;_allowMalformed<-8,_stringSink<-57,_isFirstCharacter@-8,_convert$_value@-0,_expectedUnits@-0,_extraUnits@-0",
      get$hasPartialInput: [function() {
        return J.$gt$n(this._expectedUnits, 0);
      }, null, null, 1, 0, 5, "hasPartialInput"],
      close$0: [function() {
        this.flush$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      flush$2: [function(source, offset) {
        if (J.$gt$n(this._expectedUnits, 0)) {
          if (this._allowMalformed !== true)
            throw H.wrapException(new P.FormatException("Unfinished UTF-8 octet sequence", source, offset));
          this._stringSink.writeCharCode$1(65533);
          this._convert$_value = 0;
          this._expectedUnits = 0;
          this._extraUnits = 0;
        }
      }, function(source) {
        return this.flush$2(source, null);
      }, "flush$1", function() {
        return this.flush$2(null, null);
      }, "flush$0", "call$2", "call$1", "call$0", "get$flush", 0, 4, 1574, 0, 0, 19, [], 220, [], "flush"],
      convert$3: [function(codeUnits, startIndex, endIndex) {
        var value, expectedUnits, extraUnits, t1, t2, t3, t4, t5, i, t6, unit, t7, t8, oneBytes, i0;
        value = this._convert$_value;
        expectedUnits = this._expectedUnits;
        extraUnits = this._extraUnits;
        this._convert$_value = 0;
        this._expectedUnits = 0;
        this._extraUnits = 0;
        t1 = new P._Utf8Decoder_convert_scanOneByteCharacters(endIndex);
        t2 = new P._Utf8Decoder_convert_addSingleBytes(this, codeUnits, startIndex, endIndex);
        $loop$0:
          for (t3 = this._stringSink, t4 = this._allowMalformed !== true, t5 = J.getInterceptor$asx(codeUnits), i = startIndex; true; i = i0) {
            $multibyte$2:
              if (J.$gt$n(expectedUnits, 0)) {
                do {
                  t6 = J.getInterceptor(i);
                  if (t6.$eq(i, endIndex))
                    break $loop$0;
                  unit = t5.$index(codeUnits, i);
                  t7 = J.getInterceptor$n(unit);
                  if (t7.$and(unit, 192) !== 128) {
                    if (t4)
                      throw H.wrapException(new P.FormatException("Bad UTF-8 encoding 0x" + t7.toRadixString$1(unit, 16), codeUnits, i));
                    this._isFirstCharacter = false;
                    t3.writeCharCode$1(65533);
                    expectedUnits = 0;
                    break $multibyte$2;
                  } else {
                    t8 = J.$shl$n(value, 6);
                    t7 = t7.$and(unit, 63);
                    if (typeof t7 !== "number")
                      return H.iae(t7);
                    value = (t8 | t7) >>> 0;
                    expectedUnits = J.$sub$n(expectedUnits, 1);
                    i = t6.$add(i, 1);
                  }
                } while (J.$gt$n(expectedUnits, 0));
                t6 = J.$sub$n(extraUnits, 1);
                if (t6 >>> 0 !== t6 || t6 >= 4)
                  return H.ioore(C.List_127_2047_65535_1114111, t6);
                if (value <= C.List_127_2047_65535_1114111[t6]) {
                  if (t4)
                    throw H.wrapException(new P.FormatException("Overlong encoding of 0x" + C.JSInt_methods.toRadixString$1(value, 16), codeUnits, J.$sub$n(J.$sub$n(i, extraUnits), 1)));
                  value = 65533;
                  expectedUnits = 0;
                  extraUnits = 0;
                }
                if (value > 1114111) {
                  if (t4)
                    throw H.wrapException(new P.FormatException("Character outside valid Unicode range: 0x" + C.JSInt_methods.toRadixString$1(value, 16), codeUnits, J.$sub$n(J.$sub$n(i, extraUnits), 1)));
                  value = 65533;
                }
                if (this._isFirstCharacter !== true || value !== 65279)
                  t3.writeCharCode$1(value);
                this._isFirstCharacter = false;
              }
            for (; t6 = J.getInterceptor$n(i), t6.$lt(i, endIndex); i = i0) {
              oneBytes = t1.call$2(codeUnits, i);
              if (J.$gt$n(oneBytes, 0)) {
                this._isFirstCharacter = false;
                t2.call$2(i, t6.$add(i, oneBytes));
                i = t6.$add(i, oneBytes);
                if (J.$eq$(i, endIndex))
                  break;
              }
              i0 = J.$add$ns(i, 1);
              unit = t5.$index(codeUnits, i);
              t6 = J.getInterceptor$n(unit);
              if (t6.$lt(unit, 0)) {
                if (t4)
                  throw H.wrapException(new P.FormatException("Negative UTF-8 code unit: -0x" + J.toRadixString$1$n(t6.$negate(unit), 16), codeUnits, J.$sub$n(i0, 1)));
                t3.writeCharCode$1(65533);
              } else {
                if (t6.$and(unit, 224) === 192) {
                  value = t6.$and(unit, 31);
                  expectedUnits = 1;
                  extraUnits = 1;
                  continue $loop$0;
                }
                if (t6.$and(unit, 240) === 224) {
                  value = t6.$and(unit, 15);
                  expectedUnits = 2;
                  extraUnits = 2;
                  continue $loop$0;
                }
                if (t6.$and(unit, 248) === 240 && t6.$lt(unit, 245)) {
                  value = t6.$and(unit, 7);
                  expectedUnits = 3;
                  extraUnits = 3;
                  continue $loop$0;
                }
                if (t4)
                  throw H.wrapException(new P.FormatException("Bad UTF-8 encoding 0x" + t6.toRadixString$1(unit, 16), codeUnits, J.$sub$n(i0, 1)));
                this._isFirstCharacter = false;
                t3.writeCharCode$1(65533);
                value = 65533;
                expectedUnits = 0;
                extraUnits = 0;
              }
            }
            break $loop$0;
          }
        if (J.$gt$n(expectedUnits, 0)) {
          this._convert$_value = value;
          this._expectedUnits = expectedUnits;
          this._extraUnits = extraUnits;
        }
      }, "call$3", "get$convert", 6, 0, 276, 180, [], 102, [], 231, [], "convert"],
      static: {
        "^": "_Utf8Decoder__LIMITS<-14",
        _Utf8Decoder$: [function(_stringSink, _allowMalformed) {
          return new P._Utf8Decoder(_allowMalformed, _stringSink, true, 0, 0, 0);
        }, null, null, 4, 0, 676, 520, [], 711, [], "new _Utf8Decoder"]
      }
    },
    "+_Utf8Decoder": [1],
    _Utf8Decoder_convert_scanOneByteCharacters: {
      "^": "Closure:517;endIndex",
      call$2: [function(units, from) {
        var to, t1, i, t2, unit;
        to = this.endIndex;
        for (t1 = J.getInterceptor$asx(units), i = from; t2 = J.getInterceptor$n(i), t2.$lt(i, to); i = t2.$add(i, 1)) {
          unit = t1.$index(units, i);
          if (J.$and$n(unit, 127) !== unit)
            return t2.$sub(i, from);
        }
        return J.$sub$n(to, from);
      }, null, null, 4, 0, 517, 706, [], 144, [], "call"]
    },
    "+ _Utf8Decoder_convert_scanOneByteCharacters": [2],
    _Utf8Decoder_convert_addSingleBytes: {
      "^": "Closure:76;$this,codeUnits,startIndex,endIndex",
      call$2: [function(from, to) {
        this.$this._stringSink.write$1(P.String_String$fromCharCodes(this.codeUnits, from, to));
      }, null, null, 4, 0, 76, 144, [], 347, [], "call"]
    },
    "+ _Utf8Decoder_convert_addSingleBytes": [2],
    _ChunkedConversionCallback: {
      "^": "",
      $typedefType: 1702,
      $$isTypedef: true
    },
    "+_ChunkedConversionCallback": "",
    _Reviver: {
      "^": "",
      $typedefType: 12,
      $$isTypedef: true
    },
    "+_Reviver": "",
    _ToEncodable: {
      "^": "",
      $typedefType: 3,
      $$isTypedef: true
    },
    "+_ToEncodable": "",
    _AddChunk: {
      "^": "",
      $typedefType: 188,
      $$isTypedef: true
    },
    "+_AddChunk": "",
    _StringSinkCloseCallback: {
      "^": "",
      $typedefType: 6,
      $$isTypedef: true
    },
    "+_StringSinkCloseCallback": ""
  }], ["dart.core", "dart:core",, P, {
    "^": "_scannerTables<-481,_schemeStart<-0,_nonSimpleEndStates<-0,_uriStart<-0,_notSimpleIndex<-0,_fragmentStartIndex<-0,_queryStartIndex<-0,_pathStartIndex<-0,_portStartIndex<-0,_hostStartIndex<-0,_schemeEndIndex<-0,_hexDigits<-9,_LOWER_CASE_Z<-0,_LOWER_CASE_F<-0,_LOWER_CASE_A<-0,_RIGHT_BRACKET<-0,_BACKSLASH<-0,_LEFT_BRACKET<-0,_UPPER_CASE_Z<-0,_UPPER_CASE_A<-0,_EQUALS<-0,_COLON<-0,_SLASH<-0,_DOT<-0,_PLUS<-0,_AMPERSAND<-0,_PERCENT<-0,_SPACE<-0,proxy<-1,override<-1,deprecated<-1475",
    identical: [function(a, b) {
      return a == null ? b == null : a === b;
    }, "call$2", "core__identical$closure", 4, 0, 713, 87, [], 78, [], "identical"],
    identityHashCode: [function(object) {
      return H.objectHashCode(object);
    }, "call$1", "core__identityHashCode$closure", 2, 0, 714, 23, [], "identityHashCode"],
    print: [function(object) {
      var line, t1;
      line = H.S(object);
      t1 = $.printToZone;
      if (t1 == null)
        H.printString(line);
      else
        t1.call$1(line);
    }, "call$1", "core__print$closure", 2, 0, 64, 23, [], "print"],
    _isLeadSurrogate0: [function(code) {
      return J.$and$n(code, 64512) === 55296;
    }, "call$1", "core___isLeadSurrogate$closure", 2, 0, 32, 145, [], "_core$_isLeadSurrogate"],
    _isTrailSurrogate: [function(code) {
      return J.$and$n(code, 64512) === 56320;
    }, "call$1", "core___isTrailSurrogate$closure", 2, 0, 32, 145, [], "_isTrailSurrogate"],
    _combineSurrogatePair: [function(start, end) {
      var t1, t2;
      t1 = J.$shl$n(J.$and$n(start, 1023), 10);
      t2 = J.$and$n(end, 1023);
      if (typeof t2 !== "number")
        return H.iae(t2);
      return 65536 + t1 + t2;
    }, "call$2", "core___combineSurrogatePair$closure", 4, 0, 70, 3, [], 5, [], "_core$_combineSurrogatePair"],
    _createTables: [function() {
      var tables, t1, t2, t3, b;
      tables = P.List_List$generate(22, new P._createTables_closure(), true, P.Uint8List);
      t1 = new P._createTables_build(tables);
      t2 = new P._createTables_setChars();
      t3 = new P._createTables_setRange();
      b = t1.call$2(0, 225);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 1);
      t2.call$3(b, ".", 14);
      t2.call$3(b, ":", 34);
      t2.call$3(b, "/", 3);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(14, 225);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 1);
      t2.call$3(b, ".", 15);
      t2.call$3(b, ":", 34);
      t2.call$3(b, "/", 234);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(15, 225);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 1);
      t2.call$3(b, "%", 225);
      t2.call$3(b, ":", 34);
      t2.call$3(b, "/", 9);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(1, 225);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 1);
      t2.call$3(b, ":", 34);
      t2.call$3(b, "/", 10);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(2, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 139);
      t2.call$3(b, "/", 131);
      t2.call$3(b, ".", 146);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(3, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, "/", 68);
      t2.call$3(b, ".", 18);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(4, 229);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 5);
      t3.call$3(b, "AZ", 229);
      t2.call$3(b, ":", 102);
      t2.call$3(b, "@", 68);
      t2.call$3(b, "[", 232);
      t2.call$3(b, "/", 138);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(5, 229);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 5);
      t3.call$3(b, "AZ", 229);
      t2.call$3(b, ":", 102);
      t2.call$3(b, "@", 68);
      t2.call$3(b, "/", 138);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(6, 231);
      t3.call$3(b, "19", 7);
      t2.call$3(b, "@", 68);
      t2.call$3(b, "/", 138);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(7, 231);
      t3.call$3(b, "09", 7);
      t2.call$3(b, "@", 68);
      t2.call$3(b, "/", 138);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      t2.call$3(t1.call$2(8, 8), "]", 5);
      b = t1.call$2(9, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, ".", 16);
      t2.call$3(b, "/", 234);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(16, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, ".", 17);
      t2.call$3(b, "/", 234);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(17, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, "/", 9);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(10, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, ".", 18);
      t2.call$3(b, "/", 234);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(18, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, ".", 19);
      t2.call$3(b, "/", 234);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(19, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, "/", 234);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(11, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, "/", 10);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(12, 236);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 12);
      t2.call$3(b, "?", 12);
      t2.call$3(b, "#", 205);
      b = t1.call$2(13, 237);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 13);
      t2.call$3(b, "?", 13);
      t3.call$3(t1.call$2(20, 245), "az", 21);
      b = t1.call$2(21, 245);
      t3.call$3(b, "az", 21);
      t3.call$3(b, "09", 21);
      t2.call$3(b, "+-.", 21);
      return tables;
    }, "call$0", "core___createTables$closure", 0, 0, 771, "_createTables"],
    _scan: [function(uri, start, end, state, indices) {
      var tables, t1, t2, i, t3, table, char, transition, t4;
      tables = $.$get$_scannerTables();
      for (t1 = J.getInterceptor$ax(indices), t2 = J.getInterceptor$s(uri), i = start; t3 = J.getInterceptor$n(i), t3.$lt(i, end); i = t3.$add(i, 1)) {
        if (state >>> 0 !== state || state >= tables.length)
          return H.ioore(tables, state);
        table = tables[state];
        char = t2.codeUnitAt$1(uri, i) ^ 96;
        transition = J.$index$asx(table, char > 95 ? 31 : char);
        t4 = J.getInterceptor$n(transition);
        state = t4.$and(transition, 31);
        t1.$indexSet(indices, t4.$shr(transition, 5), i);
      }
      return state;
    }, "call$5", "core___scan$closure", 10, 0, 772, 40, [], 3, [], 5, [], 82, [], 620, [], "_scan"],
    _startsWithData: [function(text, start) {
      var t1, t2;
      t1 = J.getInterceptor$ns(start);
      t2 = J.getInterceptor$s(text);
      return ((t2.codeUnitAt$1(text, t1.$add(start, 4)) ^ 58) * 3 | t2.codeUnitAt$1(text, start) ^ 100 | t2.codeUnitAt$1(text, t1.$add(start, 1)) ^ 97 | t2.codeUnitAt$1(text, t1.$add(start, 2)) ^ 116 | t2.codeUnitAt$1(text, t1.$add(start, 3)) ^ 97) >>> 0;
    }, "call$2", "core___startsWithData$closure", 4, 0, 414, 106, [], 3, [], "_startsWithData"],
    _stringOrNullLength: [function(s) {
      return s == null ? 0 : J.get$length$asx(s);
    }, "call$1", "core___stringOrNullLength$closure", 2, 0, 31, 49, [], "_stringOrNullLength"],
    Function__toMangledNames_closure: {
      "^": "Closure:12;result",
      call$2: [function(symbol, value) {
        this.result.$indexSet(0, symbol.get$__internal$_name(), value);
      }, null, null, 4, 0, 12, 419, [], 1, [], "call"]
    },
    "+ Function__toMangledNames_closure": [2],
    NoSuchMethodError_toString_closure: {
      "^": "Closure:150;_box_0,sb",
      call$2: [function(key, value) {
        var t1, t2, t3;
        t1 = this.sb;
        t2 = this._box_0;
        t1._contents += t2.comma;
        t3 = t1._contents += H.S(key.get$__internal$_name());
        t1._contents = t3 + ": ";
        t1._contents += H.S(P.Error_safeToString(value));
        t2.comma = ", ";
      }, null, null, 4, 0, 150, 6, [], 1, [], "call"]
    },
    "+ NoSuchMethodError_toString_closure": [2],
    Deprecated: {
      "^": "Object;expires<-9",
      toString$0: [function(_) {
        return "Deprecated feature. Will be removed " + H.S(this.expires);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        Deprecated$: [function(expires) {
          return new P.Deprecated(expires);
        }, null, null, 2, 0, 13, 546, [], "new Deprecated"]
      }
    },
    "+Deprecated": [1],
    _Override: {
      "^": "Object;",
      static: {
        _Override$: [function() {
          return new P._Override();
        }, null, null, 0, 0, 4, "new _Override"]
      }
    },
    "+_Override": [1],
    _Proxy0: {
      "^": "Object;",
      static: {
        _Proxy$0: [function() {
          return new P._Proxy0();
        }, null, null, 0, 0, 4, "new _Proxy"]
      }
    },
    "+_Proxy": [1],
    bool: {
      "^": "Object;",
      get$hashCode: [function(_) {
        return P.Object.prototype.get$hashCode.call(this, this);
      }, null, null, 1, 0, 11, "hashCode"],
      toString$0: [function(_) {
        return this ? "true" : "false";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        bool_bool$fromEnvironment: [function($name, defaultValue) {
          throw H.wrapException(new P.UnsupportedError("bool.fromEnvironment can only be used as a const constructor"));
        }, null, null, 2, 3, 685, 4, 13, [], 135, [], "new bool$fromEnvironment"]
      }
    },
    "+bool": [1],
    Comparable: {
      "^": "Object;$ti",
      "<>": [983],
      static: {
        Comparable$: [function($T) {
          return new P.Comparable([$T]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P.Comparable, T]};
          }, this.$receiver, "Comparable");
        }, "new Comparable"],
        Comparable_compare: [function(a, b) {
          return J.compareTo$1$ns(a, b);
        }, "call$2", "core_Comparable_compare$closure", 4, 0, 686, 87, [], 78, [], "compare"]
      }
    },
    "+Comparable": [1],
    DateTime: {
      "^": "Object;_core$_value<-0,isUtc<-8",
      $eq: [function(_, other) {
        if (other == null)
          return false;
        if (!(other instanceof P.DateTime))
          return false;
        return J.$eq$(this._core$_value, other._core$_value) && J.$eq$(this.isUtc, other.isUtc);
      }, null, "get$==", 2, 0, 24, 2, [], "=="],
      isBefore$1: [function(other) {
        return J.$lt$n(this._core$_value, other.get$_core$_value());
      }, "call$1", "get$isBefore", 2, 0, 275, 2, [], "isBefore"],
      isAfter$1: [function(other) {
        return J.$gt$n(this._core$_value, other.get$_core$_value());
      }, "call$1", "get$isAfter", 2, 0, 275, 2, [], "isAfter"],
      isAtSameMomentAs$1: [function(other) {
        return J.$eq$(this._core$_value, other.get$_core$_value());
      }, "call$1", "get$isAtSameMomentAs", 2, 0, 275, 2, [], "isAtSameMomentAs"],
      compareTo$1: [function(_, other) {
        return J.compareTo$1$ns(this._core$_value, other.get$_core$_value());
      }, "call$1", "get$compareTo", 2, 0, 1609, 2, [], "compareTo"],
      get$hashCode: [function(_) {
        var t1, t2;
        t1 = this._core$_value;
        t2 = J.getInterceptor$n(t1);
        return J.$and$n(t2.$xor(t1, t2.$shr(t1, 30)), 1073741823);
      }, null, null, 1, 0, 11, "hashCode"],
      toLocal$0: [function() {
        if (this.isUtc === true)
          return P.DateTime$_withValue(this._core$_value, false);
        return this;
      }, "call$0", "get$toLocal", 0, 0, 85, "toLocal"],
      toUtc$0: [function() {
        if (this.isUtc === true)
          return this;
        return P.DateTime$_withValue(this._core$_value, true);
      }, "call$0", "get$toUtc", 0, 0, 85, "toUtc"],
      toString$0: [function(_) {
        var y, m, d, h, min, sec, ms;
        y = P.DateTime__fourDigits(H.Primitives_getYear(this));
        m = P.DateTime__twoDigits(H.Primitives_getMonth(this));
        d = P.DateTime__twoDigits(H.Primitives_getDay(this));
        h = P.DateTime__twoDigits(H.Primitives_getHours(this));
        min = P.DateTime__twoDigits(H.Primitives_getMinutes(this));
        sec = P.DateTime__twoDigits(H.Primitives_getSeconds(this));
        ms = P.DateTime__threeDigits(H.Primitives_getMilliseconds(this));
        if (this.isUtc === true)
          return y + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms + "Z";
        else
          return y + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      toIso8601String$0: [function() {
        var y, m, d, h, min, sec, ms;
        y = H.Primitives_getYear(this) >= -9999 && H.Primitives_getYear(this) <= 9999 ? P.DateTime__fourDigits(H.Primitives_getYear(this)) : P.DateTime__sixDigits(H.Primitives_getYear(this));
        m = P.DateTime__twoDigits(H.Primitives_getMonth(this));
        d = P.DateTime__twoDigits(H.Primitives_getDay(this));
        h = P.DateTime__twoDigits(H.Primitives_getHours(this));
        min = P.DateTime__twoDigits(H.Primitives_getMinutes(this));
        sec = P.DateTime__twoDigits(H.Primitives_getSeconds(this));
        ms = P.DateTime__threeDigits(H.Primitives_getMilliseconds(this));
        if (this.isUtc === true)
          return y + "-" + m + "-" + d + "T" + h + ":" + min + ":" + sec + "." + ms + "Z";
        else
          return y + "-" + m + "-" + d + "T" + h + ":" + min + ":" + sec + "." + ms;
      }, "call$0", "get$toIso8601String", 0, 0, 7, "toIso8601String"],
      add$1: [function(_, duration) {
        return P.DateTime$_withValue(J.$add$ns(this._core$_value, duration.get$inMilliseconds()), this.isUtc);
      }, "call$1", "get$add", 2, 0, 521, 59, [], "add"],
      subtract$1: [function(duration) {
        return P.DateTime$_withValue(J.$sub$n(this._core$_value, duration.get$inMilliseconds()), this.isUtc);
      }, "call$1", "get$subtract", 2, 0, 521, 59, [], "subtract"],
      difference$1: [function(other) {
        return P.Duration$(0, 0, 0, J.$sub$n(this._core$_value, other.get$_core$_value()), 0, 0);
      }, "call$1", "get$difference", 2, 0, 1614, 2, [], "difference"],
      get$millisecondsSinceEpoch: [function() {
        return this._core$_value;
      }, null, null, 1, 0, 11, "millisecondsSinceEpoch"],
      get$microsecondsSinceEpoch: [function() {
        var t1 = this._core$_value;
        if (typeof t1 !== "number")
          return H.iae(t1);
        return 1000 * t1;
      }, null, null, 1, 0, 11, "microsecondsSinceEpoch"],
      get$timeZoneName: [function() {
        if (this.isUtc === true)
          return "UTC";
        return H.Primitives_getTimeZoneName(this);
      }, null, null, 1, 0, 7, "timeZoneName"],
      get$timeZoneOffset: [function() {
        if (this.isUtc === true)
          return P.Duration$(0, 0, 0, 0, 0, 0);
        return P.Duration$(0, 0, 0, 0, -H.Primitives_lazyAsJsDate(this).getTimezoneOffset(), 0);
      }, null, null, 1, 0, 83, "timeZoneOffset"],
      get$year: [function() {
        return H.Primitives_getYear(this);
      }, null, null, 1, 0, 11, "year"],
      get$month: [function() {
        return H.Primitives_getMonth(this);
      }, null, null, 1, 0, 11, "month"],
      get$day: [function() {
        return H.Primitives_getDay(this);
      }, null, null, 1, 0, 11, "day"],
      get$hour: [function() {
        return H.Primitives_getHours(this);
      }, null, null, 1, 0, 11, "hour"],
      get$minute: [function() {
        return H.Primitives_getMinutes(this);
      }, null, null, 1, 0, 11, "minute"],
      get$second: [function() {
        return H.Primitives_getSeconds(this);
      }, null, null, 1, 0, 11, "second"],
      get$millisecond: [function() {
        return H.Primitives_getMilliseconds(this);
      }, null, null, 1, 0, 11, "millisecond"],
      get$microsecond: [function() {
        return 0;
      }, null, null, 1, 0, 11, "microsecond"],
      get$weekday: [function() {
        return C.JSInt_methods.$mod((this.isUtc === true ? H.Primitives_lazyAsJsDate(this).getUTCDay() + 0 : H.Primitives_lazyAsJsDate(this).getDay() + 0) + 6, 7) + 1;
      }, null, null, 1, 0, 11, "weekday"],
      DateTime$_withValue$2$isUtc: function(_value, isUtc) {
        var t1, t2;
        t1 = this._core$_value;
        t2 = J.getInterceptor$n(t1);
        if (!J.$gt$n(t2.abs$0(t1), 864e13)) {
          J.$eq$(t2.abs$0(t1), 864e13);
          t1 = false;
        } else
          t1 = true;
        if (t1)
          throw H.wrapException(P.ArgumentError$(this.get$millisecondsSinceEpoch()));
        t1 = this.isUtc;
        if (t1 == null)
          throw H.wrapException(P.ArgumentError$(t1));
      },
      $isComparable: 1,
      $asComparable: function() {
        return [P.DateTime];
      },
      static: {
        "^": "DateTime_MONDAY<-0,DateTime_TUESDAY<-0,DateTime_WEDNESDAY<-0,DateTime_THURSDAY<-0,DateTime_FRIDAY<-0,DateTime_SATURDAY<-0,DateTime_SUNDAY<-0,DateTime_DAYS_PER_WEEK<-0,DateTime_JANUARY<-0,DateTime_FEBRUARY<-0,DateTime_MARCH<-0,DateTime_APRIL<-0,DateTime_MAY<-0,DateTime_JUNE<-0,DateTime_JULY<-0,DateTime_AUGUST<-0,DateTime_SEPTEMBER<-0,DateTime_OCTOBER<-0,DateTime_NOVEMBER<-0,DateTime_DECEMBER<-0,DateTime_MONTHS_PER_YEAR<-0,DateTime__MAX_MILLISECONDS_SINCE_EPOCH<-0",
        DateTime__microsecondInRoundedMilliseconds: [function(microsecond) {
          return J.round$0$n(J.$div$n(microsecond, 1000));
        }, "call$1", "core_DateTime__microsecondInRoundedMilliseconds$closure", 2, 0, 16, 193, [], "_microsecondInRoundedMilliseconds"],
        DateTime$: [function(year, month, day, hour, minute, second, millisecond, microsecond) {
          return new P.DateTime(H.checkInt(H.Primitives_valueFromDecomposedDate(year, month, day, hour, minute, second, J.$add$ns(millisecond, J.round$0$n(J.$div$n(microsecond, 1000))), false)), false);
        }, null, null, 2, 14, 404, 195, 195, 7, 7, 7, 7, 7, 288, [], 196, [], 289, [], 290, [], 291, [], 292, [], 293, [], 193, [], "new DateTime"],
        DateTime$utc: [function(year, month, day, hour, minute, second, millisecond, microsecond) {
          return new P.DateTime(H.checkInt(H.Primitives_valueFromDecomposedDate(year, month, day, hour, minute, second, J.$add$ns(millisecond, J.round$0$n(J.$div$n(microsecond, 1000))), true)), true);
        }, null, null, 2, 14, 404, 195, 195, 7, 7, 7, 7, 7, 288, [], 196, [], 289, [], 290, [], 291, [], 292, [], 293, [], 193, [], "new DateTime$utc"],
        DateTime$now: [function() {
          return new P.DateTime(Date.now(), false);
        }, null, null, 0, 0, 4, "new DateTime$now"],
        DateTime_parse: [function(formattedString) {
          var match, t1, t2, years, month, day, hour, minute, second, milliAndMicroseconds, t3, millisecond, microsecond, sign, hourDifference, minuteDifference, isUtc, value;
          match = P.RegExp_RegExp("^([+-]?\\d{4,6})-?(\\d\\d)-?(\\d\\d)(?:[ T](\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:\\.(\\d{1,6}))?)?)?( ?[zZ]| ?([-+])(\\d\\d)(?::?(\\d\\d))?)?)?$", true, false).firstMatch$1(formattedString);
          if (match != null) {
            t1 = new P.DateTime_parse_parseIntOrZero();
            t2 = match._match;
            if (1 >= t2.length)
              return H.ioore(t2, 1);
            years = H.Primitives_parseInt(t2[1], null, null);
            if (2 >= t2.length)
              return H.ioore(t2, 2);
            month = H.Primitives_parseInt(t2[2], null, null);
            if (3 >= t2.length)
              return H.ioore(t2, 3);
            day = H.Primitives_parseInt(t2[3], null, null);
            if (4 >= t2.length)
              return H.ioore(t2, 4);
            hour = t1.call$1(t2[4]);
            if (5 >= t2.length)
              return H.ioore(t2, 5);
            minute = t1.call$1(t2[5]);
            if (6 >= t2.length)
              return H.ioore(t2, 6);
            second = t1.call$1(t2[6]);
            if (7 >= t2.length)
              return H.ioore(t2, 7);
            milliAndMicroseconds = new P.DateTime_parse_parseMilliAndMicroseconds().call$1(t2[7]);
            t3 = J.getInterceptor$n(milliAndMicroseconds);
            millisecond = t3.$tdiv(milliAndMicroseconds, 1000);
            microsecond = t3.remainder$1(milliAndMicroseconds, 1000);
            t3 = t2.length;
            if (8 >= t3)
              return H.ioore(t2, 8);
            if (t2[8] != null) {
              if (9 >= t3)
                return H.ioore(t2, 9);
              t3 = t2[9];
              if (t3 != null) {
                sign = J.$eq$(t3, "-") ? -1 : 1;
                if (10 >= t2.length)
                  return H.ioore(t2, 10);
                hourDifference = H.Primitives_parseInt(t2[10], null, null);
                if (11 >= t2.length)
                  return H.ioore(t2, 11);
                minuteDifference = t1.call$1(t2[11]);
                if (typeof hourDifference !== "number")
                  return H.iae(hourDifference);
                minuteDifference = J.$add$ns(minuteDifference, 60 * hourDifference);
                if (typeof minuteDifference !== "number")
                  return H.iae(minuteDifference);
                minute = J.$sub$n(minute, sign * minuteDifference);
              }
              isUtc = true;
            } else
              isUtc = false;
            value = H.Primitives_valueFromDecomposedDate(years, month, day, hour, minute, second, millisecond + C.JSDouble_methods.round$0(microsecond / 1000), isUtc);
            if (value == null)
              throw H.wrapException(new P.FormatException("Time out of range", formattedString, null));
            return P.DateTime$_withValue(value, isUtc);
          } else
            throw H.wrapException(new P.FormatException("Invalid date format", formattedString, null));
        }, "call$1", "core_DateTime_parse$closure", 2, 0, 246, 705, [], "parse"],
        DateTime$fromMillisecondsSinceEpoch: [function(millisecondsSinceEpoch, isUtc) {
          var t1, t2;
          if (typeof millisecondsSinceEpoch !== "number")
            return H.iae(millisecondsSinceEpoch);
          t1 = 0 + millisecondsSinceEpoch;
          t2 = new P.DateTime(t1, isUtc);
          t2.DateTime$_withValue$2$isUtc(t1, isUtc);
          return t2;
        }, null, null, 2, 3, 245, 4, 704, [], 199, [], "new DateTime$fromMillisecondsSinceEpoch"],
        DateTime$fromMicrosecondsSinceEpoch: [function(microsecondsSinceEpoch, isUtc) {
          var t1, t2;
          t1 = J.round$0$n(J.$div$n(microsecondsSinceEpoch, 1000));
          t2 = new P.DateTime(t1, isUtc);
          t2.DateTime$_withValue$2$isUtc(t1, isUtc);
          return t2;
        }, null, null, 2, 3, 245, 4, 703, [], 199, [], "new DateTime$fromMicrosecondsSinceEpoch"],
        DateTime$_withValue: [function(_value, isUtc) {
          var t1 = new P.DateTime(_value, isUtc);
          t1.DateTime$_withValue$2$isUtc(_value, isUtc);
          return t1;
        }, null, null, 2, 3, 245, 0, 174, [], 199, [], "new DateTime$_withValue"],
        DateTime__fourDigits: [function(n) {
          var t1, absN, sign;
          t1 = J.getInterceptor$n(n);
          absN = t1.abs$0(n);
          sign = t1.$lt(n, 0) ? "-" : "";
          t1 = J.getInterceptor$n(absN);
          if (t1.$ge(absN, 1000))
            return H.S(n);
          if (t1.$ge(absN, 100))
            return sign + "0" + H.S(absN);
          if (t1.$ge(absN, 10))
            return sign + "00" + H.S(absN);
          return sign + "000" + H.S(absN);
        }, "call$1", "core_DateTime__fourDigits$closure", 2, 0, 25, 89, [], "_fourDigits"],
        DateTime__sixDigits: [function(n) {
          var t1, absN, sign;
          t1 = J.getInterceptor$n(n);
          absN = t1.abs$0(n);
          sign = t1.$lt(n, 0) ? "-" : "+";
          if (J.$ge$n(absN, 100000))
            return sign + H.S(absN);
          return sign + "0" + H.S(absN);
        }, "call$1", "core_DateTime__sixDigits$closure", 2, 0, 25, 89, [], "_sixDigits"],
        DateTime__threeDigits: [function(n) {
          var t1 = J.getInterceptor$n(n);
          if (t1.$ge(n, 100))
            return H.S(n);
          if (t1.$ge(n, 10))
            return "0" + H.S(n);
          return "00" + H.S(n);
        }, "call$1", "core_DateTime__threeDigits$closure", 2, 0, 25, 89, [], "_threeDigits"],
        DateTime__twoDigits: [function(n) {
          if (J.$ge$n(n, 10))
            return H.S(n);
          return "0" + H.S(n);
        }, "call$1", "core_DateTime__twoDigits$closure", 2, 0, 25, 89, [], "_twoDigits"],
        DateTime$_internal: [function(year, month, day, hour, minute, second, millisecond, microsecond, isUtc) {
          var t1 = typeof isUtc === "boolean" ? isUtc : H.throwExpression(P.ArgumentError$value(isUtc, "isUtc", null));
          return new P.DateTime(H.checkInt(H.Primitives_valueFromDecomposedDate(year, month, day, hour, minute, second, J.$add$ns(millisecond, J.round$0$n(J.$div$n(microsecond, 1000))), isUtc)), t1);
        }, null, null, 18, 0, 690, 288, [], 196, [], 289, [], 290, [], 291, [], 292, [], 293, [], 193, [], 199, [], "new DateTime$_internal"],
        DateTime$_now: [function() {
          return new P.DateTime(Date.now(), false);
        }, null, null, 0, 0, 4, "new DateTime$_now"],
        DateTime__brokenDownDateToValue: [function(year, month, day, hour, minute, second, millisecond, microsecond, isUtc) {
          return H.Primitives_valueFromDecomposedDate(year, month, day, hour, minute, second, J.$add$ns(millisecond, J.round$0$n(J.$div$n(microsecond, 1000))), isUtc);
        }, "call$9", "core_DateTime__brokenDownDateToValue$closure", 18, 0, 691, 288, [], 196, [], 289, [], 290, [], 291, [], 292, [], 293, [], 193, [], 199, [], "_brokenDownDateToValue"]
      }
    },
    "+DateTime": [1, 1449],
    DateTime_parse_parseIntOrZero: {
      "^": "Closure:31;",
      call$1: [function(matched) {
        if (matched == null)
          return 0;
        return H.Primitives_parseInt(matched, null, null);
      }, null, null, 2, 0, 31, 617, [], "call"]
    },
    "+ DateTime_parse_parseIntOrZero": [2],
    DateTime_parse_parseMilliAndMicroseconds: {
      "^": "Closure:31;",
      call$1: [function(matched) {
        var t1, result, i, t2;
        if (matched == null)
          return 0;
        t1 = J.getInterceptor$asx(matched);
        t1.get$length(matched);
        for (result = 0, i = 0; i < 6; ++i) {
          result *= 10;
          t2 = t1.get$length(matched);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (i < t2)
            result += t1.codeUnitAt$1(matched, i) ^ 48;
        }
        return result;
      }, null, null, 2, 0, 31, 617, [], "call"]
    },
    "+ DateTime_parse_parseMilliAndMicroseconds": [2],
    double: {
      "^": "num;",
      $isComparable: 1,
      $asComparable: function() {
        return [P.num];
      },
      static: {
        "^": "double_NAN<-23,double_INFINITY<-23,double_NEGATIVE_INFINITY<-23,double_MIN_POSITIVE<-23,double_MAX_FINITE<-23",
        double$: [function() {
          return new P.double();
        }, null, null, 0, 0, 52, "new double"],
        double_parse: [function(source, onError) {
          return H.Primitives_parseDouble(source, onError);
        }, function(source) {
          return P.double_parse(source, null);
        }, "call$2", "call$1", "core_double_parse$closure", 2, 2, 692, 0, 19, [], 20, [], "parse"]
      }
    },
    "+double": [46],
    Duration: {
      "^": "Object;_duration<-0",
      $add: [function(_, other) {
        return new P.Duration(J.$add$ns(this._duration, other.get$_duration()));
      }, null, "get$+", 2, 0, 522, 2, [], "+"],
      $sub: [function(_, other) {
        return new P.Duration(J.$sub$n(this._duration, other.get$_duration()));
      }, null, "get$-", 2, 0, 522, 2, [], "-"],
      $mul: [function(_, factor) {
        return new P.Duration(J.round$0$n(J.$mul$ns(this._duration, factor)));
      }, null, "get$*", 2, 0, 1623, 616, [], "*"],
      $tdiv: [function(_, quotient) {
        if (J.$eq$(quotient, 0))
          throw H.wrapException(new P.IntegerDivisionByZeroException());
        return new P.Duration(J.$tdiv$n(this._duration, quotient));
      }, null, "get$~/", 2, 0, 1641, 651, [], "~/"],
      $lt: [function(_, other) {
        return J.$lt$n(this._duration, other.get$_duration());
      }, null, "get$<", 2, 0, 197, 2, [], "<"],
      $gt: [function(_, other) {
        return J.$gt$n(this._duration, other.get$_duration());
      }, null, "get$>", 2, 0, 197, 2, [], ">"],
      $le: [function(_, other) {
        return J.$le$n(this._duration, other.get$_duration());
      }, null, "get$<=", 2, 0, 197, 2, [], "<="],
      $ge: [function(_, other) {
        return J.$ge$n(this._duration, other.get$_duration());
      }, null, "get$>=", 2, 0, 197, 2, [], ">="],
      get$inDays: [function() {
        return J.$tdiv$n(this._duration, 864e8);
      }, null, null, 1, 0, 11, "inDays"],
      get$inHours: [function() {
        return J.$tdiv$n(this._duration, 3600000000);
      }, null, null, 1, 0, 11, "inHours"],
      get$inMinutes: [function() {
        return J.$tdiv$n(this._duration, 60000000);
      }, null, null, 1, 0, 11, "inMinutes"],
      get$inSeconds: [function() {
        return J.$tdiv$n(this._duration, 1000000);
      }, null, null, 1, 0, 11, "inSeconds"],
      get$inMilliseconds: [function() {
        return J.$tdiv$n(this._duration, 1000);
      }, null, null, 1, 0, 11, "inMilliseconds"],
      get$inMicroseconds: [function() {
        return this._duration;
      }, null, null, 1, 0, 11, "inMicroseconds"],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        if (!(other instanceof P.Duration))
          return false;
        return J.$eq$(this._duration, other._duration);
      }, null, "get$==", 2, 0, 24, 2, [], "=="],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this._duration);
      }, null, null, 1, 0, 11, "hashCode"],
      compareTo$1: [function(_, other) {
        return J.compareTo$1$ns(this._duration, other.get$_duration());
      }, "call$1", "get$compareTo", 2, 0, 1645, 2, [], "compareTo"],
      toString$0: [function(_) {
        var t1, t2, t3, twoDigitMinutes, twoDigitSeconds, sixDigitUs;
        t1 = new P.Duration_toString_twoDigits();
        t2 = this._duration;
        t3 = J.getInterceptor$n(t2);
        if (t3.$lt(t2, 0)) {
          if (typeof t2 !== "number")
            return H.iae(t2);
          return "-" + new P.Duration(0 - t2).toString$0(0);
        }
        twoDigitMinutes = t1.call$1(J.remainder$1$n(t3.$tdiv(t2, 60000000), 60));
        twoDigitSeconds = t1.call$1(J.remainder$1$n(t3.$tdiv(t2, 1000000), 60));
        sixDigitUs = new P.Duration_toString_sixDigits().call$1(t3.remainder$1(t2, 1000000));
        return H.S(t3.$tdiv(t2, 3600000000)) + ":" + H.S(twoDigitMinutes) + ":" + H.S(twoDigitSeconds) + "." + H.S(sixDigitUs);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      get$isNegative: [function(_) {
        return J.$lt$n(this._duration, 0);
      }, null, null, 1, 0, 5, "isNegative"],
      abs$0: [function(_) {
        return new P.Duration(J.abs$0$n(this._duration));
      }, "call$0", "get$abs", 0, 0, 83, "abs"],
      $negate: [function(_) {
        var t1 = this._duration;
        if (typeof t1 !== "number")
          return H.iae(t1);
        return new P.Duration(0 - t1);
      }, null, "get$unary-", 0, 0, 83, "unary-"],
      $isComparable: 1,
      $asComparable: function() {
        return [P.Duration];
      },
      static: {
        "^": "Duration_MICROSECONDS_PER_MILLISECOND<-0,Duration_MILLISECONDS_PER_SECOND<-0,Duration_SECONDS_PER_MINUTE<-0,Duration_MINUTES_PER_HOUR<-0,Duration_HOURS_PER_DAY<-0,Duration_MICROSECONDS_PER_SECOND<-0,Duration_MICROSECONDS_PER_MINUTE<-0,Duration_MICROSECONDS_PER_HOUR<-0,Duration_MICROSECONDS_PER_DAY<-0,Duration_MILLISECONDS_PER_MINUTE<-0,Duration_MILLISECONDS_PER_HOUR<-0,Duration_MILLISECONDS_PER_DAY<-0,Duration_SECONDS_PER_HOUR<-0,Duration_SECONDS_PER_DAY<-0,Duration_MINUTES_PER_DAY<-0,Duration_ZERO<-65",
        Duration$: [function(days, hours, microseconds, milliseconds, minutes, seconds) {
          if (typeof days !== "number")
            return H.iae(days);
          if (typeof hours !== "number")
            return H.iae(hours);
          if (typeof minutes !== "number")
            return H.iae(minutes);
          if (typeof seconds !== "number")
            return H.iae(seconds);
          if (typeof milliseconds !== "number")
            return H.iae(milliseconds);
          if (typeof microseconds !== "number")
            return H.iae(microseconds);
          return new P.Duration(864e8 * days + 3600000000 * hours + 60000000 * minutes + 1000000 * seconds + 1000 * milliseconds + microseconds);
        }, null, null, 0, 13, 693, 7, 7, 7, 7, 7, 7, 702, [], 701, [], 700, [], 699, [], 693, [], 692, [], "new Duration"],
        Duration$_microseconds: [function(_duration) {
          return new P.Duration(_duration);
        }, null, null, 2, 0, 22, 689, [], "new Duration$_microseconds"]
      }
    },
    "+Duration": [1, 1450],
    Duration_toString_sixDigits: {
      "^": "Closure:25;",
      call$1: [function(n) {
        if (n >= 100000)
          return H.S(n);
        if (n >= 10000)
          return "0" + H.S(n);
        if (n >= 1000)
          return "00" + H.S(n);
        if (n >= 100)
          return "000" + H.S(n);
        if (n >= 10)
          return "0000" + H.S(n);
        return "00000" + H.S(n);
      }, null, null, 2, 0, 25, 89, [], "call"]
    },
    "+ Duration_toString_sixDigits": [2],
    Duration_toString_twoDigits: {
      "^": "Closure:25;",
      call$1: [function(n) {
        if (n >= 10)
          return H.S(n);
        return "0" + H.S(n);
      }, null, null, 2, 0, 25, 89, [], "call"]
    },
    "+ Duration_toString_twoDigits": [2],
    Error: {
      "^": "Object;",
      get$stackTrace: [function() {
        return H.getTraceFromException(this.$thrownJsError);
      }, null, null, 1, 0, 198, "stackTrace"],
      static: {
        Error$: [function() {
          return new P.Error();
        }, null, null, 0, 0, 4, "new Error"],
        Error_safeToString: [function(object) {
          if (typeof object === "number" || typeof object === "boolean" || null == object)
            return J.toString$0$(object);
          if (typeof object === "string")
            return JSON.stringify(object);
          return P.Error__objectToString(object);
        }, "call$1", "core_Error_safeToString$closure", 2, 0, 283, 23, [], "safeToString"],
        Error__stringToSafeString: [function(string) {
          return JSON.stringify(string);
        }, "call$1", "core_Error__stringToSafeString$closure", 2, 0, 28, 39, [], "_stringToSafeString"],
        Error__objectToString: [function(object) {
          var t1 = J.getInterceptor(object);
          if (!!t1.$isClosure)
            return t1.toString$0(object);
          return H.Primitives_objectToHumanReadableString(object);
        }, "call$1", "core_Error__objectToString$closure", 2, 0, 283, 23, [], "_objectToString"]
      }
    },
    "+Error": [1],
    AssertionError: {
      "^": "Error;message<-1",
      toString$0: [function(_) {
        return "Assertion failed";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        AssertionError$: [function(message) {
          return new P.AssertionError(message);
        }, null, null, 0, 2, 244, 0, 17, [], "new AssertionError"]
      }
    },
    "+AssertionError": [34],
    TypeError: {
      "^": "AssertionError;message-1",
      static: {
        TypeError$: [function() {
          return new P.TypeError(null);
        }, null, null, 0, 0, 695, "new TypeError"]
      }
    },
    "+TypeError": [1451],
    CastError: {
      "^": "Error;",
      static: {
        CastError$: [function() {
          return new P.CastError();
        }, null, null, 0, 0, 696, "new CastError"]
      }
    },
    "+CastError": [34],
    NullThrownError: {
      "^": "Error;",
      toString$0: [function(_) {
        return "Throw of null.";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        NullThrownError$: [function() {
          return new P.NullThrownError();
        }, null, null, 0, 0, 697, "new NullThrownError"]
      }
    },
    "+NullThrownError": [34],
    ArgumentError: {
      "^": "Error;_hasValue<-8,invalidValue<-10,name<-9,message<-10",
      get$_errorName: [function() {
        return "Invalid argument" + (this._hasValue !== true ? "(s)" : "");
      }, null, null, 1, 0, 7, "_errorName"],
      get$_errorExplanation: [function() {
        return "";
      }, null, null, 1, 0, 7, "_errorExplanation"],
      toString$0: [function(_) {
        var t1, nameString, message, prefix, explanation, errorValue;
        t1 = this.name;
        nameString = t1 != null ? " (" + H.S(t1) + ")" : "";
        t1 = this.message;
        message = t1 == null ? "" : ": " + H.S(t1);
        prefix = this.get$_errorName() + nameString + message;
        if (this._hasValue !== true)
          return prefix;
        explanation = this.get$_errorExplanation();
        errorValue = P.Error_safeToString(this.invalidValue);
        return prefix + explanation + ": " + H.S(errorValue);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        ArgumentError$: [function(message) {
          return new P.ArgumentError(false, null, null, message);
        }, null, null, 0, 2, 406, 0, 17, [], "new ArgumentError"],
        ArgumentError$value: [function(value, $name, message) {
          return new P.ArgumentError(true, value, $name, message);
        }, null, null, 2, 4, 699, 0, 0, 1, [], 13, [], 17, [], "new ArgumentError$value"],
        ArgumentError$notNull: [function($name) {
          return new P.ArgumentError(false, null, $name, "Must not be null");
        }, null, null, 0, 2, 167, 0, 13, [], "new ArgumentError$notNull"]
      }
    },
    "+ArgumentError": [34],
    RangeError: {
      "^": "ArgumentError;start<-46,end<-46,_hasValue-8,invalidValue-10,name-9,message-10",
      get$_errorName: [function() {
        return "RangeError";
      }, null, null, 1, 0, 7, "_errorName"],
      get$_errorExplanation: [function() {
        var t1, explanation, t2, t3;
        t1 = this.start;
        if (t1 == null) {
          t1 = this.end;
          explanation = t1 != null ? ": Not less than or equal to " + H.S(t1) : "";
        } else {
          t2 = this.end;
          if (t2 == null)
            explanation = ": Not greater than or equal to " + H.S(t1);
          else {
            t3 = J.getInterceptor$n(t2);
            if (t3.$gt(t2, t1))
              explanation = ": Not in range " + H.S(t1) + ".." + H.S(t2) + ", inclusive";
            else
              explanation = t3.$lt(t2, t1) ? ": Valid value range is empty" : ": Only valid value is " + H.S(t1);
          }
        }
        return explanation;
      }, null, null, 1, 0, 7, "_errorExplanation"],
      start$0: function() {
        return this.start.call$0();
      },
      start$2$arguments: function(arg0, arg1) {
        return this.start.call$2$arguments(arg0, arg1);
      },
      static: {
        RangeError$: [function(message) {
          return new P.RangeError(null, null, false, null, null, message);
        }, null, null, 2, 0, 3, 17, [], "new RangeError"],
        RangeError$value: [function(value, $name, message) {
          return new P.RangeError(null, null, true, value, $name, message != null ? message : "Value not in range");
        }, null, null, 2, 4, 701, 0, 0, 1, [], 13, [], 17, [], "new RangeError$value"],
        RangeError$range: [function(invalidValue, minValue, maxValue, $name, message) {
          return new P.RangeError(minValue, maxValue, true, invalidValue, $name, message != null ? message : "Invalid value");
        }, null, null, 6, 4, 702, 0, 0, 567, [], 568, [], 569, [], 13, [], 17, [], "new RangeError$range"],
        RangeError_RangeError$index: [function(index, indexable, $name, message, $length) {
          return P.IndexError$(index, indexable, $name, message, $length);
        }, null, null, 4, 6, 703, 0, 0, 0, 14, [], 380, [], 13, [], 17, [], 15, [], "new RangeError$index"],
        RangeError_checkValueInInterval: [function(value, minValue, maxValue, $name, message) {
          var t1 = J.getInterceptor$n(value);
          if (t1.$lt(value, minValue) || t1.$gt(value, maxValue))
            throw H.wrapException(P.RangeError$range(value, minValue, maxValue, $name, message));
        }, function(value, minValue, maxValue) {
          return P.RangeError_checkValueInInterval(value, minValue, maxValue, null, null);
        }, function(value, minValue, maxValue, $name) {
          return P.RangeError_checkValueInInterval(value, minValue, maxValue, $name, null);
        }, "call$5", "call$3", "call$4", "core_RangeError_checkValueInInterval$closure", 6, 4, 704, 0, 0, 1, [], 568, [], 569, [], 13, [], 17, [], "checkValueInInterval"],
        RangeError_checkValidIndex: [function(index, indexable, $name, $length, message) {
          var t1;
          if ($length == null)
            $length = J.get$length$asx(indexable);
          if (typeof index !== "number")
            return H.iae(index);
          if (!(0 > index)) {
            if (typeof $length !== "number")
              return H.iae($length);
            t1 = index >= $length;
          } else
            t1 = true;
          if (t1)
            throw H.wrapException(P.IndexError$(index, indexable, $name == null ? "index" : $name, message, $length));
        }, function(index, indexable) {
          return P.RangeError_checkValidIndex(index, indexable, null, null, null);
        }, function(index, indexable, $name) {
          return P.RangeError_checkValidIndex(index, indexable, $name, null, null);
        }, function(index, indexable, $name, $length) {
          return P.RangeError_checkValidIndex(index, indexable, $name, $length, null);
        }, "call$5", "call$2", "call$3", "call$4", "core_RangeError_checkValidIndex$closure", 4, 6, 705, 0, 0, 0, 14, [], 380, [], 13, [], 15, [], 17, [], "checkValidIndex"],
        RangeError_checkValidRange: [function(start, end, $length, startName, endName, message) {
          var t1;
          if (typeof start !== "number")
            return H.iae(start);
          if (!(0 > start)) {
            if (typeof $length !== "number")
              return H.iae($length);
            t1 = start > $length;
          } else
            t1 = true;
          if (t1)
            throw H.wrapException(P.RangeError$range(start, 0, $length, startName == null ? "start" : startName, message));
          if (end != null) {
            if (typeof end !== "number")
              return H.iae(end);
            if (!(start > end)) {
              if (typeof $length !== "number")
                return H.iae($length);
              t1 = end > $length;
            } else
              t1 = true;
            if (t1)
              throw H.wrapException(P.RangeError$range(end, start, $length, endName == null ? "end" : endName, message));
            return end;
          }
          return $length;
        }, function(start, end, $length) {
          return P.RangeError_checkValidRange(start, end, $length, null, null, null);
        }, function(start, end, $length, startName) {
          return P.RangeError_checkValidRange(start, end, $length, startName, null, null);
        }, function(start, end, $length, startName, endName) {
          return P.RangeError_checkValidRange(start, end, $length, startName, endName, null);
        }, "call$6", "call$3", "call$4", "call$5", "core_RangeError_checkValidRange$closure", 6, 6, 706, 0, 0, 0, 3, [], 5, [], 15, [], 688, [], 683, [], 17, [], "checkValidRange"],
        RangeError_checkNotNegative: [function(value, $name, message) {
          if (J.$lt$n(value, 0))
            throw H.wrapException(P.RangeError$range(value, 0, null, $name, message));
        }, function(value) {
          return P.RangeError_checkNotNegative(value, null, null);
        }, function(value, $name) {
          return P.RangeError_checkNotNegative(value, $name, null);
        }, "call$3", "call$1", "call$2", "core_RangeError_checkNotNegative$closure", 2, 4, 707, 0, 0, 1, [], 13, [], 17, [], "checkNotNegative"]
      }
    },
    "+RangeError": [479],
    IndexError: {
      "^": "ArgumentError;indexable<-10,length>-0,_hasValue-8,invalidValue-10,name-9,message-10",
      get$start: [function() {
        return 0;
      }, null, null, 1, 0, 11, "start"],
      get$end: [function() {
        return J.$sub$n(this.length, 1);
      }, null, null, 1, 0, 11, "end"],
      get$_errorName: [function() {
        return "RangeError";
      }, null, null, 1, 0, 7, "_errorName"],
      get$_errorExplanation: [function() {
        if (J.$lt$n(this.invalidValue, 0))
          return ": index must not be negative";
        var t1 = this.length;
        if (J.$eq$(t1, 0))
          return ": no indices are valid";
        return ": index should be less than " + H.S(t1);
      }, null, null, 1, 0, 7, "_errorExplanation"],
      length$0: function($receiver) {
        return this.length.call$0();
      },
      start$0: function() {
        return this.get$start().call$0();
      },
      start$2$arguments: function(arg0, arg1) {
        return this.get$start().call$2$arguments(arg0, arg1);
      },
      static: {
        IndexError$: [function(invalidValue, indexable, $name, message, $length) {
          var t1 = $length != null ? $length : J.get$length$asx(indexable);
          return new P.IndexError(indexable, t1, true, invalidValue, $name, message != null ? message : "Index out of range");
        }, null, null, 4, 6, 708, 0, 0, 0, 567, [], 380, [], 13, [], 17, [], 15, [], "new IndexError"]
      }
    },
    "+IndexError": [479, 1453],
    FallThroughError: {
      "^": "Error;",
      toString$0: [function(_) {
        return this.super$Object$toString(0);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        FallThroughError$: [function() {
          return new P.FallThroughError();
        }, null, null, 0, 0, 4, "new FallThroughError"]
      }
    },
    "+FallThroughError": [34],
    AbstractClassInstantiationError: {
      "^": "Error;_className<-9",
      toString$0: [function(_) {
        return "Cannot instantiate abstract class: '" + H.S(this._className) + "'";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        AbstractClassInstantiationError$: [function(className) {
          return new P.AbstractClassInstantiationError(className);
        }, null, null, 2, 0, 13, 682, [], "new AbstractClassInstantiationError"]
      }
    },
    "+AbstractClassInstantiationError": [34],
    NoSuchMethodError: {
      "^": "Error;_core$_receiver<-1,_memberName<-1454,_core$_arguments<-50,_namedArguments<-1455,_existingArgumentNames<-50",
      toString$0: [function(_) {
        var t1, sb, t2, argument, memberName, receiverText, actualParameters, formalParameters;
        t1 = {};
        sb = new P.StringBuffer("");
        t1.comma = "";
        t2 = this._core$_arguments;
        if (t2 != null)
          for (t2 = J.get$iterator$ax(t2); t2.moveNext$0();) {
            argument = t2.get$current();
            sb._contents += t1.comma;
            sb._contents += H.S(P.Error_safeToString(argument));
            t1.comma = ", ";
          }
        t2 = this._namedArguments;
        if (t2 != null)
          J.forEach$1$ax(t2, new P.NoSuchMethodError_toString_closure(t1, sb));
        memberName = this._memberName.get$__internal$_name();
        receiverText = P.Error_safeToString(this._core$_receiver);
        actualParameters = sb.toString$0(0);
        t1 = this._existingArgumentNames;
        if (t1 == null)
          return "NoSuchMethodError: method not found: '" + H.S(memberName) + "'\nReceiver: " + H.S(receiverText) + "\nArguments: [" + actualParameters + "]";
        else {
          formalParameters = J.join$1$ax(t1, ", ");
          return "NoSuchMethodError: incorrect number of arguments passed to method named '" + H.S(memberName) + "'\nReceiver: " + H.S(receiverText) + "\nTried calling: " + H.S(memberName) + "(" + actualParameters + ")\nFound: " + H.S(memberName) + "(" + H.S(formalParameters) + ")";
        }
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        NoSuchMethodError$: [function(receiver, memberName, positionalArguments, namedArguments, existingArgumentNames) {
          return new P.NoSuchMethodError(receiver, memberName, positionalArguments, namedArguments, existingArgumentNames);
        }, null, null, 8, 2, 709, 0, 681, [], 146, [], 77, [], 74, [], 680, [], "new NoSuchMethodError"]
      }
    },
    "+NoSuchMethodError": [34],
    UnsupportedError: {
      "^": "Error;message<-9",
      toString$0: [function(_) {
        return "Unsupported operation: " + H.S(this.message);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        UnsupportedError$: [function(message) {
          return new P.UnsupportedError(message);
        }, null, null, 2, 0, 13, 17, [], "new UnsupportedError"]
      }
    },
    "+UnsupportedError": [34],
    UnimplementedError: {
      "^": "Error;message<-9",
      toString$0: [function(_) {
        var t1 = this.message;
        return t1 != null ? "UnimplementedError: " + H.S(t1) : "UnimplementedError";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        UnimplementedError$: [function(message) {
          return new P.UnimplementedError(message);
        }, null, null, 0, 2, 167, 0, 17, [], "new UnimplementedError"]
      }
    },
    "+UnimplementedError": [34, 1456],
    StateError: {
      "^": "Error;message<-9",
      toString$0: [function(_) {
        return "Bad state: " + H.S(this.message);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        StateError$: [function(message) {
          return new P.StateError(message);
        }, null, null, 2, 0, 13, 17, [], "new StateError"]
      }
    },
    "+StateError": [34],
    ConcurrentModificationError: {
      "^": "Error;modifiedObject<-1",
      toString$0: [function(_) {
        var t1 = this.modifiedObject;
        if (t1 == null)
          return "Concurrent modification during iteration.";
        return "Concurrent modification during iteration: " + H.S(P.Error_safeToString(t1)) + ".";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        ConcurrentModificationError$: [function(modifiedObject) {
          return new P.ConcurrentModificationError(modifiedObject);
        }, null, null, 0, 2, 244, 0, 678, [], "new ConcurrentModificationError"]
      }
    },
    "+ConcurrentModificationError": [34],
    OutOfMemoryError: {
      "^": "Object;",
      toString$0: [function(_) {
        return "Out of Memory";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      get$stackTrace: [function() {
        return;
      }, null, null, 1, 0, 198, "stackTrace"],
      $isError: 1,
      static: {
        OutOfMemoryError$: [function() {
          return new P.OutOfMemoryError();
        }, null, null, 0, 0, 4, "new OutOfMemoryError"]
      }
    },
    "+OutOfMemoryError": [1, 34],
    StackOverflowError: {
      "^": "Object;",
      toString$0: [function(_) {
        return "Stack Overflow";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      get$stackTrace: [function() {
        return;
      }, null, null, 1, 0, 198, "stackTrace"],
      $isError: 1,
      static: {
        StackOverflowError$: [function() {
          return new P.StackOverflowError();
        }, null, null, 0, 0, 4, "new StackOverflowError"]
      }
    },
    "+StackOverflowError": [1, 34],
    CyclicInitializationError: {
      "^": "Error;variableName<-9",
      toString$0: [function(_) {
        var t1 = this.variableName;
        return t1 == null ? "Reading static variable during its initialization" : "Reading static variable '" + H.S(t1) + "' during its initialization";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        CyclicInitializationError$: [function(variableName) {
          return new P.CyclicInitializationError(variableName);
        }, null, null, 0, 2, 167, 0, 677, [], "new CyclicInitializationError"]
      }
    },
    "+CyclicInitializationError": [34],
    Exception: {
      "^": "Object;",
      static: {
        Exception_Exception: [function(message) {
          return new P._Exception(message);
        }, null, null, 0, 2, 710, 0, 17, [], "new Exception"]
      }
    },
    "+Exception": [1],
    _Exception: {
      "^": "Object;message<-10",
      toString$0: [function(_) {
        var t1 = this.message;
        if (t1 == null)
          return "Exception";
        return "Exception: " + H.S(t1);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isException: 1,
      static: {
        _Exception$: [function(message) {
          return new P._Exception(message);
        }, null, null, 0, 2, 406, 0, 17, [], "new _Exception"]
      }
    },
    "+_Exception": [1, 102],
    FormatException: {
      "^": "Object;message<-9,source<-10,offset<-0",
      toString$0: [function(_) {
        var t1, report, offset, source, lineNum, lineStart, lastWasCR, i, char, lineEnd, end, start, prefix, postfix, slice;
        t1 = this.message;
        report = t1 != null && "" !== t1 ? "FormatException: " + H.S(t1) : "FormatException";
        offset = this.offset;
        source = this.source;
        if (typeof source !== "string")
          return offset != null ? report + (" (at offset " + H.S(offset) + ")") : report;
        if (offset != null) {
          t1 = J.getInterceptor$n(offset);
          t1 = t1.$lt(offset, 0) || t1.$gt(offset, source.length);
        } else
          t1 = false;
        if (t1)
          offset = null;
        if (offset == null) {
          if (source.length > 78)
            source = C.JSString_methods.substring$2(source, 0, 75) + "...";
          return report + "\n" + source;
        }
        if (typeof offset !== "number")
          return H.iae(offset);
        lineNum = 1;
        lineStart = 0;
        lastWasCR = null;
        i = 0;
        for (; i < offset; ++i) {
          char = C.JSString_methods._codeUnitAt$1(source, i);
          if (char === 10) {
            if (lineStart !== i || lastWasCR !== true)
              ++lineNum;
            lineStart = i + 1;
            lastWasCR = false;
          } else if (char === 13) {
            ++lineNum;
            lineStart = i + 1;
            lastWasCR = true;
          }
        }
        report = lineNum > 1 ? report + (" (at line " + lineNum + ", character " + H.S(offset - lineStart + 1) + ")\n") : report + (" (at character " + H.S(offset + 1) + ")\n");
        lineEnd = source.length;
        for (i = offset; i < source.length; ++i) {
          char = C.JSString_methods.codeUnitAt$1(source, i);
          if (char === 10 || char === 13) {
            lineEnd = i;
            break;
          }
        }
        if (lineEnd - lineStart > 78)
          if (offset - lineStart < 75) {
            end = lineStart + 75;
            start = lineStart;
            prefix = "";
            postfix = "...";
          } else {
            if (lineEnd - offset < 75) {
              start = lineEnd - 75;
              end = lineEnd;
              postfix = "";
            } else {
              start = offset - 36;
              end = offset + 36;
              postfix = "...";
            }
            prefix = "...";
          }
        else {
          end = lineEnd;
          start = lineStart;
          prefix = "";
          postfix = "";
        }
        slice = C.JSString_methods.substring$2(source, start, end);
        return report + prefix + slice + postfix + "\n" + C.JSString_methods.$mul(" ", offset - start + prefix.length) + "^\n";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isException: 1,
      static: {
        FormatException$: [function(message, source, offset) {
          return new P.FormatException(message, source, offset);
        }, null, null, 0, 6, 711, 32, 0, 0, 17, [], 19, [], 220, [], "new FormatException"]
      }
    },
    "+FormatException": [1, 102],
    IntegerDivisionByZeroException: {
      "^": "Object;",
      toString$0: [function(_) {
        return "IntegerDivisionByZeroException";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isException: 1,
      static: {
        IntegerDivisionByZeroException$: [function() {
          return new P.IntegerDivisionByZeroException();
        }, null, null, 0, 0, 4, "new IntegerDivisionByZeroException"]
      }
    },
    "+IntegerDivisionByZeroException": [1, 102],
    Expando: {
      "^": "Object;name<-9,_jsWeakMapOrKey<-1,$ti",
      toString$0: [function(_) {
        return "Expando:" + H.S(this.name);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $index: [function(_, object) {
        var t1, values;
        t1 = this._jsWeakMapOrKey;
        if (typeof t1 !== "string") {
          if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
            H.throwExpression(P.ArgumentError$value(object, "Expandos are not allowed on strings, numbers, booleans or null", null));
          return t1.get(object);
        }
        values = H.Primitives_getProperty(object, "expando$values");
        return values == null ? null : H.Primitives_getProperty(values, t1);
      }, null, "get$[]", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: T, args: [P.Object]};
        }, this.$receiver, "Expando");
      }, 23, [], "[]"],
      $indexSet: [function(_, object, value) {
        var t1, values;
        t1 = this._jsWeakMapOrKey;
        if (typeof t1 !== "string")
          t1.set(object, value);
        else {
          values = H.Primitives_getProperty(object, "expando$values");
          if (values == null) {
            values = new P.Object();
            H.Primitives_setProperty(object, "expando$values", values);
          }
          H.Primitives_setProperty(values, t1, value);
        }
      }, null, "get$[]=", 4, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [P.Object, T]};
        }, this.$receiver, "Expando");
      }, 23, [], 1, [], "[]="],
      "<>": [972],
      static: {
        "^": "Expando__EXPANDO_PROPERTY_NAME<-9,Expando__keyCount@-0",
        Expando__getFromObject: [function(key, object) {
          var values = H.Primitives_getProperty(object, "expando$values");
          return values == null ? null : H.Primitives_getProperty(values, key);
        }, "call$2", "core_Expando__getFromObject$closure", 4, 0, 678, 6, [], 23, [], "_getFromObject"],
        Expando__setOnObject: [function(key, object, value) {
          var values = H.Primitives_getProperty(object, "expando$values");
          if (values == null) {
            values = new P.Object();
            H.Primitives_setProperty(object, "expando$values", values);
          }
          H.Primitives_setProperty(values, key, value);
        }, "call$3", "core_Expando__setOnObject$closure", 6, 0, 679, 6, [], 23, [], 1, [], "_setOnObject"],
        Expando__createKey: [function() {
          var t1 = $.Expando__keyCount;
          $.Expando__keyCount = J.$add$ns(t1, 1);
          return "expando$key$" + H.S(t1);
        }, "call$0", "core_Expando__createKey$closure", 0, 0, 7, "_createKey"],
        Expando__checkType: [function(object) {
          if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
            throw H.wrapException(P.ArgumentError$value(object, "Expandos are not allowed on strings, numbers, booleans or null", null));
        }, "call$1", "core_Expando__checkType$closure", 2, 0, 3, 23, [], "_checkType"],
        Expando$: [function($name, $T) {
          var t1;
          if (typeof WeakMap == "function")
            t1 = new WeakMap();
          else {
            t1 = $.Expando__keyCount;
            $.Expando__keyCount = J.$add$ns(t1, 1);
            t1 = "expando$key$" + H.S(t1);
          }
          return new P.Expando($name, t1, [$T]);
        }, null, null, 0, 2, 167, 0, 13, [], "new Expando"]
      }
    },
    "+Expando": [1],
    Function: {
      "^": "Object;",
      static: {
        Function__toMangledNames: [function(namedArguments) {
          var result = P.LinkedHashMap__makeEmpty();
          J.forEach$1$ax(namedArguments, new P.Function__toMangledNames_closure(result));
          return result;
        }, "call$1", "core_Function__toMangledNames$closure", 2, 0, 677, 74, [], "_toMangledNames"],
        Function$: [function() {
          return new P.Function();
        }, null, null, 0, 0, 292, "new Function"],
        Function_apply: [function($function, positionalArguments, namedArguments) {
          var t1 = namedArguments == null ? null : P.Function__toMangledNames(namedArguments);
          return t1 == null ? H.Primitives_applyFunctionWithPositionalArguments($function, positionalArguments) : H.Primitives_applyFunctionWithNamedArguments($function, positionalArguments, t1);
        }, function($function, positionalArguments) {
          return P.Function_apply($function, positionalArguments, null);
        }, "call$3", "call$2", "core_Function_apply$closure", 4, 2, 712, 0, 115, [], 77, [], 74, [], "apply"]
      }
    },
    "+Function": [1],
    int: {
      "^": "num;",
      $isComparable: 1,
      $asComparable: function() {
        return [P.num];
      },
      static: {
        int_int$fromEnvironment: [function($name, defaultValue) {
          throw H.wrapException(new P.UnsupportedError("int.fromEnvironment can only be used as a const constructor"));
        }, null, null, 2, 3, 715, 0, 13, [], 135, [], "new int$fromEnvironment"],
        int_parse: [function(source, onError, radix) {
          return H.Primitives_parseInt(source, radix, onError);
        }, function(source) {
          return P.int_parse(source, null, null);
        }, function(source, onError) {
          return P.int_parse(source, onError, null);
        }, "call$3$onError$radix", "call$1", "call$2$onError", "core_int_parse$closure", 2, 5, 716, 0, 0, 19, [], 605, [], 20, [], "parse"]
      }
    },
    "+int": [46],
    Invocation: {
      "^": "Object;",
      get$isAccessor: [function() {
        return this.get$isGetter() || this.get$isSetter();
      }, null, null, 1, 0, 5, "isAccessor"],
      static: {
        Invocation$: [function() {
          return new P.Invocation();
        }, null, null, 0, 0, 717, "new Invocation"]
      }
    },
    "+Invocation": [1],
    Iterable: {
      "^": "Object;$ti",
      map$1: [function(_, f) {
        return H.MappedIterable_MappedIterable(this, f, H.getRuntimeTypeArgument(this, "Iterable", 0), null);
      }, "call$1", "get$map", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.Iterable, args: [{func: 1, args: [E]}]};
        }, this.$receiver, "Iterable");
      }, 9, [], "map"],
      where$1: ["super$Iterable$where", function(_, test) {
        return new H.WhereIterable(this, test, [H.getRuntimeTypeArgument(this, "Iterable", 0)]);
      }, "call$1", "get$where", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "Iterable");
      }, 11, [], "where"],
      expand$1: [function(_, f) {
        return new H.ExpandIterable(this, f, [H.getRuntimeTypeArgument(this, "Iterable", 0), null]);
      }, "call$1", "get$expand", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.Iterable, args: [{func: 1, ret: P.Iterable, args: [E]}]};
        }, this.$receiver, "Iterable");
      }, 9, [], "expand"],
      contains$1: [function(_, element) {
        var t1;
        for (t1 = this.get$iterator(this); t1.moveNext$0();)
          if (J.$eq$(t1.get$current(), element))
            return true;
        return false;
      }, "call$1", "get$contains", 2, 0, 15, 31, [], "contains"],
      forEach$1: [function(_, f) {
        var t1;
        for (t1 = this.get$iterator(this); t1.moveNext$0();)
          f.call$1(t1.get$current());
      }, "call$1", "get$forEach", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, v: true, args: [{func: 1, v: true, args: [E]}]};
        }, this.$receiver, "Iterable");
      }, 9, [], "forEach"],
      reduce$1: [function(_, combine) {
        var iterator, value;
        iterator = this.get$iterator(this);
        if (!iterator.moveNext$0())
          throw H.wrapException(H.IterableElementError_noElement());
        value = iterator.get$current();
        for (; iterator.moveNext$0();)
          value = combine.call$2(value, iterator.get$current());
        return value;
      }, "call$1", "get$reduce", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: E, args: [E, E]}]};
        }, this.$receiver, "Iterable");
      }, 61, [], "reduce"],
      fold$2: [function(_, initialValue, combine) {
        var t1, value;
        for (t1 = this.get$iterator(this), value = initialValue; t1.moveNext$0();)
          value = combine.call$2(value, t1.get$current());
        return value;
      }, "call$2", "get$fold", 4, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, args: [, {func: 1, args: [, E]}]};
        }, this.$receiver, "Iterable");
      }, 123, [], 61, [], "fold"],
      every$1: [function(_, f) {
        var t1;
        for (t1 = this.get$iterator(this); t1.moveNext$0();)
          if (f.call$1(t1.get$current()) !== true)
            return false;
        return true;
      }, "call$1", "get$every", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.bool, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "Iterable");
      }, 9, [], "every"],
      join$1: [function(_, separator) {
        var iterator, t1;
        iterator = this.get$iterator(this);
        if (!iterator.moveNext$0())
          return "";
        if (separator == null || J.$eq$(separator, "")) {
          t1 = "";
          do
            t1 += H.S(iterator.get$current());
          while (iterator.moveNext$0());
        } else {
          t1 = H.S(iterator.get$current());
          for (; iterator.moveNext$0();)
            t1 = t1 + H.S(separator) + H.S(iterator.get$current());
        }
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, function($receiver) {
        return this.join$1($receiver, "");
      }, "join$0", "call$1", "call$0", "get$join", 0, 2, 92, 32, 63, [], "join"],
      any$1: [function(_, f) {
        var t1;
        for (t1 = this.get$iterator(this); t1.moveNext$0();)
          if (f.call$1(t1.get$current()) === true)
            return true;
        return false;
      }, "call$1", "get$any", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: P.bool, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "Iterable");
      }, 9, [], "any"],
      toList$1$growable: [function(_, growable) {
        return P.List_List$from(this, growable, H.getRuntimeTypeArgument(this, "Iterable", 0));
      }, function($receiver) {
        return this.toList$1$growable($receiver, true);
      }, "toList$0", "call$1$growable", "call$0", "get$toList", 0, 3, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.List, E], named: {growable: P.bool}};
        }, this.$receiver, "Iterable");
      }, 25, 88, [], "toList"],
      toSet$0: [function(_) {
        return P.LinkedHashSet_LinkedHashSet$from(this, H.getRuntimeTypeArgument(this, "Iterable", 0));
      }, "call$0", "get$toSet", 0, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Set, E]};
        }, this.$receiver, "Iterable");
      }, "toSet"],
      get$length: [function(_) {
        var it, count;
        it = this.get$iterator(this);
        for (count = 0; it.moveNext$0();)
          ++count;
        return count;
      }, null, null, 1, 0, 11, "length"],
      get$isEmpty: [function(_) {
        return !this.get$iterator(this).moveNext$0();
      }, null, null, 1, 0, 5, "isEmpty"],
      get$isNotEmpty: [function(_) {
        return this.get$isEmpty(this) !== true;
      }, null, null, 1, 0, 5, "isNotEmpty"],
      take$1: [function(_, count) {
        return H.TakeIterable_TakeIterable(this, count, H.getRuntimeTypeArgument(this, "Iterable", 0));
      }, "call$1", "get$take", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [P.int]};
        }, this.$receiver, "Iterable");
      }, 43, [], "take"],
      takeWhile$1: ["super$Iterable$takeWhile", function(_, test) {
        return new H.TakeWhileIterable(this, test, [H.getRuntimeTypeArgument(this, "Iterable", 0)]);
      }, "call$1", "get$takeWhile", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "Iterable");
      }, 11, [], "takeWhile"],
      skip$1: [function(_, count) {
        return H.SkipIterable_SkipIterable(this, count, H.getRuntimeTypeArgument(this, "Iterable", 0));
      }, "call$1", "get$skip", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [P.int]};
        }, this.$receiver, "Iterable");
      }, 43, [], "skip"],
      skipWhile$1: ["super$Iterable$skipWhile", function(_, test) {
        return new H.SkipWhileIterable(this, test, [H.getRuntimeTypeArgument(this, "Iterable", 0)]);
      }, "call$1", "get$skipWhile", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: [P.Iterable, E], args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "Iterable");
      }, 11, [], "skipWhile"],
      get$first: [function(_) {
        var it = this.get$iterator(this);
        if (!it.moveNext$0())
          throw H.wrapException(H.IterableElementError_noElement());
        return it.get$current();
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "Iterable");
      }, "first"],
      get$last: [function(_) {
        var it, result;
        it = this.get$iterator(this);
        if (!it.moveNext$0())
          throw H.wrapException(H.IterableElementError_noElement());
        do
          result = it.get$current();
        while (it.moveNext$0());
        return result;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "Iterable");
      }, "last"],
      get$single: [function(_) {
        var it, result;
        it = this.get$iterator(this);
        if (!it.moveNext$0())
          throw H.wrapException(H.IterableElementError_noElement());
        result = it.get$current();
        if (it.moveNext$0())
          throw H.wrapException(H.IterableElementError_tooMany());
        return result;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E};
        }, this.$receiver, "Iterable");
      }, "single"],
      firstWhere$2$orElse: [function(_, test, orElse) {
        var t1, element;
        for (t1 = this.get$iterator(this); t1.moveNext$0();) {
          element = t1.get$current();
          if (test.call$1(element) === true)
            return element;
        }
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      }, function($receiver, test) {
        return this.firstWhere$2$orElse($receiver, test, null);
      }, "firstWhere$1", "call$2$orElse", "call$1", "get$firstWhere", 2, 3, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: P.bool, args: [E]}], named: {orElse: {func: 1, ret: E}}};
        }, this.$receiver, "Iterable");
      }, 0, 11, [], 67, [], "firstWhere"],
      lastWhere$2$orElse: [function(_, test, orElse) {
        var t1, result, foundMatching, element;
        for (t1 = this.get$iterator(this), result = null, foundMatching = false; t1.moveNext$0();) {
          element = t1.get$current();
          if (test.call$1(element) === true) {
            result = element;
            foundMatching = true;
          }
        }
        if (foundMatching)
          return result;
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      }, function($receiver, test) {
        return this.lastWhere$2$orElse($receiver, test, null);
      }, "lastWhere$1", "call$2$orElse", "call$1", "get$lastWhere", 2, 3, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: P.bool, args: [E]}], named: {orElse: {func: 1, ret: E}}};
        }, this.$receiver, "Iterable");
      }, 0, 11, [], 67, [], "lastWhere"],
      singleWhere$1: [function(_, test) {
        var t1, result, foundMatching, element;
        for (t1 = this.get$iterator(this), result = null, foundMatching = false; t1.moveNext$0();) {
          element = t1.get$current();
          if (test.call$1(element) === true) {
            if (foundMatching)
              throw H.wrapException(H.IterableElementError_tooMany());
            result = element;
            foundMatching = true;
          }
        }
        if (foundMatching)
          return result;
        throw H.wrapException(H.IterableElementError_noElement());
      }, "call$1", "get$singleWhere", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [{func: 1, ret: P.bool, args: [E]}]};
        }, this.$receiver, "Iterable");
      }, 11, [], "singleWhere"],
      elementAt$1: [function(_, index) {
        var t1, elementIndex, element;
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(P.ArgumentError$notNull("index"));
        if (index < 0)
          H.throwExpression(P.RangeError$range(index, 0, null, "index", null));
        for (t1 = this.get$iterator(this), elementIndex = 0; t1.moveNext$0();) {
          element = t1.get$current();
          if (index === elementIndex)
            return element;
          ++elementIndex;
        }
        throw H.wrapException(P.IndexError$(index, this, "index", null, elementIndex));
      }, "call$1", "get$elementAt", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [P.int]};
        }, this.$receiver, "Iterable");
      }, 14, [], "elementAt"],
      toString$0: [function(_) {
        return P.IterableBase_iterableToShortString(this, "(", ")");
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $asIterable: null,
      "<>": [986],
      static: {
        Iterable$: [function($E) {
          return new P.Iterable([$E]);
        }, null, null, 0, 0, 4, "new Iterable"],
        Iterable_Iterable$generate: [function(count, generator, $E) {
          var t1;
          if (J.$le$n(count, 0))
            return new H.EmptyIterable([$E]);
          t1 = generator != null ? generator : H.functionTypeCast(P.core__GeneratorIterable__id$closure(), {func: 1, ret: $E, args: [P.int]});
          return new P._GeneratorIterable(count, t1, [$E]);
        }, null, null, 2, 2, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.Iterable, E], args: [P.int], opt: [{func: 1, ret: E, args: [P.int]}]};
          }, this.$receiver, "Iterable");
        }, 0, 43, [], 363, [], "new Iterable$generate"],
        Iterable_Iterable$empty: [function($E) {
          return new H.EmptyIterable([$E]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.Iterable, E]};
          }, this.$receiver, "Iterable");
        }, "new Iterable$empty"]
      }
    },
    "+Iterable": [1],
    _GeneratorIterable: {
      "^": "ListIterable;length>-0,_generator<-1457,$ti",
      elementAt$1: [function(_, index) {
        P.RangeError_checkValidIndex(index, this, null, null, null);
        return this._generator.call$1(index);
      }, "call$1", "get$elementAt", 2, 0, function() {
        return H.computeSignature(function(E) {
          return {func: 1, ret: E, args: [P.int]};
        }, this.$receiver, "_GeneratorIterable");
      }, 14, [], "elementAt"],
      length$0: function($receiver) {
        return this.length.call$0();
      },
      "<>": [239],
      static: {
        _GeneratorIterable$: [function($length, generator, $E) {
          var t1 = generator != null ? generator : H.functionTypeCast(P.core__GeneratorIterable__id$closure(), {func: 1, ret: $E, args: [P.int]});
          return new P._GeneratorIterable($length, t1, [$E]);
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, args: [P.int, {func: 1, ret: E, args: [P.int]}]};
          }, this.$receiver, "_GeneratorIterable");
        }, 15, [], 363, [], "new _GeneratorIterable"],
        _GeneratorIterable__id: [function(n) {
          return n;
        }, "call$1", "core__GeneratorIterable__id$closure", 2, 0, 16, 89, [], "_core$_id"]
      }
    },
    "+_GeneratorIterable": [1458],
    BidirectionalIterator: {
      "^": "Object;$ti",
      "<>": [539],
      static: {
        BidirectionalIterator$: [function($E) {
          return new P.BidirectionalIterator([$E]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.BidirectionalIterator, E]};
          }, this.$receiver, "BidirectionalIterator");
        }, "new BidirectionalIterator"]
      }
    },
    "+BidirectionalIterator": [1, 1459],
    Iterator: {
      "^": "Object;$ti",
      "<>": [973],
      static: {
        Iterator$: [function($E) {
          return new P.Iterator([$E]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.Iterator, E]};
          }, this.$receiver, "Iterator");
        }, "new Iterator"]
      }
    },
    "+Iterator": [1],
    List: {
      "^": "Object;$ti",
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $asList: null,
      $isIterable: 1,
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: null,
      "<>": [576],
      static: {
        List_List: [function($length, $E) {
          return J.JSArray_JSArray$list($length, $E);
        }, null, null, 0, 2, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.List, E], opt: [P.int]};
          }, this.$receiver, "List");
        }, 676, 15, [], "new List"],
        List_List$filled: [function($length, fill, growable, $E) {
          var result, t1, i;
          if (growable === true) {
            if (typeof $length !== "number" || Math.floor($length) !== $length || $length < 0)
              H.throwExpression(P.ArgumentError$("Length must be a non-negative integer: " + H.S($length)));
            result = H.setRuntimeTypeInfo(new Array($length), [$E]);
          } else
            result = J.JSArray_JSArray$fixed($length, $E);
          if (!J.$eq$($length, 0) && fill != null)
            for (t1 = result.length, i = 0; i < t1; ++i)
              result[i] = fill;
          return result;
        }, null, null, 4, 3, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.List, E], args: [P.int, E], named: {growable: P.bool}};
          }, this.$receiver, "List");
        }, 4, 15, [], 459, [], 88, [], "new List$filled"],
        List_List$from: [function(elements, growable, $E) {
          var list, t1;
          list = H.setRuntimeTypeInfo([], [$E]);
          for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
            list.push(t1.get$current());
          if (growable === true)
            return list;
          list.fixed$length = Array;
          return list;
        }, null, null, 2, 3, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.List, E], args: [P.Iterable], named: {growable: P.bool}};
          }, this.$receiver, "List");
        }, 25, 35, [], 88, [], "new List$from"],
        List_List$generate: [function($length, generator, growable, $E) {
          var t1, result, i;
          t1 = [$E];
          if (growable === true) {
            result = H.setRuntimeTypeInfo([], t1);
            C.JSArray_methods.set$length(result, $length);
          } else {
            if (typeof $length !== "number")
              return H.iae($length);
            result = H.setRuntimeTypeInfo(new Array($length), t1);
          }
          if (typeof $length !== "number")
            return H.iae($length);
          i = 0;
          for (; i < $length; ++i) {
            t1 = generator.call$1(i);
            if (i >= result.length)
              return H.ioore(result, i);
            result[i] = t1;
          }
          return result;
        }, null, null, 4, 3, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.List, E], args: [P.int, {func: 1, ret: E, args: [P.int]}], named: {growable: P.bool}};
          }, this.$receiver, "List");
        }, 25, 15, [], 363, [], 88, [], "new List$generate"],
        List_List$unmodifiable: [function(elements, $E) {
          var result = P.List_List$from(elements, false, $E);
          result.fixed$length = Array;
          result.immutable$list = Array;
          return result;
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.List, E], args: [P.Iterable]};
          }, this.$receiver, "List");
        }, 35, [], "new List$unmodifiable"]
      }
    },
    "+List": [1, 1460],
    Map: {
      "^": "Object;$ti",
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      "<>": [981, 976],
      static: {
        Map_Map: [function($K, $V) {
          return new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [$K, $V]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, ret: [P.Map, K, V]};
          }, this.$receiver, "Map");
        }, "new Map"],
        Map_Map$from: [function(other, $K, $V) {
          return P.LinkedHashMap_LinkedHashMap$from(other, $K, $V);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, ret: [P.Map, K, V], args: [P.Map]};
          }, this.$receiver, "Map");
        }, 2, [], "new Map$from"],
        Map_Map$unmodifiable: [function(other, $K, $V) {
          return H.ConstantMap_ConstantMap$from(other, $K, $V);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, ret: [P.Map, K, V], args: [P.Map]};
          }, this.$receiver, "Map");
        }, 2, [], "new Map$unmodifiable"],
        Map_Map$identity: [function($K, $V) {
          return P.LinkedHashMap_LinkedHashMap$identity($K, $V);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, ret: [P.Map, K, V]};
          }, this.$receiver, "Map");
        }, "new Map$identity"],
        Map_Map$fromIterable: [function(iterable, key, value, $K, $V) {
          var map = P.LinkedHashMap_LinkedHashMap(null, null, null, $K, $V);
          P.Maps__fillMapWithMappedIterable(map, iterable, key, value);
          return map;
        }, null, null, 2, 5, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, ret: [P.Map, K, V], args: [P.Iterable], named: {key: {func: 1, ret: K, args: [,]}, value: {func: 1, ret: V, args: [,]}}};
          }, this.$receiver, "Map");
        }, 0, 0, 42, [], 6, [], 1, [], "new Map$fromIterable"],
        Map_Map$fromIterables: [function(keys, values, $K, $V) {
          var map = P.LinkedHashMap_LinkedHashMap(null, null, null, $K, $V);
          P.Maps__fillMapWithIterables(map, keys, values);
          return map;
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(K, V) {
            return {func: 1, ret: [P.Map, K, V], args: [[P.Iterable, K], [P.Iterable, V]]};
          }, this.$receiver, "Map");
        }, 177, [], 166, [], "new Map$fromIterables"]
      }
    },
    "+Map": [1],
    Null: {
      "^": "Object;",
      get$hashCode: [function(_) {
        return P.Object.prototype.get$hashCode.call(this, this);
      }, null, null, 1, 0, 11, "hashCode"],
      toString$0: [function(_) {
        return "null";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        Null_Null$_uninstantiable: [function() {
          throw H.wrapException(new P.UnsupportedError("class Null cannot be instantiated"));
        }, null, null, 0, 0, 718, "new Null$_uninstantiable"]
      }
    },
    "+Null": [1],
    num: {
      "^": "Object;",
      $isComparable: 1,
      $asComparable: function() {
        return [P.num];
      },
      static: {
        num$: [function() {
          return new P.num();
        }, null, null, 0, 0, 155, "new num"],
        num_parse: [function(input, onError) {
          var source, result;
          source = J.trim$0$s(input);
          result = H.Primitives_parseInt(source, null, P.core_num__returnIntNull$closure());
          if (result != null)
            return result;
          result = H.Primitives_parseDouble(source, P.core_num__returnDoubleNull$closure());
          if (result != null)
            return result;
          if (onError == null)
            throw H.wrapException(new P.FormatException(input, null, null));
          return onError.call$1(input);
        }, function(input) {
          return P.num_parse(input, null);
        }, "call$2", "call$1", "core_num_parse$closure", 2, 2, 719, 0, 58, [], 20, [], "parse"],
        num__returnIntNull: [function(_) {
          return;
        }, "call$1", "core_num__returnIntNull$closure", 2, 0, 31, 16, [], "_returnIntNull"],
        num__returnDoubleNull: [function(_) {
          return;
        }, "call$1", "core_num__returnDoubleNull$closure", 2, 0, 720, 16, [], "_returnDoubleNull"]
      }
    },
    "+num": [1, 1461],
    Object: {
      "^": ";",
      $eq: [function(_, other) {
        return this === other;
      }, null, "get$==", 2, 0, 24, 2, [], "=="],
      get$hashCode: [function(_) {
        return H.Primitives_objectHashCode(this);
      }, null, null, 1, 0, 11, "hashCode"],
      toString$0: ["super$Object$toString", function(_) {
        return H.Primitives_objectToHumanReadableString(this);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      noSuchMethod$1: [function(_, invocation) {
        throw H.wrapException(P.NoSuchMethodError$(this, invocation.get$memberName(), invocation.get$positionalArguments(), invocation.get$namedArguments(), null));
      }, "call$1", "get$noSuchMethod", 2, 0, 77, 118, [], "noSuchMethod"],
      get$runtimeType: [function(_) {
        return new H.TypeImpl(H.getRuntimeTypeString(this), null);
      }, null, null, 1, 0, 20, "runtimeType"],
      toString: function() {
        return this.toString$0(this);
      },
      static: {
        Object$: [function() {
          return new P.Object();
        }, null, null, 0, 0, 4, "new Object"]
      }
    },
    "+Object": [],
    Pattern: {
      "^": "Object;",
      static: {
        Pattern$: [function() {
          return new P.Pattern();
        }, null, null, 0, 0, 721, "new Pattern"]
      }
    },
    "+Pattern": [1],
    Match: {
      "^": "Object;",
      start$0: function() {
        return this.get$start().call$0();
      },
      start$2$arguments: function(arg0, arg1) {
        return this.get$start().call$2$arguments(arg0, arg1);
      },
      static: {
        Match$: [function() {
          return new P.Match();
        }, null, null, 0, 0, 196, "new Match"]
      }
    },
    "+Match": [1],
    RegExp: {
      "^": "Object;",
      $isPattern: 1,
      static: {
        RegExp_RegExp: [function(source, caseSensitive, multiLine) {
          return new H.JSSyntaxRegExp(source, H.JSSyntaxRegExp_makeNative(source, multiLine, caseSensitive, false), null, null);
        }, null, null, 2, 5, 722, 4, 25, 19, [], 674, [], 672, [], "new RegExp"]
      }
    },
    "+RegExp": [1, 480],
    Set: {
      "^": "EfficientLengthIterable;$ti",
      "<>": [442],
      static: {
        Set_Set: [function($E) {
          return P.LinkedHashSet_LinkedHashSet(null, null, null, $E);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.Set, E]};
          }, this.$receiver, "Set");
        }, "new Set"],
        Set_Set$identity: [function($E) {
          return P.LinkedHashSet_LinkedHashSet$identity($E);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.Set, E]};
          }, this.$receiver, "Set");
        }, "new Set$identity"],
        Set_Set$from: [function(elements, $E) {
          return P.LinkedHashSet_LinkedHashSet$from(elements, $E);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.Set, E], args: [P.Iterable]};
          }, this.$receiver, "Set");
        }, 35, [], "new Set$from"]
      }
    },
    "+Set": [1463],
    Sink: {
      "^": "Object;$ti",
      "<>": [958],
      static: {
        Sink$: [function($T) {
          return new P.Sink([$T]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P.Sink, T]};
          }, this.$receiver, "Sink");
        }, "new Sink"]
      }
    },
    "+Sink": [1],
    StackTrace: {
      "^": "Object;",
      static: {
        StackTrace$: [function() {
          return new P.StackTrace();
        }, null, null, 0, 0, 4, "new StackTrace"],
        StackTrace_StackTrace$fromString: [function(stackTraceString) {
          return new P._StringStackTrace(stackTraceString);
        }, null, null, 2, 0, 723, 671, [], "new StackTrace$fromString"],
        StackTrace_current: [function() {
          var stackTrace, exception;
          if ($.$get$_hasErrorStackProperty() === true)
            return H.getTraceFromException(new Error());
          try {
            throw H.wrapException("");
          } catch (exception) {
            H.unwrapException(exception);
            stackTrace = H.getTraceFromException(exception);
            return stackTrace;
          }
        }, null, null, 1, 0, 198, "current"]
      }
    },
    "+StackTrace": [1],
    _StringStackTrace: {
      "^": "Object;_stackTrace<-9",
      toString$0: [function(_) {
        return this._stackTrace;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        _StringStackTrace$: [function(_stackTrace) {
          return new P._StringStackTrace(_stackTrace);
        }, null, null, 2, 0, 13, 670, [], "new _StringStackTrace"]
      }
    },
    "+_StringStackTrace": [1, 221],
    Stopwatch: {
      "^": "Object;_core$_start@-0,_stop@-0",
      get$frequency: [function() {
        return $.Stopwatch__frequency;
      }, null, null, 1, 0, 11, "frequency"],
      start$0: [function() {
        if (this._stop != null) {
          this._core$_start = J.$add$ns(this._core$_start, J.$sub$n($.Primitives_timerTicks.call$0(), this._stop));
          this._stop = null;
        }
      }, "call$0", "get$start", 0, 0, 6, "start"],
      stop$0: [function() {
        if (this._stop == null)
          this._stop = $.Primitives_timerTicks.call$0();
      }, "call$0", "get$stop", 0, 0, 6, "stop"],
      reset$0: [function() {
        var t1 = this._stop;
        this._core$_start = t1 == null ? $.Primitives_timerTicks.call$0() : t1;
      }, "call$0", "get$reset", 0, 0, 6, "reset"],
      get$elapsedTicks: [function() {
        var t1 = this._stop;
        if (t1 == null)
          t1 = $.Primitives_timerTicks.call$0();
        return J.$sub$n(t1, this._core$_start);
      }, null, null, 1, 0, 11, "elapsedTicks"],
      get$elapsed: [function() {
        var t1 = this._stop;
        if (t1 == null)
          t1 = $.Primitives_timerTicks.call$0();
        return P.Duration$(0, 0, J.$tdiv$n(J.$mul$ns(J.$sub$n(t1, this._core$_start), 1000000), $.Stopwatch__frequency), 0, 0, 0);
      }, null, null, 1, 0, 83, "elapsed"],
      get$elapsedMicroseconds: [function() {
        var t1 = this._stop;
        if (t1 == null)
          t1 = $.Primitives_timerTicks.call$0();
        return J.$tdiv$n(J.$mul$ns(J.$sub$n(t1, this._core$_start), 1000000), $.Stopwatch__frequency);
      }, null, null, 1, 0, 11, "elapsedMicroseconds"],
      get$elapsedMilliseconds: [function() {
        var t1 = this._stop;
        if (t1 == null)
          t1 = $.Primitives_timerTicks.call$0();
        return J.$tdiv$n(J.$mul$ns(J.$sub$n(t1, this._core$_start), 1000), $.Stopwatch__frequency);
      }, null, null, 1, 0, 11, "elapsedMilliseconds"],
      get$isRunning: [function() {
        return this._stop == null;
      }, null, null, 1, 0, 5, "isRunning"],
      static: {
        "^": "Stopwatch__frequency@-0",
        Stopwatch$: [function() {
          if ($.Stopwatch__frequency == null) {
            H.Primitives_initTicker();
            $.Stopwatch__frequency = $.Primitives_timerFrequency;
          }
          return new P.Stopwatch(0, 0);
        }, null, null, 0, 0, 4, "new Stopwatch"],
        Stopwatch__initTicker: [function() {
          H.Primitives_initTicker();
          $.Stopwatch__frequency = $.Primitives_timerFrequency;
        }, "call$0", "core_Stopwatch__initTicker$closure", 0, 0, 6, "_initTicker"],
        Stopwatch__now: [function() {
          return $.Primitives_timerTicks.call$0();
        }, "call$0", "core_Stopwatch__now$closure", 0, 0, 11, "_now"]
      }
    },
    "+Stopwatch": [1],
    String: {
      "^": "Object;",
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $isComparable: 1,
      $asComparable: function() {
        return [P.String];
      },
      $isPattern: 1,
      static: {
        String__stringFromJSArray: [function(list, start, endOrNull) {
          var t1, len, end;
          t1 = J.getInterceptor$asx(list);
          len = t1.get$length(list);
          end = P.RangeError_checkValidRange(start, endOrNull, len, null, null, null);
          return H.Primitives_stringFromCharCodes(J.$gt$n(start, 0) || J.$lt$n(end, len) ? t1.sublist$2(list, start, end) : list);
        }, "call$3", "core_String__stringFromJSArray$closure", 6, 0, 680, 125, [], 3, [], 543, [], "_stringFromJSArray"],
        String__stringFromUint8List: [function(charCodes, start, endOrNull) {
          return H.Primitives_stringFromNativeUint8List(charCodes, start, P.RangeError_checkValidRange(start, endOrNull, J.get$length$asx(charCodes), null, null, null));
        }, "call$3", "core_String__stringFromUint8List$closure", 6, 0, 681, 375, [], 3, [], 543, [], "_stringFromUint8List"],
        String__stringFromIterable: [function(charCodes, start, end) {
          var t1, it, i, list;
          if (J.$lt$n(start, 0))
            throw H.wrapException(P.RangeError$range(start, 0, J.get$length$asx(charCodes), null, null));
          t1 = end == null;
          if (!t1 && J.$lt$n(end, start))
            throw H.wrapException(P.RangeError$range(end, start, J.get$length$asx(charCodes), null, null));
          it = J.get$iterator$ax(charCodes);
          if (typeof start !== "number")
            return H.iae(start);
          i = 0;
          for (; i < start; ++i)
            if (!it.moveNext$0())
              throw H.wrapException(P.RangeError$range(start, 0, i, null, null));
          list = [];
          if (t1)
            for (; it.moveNext$0();)
              list.push(it.get$current());
          else {
            i = start;
            while (true) {
              if (typeof end !== "number")
                return H.iae(end);
              if (!(i < end))
                break;
              if (!it.moveNext$0())
                throw H.wrapException(P.RangeError$range(end, start, i, null, null));
              list.push(it.get$current());
              ++i;
            }
          }
          return H.Primitives_stringFromCharCodes(list);
        }, "call$3", "core_String__stringFromIterable$closure", 6, 0, 682, 375, [], 3, [], 5, [], "_stringFromIterable"],
        String_String$fromCharCodes: [function(charCodes, start, end) {
          var len;
          if (typeof charCodes === "object" && charCodes !== null && charCodes.constructor === Array) {
            len = charCodes.length;
            end = P.RangeError_checkValidRange(start, end, len, null, null, null);
            return H.Primitives_stringFromCharCodes(J.$gt$n(start, 0) || J.$lt$n(end, len) ? C.JSArray_methods.sublist$2(charCodes, start, end) : charCodes);
          }
          if (!!J.getInterceptor(charCodes).$isNativeUint8List)
            return H.Primitives_stringFromNativeUint8List(charCodes, start, P.RangeError_checkValidRange(start, end, charCodes.length, null, null, null));
          return P.String__stringFromIterable(charCodes, start, end);
        }, null, null, 2, 4, 724, 7, 0, 375, [], 3, [], 5, [], "new String$fromCharCodes"],
        String_String$fromCharCode: [function(charCode) {
          return H.Primitives_stringFromCharCode(charCode);
        }, null, null, 2, 0, 25, 84, [], "new String$fromCharCode"],
        String_String$fromEnvironment: [function($name, defaultValue) {
          throw H.wrapException(new P.UnsupportedError("String.fromEnvironment can only be used as a const constructor"));
        }, null, null, 2, 3, 725, 0, 13, [], 135, [], "new String$fromEnvironment"]
      }
    },
    "+String": [1, 480, 1464],
    Runes: {
      "^": "Iterable;string<-9",
      get$iterator: [function(_) {
        return new P.RuneIterator(this.string, 0, 0, null);
      }, null, null, 1, 0, 1649, "iterator"],
      get$last: [function(_) {
        var t1, t2, $length, t3, code, previousCode;
        t1 = this.string;
        t2 = J.getInterceptor$asx(t1);
        if (J.$eq$(t2.get$length(t1), 0))
          throw H.wrapException(new P.StateError("No elements."));
        $length = t2.get$length(t1);
        t3 = J.getInterceptor$n($length);
        code = t2.codeUnitAt$1(t1, t3.$sub($length, 1));
        if ((code & 64512) === 56320 && J.$gt$n(t2.get$length(t1), 1)) {
          previousCode = t2.codeUnitAt$1(t1, t3.$sub($length, 2));
          if ((previousCode & 64512) === 55296)
            return P._combineSurrogatePair(previousCode, code);
        }
        return code;
      }, null, null, 1, 0, 11, "last"],
      $asIterable: function() {
        return [P.int];
      },
      "<>": [],
      static: {
        Runes$: [function(string) {
          return new P.Runes(string);
        }, null, null, 2, 0, 13, 39, [], "new Runes"]
      }
    },
    "+Runes": [1465],
    RuneIterator: {
      "^": "Object;string<-9,_core$_position@-0,_nextPosition@-0,_currentCodePoint@-0",
      _checkSplitSurrogate$1: [function(index) {
        var t1, t2, t3;
        t1 = J.getInterceptor$n(index);
        if (t1.$gt(index, 0)) {
          t2 = this.string;
          t3 = J.getInterceptor$asx(t2);
          t1 = t1.$lt(index, t3.get$length(t2)) && (t3.codeUnitAt$1(t2, t1.$sub(index, 1)) & 64512) === 55296 && (t3.codeUnitAt$1(t2, index) & 64512) === 56320;
        } else
          t1 = false;
        if (t1)
          throw H.wrapException(P.ArgumentError$("Index inside surrogate pair: " + H.S(index)));
      }, "call$1", "get$_checkSplitSurrogate", 2, 0, 17, 14, [], "_checkSplitSurrogate"],
      get$rawIndex: [function() {
        return !J.$eq$(this._core$_position, this._nextPosition) ? this._core$_position : null;
      }, null, null, 1, 0, 11, "rawIndex"],
      set$rawIndex: [function(rawIndex) {
        var t1 = this.string;
        P.RangeError_checkValidIndex(rawIndex, t1, "rawIndex", null, null);
        P.RangeError_checkValueInInterval(rawIndex, 0, J.get$length$asx(t1), "rawIndex", null);
        this._checkSplitSurrogate$1(rawIndex);
        this._nextPosition = rawIndex;
        this._core$_position = rawIndex;
        this._currentCodePoint = null;
        this.moveNext$0();
      }, null, null, 3, 0, 17, 615, [], "rawIndex"],
      reset$1: [function(rawIndex) {
        P.RangeError_checkValueInInterval(rawIndex, 0, J.get$length$asx(this.string), "rawIndex", null);
        this._checkSplitSurrogate$1(rawIndex);
        this._nextPosition = rawIndex;
        this._core$_position = rawIndex;
        this._currentCodePoint = null;
      }, function() {
        return this.reset$1(0);
      }, "reset$0", "call$1", "call$0", "get$reset", 0, 2, 1651, 7, 615, [], "reset"],
      get$current: [function() {
        return this._currentCodePoint;
      }, null, null, 1, 0, 11, "current"],
      get$currentSize: [function() {
        return J.$sub$n(this._nextPosition, this._core$_position);
      }, null, null, 1, 0, 11, "currentSize"],
      get$currentAsString: [function() {
        if (J.$eq$(this._core$_position, this._nextPosition))
          return;
        if (J.$eq$(J.$add$ns(this._core$_position, 1), this._nextPosition))
          return J.$index$asx(this.string, this._core$_position);
        return J.substring$2$s(this.string, this._core$_position, this._nextPosition);
      }, null, null, 1, 0, 7, "currentAsString"],
      moveNext$0: [function() {
        var t1, t2, t3, codeUnit, nextPosition, nextCodeUnit;
        t1 = this._nextPosition;
        this._core$_position = t1;
        t2 = this.string;
        t3 = J.getInterceptor$asx(t2);
        if (J.$eq$(t1, t3.get$length(t2))) {
          this._currentCodePoint = null;
          return false;
        }
        codeUnit = t3.codeUnitAt$1(t2, this._core$_position);
        nextPosition = J.$add$ns(this._core$_position, 1);
        if ((codeUnit & 64512) === 55296 && J.$lt$n(nextPosition, t3.get$length(t2))) {
          nextCodeUnit = t3.codeUnitAt$1(t2, nextPosition);
          if ((nextCodeUnit & 64512) === 56320) {
            this._nextPosition = J.$add$ns(nextPosition, 1);
            this._currentCodePoint = P._combineSurrogatePair(codeUnit, nextCodeUnit);
            return true;
          }
        }
        this._nextPosition = nextPosition;
        this._currentCodePoint = codeUnit;
        return true;
      }, "call$0", "get$moveNext", 0, 0, 5, "moveNext"],
      movePrevious$0: [function() {
        var t1, position, t2, codeUnit, t3, prevCodeUnit;
        t1 = this._core$_position;
        this._nextPosition = t1;
        if (J.$eq$(t1, 0)) {
          this._currentCodePoint = null;
          return false;
        }
        position = J.$sub$n(this._core$_position, 1);
        t1 = this.string;
        t2 = J.getInterceptor$s(t1);
        codeUnit = t2.codeUnitAt$1(t1, position);
        if ((codeUnit & 64512) === 56320 && J.$gt$n(position, 0)) {
          t3 = J.getInterceptor$n(position);
          prevCodeUnit = t2.codeUnitAt$1(t1, t3.$sub(position, 1));
          if ((prevCodeUnit & 64512) === 55296) {
            this._core$_position = t3.$sub(position, 1);
            this._currentCodePoint = P._combineSurrogatePair(prevCodeUnit, codeUnit);
            return true;
          }
        }
        this._core$_position = position;
        this._currentCodePoint = codeUnit;
        return true;
      }, "call$0", "get$movePrevious", 0, 0, 5, "movePrevious"],
      RuneIterator$at$2: function(string, index) {
        P.RangeError_checkValueInInterval(index, 0, J.get$length$asx(string), null, null);
        this._checkSplitSurrogate$1(index);
      },
      static: {
        RuneIterator$: [function(string) {
          return new P.RuneIterator(string, 0, 0, null);
        }, null, null, 2, 0, 13, 39, [], "new RuneIterator"],
        RuneIterator$at: [function(string, index) {
          var t1 = new P.RuneIterator(string, index, index, null);
          t1.RuneIterator$at$2(string, index);
          return t1;
        }, null, null, 4, 0, 147, 39, [], 14, [], "new RuneIterator$at"]
      }
    },
    "+RuneIterator": [1, 1466],
    StringBuffer: {
      "^": "Object;_contents@-9",
      get$length: [function(_) {
        return J.get$length$asx(this._contents);
      }, null, null, 1, 0, 11, "length"],
      get$isEmpty: [function(_) {
        return J.$eq$(J.get$length$asx(this._contents), 0);
      }, null, null, 1, 0, 5, "isEmpty"],
      get$isNotEmpty: [function(_) {
        return !J.$eq$(J.get$length$asx(this._contents), 0);
      }, null, null, 1, 0, 5, "isNotEmpty"],
      write$1: [function(obj) {
        this._contents += H.S(obj);
      }, "call$1", "get$write", 2, 0, 64, 143, [], "write"],
      writeCharCode$1: [function(charCode) {
        this._contents += H.Primitives_stringFromCharCode(charCode);
      }, "call$1", "get$writeCharCode", 2, 0, 17, 84, [], "writeCharCode"],
      writeAll$2: [function(objects, separator) {
        this._contents = P.StringBuffer__writeAll(this._contents, objects, separator);
      }, function(objects) {
        return this.writeAll$2(objects, "");
      }, "writeAll$1", "call$2", "call$1", "get$writeAll", 2, 2, 135, 32, 119, [], 63, [], "writeAll"],
      writeln$1: [function(obj) {
        this._contents += H.S(obj) + "\n";
      }, function() {
        return this.writeln$1("");
      }, "writeln$0", "call$1", "call$0", "get$writeln", 0, 2, 134, 32, 143, [], "writeln"],
      clear$0: [function(_) {
        this._contents = "";
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      toString$0: [function(_) {
        var t1 = this._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      _writeString$1: [function(str) {
        this._contents += str;
      }, "call$1", "get$_writeString", 2, 0, 27, 120, [], "_writeString"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      static: {
        StringBuffer__writeAll: [function(string, objects, separator) {
          var iterator = J.get$iterator$ax(objects);
          if (!iterator.moveNext$0())
            return string;
          if (J.get$isEmpty$asx(separator) === true) {
            do
              string += H.S(iterator.get$current());
            while (iterator.moveNext$0());
          } else {
            string += H.S(iterator.get$current());
            for (; iterator.moveNext$0();)
              string = string + H.S(separator) + H.S(iterator.get$current());
          }
          return string;
        }, "call$3", "core_StringBuffer__writeAll$closure", 6, 0, 683, 39, [], 119, [], 63, [], "_writeAll"],
        StringBuffer__writeOne: [function(string, obj) {
          return string + H.S(obj);
        }, "call$2", "core_StringBuffer__writeOne$closure", 4, 0, 684, 39, [], 143, [], "_writeOne"],
        StringBuffer$: [function($content) {
          return new P.StringBuffer(H.S($content));
        }, null, null, 0, 2, 244, 32, 410, [], "new StringBuffer"]
      }
    },
    "+StringBuffer": [1, 57],
    StringSink: {
      "^": "Object;",
      static: {
        StringSink$: [function() {
          return new P.StringSink();
        }, null, null, 0, 0, 727, "new StringSink"]
      }
    },
    "+StringSink": [1],
    Symbol: {
      "^": "Object;",
      static: {
        Symbol_Symbol: [function($name) {
          return new H.Symbol0($name);
        }, null, null, 2, 0, 728, 13, [], "new Symbol"]
      }
    },
    "+Symbol": [1],
    Type: {
      "^": "Object;",
      static: {
        Type$: [function() {
          return new P.Type();
        }, null, null, 0, 0, 20, "new Type"]
      }
    },
    "+Type": [1],
    Uri: {
      "^": "Object;",
      get$hasScheme: [function() {
        var t1 = this.get$scheme();
        return t1.get$isNotEmpty(t1);
      }, null, null, 1, 0, 5, "hasScheme"],
      static: {
        Uri_base: [function() {
          var uri = H.Primitives_currentUri();
          if (uri != null)
            return P.Uri_parse(uri, 0, null);
          throw H.wrapException(new P.UnsupportedError("'Uri.base' is not supported"));
        }, null, null, 1, 0, 43, "base"],
        Uri_Uri: [function(fragment, host, path, pathSegments, port, query, queryParameters, scheme, userInfo) {
          return P._Uri__Uri(fragment, host, path, pathSegments, port, query, queryParameters, scheme, userInfo);
        }, null, null, 0, 19, 273, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, [], 209, [], 29, [], 26, [], 10, [], 213, [], 129, [], 107, [], 216, [], "new Uri"],
        Uri_Uri$http: [function(authority, unencodedPath, queryParameters) {
          return P._Uri__makeHttpUri("http", authority, unencodedPath, queryParameters);
        }, null, null, 4, 2, 408, 0, 217, [], 218, [], 107, [], "new Uri$http"],
        Uri_Uri$https: [function(authority, unencodedPath, queryParameters) {
          return P._Uri__makeHttpUri("https", authority, unencodedPath, queryParameters);
        }, null, null, 4, 2, 408, 0, 217, [], 218, [], 107, [], "new Uri$https"],
        Uri_Uri$file: [function(path, windows) {
          return P._Uri__Uri$file(path, windows);
        }, null, null, 2, 3, 409, 0, 10, [], 170, [], "new Uri$file"],
        Uri_Uri$directory: [function(path, windows) {
          return P._Uri__Uri$directory(path, windows);
        }, null, null, 2, 3, 409, 0, 10, [], 170, [], "new Uri$directory"],
        Uri_Uri$dataFromString: [function($content, base64, encoding, mimeType, parameters) {
          var buffer, indices, charsetName, encodingName, t1;
          buffer = new P.StringBuffer("");
          indices = [-1];
          charsetName = parameters != null ? J.$index$asx(parameters, "charset") : null;
          if (encoding == null) {
            if (charsetName != null)
              encoding = P.Encoding_getByName(charsetName);
            encodingName = null;
          } else
            encodingName = charsetName == null ? encoding.get$name() : null;
          if (encoding == null)
            encoding = C.AsciiCodec_false;
          P.UriData__writeUri(mimeType, encodingName, parameters, buffer, indices);
          indices.push(J.get$length$asx(buffer._contents));
          t1 = buffer._contents;
          if (base64 === true) {
            t1 += ";base64,";
            buffer._contents = t1;
            indices.push(t1.length - 1);
            buffer._contents += H.S(encoding.fuse$1(C.Base64Codec_Base64Encoder_false).encode$1($content));
          } else {
            buffer._contents = t1 + ",";
            P.UriData__uriEncodeBytes(C.List_CVk, encoding.encode$1($content), buffer);
          }
          t1 = buffer._contents;
          return new P.UriData(t1.charCodeAt(0) == 0 ? t1 : t1, indices, null).get$uri();
        }, null, null, 2, 9, 731, 0, 0, 0, 4, 410, [], 172, [], 48, [], 117, [], 601, [], "new Uri$dataFromString"],
        Uri_Uri$dataFromBytes: [function(bytes, mimeType, parameters, percentEncoded) {
          var buffer, indices, t1;
          buffer = new P.StringBuffer("");
          indices = [-1];
          P.UriData__writeUri(mimeType, null, parameters, buffer, indices);
          indices.push(J.get$length$asx(buffer._contents));
          t1 = buffer._contents;
          if (percentEncoded === true) {
            buffer._contents = t1 + ",";
            P.UriData__uriEncodeBytes(C.List_CVk, bytes, buffer);
          } else {
            t1 += ";base64,";
            buffer._contents = t1;
            indices.push(t1.length - 1);
            C.Base64Encoder_false.startChunkedConversion$1(new P._StringSinkConversionSink(buffer)).addSlice$4(bytes, 0, J.get$length$asx(bytes), true);
          }
          t1 = buffer._contents;
          return new P.UriData(t1.charCodeAt(0) == 0 ? t1 : t1, indices, null).get$uri();
        }, null, null, 2, 7, 732, 602, 0, 4, 30, [], 172, [], 117, [], 603, [], "new Uri$dataFromBytes"],
        Uri_parse: [function(uri, start, end) {
          var t1, t2, dataDelta, t3, indices, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, t4, t5, isSimple, scheme, t6, t7, t8, schemeAuth, delta, t9;
          if (end == null)
            end = J.get$length$asx(uri);
          t1 = J.getInterceptor$ns(start);
          t2 = J.getInterceptor$n(end);
          if (t2.$ge(end, t1.$add(start, 5))) {
            dataDelta = P._startsWithData(uri, start);
            if (dataDelta === 0)
              return P.UriData__parse(t1.$gt(start, 0) || t2.$lt(end, J.get$length$asx(uri)) ? J.substring$2$s(uri, start, end) : uri, 5, null).get$uri();
            else if (dataDelta === 32)
              return P.UriData__parse(J.substring$2$s(uri, t1.$add(start, 5), end), 0, null).get$uri();
          }
          t3 = new Array(8);
          t3.fixed$length = Array;
          indices = H.setRuntimeTypeInfo(t3, [P.int]);
          indices[0] = 0;
          indices[1] = t1.$sub(start, 1);
          indices[2] = t1.$sub(start, 1);
          indices[7] = t1.$sub(start, 1);
          indices[3] = start;
          indices[4] = start;
          indices[5] = end;
          indices[6] = end;
          if (J.$ge$n(P._scan(uri, start, end, 0, indices), 14))
            indices[7] = end;
          schemeEnd = indices[1];
          t3 = J.getInterceptor$n(schemeEnd);
          if (t3.$ge(schemeEnd, start))
            if (J.$eq$(P._scan(uri, start, schemeEnd, 20, indices), 20))
              indices[7] = schemeEnd;
          hostStart = J.$add$ns(indices[2], 1);
          portStart = indices[3];
          pathStart = indices[4];
          queryStart = indices[5];
          fragmentStart = indices[6];
          t4 = J.getInterceptor$n(fragmentStart);
          if (t4.$lt(fragmentStart, queryStart))
            queryStart = fragmentStart;
          t5 = J.getInterceptor$n(pathStart);
          if (t5.$lt(pathStart, hostStart) || t5.$le(pathStart, schemeEnd))
            pathStart = queryStart;
          if (J.$lt$n(portStart, hostStart))
            portStart = pathStart;
          isSimple = J.$lt$n(indices[7], start);
          if (isSimple) {
            t5 = J.getInterceptor$n(hostStart);
            if (t5.$gt(hostStart, t3.$add(schemeEnd, 3))) {
              scheme = null;
              isSimple = false;
            } else {
              t6 = J.getInterceptor$n(portStart);
              if (t6.$gt(portStart, start) && J.$eq$(t6.$add(portStart, 1), pathStart)) {
                scheme = null;
                isSimple = false;
              } else {
                t7 = J.getInterceptor$n(queryStart);
                if (!(t7.$lt(queryStart, end) && t7.$eq(queryStart, J.$add$ns(pathStart, 2)) && J.startsWith$2$s(uri, "..", pathStart)))
                  t8 = t7.$gt(queryStart, J.$add$ns(pathStart, 2)) && J.startsWith$2$s(uri, "/..", t7.$sub(queryStart, 3));
                else
                  t8 = true;
                if (t8) {
                  scheme = null;
                  isSimple = false;
                } else {
                  if (t3.$eq(schemeEnd, t1.$add(start, 4))) {
                    t8 = J.getInterceptor$s(uri);
                    if (t8.startsWith$2(uri, "file", start)) {
                      if (t5.$le(hostStart, start)) {
                        if (!t8.startsWith$2(uri, "/", pathStart)) {
                          schemeAuth = "file:///";
                          delta = 3;
                        } else {
                          schemeAuth = "file://";
                          delta = 2;
                        }
                        uri = schemeAuth + t8.substring$2(uri, pathStart, end);
                        schemeEnd = t3.$sub(schemeEnd, start);
                        if (typeof start !== "number")
                          return H.iae(start);
                        t1 = delta - start;
                        queryStart = t7.$add(queryStart, t1);
                        fragmentStart = t4.$add(fragmentStart, t1);
                        end = uri.length;
                        start = 0;
                        hostStart = 7;
                        portStart = 7;
                        pathStart = 7;
                      } else {
                        t9 = J.getInterceptor(pathStart);
                        if (t9.$eq(pathStart, queryStart))
                          if (t1.$eq(start, 0) && t2.$eq(end, t8.get$length(uri))) {
                            uri = t8.replaceRange$3(uri, pathStart, queryStart, "/");
                            queryStart = t7.$add(queryStart, 1);
                            fragmentStart = t4.$add(fragmentStart, 1);
                            end = t2.$add(end, 1);
                          } else {
                            uri = t8.substring$2(uri, start, pathStart) + "/" + t8.substring$2(uri, queryStart, end);
                            schemeEnd = t3.$sub(schemeEnd, start);
                            hostStart = t5.$sub(hostStart, start);
                            portStart = t6.$sub(portStart, start);
                            pathStart = t9.$sub(pathStart, start);
                            if (typeof start !== "number")
                              return H.iae(start);
                            t1 = 1 - start;
                            queryStart = t7.$add(queryStart, t1);
                            fragmentStart = t4.$add(fragmentStart, t1);
                            end = uri.length;
                            start = 0;
                          }
                      }
                      scheme = "file";
                    } else if (t8.startsWith$2(uri, "http", start)) {
                      if (t6.$gt(portStart, start) && J.$eq$(t6.$add(portStart, 3), pathStart) && t8.startsWith$2(uri, "80", t6.$add(portStart, 1))) {
                        t1 = t1.$eq(start, 0) && t2.$eq(end, t8.get$length(uri));
                        t9 = J.getInterceptor$n(pathStart);
                        if (t1) {
                          uri = t8.replaceRange$3(uri, portStart, pathStart, "");
                          pathStart = t9.$sub(pathStart, 3);
                          queryStart = t7.$sub(queryStart, 3);
                          fragmentStart = t4.$sub(fragmentStart, 3);
                          end = t2.$sub(end, 3);
                        } else {
                          uri = t8.substring$2(uri, start, portStart) + t8.substring$2(uri, pathStart, end);
                          schemeEnd = t3.$sub(schemeEnd, start);
                          hostStart = t5.$sub(hostStart, start);
                          portStart = t6.$sub(portStart, start);
                          if (typeof start !== "number")
                            return H.iae(start);
                          t1 = 3 + start;
                          pathStart = t9.$sub(pathStart, t1);
                          queryStart = t7.$sub(queryStart, t1);
                          fragmentStart = t4.$sub(fragmentStart, t1);
                          end = uri.length;
                          start = 0;
                        }
                      }
                      scheme = "http";
                    } else
                      scheme = null;
                  } else if (t3.$eq(schemeEnd, t1.$add(start, 5)) && J.startsWith$2$s(uri, "https", start)) {
                    if (t6.$gt(portStart, start) && J.$eq$(t6.$add(portStart, 4), pathStart) && J.startsWith$2$s(uri, "443", t6.$add(portStart, 1))) {
                      t1 = t1.$eq(start, 0) && t2.$eq(end, J.get$length$asx(uri));
                      t8 = J.getInterceptor$asx(uri);
                      t9 = J.getInterceptor$n(pathStart);
                      if (t1) {
                        uri = t8.replaceRange$3(uri, portStart, pathStart, "");
                        pathStart = t9.$sub(pathStart, 4);
                        queryStart = t7.$sub(queryStart, 4);
                        fragmentStart = t4.$sub(fragmentStart, 4);
                        end = t2.$sub(end, 3);
                      } else {
                        uri = t8.substring$2(uri, start, portStart) + t8.substring$2(uri, pathStart, end);
                        schemeEnd = t3.$sub(schemeEnd, start);
                        hostStart = t5.$sub(hostStart, start);
                        portStart = t6.$sub(portStart, start);
                        if (typeof start !== "number")
                          return H.iae(start);
                        t1 = 4 + start;
                        pathStart = t9.$sub(pathStart, t1);
                        queryStart = t7.$sub(queryStart, t1);
                        fragmentStart = t4.$sub(fragmentStart, t1);
                        end = uri.length;
                        start = 0;
                      }
                    }
                    scheme = "https";
                  } else
                    scheme = null;
                  isSimple = true;
                }
              }
            }
          } else
            scheme = null;
          if (isSimple) {
            if (J.$gt$n(start, 0) || J.$lt$n(end, J.get$length$asx(uri))) {
              uri = J.substring$2$s(uri, start, end);
              schemeEnd = J.$sub$n(schemeEnd, start);
              hostStart = J.$sub$n(hostStart, start);
              portStart = J.$sub$n(portStart, start);
              pathStart = J.$sub$n(pathStart, start);
              queryStart = J.$sub$n(queryStart, start);
              fragmentStart = J.$sub$n(fragmentStart, start);
            }
            return new P._SimpleUri(uri, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, scheme, null);
          }
          return P._Uri__Uri$notSimple(uri, start, end, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, scheme);
        }, function(uri) {
          return P.Uri_parse(uri, 0, null);
        }, function(uri, start) {
          return P.Uri_parse(uri, start, null);
        }, "call$3", "call$1", "call$2", "core_Uri_parse$closure", 2, 4, 733, 7, 0, 40, [], 3, [], 5, [], "parse"],
        Uri_encodeComponent: [function(component) {
          return P._Uri__uriEncode(C.List_KIf, component, C.Utf8Codec_false, false);
        }, "call$1", "core_Uri_encodeComponent$closure", 2, 0, 28, 277, [], "encodeComponent"],
        Uri_encodeQueryComponent: [function(component, encoding) {
          return P._Uri__uriEncode(C.List_nxB, component, encoding, true);
        }, function(component) {
          return P.Uri_encodeQueryComponent(component, C.Utf8Codec_false);
        }, "call$2$encoding", "call$1", "core_Uri_encodeQueryComponent$closure", 2, 3, 410, 73, 277, [], 48, [], "encodeQueryComponent"],
        Uri_decodeComponent: [function(encodedComponent) {
          return P._Uri__uriDecode(encodedComponent, 0, J.get$length$asx(encodedComponent), C.Utf8Codec_false, false);
        }, "call$1", "core_Uri_decodeComponent$closure", 2, 0, 28, 606, [], "decodeComponent"],
        Uri_decodeQueryComponent: [function(encodedComponent, encoding) {
          return P._Uri__uriDecode(encodedComponent, 0, J.get$length$asx(encodedComponent), encoding, true);
        }, function(encodedComponent) {
          return P.Uri_decodeQueryComponent(encodedComponent, C.Utf8Codec_false);
        }, "call$2$encoding", "call$1", "core_Uri_decodeQueryComponent$closure", 2, 3, 410, 73, 606, [], 48, [], "decodeQueryComponent"],
        Uri_encodeFull: [function(uri) {
          return P._Uri__uriEncode(C.List_gnE, uri, C.Utf8Codec_false, false);
        }, "call$1", "core_Uri_encodeFull$closure", 2, 0, 28, 40, [], "encodeFull"],
        Uri_decodeFull: [function(uri) {
          return P._Uri__uriDecode(uri, 0, J.get$length$asx(uri), C.Utf8Codec_false, false);
        }, "call$1", "core_Uri_decodeFull$closure", 2, 0, 28, 40, [], "decodeFull"],
        Uri_splitQueryString: [function(query, encoding) {
          return C.JSArray_methods.fold$2(J.split$1$s(query, "&"), P.LinkedHashMap__makeEmpty(), new P.Uri_splitQueryString_closure(encoding));
        }, function(query) {
          return P.Uri_splitQueryString(query, C.Utf8Codec_false);
        }, "call$2$encoding", "call$1", "core_Uri_splitQueryString$closure", 2, 3, 735, 73, 129, [], 48, [], "splitQueryString"],
        Uri_parseIPv4Address: [function(host) {
          return P.Uri__parseIPv4Address(host, 0, J.get$length$asx(host));
        }, "call$1", "core_Uri_parseIPv4Address$closure", 2, 0, 141, 29, [], "parseIPv4Address"],
        Uri__parseIPv4Address: [function(host, start, end) {
          var t1, t2, result, t3, i, partStart, partIndex, t4, char, part, partIndex0;
          t1 = new P.Uri__parseIPv4Address_error(host);
          t2 = H._checkLength(4);
          result = new Uint8Array(t2);
          for (t3 = J.getInterceptor$s(host), i = start, partStart = i, partIndex = 0; t4 = J.getInterceptor$n(i), t4.$lt(i, end); i = t4.$add(i, 1)) {
            char = t3.codeUnitAt$1(host, i);
            if (char !== 46) {
              if ((char ^ 48) > 9)
                t1.call$2("invalid character", i);
            } else {
              if (partIndex === 3)
                t1.call$2("IPv4 address should contain exactly 4 parts", i);
              part = H.Primitives_parseInt(t3.substring$2(host, partStart, i), null, null);
              if (J.$gt$n(part, 255))
                t1.call$2("each part must be in the range 0..255", partStart);
              partIndex0 = partIndex + 1;
              if (partIndex >= t2)
                return H.ioore(result, partIndex);
              result[partIndex] = part;
              partStart = t4.$add(i, 1);
              partIndex = partIndex0;
            }
          }
          if (partIndex !== 3)
            t1.call$2("IPv4 address should contain exactly 4 parts", end);
          part = H.Primitives_parseInt(t3.substring$2(host, partStart, end), null, null);
          if (J.$gt$n(part, 255))
            t1.call$2("each part must be in the range 0..255", partStart);
          if (partIndex >= t2)
            return H.ioore(result, partIndex);
          result[partIndex] = part;
          return result;
        }, "call$3", "core_Uri__parseIPv4Address$closure", 6, 0, 736, 29, [], 3, [], 5, [], "_parseIPv4Address"],
        Uri_parseIPv6Address: [function(host, start, end) {
          var t1, t2, t3, parts, i, partStart, wildcardSeen, seenDot, t4, char, atEnd, isLastWildcard, last, bytes, index, value, wildCardLength, j;
          if (end == null)
            end = J.get$length$asx(host);
          t1 = new P.Uri_parseIPv6Address_error(host);
          t2 = new P.Uri_parseIPv6Address_parseHex(host, t1);
          t3 = J.getInterceptor$asx(host);
          if (J.$lt$n(t3.get$length(host), 2))
            t1.call$1("address is too short");
          parts = [];
          for (i = start, partStart = i, wildcardSeen = false, seenDot = false; t4 = J.getInterceptor$n(i), t4.$lt(i, end); i = J.$add$ns(i, 1)) {
            char = t3.codeUnitAt$1(host, i);
            if (char === 58) {
              if (t4.$eq(i, start)) {
                i = t4.$add(i, 1);
                if (t3.codeUnitAt$1(host, i) !== 58)
                  t1.call$2("invalid start colon.", i);
                partStart = i;
              }
              t4 = J.getInterceptor(i);
              if (t4.$eq(i, partStart)) {
                if (wildcardSeen)
                  t1.call$2("only one wildcard `::` is allowed", i);
                parts.push(-1);
                wildcardSeen = true;
              } else
                parts.push(t2.call$2(partStart, i));
              partStart = t4.$add(i, 1);
            } else if (char === 46)
              seenDot = true;
          }
          if (parts.length === 0)
            t1.call$1("too few parts");
          atEnd = J.$eq$(partStart, end);
          isLastWildcard = J.$eq$(C.JSArray_methods.get$last(parts), -1);
          if (atEnd && !isLastWildcard)
            t1.call$2("expected a part after last `:`", end);
          if (!atEnd)
            if (!seenDot)
              parts.push(t2.call$2(partStart, end));
            else {
              last = P.Uri__parseIPv4Address(host, partStart, end);
              t2 = J.$shl$n(last[0], 8);
              t3 = last[1];
              if (typeof t3 !== "number")
                return H.iae(t3);
              parts.push((t2 | t3) >>> 0);
              t3 = J.$shl$n(last[2], 8);
              t2 = last[3];
              if (typeof t2 !== "number")
                return H.iae(t2);
              parts.push((t3 | t2) >>> 0);
            }
          if (wildcardSeen) {
            if (parts.length > 7)
              t1.call$1("an address with a wildcard must have less than 7 parts");
          } else if (parts.length !== 8)
            t1.call$1("an address without a wildcard must contain exactly 8 parts");
          bytes = new Uint8Array(16);
          for (i = 0, index = 0; i < parts.length; ++i) {
            value = parts[i];
            t1 = J.getInterceptor(value);
            if (t1.$eq(value, -1)) {
              wildCardLength = 9 - parts.length;
              for (j = 0; j < wildCardLength; ++j) {
                if (index < 0 || index >= 16)
                  return H.ioore(bytes, index);
                bytes[index] = 0;
                t1 = index + 1;
                if (t1 >= 16)
                  return H.ioore(bytes, t1);
                bytes[t1] = 0;
                index += 2;
              }
            } else {
              t2 = t1.$shr(value, 8);
              if (index < 0 || index >= 16)
                return H.ioore(bytes, index);
              bytes[index] = t2;
              t2 = index + 1;
              t1 = t1.$and(value, 255);
              if (t2 >= 16)
                return H.ioore(bytes, t2);
              bytes[t2] = t1;
              index += 2;
            }
          }
          return bytes;
        }, function(host) {
          return P.Uri_parseIPv6Address(host, 0, null);
        }, function(host, start) {
          return P.Uri_parseIPv6Address(host, start, null);
        }, "call$3", "call$1", "call$2", "core_Uri_parseIPv6Address$closure", 2, 4, 172, 7, 0, 29, [], 3, [], 5, [], "parseIPv6Address"]
      }
    },
    "+Uri": [1],
    Uri_splitQueryString_closure: {
      "^": "Closure:12;encoding",
      call$2: [function(map, element) {
        var t1, index, t2, key, value;
        t1 = J.getInterceptor$asx(element);
        index = t1.indexOf$1(element, "=");
        t2 = J.getInterceptor(index);
        if (t2.$eq(index, -1)) {
          if (!t1.$eq(element, ""))
            J.$indexSet$ax(map, P._Uri__uriDecode(element, 0, t1.get$length(element), this.encoding, true), "");
        } else if (!t2.$eq(index, 0)) {
          key = t1.substring$2(element, 0, index);
          value = t1.substring$1(element, t2.$add(index, 1));
          t1 = this.encoding;
          J.$indexSet$ax(map, P._Uri__uriDecode(key, 0, key.length, t1, true), P._Uri__uriDecode(value, 0, value.length, t1, true));
        }
        return map;
      }, null, null, 4, 0, 12, 55, [], 31, [], "call"]
    },
    "+ Uri_splitQueryString_closure": [2],
    Uri__parseIPv4Address_error: {
      "^": "Closure:285;host",
      call$2: [function(msg, position) {
        throw H.wrapException(new P.FormatException("Illegal IPv4 address, " + msg, this.host, position));
      }, null, null, 4, 0, 285, 92, [], 253, [], "call"]
    },
    "+ Uri__parseIPv4Address_error": [2],
    Uri_parseIPv6Address_error: {
      "^": "Closure:531;host",
      call$2: [function(msg, position) {
        throw H.wrapException(new P.FormatException("Illegal IPv6 address, " + msg, this.host, position));
      }, function(msg) {
        return this.call$2(msg, null);
      }, "call$1", null, null, null, 2, 2, 531, 0, 92, [], 253, [], "call"]
    },
    "+ Uri_parseIPv6Address_error": [2],
    Uri_parseIPv6Address_parseHex: {
      "^": "Closure:70;host,error",
      call$2: [function(start, end) {
        var value, t1;
        if (J.$gt$n(J.$sub$n(end, start), 4))
          this.error.call$2("an IPv6 part can only contain a maximum of 4 hex digits", start);
        value = H.Primitives_parseInt(J.substring$2$s(this.host, start, end), 16, null);
        t1 = J.getInterceptor$n(value);
        if (t1.$lt(value, 0) || t1.$gt(value, 65535))
          this.error.call$2("each part must be in the range of `0x0..0xFFFF`", start);
        return value;
      }, null, null, 4, 0, 70, 3, [], 5, [], "call"]
    },
    "+ Uri_parseIPv6Address_parseHex": [2],
    _Uri: {
      "^": "Object;scheme<-9,_userInfo<-9,_host<-9,_port@-0,path<-9,_query<-9,_fragment<-9,_pathSegments@-61,_text@-9,_hashCodeCache@-0,_queryParameters@-82,_queryParameterLists@-259",
      get$authority: [function() {
        var sb, t1;
        if (this._host == null)
          return "";
        sb = new P.StringBuffer("");
        this._writeAuthority$1(sb);
        t1 = sb._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, null, null, 1, 0, 7, "authority"],
      get$userInfo: [function() {
        return this._userInfo;
      }, null, null, 1, 0, 7, "userInfo"],
      get$host: [function() {
        var t1, t2;
        t1 = this._host;
        if (t1 == null)
          return "";
        t2 = J.getInterceptor$s(t1);
        if (t2.startsWith$1(t1, "["))
          return t2.substring$2(t1, 1, J.$sub$n(t2.get$length(t1), 1));
        return t1;
      }, null, null, 1, 0, 7, "host"],
      get$port: [function() {
        var t1 = this._port;
        if (t1 == null)
          return P._Uri__defaultPort(this.scheme);
        return t1;
      }, null, null, 1, 0, 11, "port"],
      get$query: [function() {
        var t1 = this._query;
        return t1 == null ? "" : t1;
      }, null, null, 1, 0, 7, "query"],
      get$fragment: [function() {
        var t1 = this._fragment;
        return t1 == null ? "" : t1;
      }, null, null, 1, 0, 7, "fragment"],
      isScheme$1: [function(scheme) {
        var thisScheme = this.scheme;
        if (scheme == null)
          return J.get$isEmpty$asx(thisScheme);
        if (!J.$eq$(J.get$length$asx(scheme), J.get$length$asx(thisScheme)))
          return false;
        return P._Uri__compareScheme(scheme, thisScheme);
      }, "call$1", "get$isScheme", 2, 0, 30, 44, [], "isScheme"],
      replace$9$fragment$host$path$pathSegments$port$query$queryParameters$scheme$userInfo: [function(fragment, host, path, pathSegments, port, query, queryParameters, scheme, userInfo) {
        var scheme0, schemeChanged, isFile, host0, hasAuthority, t1;
        scheme0 = this.scheme;
        if (scheme != null) {
          scheme = P._Uri__makeScheme(scheme, 0, J.get$length$asx(scheme));
          schemeChanged = !J.$eq$(scheme, scheme0);
        } else {
          scheme = scheme0;
          schemeChanged = false;
        }
        isFile = J.$eq$(scheme, "file");
        userInfo = userInfo != null ? P._Uri__makeUserInfo(userInfo, 0, J.get$length$asx(userInfo)) : this._userInfo;
        if (port != null)
          port = P._Uri__makePort(port, scheme);
        else {
          port = this._port;
          if (schemeChanged)
            port = P._Uri__makePort(port, scheme);
        }
        if (host != null)
          host = P._Uri__makeHost(host, 0, J.get$length$asx(host), false);
        else {
          host0 = this._host;
          if (host0 != null)
            host = host0;
          else if (J.get$isNotEmpty$asx(userInfo) || port != null || isFile)
            host = "";
        }
        hasAuthority = host != null;
        t1 = path == null;
        if (!t1 || pathSegments != null)
          path = P._Uri__makePath(path, 0, t1 ? 0 : J.get$length$asx(path), pathSegments, scheme, hasAuthority);
        else {
          path = this.path;
          if (!isFile)
            t1 = hasAuthority && J.get$isEmpty$asx(path) !== true;
          else
            t1 = true;
          if (t1 && !J.startsWith$1$s(path, "/"))
            path = C.JSString_methods.$add("/", path);
        }
        t1 = query == null;
        if (!t1 || queryParameters != null)
          query = P._Uri__makeQuery(query, 0, t1 ? 0 : J.get$length$asx(query), queryParameters);
        else
          query = this._query;
        return new P._Uri(scheme, userInfo, host, port, path, query, fragment != null ? P._Uri__makeFragment(fragment, 0, J.get$length$asx(fragment)) : this._fragment, null, null, null, null, null);
      }, function() {
        return this.replace$9$fragment$host$path$pathSegments$port$query$queryParameters$scheme$userInfo(null, null, null, null, null, null, null, null, null);
      }, "replace$0", function(path) {
        return this.replace$9$fragment$host$path$pathSegments$port$query$queryParameters$scheme$userInfo(null, null, path, null, null, null, null, null, null);
      }, "replace$1$path", function(scheme) {
        return this.replace$9$fragment$host$path$pathSegments$port$query$queryParameters$scheme$userInfo(null, null, null, null, null, null, null, scheme, null);
      }, "replace$1$scheme", "call$9$fragment$host$path$pathSegments$port$query$queryParameters$scheme$userInfo", "call$0", "call$1$path", "call$1$scheme", "get$replace", 0, 19, 273, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, [], 209, [], 29, [], 26, [], 10, [], 213, [], 129, [], 107, [], 216, [], "replace"],
      removeFragment$0: [function() {
        if (this._fragment == null)
          return this;
        return new P._Uri(this.scheme, this._userInfo, this._host, this._port, this.path, this._query, null, null, null, null, null, null);
      }, "call$0", "get$removeFragment", 0, 0, 43, "removeFragment"],
      get$pathSegments: [function() {
        var result, pathToSplit, t1;
        result = this._pathSegments;
        if (result != null)
          return result;
        pathToSplit = this.path;
        t1 = J.getInterceptor$asx(pathToSplit);
        if (t1.get$isNotEmpty(pathToSplit) && t1.codeUnitAt$1(pathToSplit, 0) === 47)
          pathToSplit = t1.substring$1(pathToSplit, 1);
        t1 = J.getInterceptor(pathToSplit);
        result = t1.$eq(pathToSplit, "") ? C.List_empty4 : P.List_List$unmodifiable(new H.MappedListIterable(t1.split$1(pathToSplit, "/"), P.core_Uri_decodeComponent$closure(), [null, null]), P.String);
        this._pathSegments = result;
        return result;
      }, null, null, 1, 0, 93, "pathSegments"],
      get$queryParameters: [function() {
        var t1, t2;
        t1 = this._queryParameters;
        if (t1 == null) {
          t1 = this._query;
          t2 = P.String;
          t2 = new P.UnmodifiableMapView(P.Uri_splitQueryString(t1 == null ? "" : t1, C.Utf8Codec_false), [t2, t2]);
          this._queryParameters = t2;
          t1 = t2;
        }
        return t1;
      }, null, null, 1, 0, 106, "queryParameters"],
      get$queryParametersAll: [function() {
        var t1, queryParameterLists, t2, key, result;
        t1 = this._queryParameterLists;
        if (t1 == null) {
          t1 = this._query;
          queryParameterLists = P._Uri__splitQueryStringAll(t1 == null ? "" : t1, C.Utf8Codec_false);
          for (t1 = queryParameterLists.get$keys(), t1 = t1.get$iterator(t1), t2 = P.String; t1.moveNext$0();) {
            key = t1.get$current();
            result = P.List_List$from(queryParameterLists.$index(0, key), false, t2);
            result.fixed$length = Array;
            result.immutable$list = Array;
            queryParameterLists.$indexSet(0, key, result);
          }
          t1 = H.ConstantMap_ConstantMap$from(queryParameterLists, t2, [P.List, P.String]);
          this._queryParameterLists = t1;
        }
        return t1;
      }, null, null, 1, 0, 415, "queryParametersAll"],
      normalizePath$0: [function() {
        var t1, path;
        t1 = this.path;
        path = P._Uri__normalizePath(t1, this.scheme, this._host != null);
        if (path == null ? t1 == null : path === t1)
          return this;
        return this.replace$1$path(path);
      }, "call$0", "get$normalizePath", 0, 0, 43, "normalizePath"],
      get$isAbsolute: [function() {
        if (!J.$eq$(this.scheme, "")) {
          var t1 = this._fragment;
          t1 = J.$eq$(t1 == null ? "" : t1, "");
        } else
          t1 = false;
        return t1;
      }, null, null, 1, 0, 5, "isAbsolute"],
      _mergePaths$2: [function(base, reference) {
        var t1, backCount, refStart, t2, baseEnd, t3, newEnd, t4, delta, t5;
        for (t1 = J.getInterceptor$s(reference), backCount = 0, refStart = 0; t1.startsWith$2(reference, "../", refStart);) {
          refStart += 3;
          ++backCount;
        }
        t2 = J.getInterceptor$asx(base);
        baseEnd = t2.lastIndexOf$1(base, "/");
        while (true) {
          t3 = J.getInterceptor$n(baseEnd);
          if (!(t3.$gt(baseEnd, 0) && backCount > 0))
            break;
          newEnd = t2.lastIndexOf$2(base, "/", t3.$sub(baseEnd, 1));
          t4 = J.getInterceptor$n(newEnd);
          if (t4.$lt(newEnd, 0))
            break;
          delta = t3.$sub(baseEnd, newEnd);
          t5 = J.getInterceptor(delta);
          if (t5.$eq(delta, 2) || t5.$eq(delta, 3))
            if (t2.codeUnitAt$1(base, t4.$add(newEnd, 1)) === 46)
              t4 = t5.$eq(delta, 2) || t2.codeUnitAt$1(base, t4.$add(newEnd, 2)) === 46;
            else
              t4 = false;
          else
            t4 = false;
          if (t4)
            break;
          --backCount;
          baseEnd = newEnd;
        }
        return t2.replaceRange$3(base, t3.$add(baseEnd, 1), null, t1.substring$1(reference, refStart - 3 * backCount));
      }, "call$2", "get$_mergePaths", 4, 0, 1202, 613, [], 187, [], "_mergePaths"],
      resolve$1: [function(reference) {
        return this.resolveUri$1(P.Uri_parse(reference, 0, null));
      }, "call$1", "get$resolve", 2, 0, 310, 187, [], "resolve"],
      resolveUri$1: [function(reference) {
        var targetScheme, targetUserInfo, targetHost, targetPort, targetPath, targetQuery, t1, t2, mergedPath, t3;
        if (J.get$isNotEmpty$asx(reference.get$scheme())) {
          targetScheme = reference.get$scheme();
          if (reference.get$hasAuthority()) {
            targetUserInfo = reference.get$userInfo();
            targetHost = reference.get$host();
            targetPort = reference.get$hasPort() ? reference.get$port() : null;
          } else {
            targetUserInfo = "";
            targetHost = null;
            targetPort = null;
          }
          targetPath = P._Uri__removeDotSegments(reference.get$path());
          targetQuery = reference.get$hasQuery() ? reference.get$query() : null;
        } else {
          targetScheme = this.scheme;
          if (reference.get$hasAuthority()) {
            targetUserInfo = reference.get$userInfo();
            targetHost = reference.get$host();
            targetPort = P._Uri__makePort(reference.get$hasPort() ? reference.get$port() : null, targetScheme);
            targetPath = P._Uri__removeDotSegments(reference.get$path());
            targetQuery = reference.get$hasQuery() ? reference.get$query() : null;
          } else {
            targetUserInfo = this._userInfo;
            targetHost = this._host;
            targetPort = this._port;
            if (J.$eq$(reference.get$path(), "")) {
              targetPath = this.path;
              targetQuery = reference.get$hasQuery() ? reference.get$query() : this._query;
            } else {
              if (reference.get$hasAbsolutePath())
                targetPath = P._Uri__removeDotSegments(reference.get$path());
              else {
                t1 = this.path;
                t2 = J.getInterceptor$asx(t1);
                if (t2.get$isEmpty(t1) === true)
                  if (targetHost == null)
                    targetPath = !J.get$isNotEmpty$asx(targetScheme) ? reference.get$path() : P._Uri__removeDotSegments(reference.get$path());
                  else
                    targetPath = P._Uri__removeDotSegments(C.JSString_methods.$add("/", reference.get$path()));
                else {
                  mergedPath = this._mergePaths$2(t1, reference.get$path());
                  t3 = J.getInterceptor$asx(targetScheme);
                  if (t3.get$isNotEmpty(targetScheme) || targetHost != null || t2.startsWith$1(t1, "/"))
                    targetPath = P._Uri__removeDotSegments(mergedPath);
                  else
                    targetPath = P._Uri__normalizeRelativePath(mergedPath, t3.get$isNotEmpty(targetScheme) || targetHost != null);
                }
              }
              targetQuery = reference.get$hasQuery() ? reference.get$query() : null;
            }
          }
        }
        return new P._Uri(targetScheme, targetUserInfo, targetHost, targetPort, targetPath, targetQuery, reference.get$hasFragment() ? reference.get$fragment() : null, null, null, null, null, null);
      }, "call$1", "get$resolveUri", 2, 0, 311, 187, [], "resolveUri"],
      get$hasScheme: [function() {
        return J.get$isNotEmpty$asx(this.scheme);
      }, null, null, 1, 0, 5, "hasScheme"],
      get$hasAuthority: [function() {
        return this._host != null;
      }, null, null, 1, 0, 5, "hasAuthority"],
      get$hasPort: [function() {
        return this._port != null;
      }, null, null, 1, 0, 5, "hasPort"],
      get$hasQuery: [function() {
        return this._query != null;
      }, null, null, 1, 0, 5, "hasQuery"],
      get$hasFragment: [function() {
        return this._fragment != null;
      }, null, null, 1, 0, 5, "hasFragment"],
      get$hasEmptyPath: [function() {
        return J.get$isEmpty$asx(this.path);
      }, null, null, 1, 0, 5, "hasEmptyPath"],
      get$hasAbsolutePath: [function() {
        return J.startsWith$1$s(this.path, "/");
      }, null, null, 1, 0, 5, "hasAbsolutePath"],
      get$origin: [function() {
        var t1, t2;
        t1 = this.scheme;
        t2 = J.getInterceptor(t1);
        if (t2.$eq(t1, ""))
          throw H.wrapException(new P.StateError("Cannot use origin without a scheme: " + H.S(this)));
        if (!t2.$eq(t1, "http") && !t2.$eq(t1, "https"))
          throw H.wrapException(new P.StateError("Origin is only applicable schemes http and https: " + H.S(this)));
        t2 = this._host;
        if (t2 == null || J.$eq$(t2, ""))
          throw H.wrapException(new P.StateError("A " + H.S(t1) + ": URI should have a non-empty host name: " + H.S(this)));
        if (this._port == null)
          return H.S(t1) + "://" + H.S(t2);
        return H.S(t1) + "://" + H.S(t2) + ":" + H.S(this._port);
      }, null, null, 1, 0, 7, "origin"],
      toFilePath$1$windows: [function(windows) {
        var t1, t2, pathSegments;
        t1 = this.scheme;
        t2 = J.getInterceptor(t1);
        if (!t2.$eq(t1, "") && !t2.$eq(t1, "file"))
          throw H.wrapException(new P.UnsupportedError("Cannot extract a file path from a " + H.S(t1) + " URI"));
        t1 = this._query;
        if (!J.$eq$(t1 == null ? "" : t1, ""))
          throw H.wrapException(new P.UnsupportedError("Cannot extract a file path from a URI with a query component"));
        t1 = this._fragment;
        if (!J.$eq$(t1 == null ? "" : t1, ""))
          throw H.wrapException(new P.UnsupportedError("Cannot extract a file path from a URI with a fragment component"));
        if ((windows == null ? false : windows) === true)
          t1 = P._Uri__toWindowsFilePath(this);
        else {
          if (this._host != null && !J.$eq$(this.get$host(), ""))
            H.throwExpression(new P.UnsupportedError("Cannot extract a non-Windows file path from a file URI with an authority"));
          pathSegments = this.get$pathSegments();
          P._Uri__checkNonWindowsPathReservedCharacters(pathSegments, false);
          t1 = P.StringBuffer__writeAll(J.startsWith$1$s(this.path, "/") ? "/" : "", pathSegments, "/");
          t1 = t1.charCodeAt(0) == 0 ? t1 : t1;
        }
        return t1;
      }, function() {
        return this.toFilePath$1$windows(null);
      }, "toFilePath$0", "call$1$windows", "call$0", "get$toFilePath", 0, 3, 312, 0, 170, [], "toFilePath"],
      _toFilePath$0: [function() {
        var pathSegments, t1;
        if (this._host != null && !J.$eq$(this.get$host(), ""))
          throw H.wrapException(new P.UnsupportedError("Cannot extract a non-Windows file path from a file URI with an authority"));
        pathSegments = this.get$pathSegments();
        P._Uri__checkNonWindowsPathReservedCharacters(pathSegments, false);
        t1 = P.StringBuffer__writeAll(J.startsWith$1$s(this.path, "/") ? "/" : "", pathSegments, "/");
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, "call$0", "get$_toFilePath", 0, 0, 7, "_toFilePath"],
      get$_isPathAbsolute: [function() {
        var t1 = this.path;
        return t1 != null && J.startsWith$1$s(t1, "/");
      }, null, null, 1, 0, 5, "_isPathAbsolute"],
      _writeAuthority$1: [function(ss) {
        var t1 = this._userInfo;
        if (J.get$isNotEmpty$asx(t1)) {
          ss.write$1(t1);
          ss.write$1("@");
        }
        t1 = this._host;
        if (t1 != null)
          ss.write$1(t1);
        if (this._port != null) {
          ss.write$1(":");
          ss.write$1(this._port);
        }
      }, "call$1", "get$_writeAuthority", 2, 0, 984, 656, [], "_writeAuthority"],
      get$data: [function() {
        return J.$eq$(this.scheme, "data") ? P.UriData_UriData$fromUri(this) : null;
      }, null, null, 1, 0, 272, "data"],
      toString$0: [function(_) {
        var t1 = this._text;
        if (t1 == null) {
          t1 = this._initializeText$0();
          this._text = t1;
        }
        return t1;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      _initializeText$0: [function() {
        var sb, t1, t2, t3;
        sb = new P.StringBuffer("");
        t1 = this.scheme;
        t2 = J.getInterceptor$asx(t1);
        if (t2.get$isNotEmpty(t1)) {
          t3 = H.S(t1);
          sb._contents = t3;
          t3 += ":";
          sb._contents = t3;
        } else
          t3 = "";
        if (this._host != null || t2.$eq(t1, "file")) {
          sb._contents = t3 + "//";
          this._writeAuthority$1(sb);
        }
        t1 = sb._contents += H.S(this.path);
        t2 = this._query;
        if (t2 != null) {
          sb._contents = t1 + "?";
          t1 = sb._contents += H.S(t2);
        }
        t2 = this._fragment;
        if (t2 != null) {
          sb._contents = t1 + "#";
          t1 = sb._contents += H.S(t2);
        }
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, "call$0", "get$_initializeText", 0, 0, 7, "_initializeText"],
      $eq: [function(_, other) {
        var t1, t2;
        if (other == null)
          return false;
        if (this === other)
          return true;
        if (!!J.getInterceptor(other).$isUri) {
          if (J.$eq$(this.scheme, other.get$scheme()))
            if (this._host != null === other.get$hasAuthority())
              if (J.$eq$(this._userInfo, other.get$userInfo()))
                if (J.$eq$(this.get$host(), other.get$host()))
                  if (J.$eq$(this.get$port(), other.get$port()))
                    if (J.$eq$(this.path, other.get$path())) {
                      t1 = this._query;
                      t2 = t1 == null;
                      if (!t2 === other.get$hasQuery()) {
                        if (t2)
                          t1 = "";
                        if (J.$eq$(t1, other.get$query())) {
                          t1 = this._fragment;
                          t2 = t1 == null;
                          if (!t2 === other.get$hasFragment()) {
                            if (t2)
                              t1 = "";
                            t1 = J.$eq$(t1, other.get$fragment());
                          } else
                            t1 = false;
                        } else
                          t1 = false;
                      } else
                        t1 = false;
                    } else
                      t1 = false;
                  else
                    t1 = false;
                else
                  t1 = false;
              else
                t1 = false;
            else
              t1 = false;
          else
            t1 = false;
          return t1;
        }
        return false;
      }, null, "get$==", 2, 0, 24, 2, [], "=="],
      get$hashCode: [function(_) {
        var t1 = this._hashCodeCache;
        if (t1 == null) {
          t1 = this._text;
          if (t1 == null) {
            t1 = this._initializeText$0();
            this._text = t1;
          }
          t1 = J.get$hashCode$(t1);
          this._hashCodeCache = t1;
        }
        return t1;
      }, null, null, 1, 0, 11, "hashCode"],
      $isUri: 1,
      static: {
        "^": "_Uri__unreservedTable<-10,_Uri__unreserved2396Table<-10,_Uri__encodeFullTable<-10,_Uri__schemeTable<-10,_Uri__schemeLowerTable<-10,_Uri__subDelimitersTable<-10,_Uri__genDelimitersTable<-10,_Uri__userinfoTable<-10,_Uri__regNameTable<-10,_Uri__pathCharTable<-10,_Uri__pathCharOrSlashTable<-10,_Uri__queryCharTable<-10,_Uri__needsNoEncoding<-260",
        _Uri$_internal: [function(scheme, _userInfo, _host, _port, path, _query, _fragment) {
          return new P._Uri(scheme, _userInfo, _host, _port, path, _query, _fragment, null, null, null, null, null);
        }, null, null, 14, 0, 737, 44, [], 669, [], 667, [], 665, [], 10, [], 663, [], 661, [], "new _Uri$_internal"],
        _Uri__Uri$notSimple: [function(uri, start, end, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, scheme) {
          var t1, userInfoStart, userInfo, host, port, path, query;
          if (scheme == null) {
            t1 = J.getInterceptor$n(schemeEnd);
            if (t1.$gt(schemeEnd, start))
              scheme = P._Uri__makeScheme(uri, start, schemeEnd);
            else {
              if (t1.$eq(schemeEnd, start))
                P._Uri__fail(uri, start, "Invalid empty scheme");
              scheme = "";
            }
          }
          t1 = J.getInterceptor$n(hostStart);
          if (t1.$gt(hostStart, start)) {
            userInfoStart = J.$add$ns(schemeEnd, 3);
            userInfo = J.$lt$n(userInfoStart, hostStart) ? P._Uri__makeUserInfo(uri, userInfoStart, t1.$sub(hostStart, 1)) : "";
            host = P._Uri__makeHost(uri, hostStart, portStart, false);
            t1 = J.getInterceptor$ns(portStart);
            port = J.$lt$n(t1.$add(portStart, 1), pathStart) ? P._Uri__makePort(H.Primitives_parseInt(J.substring$2$s(uri, t1.$add(portStart, 1), pathStart), null, new P.closure1(uri, portStart)), scheme) : null;
          } else {
            userInfo = "";
            host = null;
            port = null;
          }
          path = P._Uri__makePath(uri, pathStart, queryStart, null, scheme, host != null);
          t1 = J.getInterceptor$n(queryStart);
          query = t1.$lt(queryStart, fragmentStart) ? P._Uri__makeQuery(uri, t1.$add(queryStart, 1), fragmentStart, null) : null;
          t1 = J.getInterceptor$n(fragmentStart);
          return new P._Uri(scheme, userInfo, host, port, path, query, t1.$lt(fragmentStart, end) ? P._Uri__makeFragment(uri, t1.$add(fragmentStart, 1), end) : null, null, null, null, null, null);
        }, null, null, 20, 0, 738, 40, [], 3, [], 5, [], 655, [], 654, [], 653, [], 652, [], 650, [], 649, [], 44, [], "new _Uri$notSimple"],
        _Uri__Uri: [function(fragment, host, path, pathSegments, port, query, queryParameters, scheme, userInfo) {
          var t1, isFile, t2, hasAuthority;
          scheme = P._Uri__makeScheme(scheme, 0, scheme == null ? 0 : J.get$length$asx(scheme));
          userInfo = P._Uri__makeUserInfo(userInfo, 0, userInfo == null ? 0 : J.get$length$asx(userInfo));
          host = P._Uri__makeHost(host, 0, host == null ? 0 : J.get$length$asx(host), false);
          if (J.$eq$(query, ""))
            query = null;
          query = P._Uri__makeQuery(query, 0, query == null ? 0 : J.get$length$asx(query), queryParameters);
          fragment = P._Uri__makeFragment(fragment, 0, fragment == null ? 0 : J.get$length$asx(fragment));
          port = P._Uri__makePort(port, scheme);
          t1 = J.getInterceptor(scheme);
          isFile = t1.$eq(scheme, "file");
          if (host == null)
            t2 = userInfo.length !== 0 || port != null || isFile;
          else
            t2 = false;
          if (t2)
            host = "";
          t2 = host == null;
          hasAuthority = !t2;
          path = P._Uri__makePath(path, 0, path == null ? 0 : J.get$length$asx(path), pathSegments, scheme, hasAuthority);
          if (t1.get$isEmpty(scheme) === true && t2 && !J.startsWith$1$s(path, "/"))
            path = P._Uri__normalizeRelativePath(path, t1.get$isNotEmpty(scheme) || hasAuthority);
          else
            path = P._Uri__removeDotSegments(path);
          return new P._Uri(scheme, userInfo, t2 && J.startsWith$1$s(path, "//") ? "" : host, port, path, query, fragment, null, null, null, null, null);
        }, null, null, 0, 19, 739, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, [], 209, [], 29, [], 26, [], 10, [], 213, [], 129, [], 107, [], 216, [], "new _Uri"],
        _Uri__Uri$http: [function(authority, unencodedPath, queryParameters) {
          return P._Uri__makeHttpUri("http", authority, unencodedPath, queryParameters);
        }, null, null, 4, 2, 411, 0, 217, [], 218, [], 107, [], "new _Uri$http"],
        _Uri__Uri$https: [function(authority, unencodedPath, queryParameters) {
          return P._Uri__makeHttpUri("https", authority, unencodedPath, queryParameters);
        }, null, null, 4, 2, 411, 0, 217, [], 218, [], 107, [], "new _Uri$https"],
        _Uri__defaultPort: [function(scheme) {
          var t1 = J.getInterceptor(scheme);
          if (t1.$eq(scheme, "http"))
            return 80;
          if (t1.$eq(scheme, "https"))
            return 443;
          return 0;
        }, "call$1", "core__Uri__defaultPort$closure", 2, 0, 31, 44, [], "_defaultPort"],
        _Uri__compareScheme: [function(scheme, uri) {
          var t1, t2, i, t3, schemeChar, uriChar, delta, lowerChar;
          t1 = J.getInterceptor$asx(scheme);
          t2 = J.getInterceptor$s(uri);
          i = 0;
          while (true) {
            t3 = t1.get$length(scheme);
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (!(i < t3))
              break;
            c$0: {
              schemeChar = t1.codeUnitAt$1(scheme, i);
              uriChar = t2.codeUnitAt$1(uri, i);
              delta = schemeChar ^ uriChar;
              if (delta !== 0) {
                if (delta === 32) {
                  lowerChar = uriChar | delta;
                  if (97 <= lowerChar && lowerChar <= 122)
                    break c$0;
                }
                return false;
              }
            }
            ++i;
          }
          return true;
        }, "call$2", "core__Uri__compareScheme$closure", 4, 0, 412, 44, [], 40, [], "_compareScheme"],
        _Uri__fail: [function(uri, index, message) {
          throw H.wrapException(new P.FormatException(message, uri, index));
        }, "call$3", "core__Uri__fail$closure", 6, 0, 742, 40, [], 14, [], 17, [], "_fail"],
        _Uri__makeHttpUri: [function(scheme, authority, unencodedPath, queryParameters) {
          var userInfo, hostStart, t1, i, t2, hostEnd, port, portString, host;
          if (authority != null && J.get$isNotEmpty$asx(authority)) {
            t1 = J.getInterceptor$asx(authority);
            i = 0;
            while (true) {
              t2 = t1.get$length(authority);
              if (typeof t2 !== "number")
                return H.iae(t2);
              if (!(i < t2)) {
                userInfo = "";
                hostStart = 0;
                break;
              }
              if (t1.codeUnitAt$1(authority, i) === 64) {
                userInfo = t1.substring$2(authority, 0, i);
                hostStart = i + 1;
                break;
              }
              ++i;
            }
            t2 = t1.get$length(authority);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (hostStart < t2 && t1.codeUnitAt$1(authority, hostStart) === 91) {
              hostEnd = hostStart;
              while (true) {
                t2 = t1.get$length(authority);
                if (typeof t2 !== "number")
                  return H.iae(t2);
                if (!(hostEnd < t2))
                  break;
                if (t1.codeUnitAt$1(authority, hostEnd) === 93)
                  break;
                ++hostEnd;
              }
              if (hostEnd === t1.get$length(authority))
                throw H.wrapException(new P.FormatException("Invalid IPv6 host entry.", authority, hostStart));
              P.Uri_parseIPv6Address(authority, hostStart + 1, hostEnd);
              ++hostEnd;
              if (hostEnd !== t1.get$length(authority) && t1.codeUnitAt$1(authority, hostEnd) !== 58)
                throw H.wrapException(new P.FormatException("Invalid end of authority", authority, hostEnd));
            } else
              hostEnd = hostStart;
            while (true) {
              t2 = t1.get$length(authority);
              if (typeof t2 !== "number")
                return H.iae(t2);
              if (!(hostEnd < t2)) {
                port = null;
                break;
              }
              if (t1.codeUnitAt$1(authority, hostEnd) === 58) {
                portString = t1.substring$1(authority, hostEnd + 1);
                port = portString.length !== 0 ? H.Primitives_parseInt(portString, null, null) : null;
                break;
              }
              ++hostEnd;
            }
            host = t1.substring$2(authority, hostStart, hostEnd);
          } else {
            userInfo = "";
            host = null;
            port = null;
          }
          return P._Uri__Uri(null, host, null, J.split$1$s(unencodedPath, "/"), port, null, queryParameters, scheme, userInfo);
        }, "call$4", "core__Uri__makeHttpUri$closure", 8, 0, 743, 44, [], 217, [], 218, [], 107, [], "_makeHttpUri"],
        _Uri__Uri$file: [function(path, windows) {
          return (windows == null ? false : windows) === true ? P._Uri__makeWindowsFileUrl(path, false) : P._Uri__makeFileUri(path, false);
        }, null, null, 2, 3, 413, 0, 10, [], 170, [], "new _Uri$file"],
        _Uri__Uri$directory: [function(path, windows) {
          return (windows == null ? false : windows) === true ? P._Uri__makeWindowsFileUrl(path, true) : P._Uri__makeFileUri(path, true);
        }, null, null, 2, 3, 413, 0, 10, [], 170, [], "new _Uri$directory"],
        _Uri__isWindows: [function() {
          return false;
        }, null, null, 1, 0, 5, "_isWindows"],
        _Uri__checkNonWindowsPathReservedCharacters: [function(segments, argumentError) {
          J.forEach$1$ax(segments, new P._Uri__checkNonWindowsPathReservedCharacters_closure(argumentError));
        }, "call$2", "core__Uri__checkNonWindowsPathReservedCharacters$closure", 4, 0, 745, 618, [], 357, [], "_checkNonWindowsPathReservedCharacters"],
        _Uri__checkWindowsPathReservedCharacters: [function(segments, argumentError, firstSegment) {
          var t1;
          for (t1 = J.skip$1$ax(segments, firstSegment), t1 = t1.get$iterator(t1); t1.moveNext$0();)
            if (J.contains$1$asx(t1.get$current(), P.RegExp_RegExp('["*/:<>?\\\\|]', true, false)) === true)
              if (argumentError === true)
                throw H.wrapException(P.ArgumentError$("Illegal character in path"));
              else
                throw H.wrapException(new P.UnsupportedError("Illegal character in path"));
        }, function(segments, argumentError) {
          return P._Uri__checkWindowsPathReservedCharacters(segments, argumentError, 0);
        }, "call$3", "call$2", "core__Uri__checkWindowsPathReservedCharacters$closure", 4, 2, 746, 7, 618, [], 357, [], 638, [], "_checkWindowsPathReservedCharacters"],
        _Uri__checkWindowsDriveLetter: [function(charCode, argumentError) {
          var t1;
          if (typeof charCode !== "number")
            return H.iae(charCode);
          if (!(65 <= charCode && charCode <= 90))
            t1 = 97 <= charCode && charCode <= 122;
          else
            t1 = true;
          if (t1)
            return;
          if (argumentError === true)
            throw H.wrapException(P.ArgumentError$("Illegal drive letter " + P.String_String$fromCharCode(charCode)));
          else
            throw H.wrapException(new P.UnsupportedError("Illegal drive letter " + P.String_String$fromCharCode(charCode)));
        }, "call$2", "core__Uri__checkWindowsDriveLetter$closure", 4, 0, 747, 84, [], 357, [], "_checkWindowsDriveLetter"],
        _Uri__makeFileUri: [function(path, slashTerminated) {
          var t1, segments;
          t1 = J.getInterceptor$s(path);
          segments = t1.split$1(path, "/");
          if (slashTerminated === true && segments.length !== 0 && J.get$isNotEmpty$asx(C.JSArray_methods.get$last(segments)))
            segments.push("");
          if (t1.startsWith$1(path, "/"))
            return P._Uri__Uri(null, null, null, segments, null, null, null, "file", null);
          else
            return P._Uri__Uri(null, null, null, segments, null, null, null, null, null);
        }, "call$2", "core__Uri__makeFileUri$closure", 4, 0, 187, 10, [], 621, [], "_makeFileUri"],
        _Uri__makeWindowsFileUrl: [function(path, slashTerminated) {
          var t1, pathSegments, pathStart, hostPart;
          t1 = J.getInterceptor$s(path);
          if (t1.startsWith$1(path, "\\\\?\\"))
            if (t1.startsWith$2(path, "UNC\\", 4))
              path = t1.replaceRange$3(path, 0, 7, "\\");
            else {
              path = t1.substring$1(path, 4);
              if (path.length < 3 || C.JSString_methods._codeUnitAt$1(path, 1) !== 58 || C.JSString_methods._codeUnitAt$1(path, 2) !== 92)
                throw H.wrapException(P.ArgumentError$("Windows paths with \\\\?\\ prefix must be absolute"));
            }
          else
            path = t1.replaceAll$2(path, "/", "\\");
          t1 = path.length;
          if (t1 > 1 && C.JSString_methods._codeUnitAt$1(path, 1) === 58) {
            P._Uri__checkWindowsDriveLetter(C.JSString_methods._codeUnitAt$1(path, 0), true);
            if (t1 === 2 || C.JSString_methods._codeUnitAt$1(path, 2) !== 92)
              throw H.wrapException(P.ArgumentError$("Windows paths with drive letter must be absolute"));
            pathSegments = path.split("\\");
            if (slashTerminated === true && J.get$isNotEmpty$asx(C.JSArray_methods.get$last(pathSegments)))
              pathSegments.push("");
            P._Uri__checkWindowsPathReservedCharacters(pathSegments, true, 1);
            return P._Uri__Uri(null, null, null, pathSegments, null, null, null, "file", null);
          }
          if (C.JSString_methods.startsWith$1(path, "\\"))
            if (C.JSString_methods.startsWith$2(path, "\\", 1)) {
              pathStart = C.JSString_methods.indexOf$2(path, "\\", 2);
              t1 = pathStart < 0;
              hostPart = t1 ? C.JSString_methods.substring$1(path, 2) : C.JSString_methods.substring$2(path, 2, pathStart);
              pathSegments = (t1 ? "" : C.JSString_methods.substring$1(path, pathStart + 1)).split("\\");
              P._Uri__checkWindowsPathReservedCharacters(pathSegments, true, 0);
              if (slashTerminated === true && J.get$isNotEmpty$asx(C.JSArray_methods.get$last(pathSegments)))
                pathSegments.push("");
              return P._Uri__Uri(null, hostPart, null, pathSegments, null, null, null, "file", null);
            } else {
              pathSegments = path.split("\\");
              if (slashTerminated === true && J.get$isNotEmpty$asx(C.JSArray_methods.get$last(pathSegments)))
                pathSegments.push("");
              P._Uri__checkWindowsPathReservedCharacters(pathSegments, true, 0);
              return P._Uri__Uri(null, null, null, pathSegments, null, null, null, "file", null);
            }
          else {
            pathSegments = path.split("\\");
            P._Uri__checkWindowsPathReservedCharacters(pathSegments, true, 0);
            if (slashTerminated === true && pathSegments.length !== 0 && J.get$isNotEmpty$asx(C.JSArray_methods.get$last(pathSegments)))
              pathSegments.push("");
            return P._Uri__Uri(null, null, null, pathSegments, null, null, null, null, null);
          }
        }, "call$2", "core__Uri__makeWindowsFileUrl$closure", 4, 0, 187, 10, [], 621, [], "_makeWindowsFileUrl"],
        _Uri__makePort: [function(port, scheme) {
          if (port != null && J.$eq$(port, P._Uri__defaultPort(scheme)))
            return;
          return port;
        }, "call$2", "core__Uri__makePort$closure", 4, 0, 749, 26, [], 44, [], "_makePort"],
        _Uri__makeHost: [function(host, start, end, strictIPv6) {
          var t1, t2, t3, i;
          if (host == null)
            return;
          t1 = J.getInterceptor(start);
          if (t1.$eq(start, end))
            return "";
          t2 = J.getInterceptor$s(host);
          if (t2.codeUnitAt$1(host, start) === 91) {
            t3 = J.getInterceptor$n(end);
            if (t2.codeUnitAt$1(host, t3.$sub(end, 1)) !== 93)
              P._Uri__fail(host, start, "Missing end `]` to match `[` in host");
            P.Uri_parseIPv6Address(host, t1.$add(start, 1), t3.$sub(end, 1));
            return t2.substring$2(host, start, end).toLowerCase();
          }
          if (strictIPv6 !== true)
            for (i = start; t1 = J.getInterceptor$n(i), t1.$lt(i, end); i = t1.$add(i, 1))
              if (t2.codeUnitAt$1(host, i) === 58) {
                P.Uri_parseIPv6Address(host, start, end);
                return "[" + H.S(host) + "]";
              }
          return P._Uri__normalizeRegName(host, start, end);
        }, "call$4", "core__Uri__makeHost$closure", 8, 0, 750, 29, [], 3, [], 5, [], 630, [], "_makeHost"],
        _Uri__isRegNameChar: [function(char) {
          var t1, t2;
          t1 = J.getInterceptor$n(char);
          if (t1.$lt(char, 127)) {
            t2 = t1.$shr(char, 4);
            if (t2 >= 8)
              return H.ioore(C.List_qNA, t2);
            t2 = C.List_qNA[t2];
            t1 = t1.$and(char, 15);
            if (typeof t1 !== "number")
              return H.iae(t1);
            t1 = (t2 & C.JSInt_methods._shlPositive$1(1, t1)) !== 0;
          } else
            t1 = false;
          return t1;
        }, "call$1", "core__Uri__isRegNameChar$closure", 2, 0, 32, 397, [], "_isRegNameChar"],
        _Uri__normalizeRegName: [function(host, start, end) {
          var t1, index, sectionStart, buffer, isNormalized, t2, char, replacement, t3, slice, sourceLength, tail;
          for (t1 = J.getInterceptor$s(host), index = start, sectionStart = index, buffer = null, isNormalized = true; t2 = J.getInterceptor$n(index), t2.$lt(index, end);) {
            char = t1.codeUnitAt$1(host, index);
            if (char === 37) {
              replacement = P._Uri__normalizeEscape(host, index, true);
              t3 = replacement == null;
              if (t3 && isNormalized) {
                index = t2.$add(index, 3);
                continue;
              }
              if (buffer == null)
                buffer = new P.StringBuffer("");
              slice = t1.substring$2(host, sectionStart, index);
              if (!isNormalized)
                slice = slice.toLowerCase();
              buffer._contents = buffer._contents + slice;
              if (t3) {
                replacement = t1.substring$2(host, index, t2.$add(index, 3));
                sourceLength = 3;
              } else if (replacement === "%") {
                replacement = "%25";
                sourceLength = 1;
              } else
                sourceLength = 3;
              buffer._contents += replacement;
              index = t2.$add(index, sourceLength);
              sectionStart = index;
              isNormalized = true;
            } else {
              if (char < 127) {
                t3 = char >>> 4;
                if (t3 >= 8)
                  return H.ioore(C.List_qNA, t3);
                t3 = (C.List_qNA[t3] & 1 << (char & 15)) !== 0;
              } else
                t3 = false;
              if (t3) {
                if (isNormalized && 65 <= char && 90 >= char) {
                  if (buffer == null)
                    buffer = new P.StringBuffer("");
                  if (J.$lt$n(sectionStart, index)) {
                    t3 = t1.substring$2(host, sectionStart, index);
                    buffer._contents = buffer._contents + t3;
                    sectionStart = index;
                  }
                  isNormalized = false;
                }
                index = t2.$add(index, 1);
              } else {
                if (char <= 93) {
                  t3 = char >>> 4;
                  if (t3 >= 8)
                    return H.ioore(C.List_2Vk, t3);
                  t3 = (C.List_2Vk[t3] & 1 << (char & 15)) !== 0;
                } else
                  t3 = false;
                if (t3)
                  P._Uri__fail(host, index, "Invalid character");
                else {
                  if ((char & 64512) === 55296 && J.$lt$n(t2.$add(index, 1), end)) {
                    tail = t1.codeUnitAt$1(host, t2.$add(index, 1));
                    if ((tail & 64512) === 56320) {
                      char = 65536 | (char & 1023) << 10 | tail & 1023;
                      sourceLength = 2;
                    } else
                      sourceLength = 1;
                  } else
                    sourceLength = 1;
                  if (buffer == null)
                    buffer = new P.StringBuffer("");
                  slice = t1.substring$2(host, sectionStart, index);
                  if (!isNormalized)
                    slice = slice.toLowerCase();
                  buffer._contents = buffer._contents + slice;
                  buffer._contents += P._Uri__escapeChar(char);
                  index = t2.$add(index, sourceLength);
                  sectionStart = index;
                }
              }
            }
          }
          if (buffer == null)
            return t1.substring$2(host, start, end);
          if (J.$lt$n(sectionStart, end)) {
            slice = t1.substring$2(host, sectionStart, end);
            buffer._contents += !isNormalized ? slice.toLowerCase() : slice;
          }
          t1 = buffer._contents;
          return t1.charCodeAt(0) == 0 ? t1 : t1;
        }, "call$3", "core__Uri__normalizeRegName$closure", 6, 0, 149, 29, [], 3, [], 5, [], "_normalizeRegName"],
        _Uri__makeScheme: [function(scheme, start, end) {
          var t1, i, containsUpperCase, t2, codeUnit, t3;
          if (J.$eq$(start, end))
            return "";
          t1 = J.getInterceptor$s(scheme);
          if (!P._Uri__isAlphabeticCharacter(t1.codeUnitAt$1(scheme, start)))
            P._Uri__fail(scheme, start, "Scheme not starting with alphabetic character");
          for (i = start, containsUpperCase = false; t2 = J.getInterceptor$n(i), t2.$lt(i, end); i = t2.$add(i, 1)) {
            codeUnit = t1.codeUnitAt$1(scheme, i);
            if (codeUnit < 128) {
              t3 = codeUnit >>> 4;
              if (t3 >= 8)
                return H.ioore(C.List_JYB, t3);
              t3 = (C.List_JYB[t3] & 1 << (codeUnit & 15)) !== 0;
            } else
              t3 = false;
            if (!t3)
              P._Uri__fail(scheme, i, "Illegal scheme character");
            if (65 <= codeUnit && codeUnit <= 90)
              containsUpperCase = true;
          }
          scheme = t1.substring$2(scheme, start, end);
          return P._Uri__canonicalizeScheme(containsUpperCase ? scheme.toLowerCase() : scheme);
        }, "call$3", "core__Uri__makeScheme$closure", 6, 0, 149, 44, [], 3, [], 5, [], "_makeScheme"],
        _Uri__canonicalizeScheme: [function(scheme) {
          var t1 = J.getInterceptor(scheme);
          if (t1.$eq(scheme, "http"))
            return "http";
          if (t1.$eq(scheme, "file"))
            return "file";
          if (t1.$eq(scheme, "https"))
            return "https";
          if (t1.$eq(scheme, "package"))
            return "package";
          return scheme;
        }, "call$1", "core__Uri__canonicalizeScheme$closure", 2, 0, 28, 44, [], "_canonicalizeScheme"],
        _Uri__makeUserInfo: [function(userInfo, start, end) {
          var t1;
          if (userInfo == null)
            return "";
          t1 = P._Uri__normalize(userInfo, start, end, C.List_gRj, false);
          return t1 == null ? J.substring$2$s(userInfo, start, end) : t1;
        }, "call$3", "core__Uri__makeUserInfo$closure", 6, 0, 149, 209, [], 3, [], 5, [], "_makeUserInfo"],
        _Uri__makePath: [function(path, start, end, pathSegments, scheme, hasAuthority) {
          var isFile, ensureLeadingSlash, t1, result;
          isFile = J.$eq$(scheme, "file");
          ensureLeadingSlash = isFile || hasAuthority === true;
          t1 = path == null;
          if (t1 && pathSegments == null)
            return isFile ? "/" : "";
          t1 = !t1;
          if (t1 && pathSegments != null)
            throw H.wrapException(P.ArgumentError$("Both path and pathSegments specified"));
          if (t1) {
            result = P._Uri__normalize(path, start, end, C.List_qg4, false);
            if (result == null)
              result = J.substring$2$s(path, start, end);
          } else
            result = J.map$1$ax(pathSegments, new P._Uri__makePath_closure()).join$1(0, "/");
          t1 = J.getInterceptor$asx(result);
          if (t1.get$isEmpty(result)) {
            if (isFile)
              return "/";
          } else if (ensureLeadingSlash && !t1.startsWith$1(result, "/"))
            result = C.JSString_methods.$add("/", result);
          return P._Uri__normalizePath(result, scheme, hasAuthority);
        }, "call$6", "core__Uri__makePath$closure", 12, 0, 751, 10, [], 3, [], 5, [], 213, [], 44, [], 624, [], "_makePath"],
        _Uri__normalizePath: [function(path, scheme, hasAuthority) {
          var t1 = J.getInterceptor$asx(scheme);
          if (t1.get$isEmpty(scheme) === true && hasAuthority !== true && !J.startsWith$1$s(path, "/"))
            return P._Uri__normalizeRelativePath(path, t1.get$isNotEmpty(scheme) || hasAuthority === true);
          return P._Uri__removeDotSegments(path);
        }, "call$3", "core__Uri__normalizePath$closure", 6, 0, 752, 10, [], 44, [], 624, [], "_normalizePath"],
        _Uri__makeQuery: [function(query, start, end, queryParameters) {
          var t1, result;
          t1 = {};
          if (query != null) {
            if (queryParameters != null)
              throw H.wrapException(P.ArgumentError$("Both query and queryParameters specified"));
            t1 = P._Uri__normalize(query, start, end, C.List_CVk, false);
            return t1 == null ? J.substring$2$s(query, start, end) : t1;
          }
          if (queryParameters == null)
            return;
          result = new P.StringBuffer("");
          t1.separator = "";
          J.forEach$1$ax(queryParameters, new P._Uri__makeQuery_closure(new P._Uri__makeQuery_writeParameter(t1, result)));
          t1 = result._contents;
          return t1.charCodeAt(0) == 0 ? t1 : t1;
        }, "call$4", "core__Uri__makeQuery$closure", 8, 0, 753, 129, [], 3, [], 5, [], 107, [], "_makeQuery"],
        _Uri__makeFragment: [function(fragment, start, end) {
          var t1;
          if (fragment == null)
            return;
          t1 = P._Uri__normalize(fragment, start, end, C.List_CVk, false);
          return t1 == null ? J.substring$2$s(fragment, start, end) : t1;
        }, "call$3", "core__Uri__makeFragment$closure", 6, 0, 149, 216, [], 3, [], 5, [], "_makeFragment"],
        _Uri__normalizeEscape: [function(source, index, lowerCase) {
          var t1, t2, firstDigit, secondDigit, firstDigitValue, secondDigitValue, value, t3;
          t1 = J.getInterceptor$ns(index);
          t2 = J.getInterceptor$asx(source);
          if (J.$ge$n(t1.$add(index, 2), t2.get$length(source)))
            return "%";
          firstDigit = t2.codeUnitAt$1(source, t1.$add(index, 1));
          secondDigit = t2.codeUnitAt$1(source, t1.$add(index, 2));
          firstDigitValue = H.hexDigitValue(firstDigit);
          secondDigitValue = H.hexDigitValue(secondDigit);
          if (firstDigitValue < 0 || secondDigitValue < 0)
            return "%";
          value = firstDigitValue * 16 + secondDigitValue;
          if (value < 127) {
            t3 = C.JSInt_methods._shrOtherPositive$1(value, 4);
            if (t3 >= 8)
              return H.ioore(C.List_nxB, t3);
            t3 = (C.List_nxB[t3] & 1 << (value & 15)) !== 0;
          } else
            t3 = false;
          if (t3)
            return H.Primitives_stringFromCharCode(lowerCase === true && 65 <= value && 90 >= value ? (value | 32) >>> 0 : value);
          if (firstDigit >= 97 || secondDigit >= 97)
            return t2.substring$2(source, index, t1.$add(index, 3)).toUpperCase();
          return;
        }, "call$3", "core__Uri__normalizeEscape$closure", 6, 0, 754, 19, [], 14, [], 748, [], "_normalizeEscape"],
        _Uri__escapeChar: [function(char) {
          var t1, codeUnits, flag, encodedBytes, t2, index, byte, t3, t4;
          t1 = J.getInterceptor$n(char);
          if (t1.$lt(char, 128)) {
            codeUnits = new Array(3);
            codeUnits.fixed$length = Array;
            codeUnits[0] = 37;
            codeUnits[1] = C.JSString_methods._codeUnitAt$1("0123456789ABCDEF", t1.$shr(char, 4));
            codeUnits[2] = C.JSString_methods.codeUnitAt$1("0123456789ABCDEF", t1.$and(char, 15));
          } else {
            if (t1.$gt(char, 2047))
              if (t1.$gt(char, 65535)) {
                flag = 240;
                encodedBytes = 4;
              } else {
                flag = 224;
                encodedBytes = 3;
              }
            else {
              flag = 192;
              encodedBytes = 2;
            }
            t2 = 3 * encodedBytes;
            codeUnits = new Array(t2);
            codeUnits.fixed$length = Array;
            for (index = 0; --encodedBytes, encodedBytes >= 0; flag = 128) {
              byte = t1.$shr(char, 6 * encodedBytes) & 63 | flag;
              if (index >= t2)
                return H.ioore(codeUnits, index);
              codeUnits[index] = 37;
              t3 = index + 1;
              t4 = C.JSString_methods._codeUnitAt$1("0123456789ABCDEF", byte >>> 4);
              if (t3 >= t2)
                return H.ioore(codeUnits, t3);
              codeUnits[t3] = t4;
              t4 = index + 2;
              t3 = C.JSString_methods._codeUnitAt$1("0123456789ABCDEF", byte & 15);
              if (t4 >= t2)
                return H.ioore(codeUnits, t4);
              codeUnits[t4] = t3;
              index += 3;
            }
          }
          return P.String_String$fromCharCodes(codeUnits, 0, null);
        }, "call$1", "core__Uri__escapeChar$closure", 2, 0, 25, 397, [], "_escapeChar"],
        _Uri__normalizeOrSubstring: [function(component, start, end, charTable) {
          var t1 = P._Uri__normalize(component, start, end, charTable, false);
          return t1 == null ? J.substring$2$s(component, start, end) : t1;
        }, "call$4", "core__Uri__normalizeOrSubstring$closure", 8, 0, 755, 277, [], 3, [], 5, [], 493, [], "_normalizeOrSubstring"],
        _Uri__normalize: [function(component, start, end, charTable, escapeDelimiters) {
          var t1, t2, t3, index, sectionStart, buffer, t4, char, replacement, sourceLength, t5, tail;
          for (t1 = J.getInterceptor$s(component), t2 = escapeDelimiters !== true, t3 = J.getInterceptor$asx(charTable), index = start, sectionStart = index, buffer = null; t4 = J.getInterceptor$n(index), t4.$lt(index, end);) {
            char = t1.codeUnitAt$1(component, index);
            if (char < 127 && J.$and$n(t3.$index(charTable, char >>> 4), 1 << (char & 15) >>> 0) !== 0)
              index = t4.$add(index, 1);
            else {
              if (char === 37) {
                replacement = P._Uri__normalizeEscape(component, index, false);
                if (replacement == null) {
                  index = t4.$add(index, 3);
                  continue;
                }
                if ("%" === replacement) {
                  replacement = "%25";
                  sourceLength = 1;
                } else
                  sourceLength = 3;
              } else {
                if (t2)
                  if (char <= 93) {
                    t5 = char >>> 4;
                    if (t5 >= 8)
                      return H.ioore(C.List_2Vk, t5);
                    t5 = (C.List_2Vk[t5] & 1 << (char & 15)) !== 0;
                  } else
                    t5 = false;
                else
                  t5 = false;
                if (t5) {
                  P._Uri__fail(component, index, "Invalid character");
                  replacement = null;
                  sourceLength = null;
                } else {
                  if ((char & 64512) === 55296)
                    if (J.$lt$n(t4.$add(index, 1), end)) {
                      tail = t1.codeUnitAt$1(component, t4.$add(index, 1));
                      if ((tail & 64512) === 56320) {
                        char = 65536 | (char & 1023) << 10 | tail & 1023;
                        sourceLength = 2;
                      } else
                        sourceLength = 1;
                    } else
                      sourceLength = 1;
                  else
                    sourceLength = 1;
                  replacement = P._Uri__escapeChar(char);
                }
              }
              if (buffer == null)
                buffer = new P.StringBuffer("");
              t5 = t1.substring$2(component, sectionStart, index);
              buffer._contents = buffer._contents + t5;
              buffer._contents += H.S(replacement);
              index = t4.$add(index, sourceLength);
              sectionStart = index;
            }
          }
          if (buffer == null)
            return;
          if (J.$lt$n(sectionStart, end))
            buffer._contents += t1.substring$2(component, sectionStart, end);
          t1 = buffer._contents;
          return t1.charCodeAt(0) == 0 ? t1 : t1;
        }, function(component, start, end, charTable) {
          return P._Uri__normalize(component, start, end, charTable, false);
        }, "call$5$escapeDelimiters", "call$4", "core__Uri__normalize$closure", 8, 3, 756, 4, 277, [], 3, [], 5, [], 493, [], 868, [], "_normalize"],
        _Uri__isSchemeCharacter: [function(ch) {
          var t1, t2;
          t1 = J.getInterceptor$n(ch);
          if (t1.$lt(ch, 128)) {
            t2 = t1.$shr(ch, 4);
            if (t2 >= 8)
              return H.ioore(C.List_JYB, t2);
            t2 = C.List_JYB[t2];
            t1 = t1.$and(ch, 15);
            if (typeof t1 !== "number")
              return H.iae(t1);
            t1 = (t2 & C.JSInt_methods._shlPositive$1(1, t1)) !== 0;
          } else
            t1 = false;
          return t1;
        }, "call$1", "core__Uri__isSchemeCharacter$closure", 2, 0, 32, 517, [], "_isSchemeCharacter"],
        _Uri__isGeneralDelimiter: [function(ch) {
          var t1, t2;
          t1 = J.getInterceptor$n(ch);
          if (t1.$le(ch, 93)) {
            t2 = t1.$shr(ch, 4);
            if (t2 >= 8)
              return H.ioore(C.List_2Vk, t2);
            t2 = C.List_2Vk[t2];
            t1 = t1.$and(ch, 15);
            if (typeof t1 !== "number")
              return H.iae(t1);
            t1 = (t2 & C.JSInt_methods._shlPositive$1(1, t1)) !== 0;
          } else
            t1 = false;
          return t1;
        }, "call$1", "core__Uri__isGeneralDelimiter$closure", 2, 0, 32, 517, [], "_isGeneralDelimiter"],
        _Uri__mayContainDotSegments: [function(path) {
          var t1 = J.getInterceptor$s(path);
          if (t1.startsWith$1(path, "."))
            return true;
          return !J.$eq$(t1.indexOf$1(path, "/."), -1);
        }, "call$1", "core__Uri__mayContainDotSegments$closure", 2, 0, 30, 10, [], "_mayContainDotSegments"],
        _Uri__removeDotSegments: [function(path) {
          var output, t1, t2, appendSlash, _i, segment, t3;
          if (!P._Uri__mayContainDotSegments(path))
            return path;
          output = [];
          for (t1 = J.split$1$s(path, "/"), t2 = t1.length, appendSlash = false, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
            segment = t1[_i];
            if (J.$eq$(segment, "..")) {
              t3 = output.length;
              if (t3 !== 0) {
                if (0 >= t3)
                  return H.ioore(output, -1);
                output.pop();
                if (output.length === 0)
                  output.push("");
              }
              appendSlash = true;
            } else if ("." === segment)
              appendSlash = true;
            else {
              output.push(segment);
              appendSlash = false;
            }
          }
          if (appendSlash)
            output.push("");
          return C.JSArray_methods.join$1(output, "/");
        }, "call$1", "core__Uri__removeDotSegments$closure", 2, 0, 28, 10, [], "_removeDotSegments"],
        _Uri__normalizeRelativePath: [function(path, allowScheme) {
          var output, t1, t2, appendSlash, _i, segment;
          if (!P._Uri__mayContainDotSegments(path))
            return allowScheme !== true ? P._Uri__escapeScheme(path) : path;
          output = [];
          for (t1 = J.split$1$s(path, "/"), t2 = t1.length, appendSlash = false, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
            segment = t1[_i];
            if (".." === segment)
              if (output.length !== 0 && !J.$eq$(C.JSArray_methods.get$last(output), "..")) {
                if (0 >= output.length)
                  return H.ioore(output, -1);
                output.pop();
                appendSlash = true;
              } else {
                output.push("..");
                appendSlash = false;
              }
            else if ("." === segment)
              appendSlash = true;
            else {
              output.push(segment);
              appendSlash = false;
            }
          }
          t1 = output.length;
          if (t1 !== 0)
            if (t1 === 1) {
              if (0 >= t1)
                return H.ioore(output, 0);
              t1 = J.get$isEmpty$asx(output[0]) === true;
            } else
              t1 = false;
          else
            t1 = true;
          if (t1)
            return "./";
          if (appendSlash || J.$eq$(C.JSArray_methods.get$last(output), ".."))
            output.push("");
          if (allowScheme !== true) {
            if (0 >= output.length)
              return H.ioore(output, 0);
            t1 = P._Uri__escapeScheme(output[0]);
            if (0 >= output.length)
              return H.ioore(output, 0);
            output[0] = t1;
          }
          return C.JSArray_methods.join$1(output, "/");
        }, "call$2", "core__Uri__normalizeRelativePath$closure", 4, 0, 757, 10, [], 629, [], "_normalizeRelativePath"],
        _Uri__escapeScheme: [function(path) {
          var t1, i, t2, char;
          t1 = J.getInterceptor$asx(path);
          if (J.$ge$n(t1.get$length(path), 2) && P._Uri__isAlphabeticCharacter(t1.codeUnitAt$1(path, 0))) {
            i = 1;
            while (true) {
              t2 = t1.get$length(path);
              if (typeof t2 !== "number")
                return H.iae(t2);
              if (!(i < t2))
                break;
              char = t1.codeUnitAt$1(path, i);
              if (char === 58)
                return t1.substring$2(path, 0, i) + "%3A" + t1.substring$1(path, i + 1);
              if (char <= 127) {
                t2 = char >>> 4;
                if (t2 >= 8)
                  return H.ioore(C.List_JYB, t2);
                t2 = (C.List_JYB[t2] & 1 << (char & 15)) === 0;
              } else
                t2 = true;
              if (t2)
                break;
              ++i;
            }
          }
          return path;
        }, "call$1", "core__Uri__escapeScheme$closure", 2, 0, 28, 10, [], "_escapeScheme"],
        _Uri__toWindowsFilePath: [function(uri) {
          var segments, t1, hasDriveLetter, t2, host;
          segments = uri.get$pathSegments();
          t1 = J.getInterceptor$asx(segments);
          if (J.$gt$n(t1.get$length(segments), 0) && J.$eq$(J.get$length$asx(t1.$index(segments, 0)), 2) && J.codeUnitAt$1$s(t1.$index(segments, 0), 1) === 58) {
            P._Uri__checkWindowsDriveLetter(J.codeUnitAt$1$s(t1.$index(segments, 0), 0), false);
            P._Uri__checkWindowsPathReservedCharacters(segments, false, 1);
            hasDriveLetter = true;
          } else {
            P._Uri__checkWindowsPathReservedCharacters(segments, false, 0);
            hasDriveLetter = false;
          }
          t2 = uri.get$hasAbsolutePath() && !hasDriveLetter ? "\\" : "";
          if (uri.get$hasAuthority()) {
            host = uri.get$host();
            if (J.get$isNotEmpty$asx(host))
              t2 = t2 + "\\" + H.S(host) + "\\";
          }
          t2 = P.StringBuffer__writeAll(t2, segments, "\\");
          t1 = hasDriveLetter && J.$eq$(t1.get$length(segments), 1) ? t2 + "\\" : t2;
          return t1.charCodeAt(0) == 0 ? t1 : t1;
        }, "call$1", "core__Uri__toWindowsFilePath$closure", 2, 0, 758, 40, [], "_toWindowsFilePath"],
        _Uri__createList: [function() {
          return [];
        }, "call$0", "core__Uri__createList$closure", 0, 0, 530, "_createList"],
        _Uri__splitQueryStringAll: [function(query, encoding) {
          var result, t1, t2, i, start, equalsIndex, t3, char;
          result = P.LinkedHashMap__makeEmpty();
          t1 = new P._Uri__splitQueryStringAll_parsePair(query, encoding, result);
          t2 = J.getInterceptor$asx(query);
          i = 0;
          start = 0;
          equalsIndex = -1;
          while (true) {
            t3 = t2.get$length(query);
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (!(i < t3))
              break;
            char = t2.codeUnitAt$1(query, i);
            if (char === 61) {
              if (equalsIndex < 0)
                equalsIndex = i;
            } else if (char === 38) {
              t1.call$3(start, equalsIndex, i);
              start = i + 1;
              equalsIndex = -1;
            }
            ++i;
          }
          t1.call$3(start, equalsIndex, i);
          return result;
        }, function(query) {
          return P._Uri__splitQueryStringAll(query, C.Utf8Codec_false);
        }, "call$2$encoding", "call$1", "core__Uri__splitQueryStringAll$closure", 2, 3, 759, 73, 129, [], 48, [], "_splitQueryStringAll"],
        _Uri__uriEncode: [function(canonicalTable, text, encoding, spaceToPlus) {
          var bytes, t1, t2, t3, i, t4, t5, byte, t6, t7;
          if (encoding === C.Utf8Codec_false && $.$get$_Uri__needsNoEncoding()._nativeRegExp.test(H.checkString(text)))
            return text;
          bytes = encoding.encode$1(text);
          t1 = J.getInterceptor$asx(bytes);
          t2 = spaceToPlus === true;
          t3 = J.getInterceptor$asx(canonicalTable);
          i = 0;
          t4 = "";
          while (true) {
            t5 = t1.get$length(bytes);
            if (typeof t5 !== "number")
              return H.iae(t5);
            if (!(i < t5))
              break;
            byte = t1.$index(bytes, i);
            t5 = J.getInterceptor$n(byte);
            if (t5.$lt(byte, 128)) {
              t6 = t3.$index(canonicalTable, t5.$shr(byte, 4));
              t7 = t5.$and(byte, 15);
              if (typeof t7 !== "number")
                return H.iae(t7);
              t7 = J.$and$n(t6, C.JSInt_methods._shlPositive$1(1, t7)) !== 0;
              t6 = t7;
            } else
              t6 = false;
            if (t6)
              t4 += H.Primitives_stringFromCharCode(byte);
            else if (t2 && t5.$eq(byte, 32))
              t4 += "+";
            else {
              t4 = t4 + "%" + "0123456789ABCDEF"[t5.$shr(byte, 4) & 15];
              t5 = t5.$and(byte, 15);
              if (t5 >>> 0 !== t5 || t5 >= 16)
                return H.ioore("0123456789ABCDEF", t5);
              t5 = t4 + "0123456789ABCDEF"[t5];
              t4 = t5;
            }
            ++i;
          }
          return t4.charCodeAt(0) == 0 ? t4 : t4;
        }, "call$4", "core__Uri__uriEncode$closure", 8, 0, 760, 622, [], 106, [], 48, [], 631, [], "_uriEncode"],
        _Uri__hexCharPairToByte: [function(s, pos) {
          var t1, t2, byte, i, charCode;
          for (t1 = J.getInterceptor$ns(pos), t2 = J.getInterceptor$s(s), byte = 0, i = 0; i < 2; ++i) {
            charCode = t2.codeUnitAt$1(s, t1.$add(pos, i));
            if (48 <= charCode && charCode <= 57)
              byte = byte * 16 + charCode - 48;
            else {
              charCode |= 32;
              if (97 <= charCode && charCode <= 102)
                byte = byte * 16 + charCode - 87;
              else
                throw H.wrapException(P.ArgumentError$("Invalid URL encoding"));
            }
          }
          return byte;
        }, "call$2", "core__Uri__hexCharPairToByte$closure", 4, 0, 414, 49, [], 632, [], "_hexCharPairToByte"],
        _Uri__uriDecode: [function(text, start, end, encoding, plusToSpace) {
          var simple, t1, t2, i, t3, codeUnit, t4, bytes;
          t1 = J.getInterceptor$asx(text);
          t2 = plusToSpace === true;
          i = start;
          while (true) {
            t3 = J.getInterceptor$n(i);
            if (!t3.$lt(i, end)) {
              simple = true;
              break;
            }
            codeUnit = t1.codeUnitAt$1(text, i);
            if (codeUnit <= 127)
              if (codeUnit !== 37)
                t4 = t2 && codeUnit === 43;
              else
                t4 = true;
            else
              t4 = true;
            if (t4) {
              simple = false;
              break;
            }
            i = t3.$add(i, 1);
          }
          if (simple)
            if (C.Utf8Codec_false === encoding || C.Latin1Codec_false === encoding || C.AsciiCodec_false === encoding)
              return t1.substring$2(text, start, end);
            else
              bytes = new H.CodeUnits(t1.substring$2(text, start, end));
          else {
            bytes = [];
            for (i = start; t3 = J.getInterceptor$n(i), t3.$lt(i, end); i = J.$add$ns(i, 1)) {
              codeUnit = t1.codeUnitAt$1(text, i);
              if (codeUnit > 127)
                throw H.wrapException(P.ArgumentError$("Illegal percent encoding in URI"));
              if (codeUnit === 37) {
                if (J.$gt$n(t3.$add(i, 3), t1.get$length(text)))
                  throw H.wrapException(P.ArgumentError$("Truncated URI"));
                bytes.push(P._Uri__hexCharPairToByte(text, t3.$add(i, 1)));
                i = t3.$add(i, 2);
              } else if (t2 && codeUnit === 43)
                bytes.push(32);
              else
                bytes.push(codeUnit);
            }
          }
          return encoding.decode$1(bytes);
        }, "call$5", "core__Uri__uriDecode$closure", 10, 0, 762, 106, [], 3, [], 5, [], 48, [], 633, [], "_uriDecode"],
        _Uri__isAlphabeticCharacter: [function(codeUnit) {
          var lowerCase = J.$or$n(codeUnit, 32);
          if (typeof lowerCase !== "number")
            return H.iae(lowerCase);
          return 97 <= lowerCase && lowerCase <= 122;
        }, "call$1", "core__Uri__isAlphabeticCharacter$closure", 2, 0, 32, 366, [], "_isAlphabeticCharacter"],
        _Uri__isUnreservedChar: [function(char) {
          var t1, t2;
          t1 = J.getInterceptor$n(char);
          if (t1.$lt(char, 127)) {
            t2 = t1.$shr(char, 4);
            if (t2 >= 8)
              return H.ioore(C.List_nxB, t2);
            t2 = C.List_nxB[t2];
            t1 = t1.$and(char, 15);
            if (typeof t1 !== "number")
              return H.iae(t1);
            t1 = (t2 & C.JSInt_methods._shlPositive$1(1, t1)) !== 0;
          } else
            t1 = false;
          return t1;
        }, "call$1", "core__Uri__isUnreservedChar$closure", 2, 0, 32, 397, [], "_isUnreservedChar"]
      }
    },
    "+_Uri": [1, 36],
    closure1: {
      "^": "Closure:3;uri,portStart",
      call$1: [function(_) {
        throw H.wrapException(new P.FormatException("Invalid port", this.uri, J.$add$ns(this.portStart, 1)));
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ closure": [2],
    _Uri__checkNonWindowsPathReservedCharacters_closure: {
      "^": "Closure:3;argumentError",
      call$1: [function(segment) {
        if (J.contains$1$asx(segment, "/") === true)
          if (this.argumentError === true)
            throw H.wrapException(P.ArgumentError$("Illegal path character " + H.S(segment)));
          else
            throw H.wrapException(new P.UnsupportedError("Illegal path character " + H.S(segment)));
      }, null, null, 2, 0, 3, 657, [], "call"]
    },
    "+ _Uri__checkNonWindowsPathReservedCharacters_closure": [2],
    _Uri__makePath_closure: {
      "^": "Closure:3;",
      call$1: [function(s) {
        return P._Uri__uriEncode(C.List_qg40, s, C.Utf8Codec_false, false);
      }, null, null, 2, 0, 3, 49, [], "call"]
    },
    "+ _Uri__makePath_closure": [2],
    _Uri__makeQuery_writeParameter: {
      "^": "Closure:215;_box_0,result",
      call$2: [function(key, value) {
        var t1, t2;
        t1 = this.result;
        t2 = this._box_0;
        t1._contents += t2.separator;
        t2.separator = "&";
        t1._contents += H.S(P._Uri__uriEncode(C.List_nxB, key, C.Utf8Codec_false, true));
        if (value != null && J.get$isNotEmpty$asx(value)) {
          t1._contents += "=";
          t1._contents += H.S(P._Uri__uriEncode(C.List_nxB, value, C.Utf8Codec_false, true));
        }
      }, null, null, 4, 0, 215, 6, [], 1, [], "call"]
    },
    "+ _Uri__makeQuery_writeParameter": [2],
    _Uri__makeQuery_closure: {
      "^": "Closure:12;writeParameter",
      call$2: [function(key, value) {
        var t1, t2;
        if (value == null || typeof value === "string")
          this.writeParameter.call$2(key, value);
        else
          for (t1 = J.get$iterator$ax(value), t2 = this.writeParameter; t1.moveNext$0();)
            t2.call$2(key, t1.get$current());
      }, null, null, 4, 0, 12, 6, [], 1, [], "call"]
    },
    "+ _Uri__makeQuery_closure": [2],
    _Uri__splitQueryStringAll_parsePair: {
      "^": "Closure:314;query,encoding,result",
      call$3: [function(start, equalsIndex, end) {
        var t1, t2, key, value;
        if (start === end)
          return;
        t1 = this.query;
        t2 = this.encoding;
        if (equalsIndex < 0) {
          key = P._Uri__uriDecode(t1, start, end, t2, true);
          value = "";
        } else {
          key = P._Uri__uriDecode(t1, start, equalsIndex, t2, true);
          value = P._Uri__uriDecode(t1, equalsIndex + 1, end, t2, true);
        }
        J.add$1$ax(this.result.putIfAbsent$2(key, P.core__Uri__createList$closure()), value);
      }, null, null, 6, 0, 314, 3, [], 658, [], 5, [], "call"]
    },
    "+ _Uri__splitQueryStringAll_parsePair": [2],
    UriData: {
      "^": "Object;_text<-9,_separatorIndices<-14,_uriCache@-36",
      get$uri: [function() {
        var t1, colonIndex, t2, t3, queryIndex, end, t4, query, path;
        t1 = this._uriCache;
        if (t1 != null)
          return t1;
        colonIndex = J.$index$asx(this._separatorIndices, 0);
        t1 = this._text;
        t2 = J.getInterceptor$ns(colonIndex);
        t3 = J.getInterceptor$asx(t1);
        queryIndex = t3.indexOf$2(t1, "?", t2.$add(colonIndex, 1));
        end = t3.get$length(t1);
        t4 = J.getInterceptor$n(queryIndex);
        if (t4.$ge(queryIndex, 0)) {
          t4 = t4.$add(queryIndex, 1);
          query = P._Uri__normalize(t1, t4, end, C.List_CVk, false);
          if (query == null)
            query = t3.substring$2(t1, t4, end);
          end = queryIndex;
        } else
          query = null;
        t2 = t2.$add(colonIndex, 1);
        path = P._Uri__normalize(t1, t2, end, C.List_qg4, false);
        t1 = new P._DataUri(this, "data", null, null, null, path == null ? t3.substring$2(t1, t2, end) : path, query, null, null, null, null, null, null);
        this._uriCache = t1;
        return t1;
      }, null, null, 1, 0, 43, "uri"],
      get$mimeType: [function() {
        var t1, t2, start, end;
        t1 = this._separatorIndices;
        t2 = J.getInterceptor$asx(t1);
        start = J.$add$ns(t2.$index(t1, 0), 1);
        end = t2.$index(t1, 1);
        if (J.$eq$(start, end))
          return "text/plain";
        return P._Uri__uriDecode(this._text, start, end, C.Utf8Codec_false, false);
      }, null, null, 1, 0, 7, "mimeType"],
      get$charset: [function() {
        var t1, t2, parameterEnd, t3, t4, i, keyStart, keyEnd, t5;
        t1 = this._separatorIndices;
        t2 = J.getInterceptor$asx(t1);
        parameterEnd = J.$sub$n(t2.get$length(t1), 1);
        if (J.get$isOdd$i(t2.get$length(t1)))
          parameterEnd = J.$sub$n(parameterEnd, 1);
        if (typeof parameterEnd !== "number")
          return H.iae(parameterEnd);
        t3 = this._text;
        t4 = J.getInterceptor$s(t3);
        i = 1;
        for (; i < parameterEnd; i += 2) {
          keyStart = J.$add$ns(t2.$index(t1, i), 1);
          keyEnd = t2.$index(t1, i + 1);
          t5 = J.getInterceptor(keyEnd);
          if (t5.$eq(keyEnd, J.$add$ns(keyStart, 7)) && t4.startsWith$2(t3, "charset", keyStart))
            return P._Uri__uriDecode(t3, t5.$add(keyEnd, 1), t2.$index(t1, i + 2), C.Utf8Codec_false, false);
        }
        return "US-ASCII";
      }, null, null, 1, 0, 7, "charset"],
      get$isBase64: [function() {
        return J.get$isOdd$i(J.get$length$asx(this._separatorIndices));
      }, null, null, 1, 0, 5, "isBase64"],
      get$contentText: [function() {
        return J.substring$1$s(this._text, J.$add$ns(J.get$last$ax(this._separatorIndices), 1));
      }, null, null, 1, 0, 7, "contentText"],
      contentAsBytes$0: [function() {
        var text, t1, t2, start, $length, i, result, index, t3, codeUnit, index0, byte;
        text = this._text;
        t1 = this._separatorIndices;
        t2 = J.getInterceptor$ax(t1);
        start = J.$add$ns(t2.get$last(t1), 1);
        if (J.get$isOdd$i(t2.get$length(t1)))
          return C.C_Base64Decoder.convert$2(text, start);
        t1 = J.getInterceptor$asx(text);
        $length = J.$sub$n(t1.get$length(text), start);
        for (i = start; t2 = J.getInterceptor$n(i), t2.$lt(i, t1.get$length(text)); i = J.$add$ns(i, 1))
          if (t1.codeUnitAt$1(text, i) === 37) {
            i = t2.$add(i, 2);
            $length = J.$sub$n($length, 2);
          }
        t2 = H._checkLength($length);
        result = new Uint8Array(t2);
        if (J.$eq$($length, t1.get$length(text))) {
          C.NativeUint8List_methods.setRange$4(result, 0, $length, t1.get$codeUnits(text), start);
          return result;
        }
        for (i = start, index = 0; t3 = J.getInterceptor$n(i), t3.$lt(i, t1.get$length(text)); i = J.$add$ns(i, 1)) {
          codeUnit = t1.codeUnitAt$1(text, i);
          if (codeUnit !== 37) {
            index0 = index + 1;
            if (index >= t2)
              return H.ioore(result, index);
            result[index] = codeUnit;
          } else {
            if (J.$lt$n(t3.$add(i, 2), t1.get$length(text))) {
              byte = H.parseHexByte(text, t3.$add(i, 1));
              if (byte >= 0) {
                index0 = index + 1;
                if (index >= t2)
                  return H.ioore(result, index);
                result[index] = byte;
                i = t3.$add(i, 2);
                index = index0;
                continue;
              }
            }
            throw H.wrapException(new P.FormatException("Invalid percent escape", text, i));
          }
          index = index0;
        }
        return result;
      }, "call$0", "get$contentAsBytes", 0, 0, 69, "contentAsBytes"],
      contentAsString$1$encoding: [function(encoding) {
        var charset, text, t1, t2, start;
        if (encoding == null) {
          charset = this.get$charset();
          encoding = P.Encoding_getByName(charset);
          if (encoding == null)
            throw H.wrapException(new P.UnsupportedError("Unknown charset: " + H.S(charset)));
        }
        text = this._text;
        t1 = this._separatorIndices;
        t2 = J.getInterceptor$ax(t1);
        start = J.$add$ns(t2.get$last(t1), 1);
        if (J.get$isOdd$i(t2.get$length(t1)))
          return encoding.get$decoder().convert$1(C.C_Base64Decoder.convert$1(J.substring$1$s(text, start)));
        return P._Uri__uriDecode(text, start, J.get$length$asx(text), encoding, false);
      }, function() {
        return this.contentAsString$1$encoding(null);
      }, "contentAsString$0", "call$1$encoding", "call$0", "get$contentAsString", 0, 3, 315, 0, 48, [], "contentAsString"],
      get$parameters: [function() {
        var t1, result, t2, t3, i, t4, start, equals, end;
        t1 = P.String;
        result = P.LinkedHashMap_LinkedHashMap$_empty(t1, t1);
        t1 = this._separatorIndices;
        t2 = J.getInterceptor$asx(t1);
        t3 = this._text;
        i = 3;
        while (true) {
          t4 = t2.get$length(t1);
          if (typeof t4 !== "number")
            return H.iae(t4);
          if (!(i < t4))
            break;
          start = J.$add$ns(t2.$index(t1, i - 2), 1);
          equals = t2.$index(t1, i - 1);
          end = t2.$index(t1, i);
          result.$indexSet(0, P._Uri__uriDecode(t3, start, equals, C.Utf8Codec_false, false), P._Uri__uriDecode(t3, J.$add$ns(equals, 1), end, C.Utf8Codec_false, false));
          i += 2;
        }
        return result;
      }, null, null, 1, 0, 106, "parameters"],
      toString$0: [function(_) {
        var t1 = this._text;
        return J.$eq$(J.$index$asx(this._separatorIndices, 0), -1) ? "data:" + H.S(t1) : t1;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        "^": "UriData__noScheme<-0,UriData__tokenCharTable<-10,UriData__uricTable<-10,UriData__base64Table<-10",
        UriData$_: [function(_text, _separatorIndices, _uriCache) {
          return new P.UriData(_text, _separatorIndices, _uriCache);
        }, null, null, 6, 0, 763, 634, [], 635, [], 636, [], "new UriData$_"],
        UriData_UriData$fromString: [function($content, base64, encoding, mimeType, parameters) {
          var buffer, indices, charsetName, encodingName, t1;
          buffer = new P.StringBuffer("");
          indices = [-1];
          charsetName = parameters != null ? J.$index$asx(parameters, "charset") : null;
          if (encoding == null) {
            if (charsetName != null)
              encoding = P.Encoding_getByName(charsetName);
            encodingName = null;
          } else
            encodingName = charsetName == null ? encoding.get$name() : null;
          if (encoding == null)
            encoding = C.AsciiCodec_false;
          P.UriData__writeUri(mimeType, encodingName, parameters, buffer, indices);
          indices.push(J.get$length$asx(buffer._contents));
          t1 = buffer._contents;
          if (base64 === true) {
            t1 += ";base64,";
            buffer._contents = t1;
            indices.push(t1.length - 1);
            buffer._contents += H.S(encoding.fuse$1(C.Base64Codec_Base64Encoder_false).encode$1($content));
          } else {
            buffer._contents = t1 + ",";
            P.UriData__uriEncodeBytes(C.List_CVk, encoding.encode$1($content), buffer);
          }
          t1 = buffer._contents;
          return new P.UriData(t1.charCodeAt(0) == 0 ? t1 : t1, indices, null);
        }, null, null, 2, 9, 764, 0, 0, 0, 4, 410, [], 172, [], 48, [], 117, [], 601, [], "new UriData$fromString"],
        UriData_UriData$fromBytes: [function(bytes, mimeType, parameters, percentEncoded) {
          var buffer, indices, t1;
          buffer = new P.StringBuffer("");
          indices = [-1];
          P.UriData__writeUri(mimeType, null, parameters, buffer, indices);
          indices.push(J.get$length$asx(buffer._contents));
          t1 = buffer._contents;
          if (percentEncoded === true) {
            buffer._contents = t1 + ",";
            P.UriData__uriEncodeBytes(C.List_CVk, bytes, buffer);
          } else {
            t1 += ";base64,";
            buffer._contents = t1;
            indices.push(t1.length - 1);
            C.Base64Encoder_false.startChunkedConversion$1(new P._StringSinkConversionSink(buffer)).addSlice$4(bytes, 0, J.get$length$asx(bytes), true);
          }
          t1 = buffer._contents;
          return new P.UriData(t1.charCodeAt(0) == 0 ? t1 : t1, indices, null);
        }, null, null, 2, 7, 765, 602, 0, 4, 30, [], 172, [], 117, [], 603, [], "new UriData$fromBytes"],
        UriData_UriData$fromUri: [function(uri) {
          if (!J.$eq$(uri.get$scheme(), "data"))
            throw H.wrapException(P.ArgumentError$value(uri, "uri", "Scheme must be 'data'"));
          if (uri.get$hasAuthority())
            throw H.wrapException(P.ArgumentError$value(uri, "uri", "Data uri must not have authority"));
          if (uri.get$hasFragment())
            throw H.wrapException(P.ArgumentError$value(uri, "uri", "Data uri must not have a fragment part"));
          if (!uri.get$hasQuery())
            return P.UriData__parse(uri.get$path(), 0, uri);
          return P.UriData__parse(H.S(uri), 5, uri);
        }, null, null, 2, 0, 766, 40, [], "new UriData$fromUri"],
        UriData__writeUri: [function(mimeType, charsetName, parameters, buffer, indices) {
          var t1, slashIndex, t2;
          if (mimeType == null || J.$eq$(mimeType, "text/plain"))
            mimeType = "";
          t1 = J.getInterceptor$asx(mimeType);
          if (t1.get$isEmpty(mimeType) === true || mimeType === "application/octet-stream")
            buffer.write$1(mimeType);
          else {
            slashIndex = P.UriData__validateMimeType(mimeType);
            if (slashIndex < 0)
              throw H.wrapException(P.ArgumentError$value(mimeType, "mimeType", "Invalid MIME type"));
            buffer.write$1(P._Uri__uriEncode(C.List_qFt, t1.substring$2(mimeType, 0, slashIndex), C.Utf8Codec_false, false));
            buffer.write$1("/");
            buffer.write$1(P._Uri__uriEncode(C.List_qFt, t1.substring$1(mimeType, slashIndex + 1), C.Utf8Codec_false, false));
          }
          if (charsetName != null) {
            if (indices != null) {
              t1 = J.getInterceptor$asx(buffer);
              t2 = J.getInterceptor$ax(indices);
              t2.add$1(indices, t1.get$length(buffer));
              t2.add$1(indices, J.$add$ns(t1.get$length(buffer), 8));
            }
            buffer.write$1(";charset=");
            buffer.write$1(P._Uri__uriEncode(C.List_qFt, charsetName, C.Utf8Codec_false, false));
          }
          if (!(parameters == null))
            J.forEach$1$ax(parameters, new P.UriData__writeUri_closure(buffer, indices));
        }, "call$5", "core_UriData__writeUri$closure", 10, 0, 767, 172, [], 637, [], 117, [], 41, [], 620, [], "_writeUri"],
        UriData__validateMimeType: [function(mimeType) {
          var t1, slashIndex, i, t2;
          t1 = J.getInterceptor$asx(mimeType);
          slashIndex = -1;
          i = 0;
          while (true) {
            t2 = t1.get$length(mimeType);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            c$0: {
              if (t1.codeUnitAt$1(mimeType, i) !== 47)
                break c$0;
              if (slashIndex < 0) {
                slashIndex = i;
                break c$0;
              }
              return -1;
            }
            ++i;
          }
          return slashIndex;
        }, "call$1", "core_UriData__validateMimeType$closure", 2, 0, 31, 172, [], "_validateMimeType"],
        UriData_parse: [function(uri) {
          var t1, dataDelta;
          t1 = J.getInterceptor$asx(uri);
          if (J.$ge$n(t1.get$length(uri), 5)) {
            dataDelta = P._startsWithData(uri, 0);
            if (dataDelta === 0)
              return P.UriData__parse(uri, 5, null);
            if (dataDelta === 32)
              return P.UriData__parse(t1.substring$1(uri, 5), 0, null);
          }
          throw H.wrapException(new P.FormatException("Does not start with 'data:'", uri, 0));
        }, "call$1", "core_UriData_parse$closure", 2, 0, 768, 40, [], "parse"],
        UriData__parse: [function(text, start, sourceUri) {
          var indices, t1, i, slashIndex, char, t2, equalsIndex, lastSeparator, t3, data;
          indices = [J.$sub$n(start, 1)];
          for (t1 = J.getInterceptor$asx(text), i = start, slashIndex = -1, char = null; t2 = J.getInterceptor$n(i), t2.$lt(i, t1.get$length(text)); i = t2.$add(i, 1)) {
            char = t1.codeUnitAt$1(text, i);
            if (char === 44 || char === 59)
              break;
            if (char === 47) {
              if (J.$lt$n(slashIndex, 0)) {
                slashIndex = i;
                continue;
              }
              throw H.wrapException(new P.FormatException("Invalid MIME type", text, i));
            }
          }
          if (J.$lt$n(slashIndex, 0) && t2.$gt(i, start))
            throw H.wrapException(new P.FormatException("Invalid MIME type", text, i));
          for (; char !== 44;) {
            indices.push(i);
            i = J.$add$ns(i, 1);
            for (equalsIndex = -1; t2 = J.getInterceptor$n(i), t2.$lt(i, t1.get$length(text)); i = t2.$add(i, 1)) {
              char = t1.codeUnitAt$1(text, i);
              if (char === 61) {
                if (J.$lt$n(equalsIndex, 0))
                  equalsIndex = i;
              } else if (char === 59 || char === 44)
                break;
            }
            if (J.$ge$n(equalsIndex, 0))
              indices.push(equalsIndex);
            else {
              lastSeparator = C.JSArray_methods.get$last(indices);
              if (char === 44) {
                t3 = J.getInterceptor$ns(lastSeparator);
                t2 = !t2.$eq(i, t3.$add(lastSeparator, 7)) || !t1.startsWith$2(text, "base64", t3.$add(lastSeparator, 1));
              } else
                t2 = true;
              if (t2)
                throw H.wrapException(new P.FormatException("Expecting '='", text, i));
              break;
            }
          }
          indices.push(i);
          t2 = J.getInterceptor$ns(i);
          if ((indices.length & 1) === 1)
            text = C.Base64Codec_Base64Encoder_false.normalize$3(text, t2.$add(i, 1), t1.get$length(text));
          else {
            data = P._Uri__normalize(text, t2.$add(i, 1), t1.get$length(text), C.List_CVk, true);
            if (data != null)
              text = t1.replaceRange$3(text, t2.$add(i, 1), t1.get$length(text), data);
          }
          return new P.UriData(text, indices, sourceUri);
        }, "call$3", "core_UriData__parse$closure", 6, 0, 769, 106, [], 3, [], 639, [], "_core$_parse"],
        UriData__uriEncodeBytes: [function(canonicalTable, bytes, buffer) {
          var t1, t2, byteOr, i, t3, byte;
          t1 = J.getInterceptor$asx(bytes);
          t2 = J.getInterceptor$asx(canonicalTable);
          byteOr = 0;
          i = 0;
          while (true) {
            t3 = t1.get$length(bytes);
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (!(i < t3))
              break;
            byte = t1.$index(bytes, i);
            if (typeof byte !== "number")
              return H.iae(byte);
            byteOr |= byte;
            if (byte < 128 && J.$and$n(t2.$index(canonicalTable, C.JSNumber_methods._shrOtherPositive$1(byte, 4)), 1 << (byte & 15) >>> 0) !== 0)
              buffer.writeCharCode$1(byte);
            else {
              buffer.writeCharCode$1(37);
              buffer.writeCharCode$1(C.JSString_methods._codeUnitAt$1("0123456789ABCDEF", C.JSNumber_methods._shrOtherPositive$1(byte, 4)));
              buffer.writeCharCode$1(C.JSString_methods._codeUnitAt$1("0123456789ABCDEF", byte & 15));
            }
            ++i;
          }
          if ((byteOr & 4294967040) >>> 0 !== 0) {
            i = 0;
            while (true) {
              t2 = t1.get$length(bytes);
              if (typeof t2 !== "number")
                return H.iae(t2);
              if (!(i < t2))
                break;
              byte = t1.$index(bytes, i);
              t2 = J.getInterceptor$n(byte);
              if (t2.$lt(byte, 0) || t2.$gt(byte, 255))
                throw H.wrapException(P.ArgumentError$value(byte, "non-byte value", null));
              ++i;
            }
          }
        }, "call$3", "core_UriData__uriEncodeBytes$closure", 6, 0, 770, 622, [], 30, [], 41, [], "_uriEncodeBytes"]
      }
    },
    "+UriData": [1],
    UriData__writeUri_closure: {
      "^": "Closure:12;buffer,indices",
      call$2: [function(key, value) {
        var t1, t2, t3;
        if (J.get$isEmpty$asx(key) === true)
          throw H.wrapException(P.ArgumentError$value("", "Parameter names must not be empty", null));
        if (J.get$isEmpty$asx(value) === true)
          throw H.wrapException(P.ArgumentError$value("", "Parameter values must not be empty", 'parameters["' + H.S(key) + '"]'));
        t1 = this.indices;
        t2 = t1 != null;
        if (t2)
          J.add$1$ax(t1, J.get$length$asx(this.buffer));
        t3 = this.buffer;
        t3.write$1(";");
        t3.write$1(P._Uri__uriEncode(C.List_qFt, key, C.Utf8Codec_false, false));
        if (t2)
          J.add$1$ax(t1, J.get$length$asx(t3));
        t3.write$1("=");
        t3.write$1(P._Uri__uriEncode(C.List_qFt, value, C.Utf8Codec_false, false));
      }, null, null, 4, 0, 12, 6, [], 1, [], "call"]
    },
    "+ UriData__writeUri_closure": [2],
    _createTables_closure: {
      "^": "Closure:3;",
      call$1: [function(_) {
        return new Uint8Array(H._checkLength(96));
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _createTables_closure": [2],
    _createTables_build: {
      "^": "Closure:316;tables",
      call$2: [function(state, defaultTransition) {
        var t1 = this.tables;
        if (state >= t1.length)
          return H.ioore(t1, state);
        t1 = t1[state];
        J.fillRange$3$ax(t1, 0, 96, defaultTransition);
        return t1;
      }, null, null, 4, 0, 316, 82, [], 824, [], "call"]
    },
    "+ _createTables_build": [2],
    _createTables_setChars: {
      "^": "Closure:218;",
      call$3: [function(target, chars, transition) {
        var t1, t2, i;
        for (t1 = chars.length, t2 = J.getInterceptor$ax(target), i = 0; i < t1; ++i)
          t2.$indexSet(target, C.JSString_methods._codeUnitAt$1(chars, i) ^ 96, transition);
      }, null, null, 6, 0, 218, 79, [], 660, [], 611, [], "call"]
    },
    "+ _createTables_setChars": [2],
    _createTables_setRange: {
      "^": "Closure:218;",
      call$3: [function(target, range, transition) {
        var i, n, t1;
        for (i = C.JSString_methods._codeUnitAt$1(range, 0), n = C.JSString_methods._codeUnitAt$1(range, 1), t1 = J.getInterceptor$ax(target); i <= n; ++i)
          t1.$indexSet(target, (i ^ 96) >>> 0, transition);
      }, null, null, 6, 0, 218, 79, [], 662, [], 611, [], "call"]
    },
    "+ _createTables_setRange": [2],
    _SimpleUri: {
      "^": "Object;_uri<-9,_schemeEnd<-0,_hostStart<-0,_portStart<-0,_pathStart<-0,_queryStart<-0,_fragmentStart<-0,_schemeCache@-9,_hashCodeCache@-0",
      get$hasScheme: [function() {
        return J.$gt$n(this._schemeEnd, 0);
      }, null, null, 1, 0, 5, "hasScheme"],
      get$hasAuthority: [function() {
        return J.$gt$n(this._hostStart, 0);
      }, null, null, 1, 0, 5, "hasAuthority"],
      get$hasUserInfo: [function() {
        return J.$gt$n(this._hostStart, J.$add$ns(this._schemeEnd, 4));
      }, null, null, 1, 0, 5, "hasUserInfo"],
      get$hasPort: [function() {
        return J.$gt$n(this._hostStart, 0) && J.$lt$n(J.$add$ns(this._portStart, 1), this._pathStart);
      }, null, null, 1, 0, 5, "hasPort"],
      get$hasQuery: [function() {
        return J.$lt$n(this._queryStart, this._fragmentStart);
      }, null, null, 1, 0, 5, "hasQuery"],
      get$hasFragment: [function() {
        return J.$lt$n(this._fragmentStart, J.get$length$asx(this._uri));
      }, null, null, 1, 0, 5, "hasFragment"],
      get$_isFile: [function() {
        return J.$eq$(this._schemeEnd, 4) && J.startsWith$1$s(this._uri, "file");
      }, null, null, 1, 0, 5, "_isFile"],
      get$_isHttp: [function() {
        return J.$eq$(this._schemeEnd, 4) && J.startsWith$1$s(this._uri, "http");
      }, null, null, 1, 0, 5, "_isHttp"],
      get$_isHttps: [function() {
        return J.$eq$(this._schemeEnd, 5) && J.startsWith$1$s(this._uri, "https");
      }, null, null, 1, 0, 5, "_isHttps"],
      get$_isPackage: [function() {
        return J.$eq$(this._schemeEnd, 7) && J.startsWith$1$s(this._uri, "package");
      }, null, null, 1, 0, 5, "_isPackage"],
      _isScheme$1: [function(scheme) {
        return J.$eq$(this._schemeEnd, J.get$length$asx(scheme)) && J.startsWith$1$s(this._uri, scheme);
      }, "call$1", "get$_isScheme", 2, 0, 30, 44, [], "_isScheme"],
      get$hasAbsolutePath: [function() {
        return J.startsWith$2$s(this._uri, "/", this._pathStart);
      }, null, null, 1, 0, 5, "hasAbsolutePath"],
      get$hasEmptyPath: [function() {
        return J.$eq$(this._pathStart, this._queryStart);
      }, null, null, 1, 0, 5, "hasEmptyPath"],
      get$isAbsolute: [function() {
        return J.$gt$n(this._schemeEnd, 0) && !J.$lt$n(this._fragmentStart, J.get$length$asx(this._uri));
      }, null, null, 1, 0, 5, "isAbsolute"],
      isScheme$1: [function(scheme) {
        if (scheme == null || J.get$isEmpty$asx(scheme) === true)
          return J.$lt$n(this._schemeEnd, 0);
        if (!J.$eq$(J.get$length$asx(scheme), this._schemeEnd))
          return false;
        return P._Uri__compareScheme(scheme, this._uri);
      }, "call$1", "get$isScheme", 2, 0, 30, 44, [], "isScheme"],
      get$scheme: [function() {
        var t1, t2, t3;
        t1 = this._schemeEnd;
        t2 = J.getInterceptor$n(t1);
        if (t2.$le(t1, 0))
          return "";
        t3 = this._schemeCache;
        if (t3 != null)
          return t3;
        if (t2.$eq(t1, 4) && J.startsWith$1$s(this._uri, "http")) {
          this._schemeCache = "http";
          t1 = "http";
        } else if (t2.$eq(t1, 5) && J.startsWith$1$s(this._uri, "https")) {
          this._schemeCache = "https";
          t1 = "https";
        } else if (t2.$eq(t1, 4) && J.startsWith$1$s(this._uri, "file")) {
          this._schemeCache = "file";
          t1 = "file";
        } else if (t2.$eq(t1, 7) && J.startsWith$1$s(this._uri, "package")) {
          this._schemeCache = "package";
          t1 = "package";
        } else {
          t1 = J.substring$2$s(this._uri, 0, t1);
          this._schemeCache = t1;
        }
        return t1;
      }, null, null, 1, 0, 7, "scheme"],
      get$authority: [function() {
        return J.$gt$n(this._hostStart, 0) ? J.substring$2$s(this._uri, J.$add$ns(this._schemeEnd, 3), this._pathStart) : "";
      }, null, null, 1, 0, 7, "authority"],
      get$userInfo: [function() {
        var t1, t2, t3, t4;
        t1 = this._hostStart;
        t2 = this._schemeEnd;
        t3 = J.getInterceptor$ns(t2);
        t4 = J.getInterceptor$n(t1);
        return t4.$gt(t1, t3.$add(t2, 3)) ? J.substring$2$s(this._uri, t3.$add(t2, 3), t4.$sub(t1, 1)) : "";
      }, null, null, 1, 0, 7, "userInfo"],
      get$host: [function() {
        var t1 = this._hostStart;
        return J.$gt$n(t1, 0) ? J.substring$2$s(this._uri, t1, this._portStart) : "";
      }, null, null, 1, 0, 7, "host"],
      get$port: [function() {
        var t1, t2;
        if (this.get$hasPort())
          return H.Primitives_parseInt(J.substring$2$s(this._uri, J.$add$ns(this._portStart, 1), this._pathStart), null, null);
        t1 = this._schemeEnd;
        t2 = J.getInterceptor(t1);
        if (t2.$eq(t1, 4) && J.startsWith$1$s(this._uri, "http"))
          return 80;
        if (t2.$eq(t1, 5) && J.startsWith$1$s(this._uri, "https"))
          return 443;
        return 0;
      }, null, null, 1, 0, 11, "port"],
      get$path: [function() {
        return J.substring$2$s(this._uri, this._pathStart, this._queryStart);
      }, null, null, 1, 0, 7, "path"],
      get$query: [function() {
        var t1, t2, t3;
        t1 = this._queryStart;
        t2 = this._fragmentStart;
        t3 = J.getInterceptor$n(t1);
        return t3.$lt(t1, t2) ? J.substring$2$s(this._uri, t3.$add(t1, 1), t2) : "";
      }, null, null, 1, 0, 7, "query"],
      get$fragment: [function() {
        var t1, t2, t3, t4;
        t1 = this._fragmentStart;
        t2 = this._uri;
        t3 = J.getInterceptor$asx(t2);
        t4 = J.getInterceptor$n(t1);
        return t4.$lt(t1, t3.get$length(t2)) ? t3.substring$1(t2, t4.$add(t1, 1)) : "";
      }, null, null, 1, 0, 7, "fragment"],
      get$origin: [function() {
        var t1, t2, isHttp, t3, t4, t5;
        t1 = this._schemeEnd;
        t2 = J.getInterceptor(t1);
        isHttp = t2.$eq(t1, 4) && J.startsWith$1$s(this._uri, "http");
        if (t2.$lt(t1, 0))
          throw H.wrapException(new P.StateError("Cannot use origin without a scheme: " + H.S(this)));
        if (!isHttp)
          t3 = !(t2.$eq(t1, 5) && J.startsWith$1$s(this._uri, "https"));
        else
          t3 = false;
        if (t3)
          throw H.wrapException(new P.StateError("Origin is only applicable schemes http and https: " + H.S(this)));
        t3 = this._hostStart;
        t4 = J.getInterceptor(t3);
        if (t4.$eq(t3, this._portStart))
          throw H.wrapException(new P.StateError("A " + H.S(this.get$scheme()) + ": URI should have a non-empty host name: " + H.S(this)));
        if (t4.$eq(t3, t2.$add(t1, 3)))
          return J.substring$2$s(this._uri, 0, this._pathStart);
        t4 = this._uri;
        t5 = J.getInterceptor$s(t4);
        return t5.substring$2(t4, 0, t2.$add(t1, 3)) + t5.substring$2(t4, t3, this._pathStart);
      }, null, null, 1, 0, 7, "origin"],
      get$pathSegments: [function() {
        var start, end, t1, t2, parts, i, t3;
        start = this._pathStart;
        end = this._queryStart;
        t1 = this._uri;
        t2 = J.getInterceptor$s(t1);
        if (t2.startsWith$2(t1, "/", start))
          start = J.$add$ns(start, 1);
        if (J.$eq$(start, end))
          return C.List_empty4;
        parts = [];
        for (i = start; t3 = J.getInterceptor$n(i), t3.$lt(i, end); i = t3.$add(i, 1))
          if (t2.codeUnitAt$1(t1, i) === 47) {
            parts.push(t2.substring$2(t1, start, i));
            start = t3.$add(i, 1);
          }
        parts.push(t2.substring$2(t1, start, end));
        return P.List_List$unmodifiable(parts, P.String);
      }, null, null, 1, 0, 93, "pathSegments"],
      get$queryParameters: [function() {
        if (!J.$lt$n(this._queryStart, this._fragmentStart))
          return C.Map_empty0;
        var t1 = P.String;
        return new P.UnmodifiableMapView(P.Uri_splitQueryString(this.get$query(), C.Utf8Codec_false), [t1, t1]);
      }, null, null, 1, 0, 106, "queryParameters"],
      get$queryParametersAll: [function() {
        var queryParameterLists, t1, t2, key, result;
        if (!J.$lt$n(this._queryStart, this._fragmentStart))
          return C.Map_empty;
        queryParameterLists = P._Uri__splitQueryStringAll(this.get$query(), C.Utf8Codec_false);
        for (t1 = queryParameterLists.get$keys(), t1 = t1.get$iterator(t1), t2 = P.String; t1.moveNext$0();) {
          key = t1.get$current();
          result = P.List_List$from(queryParameterLists.$index(0, key), false, t2);
          result.fixed$length = Array;
          result.immutable$list = Array;
          queryParameterLists.$indexSet(0, key, result);
        }
        return H.ConstantMap_ConstantMap$from(queryParameterLists, t2, [P.List, P.String]);
      }, null, null, 1, 0, 415, "queryParametersAll"],
      _isPort$1: [function(port) {
        var portDigitStart = J.$add$ns(this._portStart, 1);
        return J.$eq$(J.$add$ns(portDigitStart, J.get$length$asx(port)), this._pathStart) && J.startsWith$2$s(this._uri, port, portDigitStart);
      }, "call$1", "get$_isPort", 2, 0, 30, 26, [], "_isPort"],
      normalizePath$0: [function() {
        return this;
      }, "call$0", "get$normalizePath", 0, 0, 43, "normalizePath"],
      removeFragment$0: [function() {
        var t1, t2, t3;
        t1 = this._fragmentStart;
        t2 = this._uri;
        t3 = J.getInterceptor$asx(t2);
        if (!J.$lt$n(t1, t3.get$length(t2)))
          return this;
        return new P._SimpleUri(t3.substring$2(t2, 0, t1), this._schemeEnd, this._hostStart, this._portStart, this._pathStart, this._queryStart, t1, this._schemeCache, null);
      }, "call$0", "get$removeFragment", 0, 0, 43, "removeFragment"],
      replace$9$fragment$host$path$pathSegments$port$query$queryParameters$scheme$userInfo: [function(fragment, host, path, pathSegments, port, query, queryParameters, scheme, userInfo) {
        var schemeChanged, isFile, t1, hasAuthority, t2, t3, t4;
        if (scheme != null) {
          scheme = P._Uri__makeScheme(scheme, 0, J.get$length$asx(scheme));
          schemeChanged = !(J.$eq$(this._schemeEnd, J.get$length$asx(scheme)) && J.startsWith$1$s(this._uri, scheme));
        } else {
          scheme = this.get$scheme();
          schemeChanged = false;
        }
        isFile = J.$eq$(scheme, "file");
        if (userInfo != null)
          userInfo = P._Uri__makeUserInfo(userInfo, 0, J.get$length$asx(userInfo));
        else {
          t1 = this._hostStart;
          userInfo = J.$gt$n(t1, 0) ? J.substring$2$s(this._uri, J.$add$ns(this._schemeEnd, 3), t1) : "";
        }
        if (port != null)
          port = P._Uri__makePort(port, scheme);
        else {
          port = this.get$hasPort() ? this.get$port() : null;
          if (schemeChanged)
            port = P._Uri__makePort(port, scheme);
        }
        if (host != null)
          host = P._Uri__makeHost(host, 0, J.get$length$asx(host), false);
        else {
          t1 = this._hostStart;
          if (J.$gt$n(t1, 0))
            host = J.substring$2$s(this._uri, t1, this._portStart);
          else if (userInfo.length !== 0 || port != null || isFile)
            host = "";
        }
        hasAuthority = host != null;
        t1 = path == null;
        if (!t1 || pathSegments != null)
          path = P._Uri__makePath(path, 0, t1 ? 0 : J.get$length$asx(path), pathSegments, scheme, hasAuthority);
        else {
          path = J.substring$2$s(this._uri, this._pathStart, this._queryStart);
          if (!isFile)
            t1 = hasAuthority && path.length !== 0;
          else
            t1 = true;
          if (t1 && !C.JSString_methods.startsWith$1(path, "/"))
            path = "/" + path;
        }
        t1 = query == null;
        if (!t1 || queryParameters != null)
          query = P._Uri__makeQuery(query, 0, t1 ? 0 : J.get$length$asx(query), queryParameters);
        else {
          t1 = this._queryStart;
          t2 = this._fragmentStart;
          t3 = J.getInterceptor$n(t1);
          if (t3.$lt(t1, t2))
            query = J.substring$2$s(this._uri, t3.$add(t1, 1), t2);
        }
        if (fragment != null)
          fragment = P._Uri__makeFragment(fragment, 0, J.get$length$asx(fragment));
        else {
          t1 = this._fragmentStart;
          t2 = this._uri;
          t3 = J.getInterceptor$asx(t2);
          t4 = J.getInterceptor$n(t1);
          if (t4.$lt(t1, t3.get$length(t2)))
            fragment = t3.substring$1(t2, t4.$add(t1, 1));
        }
        return new P._Uri(scheme, userInfo, host, port, path, query, fragment, null, null, null, null, null);
      }, function() {
        return this.replace$9$fragment$host$path$pathSegments$port$query$queryParameters$scheme$userInfo(null, null, null, null, null, null, null, null, null);
      }, "replace$0", function(path) {
        return this.replace$9$fragment$host$path$pathSegments$port$query$queryParameters$scheme$userInfo(null, null, path, null, null, null, null, null, null);
      }, "replace$1$path", function(scheme) {
        return this.replace$9$fragment$host$path$pathSegments$port$query$queryParameters$scheme$userInfo(null, null, null, null, null, null, null, scheme, null);
      }, "replace$1$scheme", "call$9$fragment$host$path$pathSegments$port$query$queryParameters$scheme$userInfo", "call$0", "call$1$path", "call$1$scheme", "get$replace", 0, 19, 273, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, [], 209, [], 29, [], 26, [], 10, [], 213, [], 129, [], 107, [], 216, [], "replace"],
      resolve$1: [function(reference) {
        return this.resolveUri$1(P.Uri_parse(reference, 0, null));
      }, "call$1", "get$resolve", 2, 0, 310, 187, [], "resolve"],
      resolveUri$1: [function(reference) {
        if (reference instanceof P._SimpleUri)
          return this._simpleMerge$2(this, reference);
        return this._toNonSimple$0().resolveUri$1(reference);
      }, "call$1", "get$resolveUri", 2, 0, 311, 187, [], "resolveUri"],
      _simpleMerge$2: [function(base, ref) {
        var isSimple, delta, refStart, baseUri, refUri, baseStart, baseEnd, t1, refEnd, t2, backCount, t3, insert;
        if (ref.get$hasScheme())
          return ref;
        if (ref.get$hasAuthority()) {
          if (!base.get$hasScheme())
            return ref;
          if (base.get$_isFile())
            isSimple = ref.get$hasEmptyPath() !== true;
          else if (base.get$_isHttp())
            isSimple = !ref._isPort$1("80");
          else
            isSimple = !base.get$_isHttps() || !ref._isPort$1("443");
          if (isSimple) {
            delta = J.$add$ns(base.get$_schemeEnd(), 1);
            return new P._SimpleUri(J.substring$2$s(base.get$_uri(), 0, J.$add$ns(base.get$_schemeEnd(), 1)) + J.substring$1$s(ref.get$_uri(), J.$add$ns(ref.get$_schemeEnd(), 1)), base.get$_schemeEnd(), J.$add$ns(ref.get$_hostStart(), delta), J.$add$ns(ref.get$_portStart(), delta), J.$add$ns(ref.get$_pathStart(), delta), J.$add$ns(ref.get$_queryStart(), delta), J.$add$ns(ref.get$_fragmentStart(), delta), base.get$_schemeCache(), null);
          } else
            return this._toNonSimple$0().resolveUri$1(ref);
        }
        if (ref.get$hasEmptyPath() === true) {
          if (ref.get$hasQuery()) {
            delta = J.$sub$n(base.get$_queryStart(), ref.get$_queryStart());
            return new P._SimpleUri(J.substring$2$s(base.get$_uri(), 0, base.get$_queryStart()) + J.substring$1$s(ref.get$_uri(), ref.get$_queryStart()), base.get$_schemeEnd(), base.get$_hostStart(), base.get$_portStart(), base.get$_pathStart(), J.$add$ns(ref.get$_queryStart(), delta), J.$add$ns(ref.get$_fragmentStart(), delta), base.get$_schemeCache(), null);
          }
          if (ref.get$hasFragment()) {
            delta = J.$sub$n(base.get$_fragmentStart(), ref.get$_fragmentStart());
            return new P._SimpleUri(J.substring$2$s(base.get$_uri(), 0, base.get$_fragmentStart()) + J.substring$1$s(ref.get$_uri(), ref.get$_fragmentStart()), base.get$_schemeEnd(), base.get$_hostStart(), base.get$_portStart(), base.get$_pathStart(), base.get$_queryStart(), J.$add$ns(ref.get$_fragmentStart(), delta), base.get$_schemeCache(), null);
          }
          return base.removeFragment$0();
        }
        if (ref.get$hasAbsolutePath()) {
          delta = J.$sub$n(base.get$_pathStart(), ref.get$_pathStart());
          return new P._SimpleUri(J.substring$2$s(base.get$_uri(), 0, base.get$_pathStart()) + J.substring$1$s(ref.get$_uri(), ref.get$_pathStart()), base.get$_schemeEnd(), base.get$_hostStart(), base.get$_portStart(), base.get$_pathStart(), J.$add$ns(ref.get$_queryStart(), delta), J.$add$ns(ref.get$_fragmentStart(), delta), base.get$_schemeCache(), null);
        }
        if (base.get$hasEmptyPath() === true && base.get$hasAuthority()) {
          refStart = ref.get$_pathStart();
          for (; J.startsWith$2$s(ref.get$_uri(), "../", refStart);)
            refStart = J.$add$ns(refStart, 3);
          delta = J.$add$ns(J.$sub$n(base.get$_pathStart(), refStart), 1);
          return new P._SimpleUri(J.substring$2$s(base.get$_uri(), 0, base.get$_pathStart()) + "/" + J.substring$1$s(ref.get$_uri(), refStart), base.get$_schemeEnd(), base.get$_hostStart(), base.get$_portStart(), base.get$_pathStart(), J.$add$ns(ref.get$_queryStart(), delta), J.$add$ns(ref.get$_fragmentStart(), delta), base.get$_schemeCache(), null);
        }
        baseUri = base.get$_uri();
        refUri = ref.get$_uri();
        baseStart = base.get$_pathStart();
        baseEnd = base.get$_queryStart();
        for (t1 = J.getInterceptor$s(baseUri); t1.startsWith$2(baseUri, "../", baseStart);)
          baseStart = J.$add$ns(baseStart, 3);
        refStart = ref.get$_pathStart();
        refEnd = ref.get$_queryStart();
        t2 = J.getInterceptor$s(refUri);
        backCount = 0;
        while (true) {
          t3 = J.getInterceptor$ns(refStart);
          if (!(J.$le$n(t3.$add(refStart, 3), refEnd) && t2.startsWith$2(refUri, "../", refStart)))
            break;
          refStart = t3.$add(refStart, 3);
          ++backCount;
        }
        for (insert = ""; t2 = J.getInterceptor$n(baseEnd), t2.$gt(baseEnd, baseStart);) {
          baseEnd = t2.$sub(baseEnd, 1);
          if (t1.codeUnitAt$1(baseUri, baseEnd) === 47) {
            if (backCount === 0) {
              insert = "/";
              break;
            }
            --backCount;
            insert = "/";
          }
        }
        t1 = J.getInterceptor(baseEnd);
        if (t1.$eq(baseEnd, baseStart) && !base.get$hasScheme() && !base.get$hasAbsolutePath()) {
          refStart = t3.$sub(refStart, backCount * 3);
          insert = "";
        }
        delta = J.$add$ns(t1.$sub(baseEnd, refStart), insert.length);
        return new P._SimpleUri(J.substring$2$s(base.get$_uri(), 0, baseEnd) + insert + J.substring$1$s(ref.get$_uri(), refStart), base.get$_schemeEnd(), base.get$_hostStart(), base.get$_portStart(), base.get$_pathStart(), J.$add$ns(ref.get$_queryStart(), delta), J.$add$ns(ref.get$_fragmentStart(), delta), base.get$_schemeCache(), null);
      }, "call$2", "get$_simpleMerge", 4, 0, 617, 613, [], 151, [], "_simpleMerge"],
      toFilePath$1$windows: [function(windows) {
        var t1, t2, t3, t4;
        t1 = this._schemeEnd;
        t2 = J.getInterceptor$n(t1);
        if (t2.$ge(t1, 0)) {
          t3 = !(t2.$eq(t1, 4) && J.startsWith$1$s(this._uri, "file"));
          t1 = t3;
        } else
          t1 = false;
        if (t1)
          throw H.wrapException(new P.UnsupportedError("Cannot extract a file path from a " + H.S(this.get$scheme()) + " URI"));
        t1 = this._queryStart;
        t2 = this._uri;
        t3 = J.getInterceptor$asx(t2);
        t4 = J.getInterceptor$n(t1);
        if (t4.$lt(t1, t3.get$length(t2))) {
          if (t4.$lt(t1, this._fragmentStart))
            throw H.wrapException(new P.UnsupportedError("Cannot extract a file path from a URI with a query component"));
          throw H.wrapException(new P.UnsupportedError("Cannot extract a file path from a URI with a fragment component"));
        }
        if ((windows == null ? false : windows) === true)
          t1 = P._Uri__toWindowsFilePath(this);
        else {
          if (J.$lt$n(this._hostStart, this._portStart))
            H.throwExpression(new P.UnsupportedError("Cannot extract a non-Windows file path from a file URI with an authority"));
          t1 = t3.substring$2(t2, this._pathStart, t1);
        }
        return t1;
      }, function() {
        return this.toFilePath$1$windows(null);
      }, "toFilePath$0", "call$1$windows", "call$0", "get$toFilePath", 0, 3, 312, 0, 170, [], "toFilePath"],
      _toFilePath$0: [function() {
        if (J.$lt$n(this._hostStart, this._portStart))
          throw H.wrapException(new P.UnsupportedError("Cannot extract a non-Windows file path from a file URI with an authority"));
        return J.substring$2$s(this._uri, this._pathStart, this._queryStart);
      }, "call$0", "get$_toFilePath", 0, 0, 7, "_toFilePath"],
      get$data: [function() {
        return;
      }, null, null, 1, 0, 272, "data"],
      get$hashCode: [function(_) {
        var t1 = this._hashCodeCache;
        if (t1 == null) {
          t1 = J.get$hashCode$(this._uri);
          this._hashCodeCache = t1;
        }
        return t1;
      }, null, null, 1, 0, 11, "hashCode"],
      $eq: [function(_, other) {
        var t1;
        if (other == null)
          return false;
        if (this === other)
          return true;
        t1 = J.getInterceptor(other);
        if (!!t1.$isUri)
          return J.$eq$(this._uri, t1.toString$0(other));
        return false;
      }, null, "get$==", 2, 0, 15, 2, [], "=="],
      _toNonSimple$0: [function() {
        var t1, t2, t3, t4, t5, t6, t7, t8, t9;
        t1 = this.get$scheme();
        t2 = this.get$userInfo();
        t3 = this._hostStart;
        t4 = J.getInterceptor$n(t3);
        if (t4.$gt(t3, 0))
          t3 = t4.$gt(t3, 0) ? J.substring$2$s(this._uri, t3, this._portStart) : "";
        else
          t3 = null;
        t4 = this.get$hasPort() ? this.get$port() : null;
        t5 = this._uri;
        t6 = this._queryStart;
        t7 = J.getInterceptor$s(t5);
        t8 = t7.substring$2(t5, this._pathStart, t6);
        t9 = this._fragmentStart;
        t6 = J.$lt$n(t6, t9) ? this.get$query() : null;
        return new P._Uri(t1, t2, t3, t4, t8, t6, J.$lt$n(t9, t7.get$length(t5)) ? this.get$fragment() : null, null, null, null, null, null);
      }, "call$0", "get$_toNonSimple", 0, 0, 43, "_toNonSimple"],
      toString$0: [function(_) {
        return this._uri;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isUri: 1,
      static: {
        _SimpleUri$: [function(_uri, _schemeEnd, _hostStart, _portStart, _pathStart, _queryStart, _fragmentStart, _schemeCache) {
          return new P._SimpleUri(_uri, _schemeEnd, _hostStart, _portStart, _pathStart, _queryStart, _fragmentStart, _schemeCache, null);
        }, null, null, 16, 0, 773, 640, [], 641, [], 642, [], 643, [], 644, [], 645, [], 646, [], 647, [], "new _SimpleUri"]
      }
    },
    "+_SimpleUri": [1, 36],
    _DataUri: {
      "^": "_Uri;_core$_data<-1472,scheme-9,_userInfo-9,_host-9,_port-0,path-9,_query-9,_fragment-9,_pathSegments-61,_text-9,_hashCodeCache-0,_queryParameters-82,_queryParameterLists-259",
      get$data: [function() {
        return this._core$_data;
      }, null, null, 1, 0, 272, "data"],
      static: {
        _DataUri$: [function(_data, path, query) {
          return new P._DataUri(_data, "data", null, null, null, path, query, null, null, null, null, null, null);
        }, null, null, 6, 0, 537, 648, [], 10, [], 129, [], "new _DataUri"]
      }
    },
    "+_DataUri": [1473],
    Comparator: {
      "^": "",
      $typedefType: 1703,
      $$isTypedef: true
    },
    "+Comparator": "",
    _Generator: {
      "^": "",
      $typedefType: 1238,
      $$isTypedef: true
    },
    "+_Generator": ""
  }], ["dart.developer", "dart:developer",, P, {
    "^": "_fastPathArguments@-9,_isProduct<-8",
    $debugger: [function(message, when) {
      if (when === true)
        debugger;
      return when;
    }, function() {
      return P.$debugger(null, true);
    }, "call$2$message$when", "call$0", "developer__debugger$closure", 0, 5, 775, 25, 0, 664, [], 17, [], "debugger"],
    inspect: [function(object) {
      return object;
    }, "call$1", "developer__inspect$closure", 2, 0, 420, 23, [], "inspect"],
    log: [function(message, error, level, $name, sequenceNumber, stackTrace, time, zone) {
    }, function(message) {
      return P.log(message, null, 0, "", null, null, null, null);
    }, "call$8$error$level$name$sequenceNumber$stackTrace$time$zone", "call$1", "developer__log$closure", 2, 15, 776, 0, 0, 7, 32, 0, 0, 0, 17, [], 226, [], 666, [], 136, [], 13, [], 34, [], 8, [], 12, [], "log"],
    registerExtension: [function(method, handler) {
      var t1;
      if (typeof method !== "string")
        throw H.wrapException(P.ArgumentError$value(method, "method", "Must be a String"));
      if (!C.JSString_methods.startsWith$1(method, "ext."))
        throw H.wrapException(P.ArgumentError$value(method, "method", "Must begin with ext."));
      t1 = $.$get$_extensions();
      if (t1.$index(0, method) != null)
        throw H.wrapException(P.ArgumentError$("Extension already registered: " + method));
      if (!H.functionTypeTest(handler, {func: 1, ret: [P.Future, P.ServiceExtensionResponse], args: [P.String, [P.Map, P.String, P.String]]}))
        throw H.wrapException(P.ArgumentError$value(handler, "handler", "Must be a ServiceExtensionHandler"));
      t1.$indexSet(0, method, handler);
    }, "call$2", "developer__registerExtension$closure", 4, 0, 778, 98, [], 358, [], "registerExtension"],
    postEvent: [function(eventKind, eventData) {
      if (typeof eventKind !== "string")
        throw H.wrapException(P.ArgumentError$value(eventKind, "eventKind", "Must be a String"));
      if (!J.getInterceptor(eventData).$isMap)
        throw H.wrapException(P.ArgumentError$value(eventData, "eventData", "Must be a Map"));
      C.JsonCodec_null_null.encode$1(eventData);
    }, "call$2", "developer__postEvent$closure", 4, 0, 779, 582, [], 581, [], "postEvent"],
    _postEvent: [function(eventKind, eventData) {
    }, "call$2", "developer___postEvent$closure", 4, 0, 215, 582, [], 581, [], "_postEvent"],
    _lookupExtension: [function(method) {
      return $.$get$_extensions().$index(0, method);
    }, "call$1", "developer___lookupExtension$closure", 2, 0, 780, 98, [], "_lookupExtension"],
    _registerExtension: [function(method, handler) {
      $.$get$_extensions().$indexSet(0, method, handler);
    }, "call$2", "developer___registerExtension$closure", 4, 0, 781, 98, [], 358, [], "_registerExtension"],
    getCurrentTag: [function() {
      return $.$get$_currentTag();
    }, "call$0", "developer__getCurrentTag$closure", 0, 0, 271, "getCurrentTag"],
    _getServerInfo: [function(sendPort) {
      sendPort.send$1(null);
    }, "call$1", "developer___getServerInfo$closure", 2, 0, 174, 296, [], "_getServerInfo"],
    _webServerControl: [function(sendPort, enable) {
      sendPort.send$1(null);
    }, "call$2", "developer___webServerControl$closure", 4, 0, 790, 296, [], 575, [], "_webServerControl"],
    _getServiceMajorVersion: [function() {
      return 0;
    }, "call$0", "developer___getServiceMajorVersion$closure", 0, 0, 11, "_getServiceMajorVersion"],
    _getServiceMinorVersion: [function() {
      return 0;
    }, "call$0", "developer___getServiceMinorVersion$closure", 0, 0, 11, "_getServiceMinorVersion"],
    _getIsolateIDFromSendPort: [function(sendPort) {
      return;
    }, "call$1", "developer___getIsolateIDFromSendPort$closure", 2, 0, 791, 296, [], "_getIsolateIDFromSendPort"],
    _argumentsAsJson: [function($arguments) {
      var t1;
      if ($arguments == null || J.$eq$(J.get$length$asx($arguments), 0)) {
        t1 = $._fastPathArguments;
        if (t1 == null) {
          t1 = '{"isolateNumber":"' + H.S($.$get$Timeline__isolateId()) + '"}';
          $._fastPathArguments = t1;
        }
        return t1;
      }
      J.$indexSet$ax($arguments, "isolateNumber", $.$get$Timeline__isolateIdString());
      return C.JsonCodec_null_null.encode$1($arguments);
    }, "call$1", "developer___argumentsAsJson$closure", 2, 0, 395, 69, [], "_argumentsAsJson"],
    _isDartStreamEnabled: [function() {
      return false;
    }, "call$0", "developer___isDartStreamEnabled$closure", 0, 0, 5, "_isDartStreamEnabled"],
    _getNextAsyncId: [function() {
      return 0;
    }, "call$0", "developer___getNextAsyncId$closure", 0, 0, 11, "_getNextAsyncId"],
    _getTraceClock: [function() {
      var t1 = $._clockValue;
      $._clockValue = t1 + 1;
      return t1;
    }, "call$0", "developer___getTraceClock$closure", 0, 0, 11, "_getTraceClock"],
    _getThreadCpuClock: [function() {
      return -1;
    }, "call$0", "developer___getThreadCpuClock$closure", 0, 0, 11, "_getThreadCpuClock"],
    _getIsolateNum: [function() {
      return 0;
    }, "call$0", "developer___getIsolateNum$closure", 0, 0, 11, "_getIsolateNum"],
    _reportTaskEvent: [function(start, taskId, phase, category, $name, argumentsAsJson) {
    }, "call$6", "developer___reportTaskEvent$closure", 12, 0, 795, 3, [], 572, [], 687, [], 378, [], 13, [], 383, [], "_reportTaskEvent"],
    _reportCompleteEvent: [function(start, startCpu, category, $name, argumentsAsJson) {
    }, "call$5", "developer___reportCompleteEvent$closure", 10, 0, 796, 3, [], 690, [], 378, [], 13, [], 383, [], "_reportCompleteEvent"],
    _reportInstantEvent: [function(start, category, $name, argumentsAsJson) {
    }, "call$4", "developer___reportInstantEvent$closure", 8, 0, 797, 3, [], 378, [], 13, [], 383, [], "_reportInstantEvent"],
    _FakeUserTag: {
      "^": "Object;label<-",
      makeCurrent$0: [function() {
        var old = $.$get$_currentTag();
        $._currentTag = this;
        return old;
      }, "call$0", "get$makeCurrent", 0, 0, 271, "makeCurrent"],
      static: {
        _FakeUserTag__FakeUserTag: function(label) {
          var existingTag, t1, instance;
          existingTag = $.$get$_FakeUserTag__instances().$index(0, label);
          if (existingTag != null)
            return existingTag;
          t1 = $.$get$_FakeUserTag__instances();
          if (t1.get$length(t1) === 64)
            throw H.wrapException(new P.UnsupportedError("UserTag instance limit (64) reached."));
          instance = new P._FakeUserTag(label);
          $.$get$_FakeUserTag__instances().$indexSet(0, label, instance);
          return instance;
        }
      }
    },
    "+_FakeUserTag": 0,
    ServiceExtensionResponse: {
      "^": "Object;_result<-9,_errorCode<-0,_errorDetail<-9",
      _isError$0: [function() {
        return this._errorCode != null && this._errorDetail != null;
      }, "call$0", "get$_isError", 0, 0, 5, "_isError"],
      _toString$0: [function() {
        var t1 = this._result;
        if (t1 != null)
          return t1;
        else {
          t1 = this._errorCode;
          return C.JsonCodec_null_null.encode$1(P.LinkedHashMap__makeLiteral(["code", t1, "message", P.ServiceExtensionResponse__errorCodeMessage(t1), "data", P.LinkedHashMap__makeLiteral(["details", this._errorDetail])]));
        }
      }, "call$0", "get$_toString", 0, 0, 7, "_toString"],
      ServiceExtensionResponse$error$2: function(errorCode, errorDetail) {
        var t1;
        P.ServiceExtensionResponse__validateErrorCode(this._errorCode);
        t1 = this._errorDetail;
        if (typeof t1 !== "string")
          throw H.wrapException(P.ArgumentError$value(t1, "errorDetail", "Must be a String"));
      },
      ServiceExtensionResponse$result$1: function(result) {
        var t1 = this._result;
        if (typeof t1 !== "string")
          throw H.wrapException(P.ArgumentError$value(t1, "result", "Must be a String"));
      },
      static: {
        "^": ["ServiceExtensionResponse_kInvalidParams<-10,ServiceExtensionResponse_kExtensionError<-10,ServiceExtensionResponse_kExtensionErrorMax<-10,ServiceExtensionResponse_kExtensionErrorMin<-10,ServiceExtensionResponse_invalidParams<-10,ServiceExtensionResponse_extensionError<-10,ServiceExtensionResponse_extensionErrorMax<-10,ServiceExtensionResponse_extensionErrorMin<-10", function() {
          return [C.Deprecated_o8I];
        }, function() {
          return [C.Deprecated_o8I];
        }, function() {
          return [C.Deprecated_o8I];
        }, function() {
          return [C.Deprecated_o8I];
        }, null, null, null, null],
        ServiceExtensionResponse$result: [function(result) {
          var t1 = new P.ServiceExtensionResponse(result, null, null);
          t1.ServiceExtensionResponse$result$1(result);
          return t1;
        }, null, null, 2, 0, 13, 93, [], "new ServiceExtensionResponse$result"],
        ServiceExtensionResponse$error: [function(errorCode, errorDetail) {
          var t1 = new P.ServiceExtensionResponse(null, errorCode, errorDetail);
          t1.ServiceExtensionResponse$error$2(errorCode, errorDetail);
          return t1;
        }, null, null, 4, 0, 148, 160, [], 668, [], "new ServiceExtensionResponse$error"],
        ServiceExtensionResponse__errorCodeMessage: [function(errorCode) {
          P.ServiceExtensionResponse__validateErrorCode(errorCode);
          if (J.$eq$(errorCode, -32602))
            return "Invalid params";
          return "Server error";
        }, "call$1", "developer_ServiceExtensionResponse__errorCodeMessage$closure", 2, 0, 25, 160, [], "_errorCodeMessage"],
        ServiceExtensionResponse__validateErrorCode: [function(errorCode) {
          if (typeof errorCode !== "number" || Math.floor(errorCode) !== errorCode)
            throw H.wrapException(P.ArgumentError$value(errorCode, "errorCode", "Must be an int"));
          if (errorCode === -32602)
            return;
          if (errorCode >= -32016 && errorCode <= -32000)
            return;
          throw H.wrapException(P.ArgumentError$value(errorCode, "errorCode", "Out of range"));
        }, "call$1", "developer_ServiceExtensionResponse__validateErrorCode$closure", 2, 0, 22, 160, [], "_validateErrorCode"]
      }
    },
    "+ServiceExtensionResponse": [1],
    UserTag: {
      "^": "Object;",
      static: {
        "^": "UserTag_MAX_USER_TAGS<-10",
        UserTag_UserTag: [function(label) {
          return P._FakeUserTag__FakeUserTag(label);
        }, null, null, 2, 0, 782, 673, [], "new UserTag"],
        UserTag_defaultTag: [function() {
          return $.$get$_FakeUserTag__defaultTag();
        }, null, null, 1, 0, 271, "defaultTag"]
      }
    },
    "+UserTag": [1],
    Metric: {
      "^": "Object;name<-9,description<-9",
      Metric$2: function($name, description) {
        var t1, t2;
        t1 = this.name;
        t2 = J.getInterceptor(t1);
        if (t2.$eq(t1, "vm") || t2.contains$1(t1, "/") === true)
          throw H.wrapException(P.ArgumentError$("Invalid Metric name."));
      },
      static: {
        Metric$: [function($name, description) {
          var t1 = new P.Metric($name, description);
          t1.Metric$2($name, description);
          return t1;
        }, null, null, 4, 0, 40, 13, [], 298, [], "new Metric"]
      }
    },
    "+Metric": [1],
    Gauge: {
      "^": "Metric;min<-23,max<-23,_value@-23,name-9,description-9",
      get$value: [function() {
        return this._value;
      }, null, null, 1, 0, 52, "value"],
      set$value: [function(v) {
        var v0, t1;
        v0 = this.min;
        t1 = J.getInterceptor$n(v);
        if (t1.$lt(v, v0))
          v = v0;
        else {
          v0 = this.max;
          if (t1.$gt(v, v0))
            v = v0;
        }
        this._value = v;
      }, null, null, 3, 0, 318, 56, [], "value"],
      _toJSON$0: [function() {
        var t1 = this.name;
        return P.LinkedHashMap__makeLiteral(["type", "Gauge", "id", "metrics/" + H.S(t1), "name", t1, "description", this.description, "value", this._value, "min", this.min, "max", this.max]);
      }, "call$0", "get$_toJSON", 0, 0, 288, "_toJSON"],
      Gauge$4: function($name, description, min, max) {
        var t1, t2;
        t1 = this.min;
        if (typeof t1 !== "number")
          throw H.wrapException(P.ArgumentError$("min must be a double"));
        t2 = this.max;
        if (typeof t2 !== "number")
          throw H.wrapException(P.ArgumentError$("max must be a double"));
        if (!(t1 < t2))
          throw H.wrapException(P.ArgumentError$("min must be less than max"));
        this._value = t1;
      },
      min$1: function(arg0) {
        return this.min.call$1(arg0);
      },
      max$1: function(arg0) {
        return this.max.call$1(arg0);
      },
      value$1: function(arg0) {
        return this.get$value().call$1(arg0);
      },
      static: {
        Gauge$: [function($name, description, min, max) {
          var t1 = new P.Gauge(min, max, null, $name, description);
          t1.Metric$2($name, description);
          t1.Gauge$4($name, description, min, max);
          return t1;
        }, null, null, 8, 0, 783, 13, [], 298, [], 675, [], 297, [], "new Gauge"]
      }
    },
    "+Gauge": [482],
    Counter: {
      "^": "Metric;_value@-23,name-9,description-9",
      get$value: [function() {
        return this._value;
      }, null, null, 1, 0, 52, "value"],
      set$value: [function(v) {
        this._value = v;
      }, null, null, 3, 0, 318, 56, [], "value"],
      _toJSON$0: [function() {
        var t1 = this.name;
        return P.LinkedHashMap__makeLiteral(["type", "Counter", "id", "metrics/" + H.S(t1), "name", t1, "description", this.description, "value", this._value]);
      }, "call$0", "get$_toJSON", 0, 0, 288, "_toJSON"],
      value$1: function(arg0) {
        return this.get$value().call$1(arg0);
      },
      static: {
        Counter$: [function($name, description) {
          var t1 = new P.Counter(0, $name, description);
          t1.Metric$2($name, description);
          return t1;
        }, null, null, 4, 0, 40, 13, [], 298, [], "new Counter"]
      }
    },
    "+Counter": [482],
    Metrics: {
      "^": "Object;",
      static: {
        "^": "Metrics__metrics<-1477",
        Metrics$: [function() {
          return new P.Metrics();
        }, null, null, 0, 0, 784, "new Metrics"],
        Metrics_register: [function(metric) {
          var t1, t2;
          if (!(metric instanceof P.Metric))
            throw H.wrapException(P.ArgumentError$("metric must be a Metric"));
          t1 = $.$get$Metrics__metrics();
          t2 = metric.name;
          if (t1.$index(0, t2) != null)
            throw H.wrapException(P.ArgumentError$("Registered metrics have unique names"));
          t1.$indexSet(0, t2, metric);
        }, "call$1", "developer_Metrics_register$closure", 2, 0, 416, 577, [], "register"],
        Metrics_deregister: [function(metric) {
          if (!(metric instanceof P.Metric))
            throw H.wrapException(P.ArgumentError$("metric must be a Metric"));
          $.$get$Metrics__metrics().remove$1(0, metric.name);
        }, "call$1", "developer_Metrics_deregister$closure", 2, 0, 416, 577, [], "deregister"],
        Metrics__printMetric: [function(id) {
          var metric = $.$get$Metrics__metrics().$index(0, id);
          if (metric == null)
            return;
          return C.JsonCodec_null_null.encode$1(metric._toJSON$0());
        }, "call$1", "developer_Metrics__printMetric$closure", 2, 0, 28, 352, [], "_printMetric"],
        Metrics__printMetrics: [function() {
          var metrics, t1;
          metrics = [];
          for (t1 = $.$get$Metrics__metrics().get$values(), t1 = t1.get$iterator(t1); t1.moveNext$0();)
            metrics.push(t1.get$current()._toJSON$0());
          return C.JsonCodec_null_null.encode$1(P.LinkedHashMap__makeLiteral(["type", "MetricList", "metrics", metrics]));
        }, "call$0", "developer_Metrics__printMetrics$closure", 0, 0, 7, "_printMetrics"]
      }
    },
    "+Metrics": [1],
    ServiceProtocolInfo: {
      "^": "Object;majorVersion<-0,minorVersion<-0,serverUri<-36",
      toString$0: [function(_) {
        var t1, t2, t3;
        t1 = this.serverUri;
        t2 = this.majorVersion;
        t3 = this.minorVersion;
        if (t1 != null)
          return "Dart VM Service Protocol v" + H.S(t2) + "." + H.S(t3) + " listening on " + H.S(t1);
        else
          return "Dart VM Service Protocol v" + H.S(t2) + "." + H.S(t3);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        ServiceProtocolInfo$: [function(serverUri) {
          return new P.ServiceProtocolInfo(0, 0, serverUri);
        }, null, null, 2, 0, 136, 679, [], "new ServiceProtocolInfo"]
      }
    },
    "+ServiceProtocolInfo": [1],
    Service: {
      "^": "Object;",
      static: {
        Service$: [function() {
          return new P.Service();
        }, null, null, 0, 0, 786, "new Service"],
        Service_getInfo: [function() {
          var $async$goto = 0, $async$completer = new P.Completer_Completer$sync(), $async$returnValue, $async$handler = 2, $async$currentError, t1, receivePort, t2, uri;
          var $async$Service_getInfo = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
            if ($async$errorCode === 1) {
              $async$currentError = $async$result;
              $async$goto = $async$handler;
            }
            while (true)
              switch ($async$goto) {
                case 0:
                  // Function start
                  t1 = $.RawReceivePortImpl__nextFreeId;
                  $.RawReceivePortImpl__nextFreeId = t1 + 1;
                  receivePort = new H.RawReceivePortImpl(t1, null, false);
                  t2 = init.globalState.currentContext;
                  t2._addRegistration$2(t1, receivePort);
                  t2._updateGlobalState$0();
                  t2 = P.Uri;
                  t1 = new P._Future(0, $.Zone__current, null, [t2]);
                  receivePort._handler = new P.Service_getInfo_closure(new P._AsyncCompleter(t1, [t2]));
                  new H._NativeJsSendPort(receivePort, init.globalState.currentContext.id).send$1(null);
                  $async$goto = 3;
                  return P._asyncHelper(t1, $async$Service_getInfo, $async$completer);
                case 3:
                  // returning from await.
                  uri = $async$result;
                  receivePort.close$0();
                  $async$returnValue = new P.ServiceProtocolInfo(0, 0, uri);
                  // goto return
                  $async$goto = 1;
                  break;
                case 1:
                  // return
                  return P._asyncHelper($async$returnValue, 0, $async$completer);
                case 2:
                  // rethrow
                  return P._asyncHelper($async$currentError, 1, $async$completer);
              }
          });
          return P._asyncHelper(null, $async$Service_getInfo, $async$completer);
        }, "call$0", "developer_Service_getInfo$closure", 0, 0, 787, "getInfo"],
        Service_controlWebServer: [function(enable) {
          var $async$goto = 0, $async$completer = new P.Completer_Completer$sync(), $async$returnValue, $async$handler = 2, $async$currentError, t1, receivePort, t2, uri;
          var $async$Service_controlWebServer = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
            if ($async$errorCode === 1) {
              $async$currentError = $async$result;
              $async$goto = $async$handler;
            }
            while (true)
              switch ($async$goto) {
                case 0:
                  // Function start
                  if (typeof enable !== "boolean")
                    throw H.wrapException(P.ArgumentError$value(enable, "enable", "Must be a bool"));
                  t1 = $.RawReceivePortImpl__nextFreeId;
                  $.RawReceivePortImpl__nextFreeId = t1 + 1;
                  receivePort = new H.RawReceivePortImpl(t1, null, false);
                  t2 = init.globalState.currentContext;
                  t2._addRegistration$2(t1, receivePort);
                  t2._updateGlobalState$0();
                  t2 = P.Uri;
                  t1 = new P._Future(0, $.Zone__current, null, [t2]);
                  receivePort._handler = new P.Service_controlWebServer_closure(new P._AsyncCompleter(t1, [t2]));
                  new H._NativeJsSendPort(receivePort, init.globalState.currentContext.id).send$1(null);
                  $async$goto = 3;
                  return P._asyncHelper(t1, $async$Service_controlWebServer, $async$completer);
                case 3:
                  // returning from await.
                  uri = $async$result;
                  receivePort.close$0();
                  $async$returnValue = new P.ServiceProtocolInfo(0, 0, uri);
                  // goto return
                  $async$goto = 1;
                  break;
                case 1:
                  // return
                  return P._asyncHelper($async$returnValue, 0, $async$completer);
                case 2:
                  // rethrow
                  return P._asyncHelper($async$currentError, 1, $async$completer);
              }
          });
          return P._asyncHelper(null, $async$Service_controlWebServer, $async$completer);
        }, function() {
          return P.Service_controlWebServer(false);
        }, "call$1$enable", "call$0", "developer_Service_controlWebServer$closure", 0, 3, 788, 4, 575, [], "controlWebServer"],
        Service_getIsolateID: [function(isolate) {
          if (!(isolate instanceof P.Isolate))
            throw H.wrapException(P.ArgumentError$value(isolate, "isolate", "Must be an Isolate"));
          return;
        }, "call$1", "developer_Service_getIsolateID$closure", 2, 0, 789, 458, [], "getIsolateID"]
      }
    },
    "+Service": [1],
    Service_getInfo_closure: {
      "^": "Closure:136;uriCompleter",
      call$1: [function(uri) {
        return this.uriCompleter.complete$1(uri);
      }, null, null, 2, 0, 136, 40, [], "call"]
    },
    "+ Service_getInfo_closure": [2],
    Service_controlWebServer_closure: {
      "^": "Closure:136;uriCompleter",
      call$1: [function(uri) {
        return this.uriCompleter.complete$1(uri);
      }, null, null, 2, 0, 136, 40, [], "call"]
    },
    "+ Service_controlWebServer_closure": [2],
    Timeline: {
      "^": "Object;",
      static: {
        "^": "Timeline__stack<-1478,Timeline__isolateId<-0,Timeline__isolateIdString<-9",
        Timeline$: [function() {
          return new P.Timeline();
        }, null, null, 0, 0, 792, "new Timeline"],
        Timeline_startSync: [function($name, $arguments) {
          if (typeof $name !== "string")
            throw H.wrapException(P.ArgumentError$value($name, "name", "Must be a String"));
          $.$get$Timeline__stack().push(null);
          return;
        }, function($name) {
          return P.Timeline_startSync($name, null);
        }, "call$2$arguments", "call$1", "developer_Timeline_startSync$closure", 2, 3, 224, 0, 13, [], 69, [], "startSync"],
        Timeline_finishSync: [function() {
          var t1, t2, block;
          t1 = $.$get$Timeline__stack();
          t2 = t1.length;
          if (t2 === 0)
            throw H.wrapException(new P.StateError("Uneven calls to startSync and finishSync"));
          if (0 >= t2)
            return H.ioore(t1, -1);
          block = t1.pop();
          if (block == null)
            return;
          P._argumentsAsJson(block._developer$_arguments);
        }, "call$0", "developer_Timeline_finishSync$closure", 0, 0, 6, "finishSync"],
        Timeline_instantSync: [function($name, $arguments) {
          if (typeof $name !== "string")
            throw H.wrapException(P.ArgumentError$value($name, "name", "Must be a String"));
          return;
        }, function($name) {
          return P.Timeline_instantSync($name, null);
        }, "call$2$arguments", "call$1", "developer_Timeline_instantSync$closure", 2, 3, 224, 0, 13, [], 69, [], "instantSync"],
        Timeline_timeSync: [function($name, $function, $arguments) {
          var t1;
          P.Timeline_startSync($name, $arguments);
          try {
            t1 = $function.call$0();
            return t1;
          } finally {
            P.Timeline_finishSync();
          }
        }, function($name, $function) {
          return P.Timeline_timeSync($name, $function, null);
        }, "call$3$arguments", "call$2", "developer_Timeline_timeSync$closure", 4, 3, 793, 0, 13, [], 115, [], 69, [], "timeSync"],
        Timeline_now: [function() {
          var t1 = $._clockValue;
          $._clockValue = t1 + 1;
          return t1;
        }, null, null, 1, 0, 11, "now"]
      }
    },
    "+Timeline": [1],
    TimelineTask: {
      "^": "Object;_taskId<-0,_stack<-1479",
      start$2$arguments: [function($name, $arguments) {
        var block, t1;
        if (typeof $name !== "string")
          throw H.wrapException(P.ArgumentError$value($name, "name", "Must be a String"));
        block = new P._AsyncBlock("Dart", $name, this._taskId, null);
        if (!!J.getInterceptor($arguments).$isMap) {
          t1 = P.LinkedHashMap__makeEmpty();
          block._developer$_arguments = t1;
          t1.addAll$1(0, $arguments);
        }
        J.add$1$ax(this._stack, block);
        $._clockValue = $._clockValue + 1;
        P._argumentsAsJson(block._developer$_arguments);
      }, function($name) {
        return this.start$2$arguments($name, null);
      }, "start$1", "call$2$arguments", "call$1", "get$start", 2, 3, 224, 0, 13, [], 69, [], "start"],
      instant$2$arguments: [function($name, $arguments) {
        var instantArguments;
        if (typeof $name !== "string")
          throw H.wrapException(P.ArgumentError$value($name, "name", "Must be a String"));
        instantArguments = !!J.getInterceptor($arguments).$isMap ? P.LinkedHashMap_LinkedHashMap$from($arguments, null, null) : null;
        $._clockValue = $._clockValue + 1;
        P._argumentsAsJson(instantArguments);
      }, function($name) {
        return this.instant$2$arguments($name, null);
      }, "instant$1", "call$2$arguments", "call$1", "get$instant", 2, 3, 224, 0, 13, [], 69, [], "instant"],
      finish$0: [function() {
        var t1, t2;
        t1 = this._stack;
        t2 = J.getInterceptor$asx(t1);
        if (J.$eq$(t2.get$length(t1), 0))
          throw H.wrapException(new P.StateError("Uneven calls to start and finish"));
        t2.removeLast$0(t1)._finish$0();
      }, "call$0", "get$finish", 0, 0, 6, "finish"],
      pass$0: [function() {
        if (J.$gt$n(J.get$length$asx(this._stack), 0))
          throw H.wrapException(new P.StateError("You cannot pass a TimelineTask without finishing all started operations"));
        return this._taskId;
      }, "call$0", "get$pass", 0, 0, 11, "pass"],
      TimelineTask$withTaskId$1: function(taskId) {
        if (typeof taskId !== "number" || Math.floor(taskId) !== taskId)
          throw H.wrapException(P.ArgumentError$value(taskId, "taskId", "Must be an int"));
      },
      static: {
        TimelineTask$: [function() {
          return new P.TimelineTask(0, []);
        }, null, null, 0, 0, 4, "new TimelineTask"],
        TimelineTask$withTaskId: [function(taskId) {
          var t1 = new P.TimelineTask(taskId, []);
          t1.TimelineTask$withTaskId$1(taskId);
          return t1;
        }, null, null, 2, 0, 22, 572, [], "new TimelineTask$withTaskId"]
      }
    },
    "+TimelineTask": [1],
    _AsyncBlock: {
      "^": "Object;category<-9,name<-9,_taskId<-0,_developer$_arguments@-122",
      _developer$_start$0: [function() {
        $._clockValue = $._clockValue + 1;
        P._argumentsAsJson(this._developer$_arguments);
      }, "call$0", "get$_developer$_start", 0, 0, 6, "_developer$_start"],
      _finish$0: [function() {
        $._clockValue = $._clockValue + 1;
        P._argumentsAsJson(null);
      }, "call$0", "get$_finish", 0, 0, 6, "_finish"],
      _appendArguments$1: [function($arguments) {
        var t1 = this._developer$_arguments;
        if (t1 == null) {
          t1 = P.LinkedHashMap__makeEmpty();
          this._developer$_arguments = t1;
        }
        J.addAll$1$ax(t1, $arguments);
      }, "call$1", "get$_appendArguments", 2, 0, 287, 69, [], "_appendArguments"],
      static: {
        _AsyncBlock$_: [function($name, _taskId) {
          return new P._AsyncBlock("Dart", $name, _taskId, null);
        }, null, null, 4, 0, 147, 13, [], 684, [], "new _AsyncBlock$_"]
      }
    },
    "+_AsyncBlock": [1],
    _SyncBlock: {
      "^": "Object;category<-9,name<-9,_developer$_arguments@-122,_developer$_start<-0,_startCpu<-0",
      finish$0: [function() {
        P._argumentsAsJson(this._developer$_arguments);
      }, "call$0", "get$finish", 0, 0, 6, "finish"],
      _appendArguments$1: [function($arguments) {
        var t1;
        if ($arguments == null)
          return;
        t1 = this._developer$_arguments;
        if (t1 == null) {
          t1 = P.LinkedHashMap__makeEmpty();
          this._developer$_arguments = t1;
        }
        J.addAll$1$ax(t1, $arguments);
      }, "call$1", "get$_appendArguments", 2, 0, 287, 69, [], "_appendArguments"],
      _developer$_start$0: function() {
        return this._developer$_start.call$0();
      },
      static: {
        _SyncBlock$_: [function($name, _start, _startCpu) {
          return new P._SyncBlock("Dart", $name, null, _start, _startCpu);
        }, null, null, 6, 0, 417, 13, [], 685, [], 686, [], "new _SyncBlock$_"]
      }
    },
    "+_SyncBlock": [1],
    ServiceExtensionHandler: {
      "^": "",
      $typedefType: 193,
      $$isTypedef: true
    },
    "+ServiceExtensionHandler": "",
    TimelineSyncFunction: {
      "^": "",
      $typedefType: 4,
      $$isTypedef: true
    },
    "+TimelineSyncFunction": "",
    TimelineAsyncFunction: {
      "^": "",
      $typedefType: 18,
      $$isTypedef: true
    },
    "+TimelineAsyncFunction": ""
  }], ["dart.io", "dart:io",, P, {
    "^": "_serverMaxWindowBits<-9,_clientMaxWindowBits<-9,_serverNoContextTakeover<-9,_clientNoContextTakeover<-9,_webSocketGUID<-9,SYSTEM_ENCODING<-1636,_stderr@-527,_stdout@-527,_stdin@-1638,_STDIO_HANDLE_TYPE_OTHER<-0,_STDIO_HANDLE_TYPE_SOCKET<-0,_STDIO_HANDLE_TYPE_FILE<-0,_STDIO_HANDLE_TYPE_PIPE<-0,_STDIO_HANDLE_TYPE_TERMINAL<-0,_nextServiceId@-0,_SSL_PROCESS_FILTER<-0,_DIRECTORY_RENAME<-0,_DIRECTORY_LIST_STOP<-0,_DIRECTORY_LIST_NEXT<-0,_DIRECTORY_LIST_START<-0,_DIRECTORY_CREATE_TEMP<-0,_DIRECTORY_EXISTS<-0,_DIRECTORY_DELETE<-0,_DIRECTORY_CREATE<-0,_SOCKET_REVERSE_LOOKUP<-0,_SOCKET_LIST_INTERFACES<-0,_SOCKET_LOOKUP<-0,_FILE_LOCK<-0,_FILE_STAT<-0,_FILE_IDENTICAL<-0,_FILE_TYPE<-0,_FILE_LINK_TARGET<-0,_FILE_RENAME_LINK<-0,_FILE_DELETE_LINK<-0,_FILE_CREATE_LINK<-0,_FILE_WRITE_FROM<-0,_FILE_READ_INTO<-0,_FILE_READ<-0,_FILE_WRITE_BYTE<-0,_FILE_READ_BYTE<-0,_FILE_FLUSH<-0,_FILE_SET_LAST_MODIFIED<-0,_FILE_LAST_MODIFIED<-0,_FILE_SET_LAST_ACCESSED<-0,_FILE_LAST_ACCESSED<-0,_FILE_LENGTH_FROM_PATH<-0,_FILE_LENGTH<-0,_FILE_TRUNCATE<-0,_FILE_SET_POSITION<-0,_FILE_POSITION<-0,_FILE_CLOSE<-0,_FILE_RESOLVE_SYMBOLIC_LINKS<-0,_FILE_OPEN<-0,_FILE_COPY<-0,_FILE_RENAME<-0,_FILE_DELETE<-0,_FILE_CREATE<-0,_FILE_EXISTS<-0,_DART_SESSION_ID<-9,_OUTGOING_BUFFER_SIZE<-0,_BLOCK_SIZE<-0,WRITE_ONLY_APPEND<-10,WRITE_ONLY<-10,APPEND<-10,WRITE<-10,READ<-10,GZIP<-1639,ZLIB<-1640,_BYTES_PER_WORD<-10,_BITS_PER_BYTE<-10,_MASK_32<-10,_MASK_8<-10,_OSERROR_RESPONSE_MESSAGE<-0,_OSERROR_RESPONSE_ERROR_CODE<-0,_ERROR_RESPONSE_ERROR_TYPE<-0,_FILE_CLOSED_RESPONSE<-0,_OSERROR_RESPONSE<-0,_ILLEGAL_ARGUMENT_RESPONSE<-0,_SUCCESS_RESPONSE<-0",
    _isErrorResponse: [function(response) {
      var t1 = J.getInterceptor(response);
      return !!t1.$isList && !J.$eq$(t1.$index(response, 0), 0);
    }, "call$1", "io___isErrorResponse$closure", 2, 0, 24, 18, [], "_isErrorResponse"],
    _exceptionFromResponse: [function(response, message, path) {
      var t1 = J.getInterceptor$asx(response);
      switch (t1.$index(response, 0)) {
        case 1:
          return new P.ArgumentError(false, null, null, H.S(message) + ": " + H.S(path));
        case 2:
          return new P.FileSystemException(message, path, new P.OSError(t1.$index(response, 2), t1.$index(response, 1)));
        case 3:
          return new P.FileSystemException("File closed", path, null);
        default:
          return new P._Exception("Unknown error");
      }
    }, "call$3", "io___exceptionFromResponse$closure", 6, 0, 370, 18, [], 17, [], 10, [], "_exceptionFromResponse"],
    _ensureFastAndSerializableByteData: [function(buffer, start, end) {
      var t1, $length, t2, newBuffer, j, i, value;
      t1 = J.getInterceptor(buffer);
      if (!!t1.$isUint8List || !!t1.$isInt8List)
        return new P._BufferAndStart(buffer, start);
      $length = J.$sub$n(end, start);
      t2 = H._checkLength($length);
      newBuffer = new Uint8Array(t2);
      if (typeof $length !== "number")
        return H.iae($length);
      j = start;
      i = 0;
      for (; i < $length; ++i) {
        value = t1.$index(buffer, j);
        if (typeof value !== "number" || Math.floor(value) !== value)
          throw H.wrapException(P.ArgumentError$("List element is not an integer at index " + H.S(j)));
        if (i >= t2)
          return H.ioore(newBuffer, i);
        newBuffer[i] = value;
        j = J.$add$ns(j, 1);
      }
      return new P._BufferAndStart(newBuffer, 0);
    }, "call$3", "io___ensureFastAndSerializableByteData$closure", 6, 0, 802, 41, [], 3, [], 5, [], "_ensureFastAndSerializableByteData"],
    _validateZLibWindowBits: [function(windowBits) {
      if (typeof windowBits !== "number")
        return H.iae(windowBits);
      if (8 > windowBits || 15 < windowBits)
        throw H.wrapException(P.RangeError$range(windowBits, 8, 15, null, null));
    }, "call$1", "io___validateZLibWindowBits$closure", 2, 0, 17, 112, [], "_validateZLibWindowBits"],
    _validateZLibeLevel: [function(level) {
      if (typeof level !== "number")
        return H.iae(level);
      if (-1 > level || 9 < level)
        throw H.wrapException(P.RangeError$range(level, -1, 9, null, null));
    }, "call$1", "io___validateZLibeLevel$closure", 2, 0, 17, 136, [], "_validateZLibeLevel"],
    _validateZLibMemLevel: [function(memLevel) {
      if (typeof memLevel !== "number")
        return H.iae(memLevel);
      if (1 > memLevel || 9 < memLevel)
        throw H.wrapException(P.RangeError$range(memLevel, 1, 9, null, null));
    }, "call$1", "io___validateZLibMemLevel$closure", 2, 0, 17, 167, [], "_validateZLibMemLevel"],
    _validateZLibStrategy: [function(strategy) {
      if (J.$eq$(C.JSArray_methods.indexOf$1(C.List_yTu0, strategy), -1))
        throw H.wrapException(P.ArgumentError$("Unsupported 'strategy'"));
    }, "call$1", "io___validateZLibStrategy$closure", 2, 0, 17, 169, [], "_validateZLibStrategy"],
    _getHttpVersion: [function() {
      var version = $.$get$Platform__version();
      return "Dart/" + H.S(C.JSNull_methods.substring$2(version, 0, C.JSNull_methods.indexOf$2(version, ".", C.JSNull_methods.indexOf$1(version, ".").$add(0, 1)))) + " (dart:io)";
    }, "call$0", "io___getHttpVersion$closure", 0, 0, 7, "_getHttpVersion"],
    exit: [function(code) {
      if (typeof code !== "number" || Math.floor(code) !== code)
        throw H.wrapException(P.ArgumentError$("Integer value for exit code expected"));
      P._ProcessUtils__exit(code);
    }, "call$1", "io__exit$closure", 2, 0, 17, 145, [], "exit"],
    exitCode: [function(code) {
      if (typeof code !== "number" || Math.floor(code) !== code)
        throw H.wrapException(P.ArgumentError$("Integer value for exit code expected"));
      P._ProcessUtils__setExitCode(code);
    }, null, null, 3, 0, 17, 145, [], "exitCode"],
    exitCode0: [function() {
      return P._ProcessUtils__getExitCode();
    }, null, null, 1, 0, 11, "exitCode"],
    sleep: [function(duration) {
      var milliseconds = duration.get$inMilliseconds();
      if (J.$lt$n(milliseconds, 0))
        throw H.wrapException(P.ArgumentError$("sleep: duration cannot be negative"));
      P._ProcessUtils__sleep(milliseconds);
    }, "call$1", "io__sleep$closure", 2, 0, 162, 59, [], "sleep"],
    pid: [function() {
      return P._ProcessUtils__pid(null);
    }, null, null, 1, 0, 11, "pid"],
    stdin: [function() {
      var t1 = $._stdin;
      if (t1 == null) {
        t1 = P._StdIOUtils__getStdioInputStream();
        $._stdin = t1;
      }
      return t1;
    }, null, null, 1, 0, 429, "stdin"],
    stdout: [function() {
      var t1 = $._stdout;
      if (t1 == null) {
        t1 = P._StdIOUtils__getStdioOutputStream(1);
        $._stdout = t1;
      }
      return t1;
    }, null, null, 1, 0, 430, "stdout"],
    stderr: [function() {
      var t1 = $._stderr;
      if (t1 == null) {
        t1 = P._StdIOUtils__getStdioOutputStream(2);
        $._stderr = t1;
      }
      return t1;
    }, null, null, 1, 0, 430, "stderr"],
    stdioType: [function(object) {
      var t1, t2, exception;
      if (object instanceof P._StdStream)
        object = object.get$_io$_stream();
      else {
        if (!J.$eq$(object, P.stdout())) {
          t1 = object;
          t2 = $._stderr;
          if (t2 == null) {
            t2 = P._StdIOUtils__getStdioOutputStream(2);
            $._stderr = t2;
          }
          t2 = J.$eq$(t1, t2);
          t1 = t2;
        } else
          t1 = true;
        if (t1)
          switch (P._StdIOUtils__getStdioHandleType(J.$eq$(object, P.stdout()) ? 1 : 2)) {
            case 0:
              return C.StdioType_terminal;
            case 1:
              return C.StdioType_pipe;
            case 2:
              return C.StdioType_file;
          }
      }
      if (object instanceof P._FileStream)
        return C.StdioType_file;
      if (!!J.getInterceptor(object).$isSocket)
        P._StdIOUtils__socketType(object);
      if (object instanceof P._IOSinkImpl)
        try {
          if (object.get$_io$_target() instanceof P._FileStreamConsumer)
            return C.StdioType_file;
        } catch (exception) {
          H.unwrapException(exception);
        }
      return C.StdioType_other;
    }, "call$1", "io__stdioType$closure", 2, 0, 986, 23, [], "stdioType"],
    BytesBuilder: {
      "^": "Object;",
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      static: {
        BytesBuilder_BytesBuilder: [function(copy) {
          if (copy === true)
            return P._CopyingBytesBuilder$(0);
          else
            return new P._BytesBuilder(0, []);
        }, null, null, 0, 3, 798, 25, 691, [], "new BytesBuilder"]
      }
    },
    "+BytesBuilder": [1],
    _CopyingBytesBuilder: {
      "^": "Object;_io$_length@-0,_io$_buffer@-89",
      add$1: [function(_, bytes) {
        var t1, bytesLength, required, i;
        t1 = J.getInterceptor$asx(bytes);
        bytesLength = t1.get$length(bytes);
        if (J.$eq$(bytesLength, 0))
          return;
        required = J.$add$ns(this._io$_length, bytesLength);
        if (J.$lt$n(J.get$length$asx(this._io$_buffer), required))
          this._io$_grow$1(required);
        if (!!t1.$isUint8List)
          J.setRange$3$ax(this._io$_buffer, this._io$_length, required, bytes);
        else {
          if (typeof bytesLength !== "number")
            return H.iae(bytesLength);
          i = 0;
          for (; i < bytesLength; ++i)
            J.$indexSet$ax(this._io$_buffer, J.$add$ns(this._io$_length, i), t1.$index(bytes, i));
        }
        this._io$_length = required;
      }, "call$1", "get$add", 2, 0, 26, 30, [], "add"],
      addByte$1: [function(byte) {
        if (J.$eq$(J.get$length$asx(this._io$_buffer), this._io$_length))
          this._io$_grow$1(this._io$_length);
        J.$indexSet$ax(this._io$_buffer, this._io$_length, byte);
        this._io$_length = J.$add$ns(this._io$_length, 1);
      }, "call$1", "get$addByte", 2, 0, 17, 149, [], "addByte"],
      _io$_grow$1: [function(required) {
        var newSize, newBuffer;
        newSize = J.$mul$ns(required, 2);
        newBuffer = new Uint8Array(H._checkLength(J.$lt$n(newSize, 1024) ? 1024 : P._CopyingBytesBuilder__pow2roundup(newSize)));
        C.NativeUint8List_methods.setRange$3(newBuffer, 0, J.get$length$asx(this._io$_buffer), this._io$_buffer);
        this._io$_buffer = newBuffer;
      }, "call$1", "get$_io$_grow", 2, 0, 17, 852, [], "_io$_grow"],
      takeBytes$0: [function() {
        if (J.$eq$(this._io$_length, 0))
          return $.$get$_CopyingBytesBuilder__emptyList();
        var buffer = J.asUint8List$2$x(J.get$buffer$x(this._io$_buffer), 0, this._io$_length);
        this._io$_length = 0;
        this._io$_buffer = $.$get$_CopyingBytesBuilder__emptyList();
        return buffer;
      }, "call$0", "get$takeBytes", 0, 0, 69, "takeBytes"],
      toBytes$0: [function() {
        if (J.$eq$(this._io$_length, 0))
          return $.$get$_CopyingBytesBuilder__emptyList();
        return new Uint8Array(H._ensureNativeList(J.asUint8List$2$x(J.get$buffer$x(this._io$_buffer), 0, this._io$_length)));
      }, "call$0", "get$toBytes", 0, 0, 69, "toBytes"],
      get$length: [function(_) {
        return this._io$_length;
      }, null, null, 1, 0, 11, "length"],
      get$isEmpty: [function(_) {
        return J.$eq$(this._io$_length, 0);
      }, null, null, 1, 0, 5, "isEmpty"],
      get$isNotEmpty: [function(_) {
        return !J.$eq$(this._io$_length, 0);
      }, null, null, 1, 0, 5, "isNotEmpty"],
      clear$0: [function(_) {
        this._io$_length = 0;
        this._io$_buffer = $.$get$_CopyingBytesBuilder__emptyList();
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      static: {
        "^": "_CopyingBytesBuilder__INIT_SIZE<-0,_CopyingBytesBuilder__emptyList<-10",
        _CopyingBytesBuilder$: [function(initialCapacity) {
          return new P._CopyingBytesBuilder(0, J.$le$n(initialCapacity, 0) ? $.$get$_CopyingBytesBuilder__emptyList() : new Uint8Array(H._checkLength(P._CopyingBytesBuilder__pow2roundup(initialCapacity))));
        }, null, null, 0, 2, 396, 7, 446, [], "new _CopyingBytesBuilder"],
        _CopyingBytesBuilder__pow2roundup: [function(x) {
          var t1;
          x = J.$sub$n(x, 1);
          t1 = J.getInterceptor$n(x);
          x = t1.$or(x, t1.$shr(x, 1));
          t1 = J.getInterceptor$n(x);
          x = t1.$or(x, t1.$shr(x, 2));
          t1 = J.getInterceptor$n(x);
          x = t1.$or(x, t1.$shr(x, 4));
          t1 = J.getInterceptor$n(x);
          x = t1.$or(x, t1.$shr(x, 8));
          t1 = J.getInterceptor$n(x);
          return J.$add$ns(t1.$or(x, t1.$shr(x, 16)), 1);
        }, "call$1", "io__CopyingBytesBuilder__pow2roundup$closure", 2, 0, 16, 38, [], "_pow2roundup"]
      }
    },
    "+_CopyingBytesBuilder": [1, 226],
    _BytesBuilder: {
      "^": "Object;_io$_length@-0,_chunks<-481",
      add$1: [function(_, bytes) {
        var typedBytes = !!J.getInterceptor(bytes).$isUint8List ? bytes : new Uint8Array(H._ensureNativeList(bytes));
        J.add$1$ax(this._chunks, typedBytes);
        this._io$_length = J.$add$ns(this._io$_length, J.get$length$asx(typedBytes));
      }, "call$1", "get$add", 2, 0, 26, 30, [], "add"],
      addByte$1: [function(byte) {
        var t1, t2;
        t1 = H._checkLength(1);
        t2 = new Uint8Array(t1);
        if (0 >= t1)
          return H.ioore(t2, 0);
        t2[0] = byte;
        J.add$1$ax(this._chunks, t2);
        this._io$_length = J.$add$ns(this._io$_length, 1);
      }, "call$1", "get$addByte", 2, 0, 17, 149, [], "addByte"],
      takeBytes$0: [function() {
        var t1, t2, buffer, t3, offset, chunk, t4, t5;
        if (J.$eq$(this._io$_length, 0))
          return $.$get$_CopyingBytesBuilder__emptyList();
        t1 = this._chunks;
        t2 = J.getInterceptor$asx(t1);
        if (J.$eq$(t2.get$length(t1), 1)) {
          buffer = t2.$index(t1, 0);
          this._io$_length = 0;
          t2.clear$0(t1);
          return buffer;
        }
        buffer = new Uint8Array(H._checkLength(this._io$_length));
        for (t3 = t2.get$iterator(t1), offset = 0; t3.moveNext$0();) {
          chunk = t3.get$current();
          t4 = J.getInterceptor$asx(chunk);
          t5 = t4.get$length(chunk);
          if (typeof t5 !== "number")
            return H.iae(t5);
          C.NativeUint8List_methods.setRange$3(buffer, offset, offset + t5, chunk);
          t4 = t4.get$length(chunk);
          if (typeof t4 !== "number")
            return H.iae(t4);
          offset += t4;
        }
        this._io$_length = 0;
        t2.clear$0(t1);
        return buffer;
      }, "call$0", "get$takeBytes", 0, 0, 69, "takeBytes"],
      toBytes$0: [function() {
        var buffer, t1, offset, chunk, t2, t3;
        if (J.$eq$(this._io$_length, 0))
          return $.$get$_CopyingBytesBuilder__emptyList();
        buffer = new Uint8Array(H._checkLength(this._io$_length));
        for (t1 = J.get$iterator$ax(this._chunks), offset = 0; t1.moveNext$0();) {
          chunk = t1.get$current();
          t2 = J.getInterceptor$asx(chunk);
          t3 = t2.get$length(chunk);
          if (typeof t3 !== "number")
            return H.iae(t3);
          C.NativeUint8List_methods.setRange$3(buffer, offset, offset + t3, chunk);
          t2 = t2.get$length(chunk);
          if (typeof t2 !== "number")
            return H.iae(t2);
          offset += t2;
        }
        return buffer;
      }, "call$0", "get$toBytes", 0, 0, 69, "toBytes"],
      get$length: [function(_) {
        return this._io$_length;
      }, null, null, 1, 0, 11, "length"],
      get$isEmpty: [function(_) {
        return J.$eq$(this._io$_length, 0);
      }, null, null, 1, 0, 5, "isEmpty"],
      get$isNotEmpty: [function(_) {
        return !J.$eq$(this._io$_length, 0);
      }, null, null, 1, 0, 5, "isNotEmpty"],
      clear$0: [function(_) {
        this._io$_length = 0;
        J.clear$0$ax(this._chunks);
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      static: {
        _BytesBuilder$: [function() {
          return new P._BytesBuilder(0, []);
        }, null, null, 0, 0, 799, "new _BytesBuilder"]
      }
    },
    "+_BytesBuilder": [1, 226],
    IOException: {
      "^": "Object;",
      toString$0: [function(_) {
        return "IOException";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isException: 1,
      static: {
        IOException$: [function() {
          return new P.IOException();
        }, null, null, 0, 0, 800, "new IOException"]
      }
    },
    "+IOException": [1, 102],
    OSError: {
      "^": "Object;message<-9,errorCode<-0",
      toString$0: [function(_) {
        var t1, t2, t3;
        t1 = this.message;
        if (J.get$isEmpty$asx(t1) !== true) {
          t1 = "OS Error: " + H.S(t1);
          t2 = this.errorCode;
          t3 = J.getInterceptor(t2);
          if (!t3.$eq(t2, -1))
            t1 = t1 + ", errno = " + H.S(t3.toString$0(t2));
        } else {
          t1 = this.errorCode;
          t2 = J.getInterceptor(t1);
          t1 = !t2.$eq(t1, -1) ? "OS Error: errno = " + H.S(t2.toString$0(t1)) : "OS Error";
        }
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        "^": "OSError_noErrorCode<-0",
        OSError$: [function(message, errorCode) {
          return new P.OSError(message, errorCode);
        }, null, null, 0, 4, 418, 32, 204, 17, [], 160, [], "new OSError"]
      }
    },
    "+OSError": [1],
    _BufferAndStart: {
      "^": "Object;buffer*-14,start@-0",
      start$0: function() {
        return this.start.call$0();
      },
      start$2$arguments: function(arg0, arg1) {
        return this.start.call$2$arguments(arg0, arg1);
      },
      static: {
        _BufferAndStart$: [function(buffer, start) {
          return new P._BufferAndStart(buffer, start);
        }, null, null, 4, 0, 321, 41, [], 3, [], "new _BufferAndStart"]
      }
    },
    "+_BufferAndStart": [1],
    _IOCrypto: {
      "^": "Object;",
      static: {
        _IOCrypto$: [function() {
          return new P._IOCrypto();
        }, null, null, 0, 0, 803, "new _IOCrypto"],
        _IOCrypto_getRandomBytes: [function(count) {
          throw H.wrapException(new P.UnsupportedError("_IOCrypto.getRandomBytes"));
        }, "call$1", "io__IOCrypto_getRandomBytes$closure", 2, 0, 229, 43, [], "getRandomBytes"]
      }
    },
    "+_IOCrypto": [1],
    _CryptoUtils: {
      "^": "Object;",
      static: {
        "^": "_CryptoUtils_PAD<-0,_CryptoUtils_CR<-0,_CryptoUtils_LF<-0,_CryptoUtils_LINE_LENGTH<-0,_CryptoUtils__encodeTable<-9,_CryptoUtils__encodeTableUrlSafe<-9,_CryptoUtils__decodeTable<-14",
        _CryptoUtils$: [function() {
          return new P._CryptoUtils();
        }, null, null, 0, 0, 804, "new _CryptoUtils"],
        _CryptoUtils_bytesToHex: [function(bytes) {
          var t1, t2, part, t3, t4;
          for (t1 = J.get$iterator$ax(bytes), t2 = ""; t1.moveNext$0(); t2 = t3) {
            part = t1.get$current();
            t3 = J.getInterceptor$n(part);
            t4 = t3.$lt(part, 16) ? "0" : "";
            t3 = t2 + (t4 + t3.toRadixString$1(part, 16));
          }
          return t2.charCodeAt(0) == 0 ? t2 : t2;
        }, "call$1", "io__CryptoUtils_bytesToHex$closure", 2, 0, 158, 30, [], "bytesToHex"],
        _CryptoUtils_bytesToBase64: [function(bytes, urlSafe, addLineSeparator) {
          var t1, len, t2, lookup, remainderLength, chunkLength, outputLen, t3, out, t4, j, i, c, i0, t5, t6, t7, x, j0, y;
          t1 = J.getInterceptor$asx(bytes);
          len = t1.get$length(bytes);
          t2 = J.getInterceptor(len);
          if (t2.$eq(len, 0))
            return "";
          lookup = urlSafe === true ? "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_" : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          remainderLength = t2.remainder$1(len, 3);
          chunkLength = t2.$sub(len, remainderLength);
          t2 = J.$mul$ns(t2.$tdiv(len, 3), 4);
          outputLen = J.$add$ns(t2, remainderLength > 0 ? 4 : 0);
          t2 = addLineSeparator === true;
          if (t2) {
            t3 = J.getInterceptor$n(outputLen);
            outputLen = t3.$add(outputLen, J.$shl$n(J.$tdiv$n(t3.$sub(outputLen, 1), 76), 1));
          }
          if (typeof outputLen !== "number")
            return H.iae(outputLen);
          t3 = new Array(outputLen);
          t3.fixed$length = Array;
          out = H.setRuntimeTypeInfo(t3, [P.int]);
          if (typeof chunkLength !== "number")
            return H.iae(chunkLength);
          t3 = out.length;
          t4 = outputLen - 2;
          j = 0;
          i = 0;
          c = 0;
          for (; i < chunkLength; i = i0) {
            i0 = i + 1;
            t5 = J.$shl$n(t1.$index(bytes, i), 16);
            i = i0 + 1;
            t6 = J.$shl$n(t1.$index(bytes, i0), 8);
            i0 = i + 1;
            t7 = t1.$index(bytes, i);
            if (typeof t7 !== "number")
              return H.iae(t7);
            x = t5 & 16777215 | t6 & 16777215 | t7;
            j0 = j + 1;
            t7 = C.JSString_methods._codeUnitAt$1(lookup, x >>> 18);
            if (j >= t3)
              return H.ioore(out, j);
            out[j] = t7;
            j = j0 + 1;
            t7 = C.JSString_methods._codeUnitAt$1(lookup, x >>> 12 & 63);
            if (j0 >= t3)
              return H.ioore(out, j0);
            out[j0] = t7;
            j0 = j + 1;
            t7 = C.JSString_methods._codeUnitAt$1(lookup, x >>> 6 & 63);
            if (j >= t3)
              return H.ioore(out, j);
            out[j] = t7;
            j = j0 + 1;
            t7 = C.JSString_methods._codeUnitAt$1(lookup, x & 63);
            if (j0 >= t3)
              return H.ioore(out, j0);
            out[j0] = t7;
            if (t2) {
              ++c;
              t5 = c === 19 && j < t4;
            } else
              t5 = false;
            if (t5) {
              j0 = j + 1;
              if (j >= t3)
                return H.ioore(out, j);
              out[j] = 13;
              j = j0 + 1;
              if (j0 >= t3)
                return H.ioore(out, j0);
              out[j0] = 10;
              c = 0;
            }
          }
          if (remainderLength === 1) {
            x = t1.$index(bytes, i);
            j0 = j + 1;
            t1 = J.getInterceptor$n(x);
            t2 = C.JSString_methods._codeUnitAt$1(lookup, t1.$shr(x, 2));
            if (j >= t3)
              return H.ioore(out, j);
            out[j] = t2;
            j = j0 + 1;
            t1 = C.JSString_methods._codeUnitAt$1(lookup, t1.$shl(x, 4) & 63);
            if (j0 >= t3)
              return H.ioore(out, j0);
            out[j0] = t1;
            j0 = j + 1;
            if (j >= t3)
              return H.ioore(out, j);
            out[j] = 61;
            if (j0 >= t3)
              return H.ioore(out, j0);
            out[j0] = 61;
          } else if (remainderLength === 2) {
            x = t1.$index(bytes, i);
            y = t1.$index(bytes, i + 1);
            j0 = j + 1;
            t1 = J.getInterceptor$n(x);
            t2 = C.JSString_methods._codeUnitAt$1(lookup, t1.$shr(x, 2));
            if (j >= t3)
              return H.ioore(out, j);
            out[j] = t2;
            j = j0 + 1;
            t2 = J.getInterceptor$n(y);
            t1 = C.JSString_methods._codeUnitAt$1(lookup, (t1.$shl(x, 4) | t2.$shr(y, 4)) & 63);
            if (j0 >= t3)
              return H.ioore(out, j0);
            out[j0] = t1;
            j0 = j + 1;
            t2 = C.JSString_methods._codeUnitAt$1(lookup, t2.$shl(y, 2) & 63);
            if (j >= t3)
              return H.ioore(out, j);
            out[j] = t2;
            if (j0 >= t3)
              return H.ioore(out, j0);
            out[j0] = 61;
          }
          return P.String_String$fromCharCodes(out, 0, null);
        }, function(bytes) {
          return P._CryptoUtils_bytesToBase64(bytes, false, false);
        }, function(bytes, urlSafe) {
          return P._CryptoUtils_bytesToBase64(bytes, urlSafe, false);
        }, "call$3", "call$1", "call$2", "io__CryptoUtils_bytesToBase64$closure", 2, 4, 805, 4, 4, 30, [], 227, [], 694, [], "bytesToBase64"],
        _CryptoUtils_base64StringToBytes: [function(input, ignoreInvalidCharacters) {
          var t1, len, t2, extrasLen, i, t3, c, padLength, currentCodeUnit, outputLen, out, o, x, j, i0, o0;
          t1 = J.getInterceptor$asx(input);
          len = t1.get$length(input);
          if (J.$eq$(len, 0))
            return H.setRuntimeTypeInfo(new Array(0), [P.int]);
          if (typeof len !== "number")
            return H.iae(len);
          t2 = ignoreInvalidCharacters !== true;
          extrasLen = 0;
          i = 0;
          for (; i < len; ++i) {
            t3 = t1.codeUnitAt$1(input, i);
            if (t3 >= 256)
              return H.ioore(C.List_q3m, t3);
            c = C.List_q3m[t3];
            if (c < 0) {
              ++extrasLen;
              if (c === -2 && t2)
                throw H.wrapException(new P.FormatException("Invalid character: " + H.S(t1.$index(input, i)), null, null));
            }
          }
          t2 = len - extrasLen;
          if (C.JSNumber_methods.$mod(t2, 4) !== 0)
            throw H.wrapException(new P.FormatException("Size of Base 64 characters in Input\r\n          must be a multiple of 4. Input: " + H.S(input), null, null));
          for (i = len - 1, padLength = 0; i >= 0; --i) {
            currentCodeUnit = t1.codeUnitAt$1(input, i);
            if (currentCodeUnit >= 256)
              return H.ioore(C.List_q3m, currentCodeUnit);
            if (C.List_q3m[currentCodeUnit] > 0)
              break;
            if (currentCodeUnit === 61)
              ++padLength;
          }
          outputLen = C.JSNumber_methods._shrOtherPositive$1(t2 * 6, 3) - padLength;
          out = H.setRuntimeTypeInfo(new Array(outputLen), [P.int]);
          for (t2 = out.length, i = 0, o = 0; o < outputLen;) {
            for (x = 0, j = 4; j > 0; i = i0) {
              i0 = i + 1;
              t3 = t1.codeUnitAt$1(input, i);
              if (t3 >= 256)
                return H.ioore(C.List_q3m, t3);
              c = C.List_q3m[t3];
              if (c >= 0) {
                x = x << 6 & 16777215 | c;
                --j;
              }
            }
            o0 = o + 1;
            if (o >= t2)
              return H.ioore(out, o);
            out[o] = x >>> 16;
            if (o0 < outputLen) {
              o = o0 + 1;
              if (o0 >= t2)
                return H.ioore(out, o0);
              out[o0] = x >>> 8 & 255;
              if (o < outputLen) {
                o0 = o + 1;
                if (o >= t2)
                  return H.ioore(out, o);
                out[o] = x & 255;
                o = o0;
              }
            } else
              o = o0;
          }
          return out;
        }, function(input) {
          return P._CryptoUtils_base64StringToBytes(input, true);
        }, "call$2", "call$1", "io__CryptoUtils_base64StringToBytes$closure", 2, 2, 806, 25, 58, [], 695, [], "base64StringToBytes"]
      }
    },
    "+_CryptoUtils": [1],
    _HashBase: {
      "^": "Object;_chunkSizeInWords<-0,_digestSizeInWords<-0,_bigEndianWords<-8,_lengthInBytes@-0,_pendingData@-14,_currentChunk@-14,_h@-14,_digestCalled@-8",
      add$1: [function(_, data) {
        if (this._digestCalled === true)
          throw H.wrapException(new P.StateError("Hash update method called after digest was retrieved"));
        this._lengthInBytes = J.$add$ns(this._lengthInBytes, J.get$length$asx(data));
        J.addAll$1$ax(this._pendingData, data);
        this._iterate$0();
      }, "call$1", "get$add", 2, 0, 320, 21, [], "add"],
      close$0: [function() {
        if (this._digestCalled === true)
          return this._resultAsBytes$0();
        this._digestCalled = true;
        this._finalizeData$0();
        this._iterate$0();
        return this._resultAsBytes$0();
      }, "call$0", "get$close", 0, 0, 69, "close"],
      get$blockSize: [function() {
        return J.$mul$ns(this._chunkSizeInWords, 4);
      }, null, null, 1, 0, 11, "blockSize"],
      _add32$2: [function(x, y) {
        return J.$and$n(J.$add$ns(x, y), 4294967295);
      }, "call$2", "get$_add32", 4, 0, 12, 38, [], 132, [], "_add32"],
      _roundUp$2: [function(val, n) {
        return J.$and$n(J.$sub$n(J.$add$ns(val, n), 1), J.$negate$n(n));
      }, "call$2", "get$_roundUp", 4, 0, 12, 422, [], 89, [], "_roundUp"],
      _rotl32$2: [function(val, shift) {
        var mod_shift, t1, t2;
        mod_shift = J.$and$n(shift, 31);
        t1 = J.getInterceptor$n(val);
        t2 = t1.$shl(val, mod_shift);
        t1 = t1.$and(val, 4294967295);
        if (typeof mod_shift !== "number")
          return H.iae(mod_shift);
        return (t2 & 4294967295 | J.$shr$n(t1, 32 - mod_shift)) >>> 0;
      }, "call$2", "get$_rotl32", 4, 0, 70, 422, [], 853, [], "_rotl32"],
      _resultAsBytes$0: [function() {
        var result, i, t1;
        result = H.setRuntimeTypeInfo([], [P.int]);
        i = 0;
        while (true) {
          t1 = J.get$length$asx(this._h);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          C.JSArray_methods.addAll$1(result, this._wordToBytes$1(J.$index$asx(this._h, i)));
          ++i;
        }
        return result;
      }, "call$0", "get$_resultAsBytes", 0, 0, 69, "_resultAsBytes"],
      _bytesToChunk$2: [function(data, dataIndex) {
        var t1, t2, t3, wordIndex, w3, t4, w2, w1, w0, word, t5, t6;
        t1 = this._chunkSizeInWords;
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2 = J.getInterceptor$asx(data);
        t3 = this._bigEndianWords === true;
        wordIndex = 0;
        for (; wordIndex < t1; ++wordIndex) {
          w3 = t3 ? t2.$index(data, dataIndex) : t2.$index(data, J.$add$ns(dataIndex, 3));
          t4 = J.getInterceptor$ns(dataIndex);
          w2 = t3 ? t2.$index(data, t4.$add(dataIndex, 1)) : t2.$index(data, t4.$add(dataIndex, 2));
          w1 = t3 ? t2.$index(data, t4.$add(dataIndex, 2)) : t2.$index(data, t4.$add(dataIndex, 1));
          w0 = t3 ? t2.$index(data, J.$add$ns(dataIndex, 3)) : t2.$index(data, dataIndex);
          dataIndex = J.$add$ns(dataIndex, 4);
          word = J.$shl$n(J.$and$n(w3, 255), 24);
          t4 = J.$shl$n(J.$and$n(w2, 255), 16);
          t5 = J.$shl$n(J.$and$n(w1, 255), 8);
          t6 = J.$and$n(w0, 255);
          if (typeof t6 !== "number")
            return H.iae(t6);
          J.$indexSet$ax(this._currentChunk, wordIndex, (word | t4 | t5 | t6) >>> 0);
        }
      }, "call$2", "get$_bytesToChunk", 4, 0, 321, 21, [], 854, [], "_bytesToChunk"],
      _wordToBytes$1: [function(word) {
        var bytes, t1, t2, t3;
        bytes = new Array(4);
        bytes.fixed$length = Array;
        t1 = this._bigEndianWords === true;
        t2 = t1 ? 24 : 0;
        t3 = J.getInterceptor$n(word);
        bytes[0] = t3.$shr(word, t2) & 255;
        bytes[1] = t3.$shr(word, t1 ? 16 : 8) & 255;
        bytes[2] = t3.$shr(word, t1 ? 8 : 16) & 255;
        bytes[3] = t3.$shr(word, t1 ? 0 : 24) & 255;
        return bytes;
      }, "call$1", "get$_wordToBytes", 2, 0, 105, 855, [], "_wordToBytes"],
      _iterate$0: [function() {
        var len, chunkSizeInBytes, t1, index;
        len = J.get$length$asx(this._pendingData);
        chunkSizeInBytes = J.$mul$ns(this._chunkSizeInWords, 4);
        t1 = J.getInterceptor$n(len);
        if (t1.$ge(len, chunkSizeInBytes)) {
          index = 0;
          while (J.$ge$n(t1.$sub(len, index), chunkSizeInBytes)) {
            this._bytesToChunk$2(this._pendingData, index);
            this._updateHash$1(this._currentChunk);
            if (typeof chunkSizeInBytes !== "number")
              return H.iae(chunkSizeInBytes);
            index += chunkSizeInBytes;
          }
          this._pendingData = J.sublist$2$ax(this._pendingData, index, len);
        }
      }, "call$0", "get$_iterate", 0, 0, 4, "_iterate"],
      _finalizeData$0: [function() {
        var contentsLength, chunkSizeInBytes, zeroPadding, i, lengthInBits, t1, t2;
        J.add$1$ax(this._pendingData, 128);
        contentsLength = J.$add$ns(this._lengthInBytes, 9);
        chunkSizeInBytes = J.$mul$ns(this._chunkSizeInWords, 4);
        zeroPadding = J.$sub$n(J.$and$n(J.$sub$n(J.$add$ns(contentsLength, chunkSizeInBytes), 1), J.$negate$n(chunkSizeInBytes)), contentsLength);
        if (typeof zeroPadding !== "number")
          return H.iae(zeroPadding);
        i = 0;
        for (; i < zeroPadding; ++i)
          J.add$1$ax(this._pendingData, 0);
        lengthInBits = J.$mul$ns(this._lengthInBytes, 8);
        t1 = this._pendingData;
        t2 = J.getInterceptor$n(lengthInBits);
        if (this._bigEndianWords === true) {
          J.addAll$1$ax(t1, this._wordToBytes$1(0));
          J.addAll$1$ax(this._pendingData, this._wordToBytes$1(t2.$and(lengthInBits, 4294967295)));
        } else {
          J.addAll$1$ax(t1, this._wordToBytes$1(t2.$and(lengthInBits, 4294967295)));
          J.addAll$1$ax(this._pendingData, this._wordToBytes$1(0));
        }
      }, "call$0", "get$_finalizeData", 0, 0, 4, "_finalizeData"],
      _HashBase$3: function(_chunkSizeInWords, _digestSizeInWords, _bigEndianWords) {
        var t1 = this._chunkSizeInWords;
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = new Array(t1);
        t1.fixed$length = Array;
        this._currentChunk = t1;
        t1 = this._digestSizeInWords;
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = new Array(t1);
        t1.fixed$length = Array;
        this._h = t1;
      },
      static: {
        _HashBase$: [function(_chunkSizeInWords, _digestSizeInWords, _bigEndianWords) {
          var t1 = new P._HashBase(_chunkSizeInWords, _digestSizeInWords, _bigEndianWords, 0, [], null, null, false);
          t1._HashBase$3(_chunkSizeInWords, _digestSizeInWords, _bigEndianWords);
          return t1;
        }, null, null, 6, 0, 807, 696, [], 697, [], 698, [], "new _HashBase"]
      }
    },
    "+_HashBase": [1],
    _MD5: {
      "^": "_HashBase;_chunkSizeInWords-0,_digestSizeInWords-0,_bigEndianWords-8,_lengthInBytes-0,_pendingData-14,_currentChunk-14,_h-14,_digestCalled-8",
      newInstance$0: [function() {
        return P._MD5$();
      }, "call$0", "get$newInstance", 0, 0, 730, "newInstance"],
      _updateHash$1: [function(m) {
        var a, b, c, d, t1, i, t2, t3, t00, t10, mod_shift, b0;
        a = J.$index$asx(this._h, 0);
        b = J.$index$asx(this._h, 1);
        c = J.$index$asx(this._h, 2);
        d = J.$index$asx(this._h, 3);
        for (t1 = J.getInterceptor$asx(m), i = 0; i < 64; ++i, a = d, d = c, c = b, b = b0) {
          if (i < 16) {
            t2 = J.getInterceptor$in(b);
            t3 = t2.$and(b, c);
            t2 = t2.$not(b);
            if (typeof d !== "number")
              return H.iae(d);
            t00 = J.$or$n(t3, (t2 & 4294967295 & d) >>> 0);
            t10 = i;
          } else if (i < 32) {
            t2 = J.getInterceptor$in(d);
            t3 = t2.$and(d, b);
            t2 = t2.$not(d);
            if (typeof c !== "number")
              return H.iae(c);
            t00 = J.$or$n(t3, (t2 & 4294967295 & c) >>> 0);
            t10 = (5 * i + 1) % 16;
          } else {
            t2 = J.getInterceptor$n(b);
            if (i < 48) {
              t00 = J.$xor$n(t2.$xor(b, c), d);
              t10 = (3 * i + 5) % 16;
            } else {
              t00 = J.$xor$n(c, t2.$or(b, (J.$not$i(d) & 4294967295) >>> 0));
              t10 = C.JSInt_methods.$mod(7 * i, 16);
            }
          }
          t2 = J.$and$n(J.$add$ns(a, t00), 4294967295);
          t3 = C.List_yzJ[i];
          t10 = t1.$index(m, t10);
          if (typeof t10 !== "number")
            return H.iae(t10);
          t10 = J.$and$n(J.$add$ns(t2, (t3 + t10 & 4294967295) >>> 0), 4294967295);
          mod_shift = C.List_kcl[i] & 31;
          t3 = J.getInterceptor$n(t10);
          b0 = J.$and$n(J.$add$ns(b, (t3.$shl(t10, mod_shift) & 4294967295 | J.$shr$n(t3.$and(t10, 4294967295), 32 - mod_shift)) >>> 0), 4294967295);
        }
        t1 = this._h;
        t2 = J.getInterceptor$asx(t1);
        t2.$indexSet(t1, 0, J.$and$n(J.$add$ns(a, t2.$index(t1, 0)), 4294967295));
        t1 = this._h;
        t2 = J.getInterceptor$asx(t1);
        t2.$indexSet(t1, 1, J.$and$n(J.$add$ns(b, t2.$index(t1, 1)), 4294967295));
        t1 = this._h;
        t2 = J.getInterceptor$asx(t1);
        t2.$indexSet(t1, 2, J.$and$n(J.$add$ns(c, t2.$index(t1, 2)), 4294967295));
        t1 = this._h;
        t2 = J.getInterceptor$asx(t1);
        t2.$indexSet(t1, 3, J.$and$n(J.$add$ns(d, t2.$index(t1, 3)), 4294967295));
      }, "call$1", "get$_updateHash", 2, 0, 26, 173, [], "_updateHash"],
      _MD5$0: function() {
        J.$indexSet$ax(this._h, 0, 1732584193);
        J.$indexSet$ax(this._h, 1, 4023233417);
        J.$indexSet$ax(this._h, 2, 2562383102);
        J.$indexSet$ax(this._h, 3, 271733878);
      },
      static: {
        "^": "_MD5__k<-10,_MD5__r<-10",
        _MD5$: [function() {
          var t1 = new P._MD5(16, 4, false, 0, [], null, null, false);
          t1._HashBase$3(16, 4, false);
          t1._MD5$0();
          return t1;
        }, null, null, 0, 0, 4, "new _MD5"]
      }
    },
    "+_MD5": [483],
    _SHA1: {
      "^": "_HashBase;_w@-14,_chunkSizeInWords-0,_digestSizeInWords-0,_bigEndianWords-8,_lengthInBytes-0,_pendingData-14,_currentChunk-14,_h-14,_digestCalled-8",
      newInstance$0: [function() {
        return P._SHA1$();
      }, "call$0", "get$newInstance", 0, 0, 922, "newInstance"],
      _updateHash$1: [function(m) {
        var a, b, c, d, e, t1, i, t2, n, t3, t4, t, c0, a0;
        a = J.$index$asx(this._h, 0);
        b = J.$index$asx(this._h, 1);
        c = J.$index$asx(this._h, 2);
        d = J.$index$asx(this._h, 3);
        e = J.$index$asx(this._h, 4);
        for (t1 = J.getInterceptor$asx(m), i = 0; i < 80; ++i, e = d, d = c, c = c0, b = a, a = a0) {
          t2 = this._w;
          if (i < 16)
            J.$indexSet$ax(t2, i, t1.$index(m, i));
          else {
            n = J.$xor$n(J.$xor$n(J.$xor$n(J.$index$asx(t2, i - 3), J.$index$asx(this._w, i - 8)), J.$index$asx(this._w, i - 14)), J.$index$asx(this._w, i - 16));
            t2 = J.getInterceptor$n(n);
            J.$indexSet$ax(this._w, i, (t2.$shl(n, 1) & 4294967295 | J.$shr$n(t2.$and(n, 4294967295), 31)) >>> 0);
          }
          t2 = J.getInterceptor$n(a);
          t3 = t2.$shl(a, 5);
          t2 = J.$shr$n(t2.$and(a, 4294967295), 27);
          if (typeof e !== "number")
            return H.iae(e);
          t4 = J.$index$asx(this._w, i);
          if (typeof t4 !== "number")
            return H.iae(t4);
          t = (((((t3 & 4294967295 | t2) >>> 0) + e & 4294967295) >>> 0) + t4 & 4294967295) >>> 0;
          if (i < 20) {
            t2 = J.getInterceptor$in(b);
            t3 = t2.$and(b, c);
            t2 = t2.$not(b);
            if (typeof d !== "number")
              return H.iae(d);
            t2 = J.$or$n(t3, (t2 & d) >>> 0);
            if (typeof t2 !== "number")
              return H.iae(t2);
            t = ((t + t2 & 4294967295) >>> 0) + 1518500249 & 4294967295;
          } else if (i < 40) {
            t2 = J.$xor$n(J.$xor$n(b, c), d);
            if (typeof t2 !== "number")
              return H.iae(t2);
            t = ((t + t2 & 4294967295) >>> 0) + 1859775393 & 4294967295;
          } else {
            t2 = J.getInterceptor$n(b);
            if (i < 60) {
              t2 = J.$or$n(J.$or$n(t2.$and(b, c), t2.$and(b, d)), J.$and$n(c, d));
              if (typeof t2 !== "number")
                return H.iae(t2);
              t = ((t + t2 & 4294967295) >>> 0) + 2400959708 & 4294967295;
            } else {
              t2 = J.$xor$n(t2.$xor(b, c), d);
              if (typeof t2 !== "number")
                return H.iae(t2);
              t = ((t + t2 & 4294967295) >>> 0) + 3395469782 & 4294967295;
            }
          }
          t2 = J.getInterceptor$n(b);
          c0 = (t2.$shl(b, 30) & 4294967295 | J.$shr$n(t2.$and(b, 4294967295), 2)) >>> 0;
          a0 = (t & 4294967295) >>> 0;
        }
        t1 = this._h;
        t2 = J.getInterceptor$asx(t1);
        t2.$indexSet(t1, 0, J.$and$n(J.$add$ns(a, t2.$index(t1, 0)), 4294967295));
        t1 = this._h;
        t2 = J.getInterceptor$asx(t1);
        t2.$indexSet(t1, 1, J.$and$n(J.$add$ns(b, t2.$index(t1, 1)), 4294967295));
        t1 = this._h;
        t2 = J.getInterceptor$asx(t1);
        t2.$indexSet(t1, 2, J.$and$n(J.$add$ns(c, t2.$index(t1, 2)), 4294967295));
        t1 = this._h;
        t2 = J.getInterceptor$asx(t1);
        t2.$indexSet(t1, 3, J.$and$n(J.$add$ns(d, t2.$index(t1, 3)), 4294967295));
        t1 = this._h;
        t2 = J.getInterceptor$asx(t1);
        t2.$indexSet(t1, 4, J.$and$n(J.$add$ns(e, t2.$index(t1, 4)), 4294967295));
      }, "call$1", "get$_updateHash", 2, 0, 26, 173, [], "_updateHash"],
      _SHA1$0: function() {
        J.$indexSet$ax(this._h, 0, 1732584193);
        J.$indexSet$ax(this._h, 1, 4023233417);
        J.$indexSet$ax(this._h, 2, 2562383102);
        J.$indexSet$ax(this._h, 3, 271733878);
        J.$indexSet$ax(this._h, 4, 3285377520);
      },
      static: {
        _SHA1$: [function() {
          var t1 = new Array(80);
          t1.fixed$length = Array;
          t1 = new P._SHA1(t1, 16, 5, true, 0, [], null, null, false);
          t1._HashBase$3(16, 5, true);
          t1._SHA1$0();
          return t1;
        }, null, null, 0, 0, 4, "new _SHA1"]
      }
    },
    "+_SHA1": [483],
    ZLibOption: {
      "^": "Object;",
      static: {
        "^": "ZLibOption_MIN_WINDOW_BITS<-0,ZLibOption_MAX_WINDOW_BITS<-0,ZLibOption_DEFAULT_WINDOW_BITS<-0,ZLibOption_MIN_LEVEL<-0,ZLibOption_MAX_LEVEL<-0,ZLibOption_DEFAULT_LEVEL<-0,ZLibOption_MIN_MEM_LEVEL<-0,ZLibOption_MAX_MEM_LEVEL<-0,ZLibOption_DEFAULT_MEM_LEVEL<-0,ZLibOption_STRATEGY_FILTERED<-0,ZLibOption_STRATEGY_HUFFMAN_ONLY<-0,ZLibOption_STRATEGY_RLE<-0,ZLibOption_STRATEGY_FIXED<-0,ZLibOption_STRATEGY_DEFAULT<-0",
        ZLibOption$: [function() {
          return new P.ZLibOption();
        }, null, null, 0, 0, 808, "new ZLibOption"]
      }
    },
    "+ZLibOption": [1],
    ZLibCodec: {
      "^": "Codec;gzip<-8,level<-0,memLevel<-0,strategy<-0,windowBits<-0,raw<-8,dictionary<-14",
      get$encoder: [function() {
        var t1, t2, t3, t4;
        t1 = this.level;
        t2 = this.windowBits;
        t3 = this.memLevel;
        t4 = this.strategy;
        P._validateZLibeLevel(t1);
        P._validateZLibMemLevel(t3);
        P._validateZLibStrategy(t4);
        P._validateZLibWindowBits(t2);
        return new P.ZLibEncoder(false, t1, t3, t4, t2, this.dictionary, this.raw);
      }, null, null, 1, 0, 322, "encoder"],
      get$decoder: [function() {
        var t1 = this.windowBits;
        P._validateZLibWindowBits(t1);
        return new P.ZLibDecoder(t1, this.dictionary, this.raw);
      }, null, null, 1, 0, 323, "decoder"],
      $asCodec: function() {
        return [[P.List, P.int], [P.List, P.int]];
      },
      "<>": [],
      static: {
        ZLibCodec$: [function(dictionary, gzip, level, memLevel, raw, strategy, windowBits) {
          P._validateZLibeLevel(level);
          P._validateZLibMemLevel(memLevel);
          P._validateZLibStrategy(strategy);
          P._validateZLibWindowBits(windowBits);
          return new P.ZLibCodec(gzip, level, memLevel, strategy, windowBits, raw, dictionary);
        }, null, null, 0, 15, 243, 394, 140, 398, 7, 0, 4, 4, 136, [], 112, [], 167, [], 169, [], 130, [], 100, [], 191, [], "new ZLibCodec"],
        ZLibCodec$_default: [function() {
          return new P.ZLibCodec(false, 6, 8, 0, 15, false, null);
        }, null, null, 0, 0, 4, "new ZLibCodec$_default"]
      }
    },
    "+ZLibCodec": [484],
    GZipCodec: {
      "^": "Codec;gzip<-8,level<-0,memLevel<-0,strategy<-0,windowBits<-0,dictionary<-14,raw<-8",
      get$encoder: [function() {
        var t1, t2, t3, t4;
        t1 = this.level;
        t2 = this.windowBits;
        t3 = this.memLevel;
        t4 = this.strategy;
        P._validateZLibeLevel(t1);
        P._validateZLibMemLevel(t3);
        P._validateZLibStrategy(t4);
        P._validateZLibWindowBits(t2);
        return new P.ZLibEncoder(true, t1, t3, t4, t2, this.dictionary, this.raw);
      }, null, null, 1, 0, 322, "encoder"],
      get$decoder: [function() {
        var t1 = this.windowBits;
        P._validateZLibWindowBits(t1);
        return new P.ZLibDecoder(t1, this.dictionary, this.raw);
      }, null, null, 1, 0, 323, "decoder"],
      $asCodec: function() {
        return [[P.List, P.int], [P.List, P.int]];
      },
      "<>": [],
      static: {
        GZipCodec$: [function(dictionary, gzip, level, memLevel, raw, strategy, windowBits) {
          P._validateZLibeLevel(level);
          P._validateZLibMemLevel(memLevel);
          P._validateZLibStrategy(strategy);
          P._validateZLibWindowBits(windowBits);
          return new P.GZipCodec(gzip, level, memLevel, strategy, windowBits, dictionary, raw);
        }, null, null, 0, 15, 243, 394, 140, 398, 7, 0, 4, 25, 136, [], 112, [], 167, [], 169, [], 130, [], 100, [], 191, [], "new GZipCodec"],
        GZipCodec$_default: [function() {
          return new P.GZipCodec(true, 6, 8, 0, 15, null, false);
        }, null, null, 0, 0, 4, "new GZipCodec$_default"]
      }
    },
    "+GZipCodec": [484],
    ZLibEncoder: {
      "^": "Converter;gzip<-8,level<-0,memLevel<-0,strategy<-0,windowBits<-0,dictionary<-14,raw<-8",
      convert$1: [function(bytes) {
        var t1, t2;
        t1 = P.BytesBuilder_BytesBuilder(false);
        t2 = this.startChunkedConversion$1(new P._BufferSink(t1));
        t2.addSlice$4(bytes, 0, J.get$length$asx(bytes), false);
        t2.close$0();
        return t1.takeBytes$0();
      }, "call$1", "get$convert", 2, 0, 269, 30, [], "convert"],
      startChunkedConversion$1: [function(sink) {
        if (!(sink instanceof P.ByteConversionSink))
          sink = new P._ByteAdapterSink(sink);
        return new P._ZLibEncoderSink(P._Filter__newZLibDeflateFilter(this.gzip, this.level, this.windowBits, this.memLevel, this.strategy, this.dictionary, this.raw), sink, false, true);
      }, "call$1", "get$startChunkedConversion", 2, 0, 268, 22, [], "startChunkedConversion"],
      $asConverter: function() {
        return [[P.List, P.int], [P.List, P.int]];
      },
      "<>": [],
      static: {
        ZLibEncoder$: [function(dictionary, gzip, level, memLevel, raw, strategy, windowBits) {
          P._validateZLibeLevel(level);
          P._validateZLibMemLevel(memLevel);
          P._validateZLibStrategy(strategy);
          P._validateZLibWindowBits(windowBits);
          return new P.ZLibEncoder(gzip, level, memLevel, strategy, windowBits, dictionary, raw);
        }, null, null, 0, 15, 243, 4, 394, 140, 398, 7, 0, 4, 191, [], 136, [], 112, [], 167, [], 169, [], 130, [], 100, [], "new ZLibEncoder"]
      }
    },
    "+ZLibEncoder": [485, 1484],
    ZLibDecoder: {
      "^": "Converter;windowBits<-0,dictionary<-14,raw<-8",
      convert$1: [function(bytes) {
        var t1, t2;
        t1 = P.BytesBuilder_BytesBuilder(false);
        t2 = this.startChunkedConversion$1(new P._BufferSink(t1));
        t2.addSlice$4(bytes, 0, J.get$length$asx(bytes), false);
        t2.close$0();
        return t1.takeBytes$0();
      }, "call$1", "get$convert", 2, 0, 269, 30, [], "convert"],
      startChunkedConversion$1: [function(sink) {
        if (!(sink instanceof P.ByteConversionSink))
          sink = new P._ByteAdapterSink(sink);
        return new P._ZLibDecoderSink(P._Filter__newZLibInflateFilter(this.windowBits, this.dictionary, this.raw), sink, false, true);
      }, "call$1", "get$startChunkedConversion", 2, 0, 268, 22, [], "startChunkedConversion"],
      $asConverter: function() {
        return [[P.List, P.int], [P.List, P.int]];
      },
      "<>": [],
      static: {
        ZLibDecoder$: [function(dictionary, raw, windowBits) {
          P._validateZLibWindowBits(windowBits);
          return new P.ZLibDecoder(windowBits, dictionary, raw);
        }, null, null, 0, 7, 810, 140, 0, 4, 112, [], 130, [], 100, [], "new ZLibDecoder"]
      }
    },
    "+ZLibDecoder": [485],
    _BufferSink: {
      "^": "ByteConversionSink;builder<-226",
      add$1: [function(_, chunk) {
        J.add$1$ax(this.builder, chunk);
      }, "call$1", "get$add", 2, 0, 26, 57, [], "add"],
      addSlice$4: [function(chunk, start, end, isLast) {
        var t1, t2;
        t1 = J.getInterceptor(chunk);
        t2 = this.builder;
        if (!!t1.$isUint8List)
          J.add$1$ax(t2, J.asUint8List$2$x(t1.get$buffer(chunk), start, J.$sub$n(end, start)));
        else
          J.add$1$ax(t2, t1.sublist$2(chunk, start, end));
      }, "call$4", "get$addSlice", 8, 0, 44, 57, [], 3, [], 5, [], 46, [], "addSlice"],
      close$0: [function() {
      }, "call$0", "get$close", 0, 0, 6, "close"],
      static: {
        _BufferSink$: [function() {
          return new P._BufferSink(P.BytesBuilder_BytesBuilder(false));
        }, null, null, 0, 0, 811, "new _BufferSink"]
      }
    },
    "+_BufferSink": [39],
    _ZLibEncoderSink: {
      "^": "_FilterSink;_filter-133,_sink-39,_closed-8,_empty-8",
      static: {
        _ZLibEncoderSink$: [function(sink, gzip, level, windowBits, memLevel, strategy, dictionary, raw) {
          return new P._ZLibEncoderSink(P._Filter__newZLibDeflateFilter(gzip, level, windowBits, memLevel, strategy, dictionary, raw), sink, false, true);
        }, null, null, 16, 0, 812, 22, [], 191, [], 136, [], 112, [], 167, [], 169, [], 130, [], 100, [], "new _ZLibEncoderSink"]
      }
    },
    "+_ZLibEncoderSink": [486],
    _ZLibDecoderSink: {
      "^": "_FilterSink;_filter-133,_sink-39,_closed-8,_empty-8",
      static: {
        _ZLibDecoderSink$: [function(sink, windowBits, dictionary, raw) {
          return new P._ZLibDecoderSink(P._Filter__newZLibInflateFilter(windowBits, dictionary, raw), sink, false, true);
        }, null, null, 8, 0, 813, 22, [], 112, [], 130, [], 100, [], "new _ZLibDecoderSink"]
      }
    },
    "+_ZLibDecoderSink": [486],
    _FilterSink: {
      "^": "ByteConversionSink;_filter>-133,_sink<-39,_closed@-8,_empty@-8",
      add$1: [function(_, data) {
        this.addSlice$4(data, 0, J.get$length$asx(data), false);
      }, "call$1", "get$add", 2, 0, 26, 21, [], "add"],
      addSlice$4: [function(data, start, end, isLast) {
        var bufferAndStart, out, t1, t2, t3, exception;
        if (this._closed === true)
          return;
        if (end == null)
          throw H.wrapException(P.ArgumentError$notNull("end"));
        P.RangeError_checkValidRange(start, end, J.get$length$asx(data), null, null, null);
        try {
          this._empty = false;
          bufferAndStart = P._ensureFastAndSerializableByteData(data, start, end);
          t1 = this._filter;
          t1.process$3(J.get$buffer$x(bufferAndStart), bufferAndStart.get$start(), J.$sub$n(end, J.$sub$n(start, bufferAndStart.get$start())));
          out = null;
          for (t2 = this._sink, t3 = J.getInterceptor$ax(t2); out = t1.processed$1$flush(false), true;)
            t3.add$1(t2, out);
        } catch (exception) {
          H.unwrapException(exception);
          this._closed = true;
          throw exception;
        }
        if (isLast === true)
          this.close$0();
      }, "call$4", "get$addSlice", 8, 0, 44, 21, [], 3, [], 5, [], 46, [], "addSlice"],
      close$0: [function() {
        var out, e, t1, t2, t3, exception;
        if (this._closed === true)
          return;
        if (this._empty === true)
          this._filter.process$3(C.List_empty, 0, 0);
        try {
          out = null;
          for (t1 = this._filter, t2 = this._sink, t3 = J.getInterceptor$ax(t2); out = t1.processed$1$end(true), true;)
            t3.add$1(t2, out);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          this._closed = true;
          throw H.wrapException(e);
        }
        this._closed = true;
        this._sink.close$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      static: {
        _FilterSink$: [function(_sink, _filter) {
          return new P._FilterSink(_filter, _sink, false, true);
        }, null, null, 4, 0, 814, 45, [], 708, [], "new _FilterSink"]
      }
    },
    "+_FilterSink": [39],
    _Filter: {
      "^": "Object;",
      static: {
        _Filter$: [function() {
          return new P._Filter();
        }, null, null, 0, 0, 815, "new _Filter"],
        _Filter__newZLibDeflateFilter: [function(gzip, level, windowBits, memLevel, strategy, dictionary, raw) {
          throw H.wrapException(new P.UnsupportedError("_newZLibDeflateFilter"));
        }, "call$7", "io__Filter__newZLibDeflateFilter$closure", 14, 0, 816, 191, [], 136, [], 112, [], 167, [], 169, [], 130, [], 100, [], "_newZLibDeflateFilter"],
        _Filter__newZLibInflateFilter: [function(windowBits, dictionary, raw) {
          throw H.wrapException(new P.UnsupportedError("_newZLibInflateFilter"));
        }, "call$3", "io__Filter__newZLibInflateFilter$closure", 6, 0, 817, 112, [], 130, [], 100, [], "_newZLibInflateFilter"]
      }
    },
    "+_Filter": [1],
    Directory: {
      "^": "Object;path<-9",
      $isFileSystemEntity: 1,
      static: {
        Directory_Directory: [function(path) {
          if (typeof path !== "string")
            H.throwExpression(P.ArgumentError$(H.S(P.Error_safeToString(path)) + " is not a String"));
          return new P._Directory(path);
        }, null, null, 2, 0, 327, 10, [], "new Directory"],
        Directory_Directory$fromUri: [function(uri) {
          return P._Directory$(uri.toFilePath$0());
        }, null, null, 2, 0, 818, 40, [], "new Directory$fromUri"],
        Directory_current0: [function() {
          return P._Directory_current();
        }, null, null, 1, 0, 110, "current"],
        Directory_current: [function(path) {
          P._Directory__setCurrent(!!J.getInterceptor(path).$isDirectory ? path.get$path() : path);
        }, null, null, 3, 0, 27, 10, [], "current"],
        Directory_systemTemp: [function() {
          P._Directory__systemTemp();
          return;
        }, null, null, 1, 0, 110, "systemTemp"]
      }
    },
    "+Directory": [1, 115],
    _Directory: {
      "^": "FileSystemEntity;path<-9",
      get$uri: [function() {
        return P._Uri__Uri$directory(this.path, null);
      }, null, null, 1, 0, 43, "uri"],
      exists$0: [function() {
        return P._IOService__dispatch(36, [this.path]).then$1(new P._Directory_exists_closure(this));
      }, "call$0", "get$exists", 0, 0, 129, "exists"],
      existsSync$0: [function() {
        P._Directory__exists(this.path);
      }, "call$0", "get$existsSync", 0, 0, 5, "existsSync"],
      get$absolute: [function() {
        return P._Directory$(this.get$_absolutePath());
      }, null, null, 1, 0, 110, "absolute"],
      create$1$recursive: [function(recursive) {
        if (recursive === true)
          return this.exists$0().then$1(new P._Directory_create_closure(this));
        else
          return P._IOService__dispatch(34, [this.path]).then$1(new P._Directory_create_closure0(this));
      }, function() {
        return this.create$1$recursive(false);
      }, "create$0", "call$1$recursive", "call$0", "get$create", 0, 3, 326, 4, 51, [], "create"],
      createSync$1$recursive: [function(recursive) {
        var t1;
        if (recursive === true) {
          if (this.existsSync$0())
            return;
          t1 = this.path;
          if (!J.$eq$(t1, P._Directory$(P.FileSystemEntity_parentOf(t1)).path))
            P._Directory$(P.FileSystemEntity_parentOf(t1)).createSync$1$recursive(true);
        }
        P._Directory__create(this.path);
      }, function() {
        return this.createSync$1$recursive(false);
      }, "createSync$0", "call$1$recursive", "call$0", "get$createSync", 0, 3, 111, 4, 51, [], "createSync"],
      createTemp$1: [function(prefix) {
        var t1, t2;
        if (prefix == null)
          prefix = "";
        t1 = this.path;
        t2 = J.getInterceptor(t1);
        if (t2.$eq(t1, ""))
          throw H.wrapException(P.ArgumentError$("Directory.createTemp called with an empty path. To use the system temp directory, use Directory.systemTemp"));
        if (!t2.endsWith$1(t1, "/"))
          t2 = $.$get$Platform_isWindows() && t2.endsWith$1(t1, "\\");
        else
          t2 = true;
        return P._IOService__dispatch(37, [t2 ? H.S(t1) + H.S(prefix) : H.S(t1) + H.S($.$get$Platform__pathSeparator()) + H.S(prefix)]).then$1(new P._Directory_createTemp_closure(this));
      }, function() {
        return this.createTemp$1(null);
      }, "createTemp$0", "call$1", "call$0", "get$createTemp", 0, 2, 581, 0, 609, [], "createTemp"],
      createTempSync$1: [function(prefix) {
        var t1, t2;
        if (prefix == null)
          prefix = "";
        t1 = this.path;
        t2 = J.getInterceptor(t1);
        if (t2.$eq(t1, ""))
          throw H.wrapException(P.ArgumentError$("Directory.createTemp called with an empty path. To use the system temp directory, use Directory.systemTemp"));
        if (!t2.endsWith$1(t1, "/"))
          t2 = $.$get$Platform_isWindows() && t2.endsWith$1(t1, "\\");
        else
          t2 = true;
        P._Directory__createTemp(t2 ? H.S(t1) + H.S(prefix) : H.S(t1) + H.S($.$get$Platform__pathSeparator()) + H.S(prefix));
      }, function() {
        return this.createTempSync$1(null);
      }, "createTempSync$0", "call$1", "call$0", "get$createTempSync", 0, 2, 599, 0, 609, [], "createTempSync"],
      _delete$1$recursive: [function(recursive) {
        return P._IOService__dispatch(35, [this.path, recursive]).then$1(new P._Directory__delete_closure(this));
      }, function() {
        return this._delete$1$recursive(false);
      }, "_delete$0", "call$1$recursive", "call$0", "get$_delete", 0, 3, 326, 4, 51, [], "_delete"],
      _deleteSync$1$recursive: [function(recursive) {
        P._Directory__deleteNative(this.path, recursive);
      }, function() {
        return this._deleteSync$1$recursive(false);
      }, "_deleteSync$0", "call$1$recursive", "call$0", "get$_deleteSync", 0, 3, 111, 4, 51, [], "_deleteSync"],
      rename$1: [function(newPath) {
        return P._IOService__dispatch(41, [this.path, newPath]).then$1(new P._Directory_rename_closure(this, newPath));
      }, "call$1", "get$rename", 2, 0, 602, 86, [], "rename"],
      renameSync$1: [function(newPath) {
        if (typeof newPath !== "string")
          throw H.wrapException(P.ArgumentError$(null));
        P._Directory__rename(this.path, newPath);
      }, "call$1", "get$renameSync", 2, 0, 327, 86, [], "renameSync"],
      list$2$followLinks$recursive: [function(_, followLinks, recursive) {
        var t1, t2;
        t1 = new P._AsyncDirectoryLister(P.FileSystemEntity__ensureTrailingPathSeparators(this.path), recursive, followLinks, null, false, false, false, null, new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]));
        t2 = new P._SyncStreamController(null, 0, null, t1.get$onListen(), null, t1.get$onResume(), t1.get$onCancel(), [P.FileSystemEntity]);
        t1.controller = t2;
        return t2.get$stream();
      }, function($receiver) {
        return this.list$2$followLinks$recursive($receiver, true, false);
      }, "list$0", function($receiver, recursive) {
        return this.list$2$followLinks$recursive($receiver, true, recursive);
      }, "list$1$recursive", "call$2$followLinks$recursive", "call$0", "call$1$recursive", "get$list", 0, 5, 620, 4, 25, 51, [], 109, [], "list"],
      listSync$2$followLinks$recursive: [function(followLinks, recursive) {
        if (typeof recursive !== "boolean" || typeof followLinks !== "boolean")
          throw H.wrapException(P.ArgumentError$(null));
        P._Directory__fillWithDirectoryListing(H.setRuntimeTypeInfo([], [P.FileSystemEntity]), P.FileSystemEntity__ensureTrailingPathSeparators(this.path), recursive, followLinks);
      }, function() {
        return this.listSync$2$followLinks$recursive(true, false);
      }, "listSync$0", function(recursive) {
        return this.listSync$2$followLinks$recursive(true, recursive);
      }, "listSync$1$recursive", "call$2$followLinks$recursive", "call$0", "call$1$recursive", "get$listSync", 0, 5, 657, 4, 25, 51, [], 109, [], "listSync"],
      toString$0: [function(_) {
        return "Directory: '" + H.S(this.path) + "'";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      _isErrorResponse$1: [function(response) {
        var t1 = J.getInterceptor(response);
        return !!t1.$isList && !J.$eq$(t1.$index(response, 0), 0);
      }, "call$1", "get$_isErrorResponse", 2, 0, 24, 18, [], "_isErrorResponse"],
      _exceptionOrErrorFromResponse$2: [function(response, message) {
        var t1 = J.getInterceptor$asx(response);
        switch (t1.$index(response, 0)) {
          case 1:
            return new P.ArgumentError(false, null, null, null);
          case 2:
            return new P.FileSystemException(message, this.path, new P.OSError(t1.$index(response, 2), t1.$index(response, 1)));
          default:
            return new P._Exception("Unknown error");
        }
      }, "call$2", "get$_exceptionOrErrorFromResponse", 4, 0, 301, 18, [], 17, [], "_exceptionOrErrorFromResponse"],
      _Directory$1: function(path) {
        var t1 = this.path;
        if (typeof t1 !== "string")
          throw H.wrapException(P.ArgumentError$(H.S(P.Error_safeToString(t1)) + " is not a String"));
      },
      $isDirectory: 1,
      static: {
        _Directory$: [function(path) {
          var t1 = new P._Directory(path);
          t1._Directory$1(path);
          return t1;
        }, null, null, 2, 0, 13, 10, [], "new _Directory"],
        _Directory__current: [function() {
          throw H.wrapException(new P.UnsupportedError("Directory._current"));
        }, "call$0", "io__Directory__current$closure", 0, 0, 4, "_io$_current"],
        _Directory__setCurrent: [function(path) {
          throw H.wrapException(new P.UnsupportedError("Directory_SetCurrent"));
        }, "call$1", "io__Directory__setCurrent$closure", 2, 0, 3, 10, [], "_setCurrent"],
        _Directory__createTemp: [function(path) {
          throw H.wrapException(new P.UnsupportedError("Directory._createTemp"));
        }, "call$1", "io__Directory__createTemp$closure", 2, 0, 13, 10, [], "_createTemp"],
        _Directory__systemTemp: [function() {
          throw H.wrapException(new P.UnsupportedError("Directory._systemTemp"));
        }, "call$0", "io__Directory__systemTemp$closure", 0, 0, 7, "_systemTemp"],
        _Directory__exists: [function(path) {
          throw H.wrapException(new P.UnsupportedError("Directory._exists"));
        }, "call$1", "io__Directory__exists$closure", 2, 0, 13, 10, [], "_exists"],
        _Directory__create: [function(path) {
          throw H.wrapException(new P.UnsupportedError("Directory._create"));
        }, "call$1", "io__Directory__create$closure", 2, 0, 13, 10, [], "_create"],
        _Directory__deleteNative: [function(path, recursive) {
          throw H.wrapException(new P.UnsupportedError("Directory._deleteNative"));
        }, "call$2", "io__Directory__deleteNative$closure", 4, 0, 187, 10, [], 51, [], "_deleteNative"],
        _Directory__rename: [function(path, newPath) {
          throw H.wrapException(new P.UnsupportedError("Directory._rename"));
        }, "call$2", "io__Directory__rename$closure", 4, 0, 40, 10, [], 86, [], "_rename"],
        _Directory__fillWithDirectoryListing: [function(list, path, recursive, followLinks) {
          throw H.wrapException(new P.UnsupportedError("Directory._fillWithDirectoryListing"));
        }, "call$4", "io__Directory__fillWithDirectoryListing$closure", 8, 0, 819, 125, [], 10, [], 51, [], 109, [], "_fillWithDirectoryListing"],
        _Directory_current: [function() {
          P._Directory__current();
        }, null, null, 1, 0, 110, "current"],
        _Directory_current0: [function(path) {
          P._Directory__setCurrent(!!J.getInterceptor(path).$isDirectory ? path.get$path() : path);
        }, null, null, 3, 0, 27, 10, [], "current"],
        _Directory_systemTemp: [function() {
          P._Directory__systemTemp();
          return;
        }, null, null, 1, 0, 110, "systemTemp"]
      }
    },
    "+_Directory": [115, 1488],
    _Directory_exists_closure: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        response.$index(0, 0);
        throw H.wrapException(this.$this._exceptionOrErrorFromResponse$2(response, "Exists failed"));
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _Directory_exists_closure": [2],
    _Directory_create_closure: {
      "^": "Closure:3;$this",
      call$1: [function(exists) {
        var t1, t2;
        if (exists)
          return this.$this;
        t1 = this.$this;
        t2 = t1.path;
        if (!J.$eq$(t2, P._Directory$(P.FileSystemEntity_parentOf(t2)).path))
          return P._Directory$(P.FileSystemEntity_parentOf(t2)).create$1$recursive(true).then$1(new P._Directory_create__closure(t1));
        else
          return t1.create$0();
      }, null, null, 2, 0, 3, 857, [], "call"]
    },
    "+ _Directory_create_closure": [2],
    _Directory_create__closure: {
      "^": "Closure:3;$this",
      call$1: [function(_) {
        return this.$this.create$0();
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _Directory_create__closure": [2],
    _Directory_create_closure0: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        response.$index(0, 0);
        throw H.wrapException(this.$this._exceptionOrErrorFromResponse$2(response, "Creation failed"));
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _Directory_create_closure": [2],
    _Directory_createTemp_closure: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        response.$index(0, 0);
        throw H.wrapException(this.$this._exceptionOrErrorFromResponse$2(response, "Creation of temporary directory failed"));
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _Directory_createTemp_closure": [2],
    _Directory__delete_closure: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        response.$index(0, 0);
        throw H.wrapException(this.$this._exceptionOrErrorFromResponse$2(response, "Deletion failed"));
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _Directory__delete_closure": [2],
    _Directory_rename_closure: {
      "^": "Closure:3;$this,newPath",
      call$1: [function(response) {
        response.$index(0, 0);
        throw H.wrapException(this.$this._exceptionOrErrorFromResponse$2(response, "Rename failed"));
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _Directory_rename_closure": [2],
    _AsyncDirectoryListerOps: {
      "^": "Object;",
      static: {
        _AsyncDirectoryListerOps__AsyncDirectoryListerOps: [function(pointer) {
          throw H.wrapException(new P.UnsupportedError("Directory._list"));
        }, null, null, 2, 0, 820, 361, [], "new _AsyncDirectoryListerOps"]
      }
    },
    "+_AsyncDirectoryListerOps": [1],
    _AsyncDirectoryLister: {
      "^": "Object;path<-9,recursive<-8,followLinks<-8,controller@-1489,canceled@-8,nextRunning@-8,closed@-8,_ops@-1490,closeCompleter@-41",
      _pointer$0: [function() {
        var t1 = this._ops;
        return t1 == null ? null : t1.getPointer$0();
      }, "call$0", "get$_pointer", 0, 0, 11, "_pointer"],
      get$stream: [function() {
        return this.controller.get$stream();
      }, null, null, 1, 0, 670, "stream"],
      onListen$0: [function() {
        P._IOService__dispatch(38, [this.path, this.recursive, this.followLinks]).then$1(new P._AsyncDirectoryLister_onListen_closure(this));
      }, "call$0", "get$onListen", 0, 0, 6, "onListen"],
      onResume$0: [function() {
        if (this.nextRunning !== true)
          this.next$0();
      }, "call$0", "get$onResume", 0, 0, 6, "onResume"],
      onCancel$0: [function() {
        this.canceled = true;
        if (this.nextRunning !== true)
          this.close$0();
        return this.closeCompleter.get$future();
      }, "call$0", "get$onCancel", 0, 0, 18, "onCancel"],
      next$0: [function() {
        if (this.canceled === true) {
          this.close$0();
          return;
        }
        if (this.controller.get$isPaused() || this.nextRunning === true)
          return;
        var t1 = this._ops;
        if (!(t1 == null))
          t1.getPointer$0();
        return;
      }, "call$0", "get$next", 0, 0, 6, "next"],
      _cleanup$0: [function() {
        this.controller.close$0();
        this.closeCompleter.complete$0();
        this._ops = null;
      }, "call$0", "get$_cleanup", 0, 0, 6, "_cleanup"],
      close$0: [function() {
        if (this.closed === true)
          return;
        if (this.nextRunning === true)
          return;
        this.closed = true;
        var t1 = this._ops;
        if (!(t1 == null))
          t1.getPointer$0();
        this._cleanup$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      error$1: [function(message) {
        var t1, errorType, t2, responseError, t3, errorPath;
        t1 = J.getInterceptor$asx(message);
        errorType = J.$index$asx(t1.$index(message, 2), 0);
        t2 = J.getInterceptor(errorType);
        if (t2.$eq(errorType, 1))
          this.controller.addError$1(new P.ArgumentError(false, null, null, null));
        else if (t2.$eq(errorType, 2)) {
          responseError = t1.$index(message, 2);
          t2 = J.getInterceptor$asx(responseError);
          t3 = t2.$index(responseError, 2);
          t2 = t2.$index(responseError, 1);
          errorPath = t1.$index(message, 1);
          if (errorPath == null)
            errorPath = this.path;
          this.controller.addError$1(new P.FileSystemException("Directory listing failed", errorPath, new P.OSError(t3, t2)));
        } else
          this.controller.addError$1(new P.FileSystemException("Internal error", "", null));
      }, "call$1", "get$error", 2, 0, 27, 17, [], "error"],
      static: {
        "^": "_AsyncDirectoryLister_LIST_FILE<-0,_AsyncDirectoryLister_LIST_DIRECTORY<-0,_AsyncDirectoryLister_LIST_LINK<-0,_AsyncDirectoryLister_LIST_ERROR<-0,_AsyncDirectoryLister_LIST_DONE<-0,_AsyncDirectoryLister_RESPONSE_TYPE<-0,_AsyncDirectoryLister_RESPONSE_PATH<-0,_AsyncDirectoryLister_RESPONSE_COMPLETE<-0,_AsyncDirectoryLister_RESPONSE_ERROR<-0",
        _AsyncDirectoryLister$: [function(path, recursive, followLinks) {
          var t1 = new P._AsyncDirectoryLister(path, recursive, followLinks, null, false, false, false, null, new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]));
          t1.controller = new P._SyncStreamController(null, 0, null, t1.get$onListen(), null, t1.get$onResume(), t1.get$onCancel(), [P.FileSystemEntity]);
          return t1;
        }, null, null, 6, 0, 821, 10, [], 51, [], 109, [], "new _AsyncDirectoryLister"]
      }
    },
    "+_AsyncDirectoryLister": [1],
    _AsyncDirectoryLister_onListen_closure: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        this.$this._ops = P._AsyncDirectoryListerOps__AsyncDirectoryListerOps(response);
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _AsyncDirectoryLister_onListen_closure": [2],
    _EventHandler: {
      "^": "Object;",
      static: {
        _EventHandler$: [function() {
          return new P._EventHandler();
        }, null, null, 0, 0, 822, "new _EventHandler"],
        _EventHandler__sendData: [function(sender, sendPort, data) {
          throw H.wrapException(new P.UnsupportedError("EventHandler._sendData"));
        }, "call$3", "io__EventHandler__sendData$closure", 6, 0, 823, 583, [], 296, [], 21, [], "_io$_sendData"]
      }
    },
    "+_EventHandler": [1],
    FileMode: {
      "^": "Object;_mode<-0",
      static: {
        "^": "FileMode_READ<-10,FileMode_WRITE<-10,FileMode_APPEND<-10,FileMode_WRITE_ONLY<-10,FileMode_WRITE_ONLY_APPEND<-10",
        FileMode$_internal: [function(_mode) {
          return new P.FileMode(_mode);
        }, null, null, 2, 0, 22, 713, [], "new FileMode$_internal"]
      }
    },
    "+FileMode": [1],
    FileLock: {
      "^": "Object;index<-0,_io$_name<-9",
      toString$0: [function(_) {
        return this._io$_name;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        "^": "FileLock_SHARED<-183,FileLock_EXCLUSIVE<-183,FileLock_BLOCKING_SHARED<-183,FileLock_BLOCKING_EXCLUSIVE<-183,FileLock_values<-1493",
        FileLock$: [function(index, _name) {
          return new P.FileLock(index, _name);
        }, null, null, 4, 0, 148, 14, [], 281, [], "new FileLock"]
      }
    },
    "+FileLock": [1],
    File: {
      "^": "Object;",
      $isFileSystemEntity: 1,
      static: {
        File_File: [function(path) {
          if (typeof path !== "string")
            H.throwExpression(P.ArgumentError$(H.S(P.Error_safeToString(path)) + " is not a String"));
          return new P._File(path);
        }, null, null, 2, 0, 266, 10, [], "new File"],
        File_File$fromUri: [function(uri) {
          return P._File$(uri.toFilePath$0());
        }, null, null, 2, 0, 824, 40, [], "new File$fromUri"]
      }
    },
    "+File": [1, 115],
    RandomAccessFile: {
      "^": "Object;",
      static: {
        RandomAccessFile$: [function() {
          return new P.RandomAccessFile();
        }, null, null, 0, 0, 825, "new RandomAccessFile"]
      }
    },
    "+RandomAccessFile": [1],
    FileSystemException: {
      "^": "Object;message<-9,path<-9,osError<-95",
      toString$0: [function(_) {
        var t1, t2;
        t1 = this.message;
        if (J.get$isEmpty$asx(t1) !== true) {
          t1 = "FileSystemException" + (": " + H.S(t1));
          t2 = this.path;
          if (t2 != null)
            t1 += ", path = '" + H.S(t2) + "'";
          t2 = this.osError;
          if (t2 != null)
            t1 += " (" + H.S(t2) + ")";
        } else {
          t1 = this.osError;
          if (t1 != null) {
            t1 = "FileSystemException" + (": " + H.S(t1));
            t2 = this.path;
            if (t2 != null)
              t1 += ", path = '" + H.S(t2) + "'";
          } else {
            t1 = this.path;
            t1 = t1 != null ? "FileSystemException" + (": " + H.S(t1)) : "FileSystemException";
          }
        }
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isException: 1,
      static: {
        FileSystemException$: [function(message, path, osError) {
          return new P.FileSystemException(message, path, osError);
        }, null, null, 0, 6, 826, 32, 32, 0, 17, [], 10, [], 108, [], "new FileSystemException"]
      }
    },
    "+FileSystemException": [1, 74],
    _FileStream: {
      "^": "Stream;_io$_controller@-487,_path@-9,_openedFile@-488,_io$_position@-0,_io$_end@-0,_closeCompleter<-41,_unsubscribed@-8,_readInProgress@-8,_closed@-8,_atEnd@-8",
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        this._setupController$0();
        return this._io$_controller.get$stream().listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, onError);
      }, "listen$2$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, null);
      }, "listen$2$onDone", function(onData, cancelOnError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, null, null);
      }, "listen$2$cancelOnError", "call$4$cancelOnError$onDone$onError", "call$1", "call$2$onError", "call$3$onDone$onError", "call$3$onDone$onError", "call$2$onDone", "call$2$cancelOnError", "get$listen", 2, 7, 94, 0, 0, 0, 27, [], 20, [], 28, [], 24, [], "listen"],
      _setupController$0: [function() {
        this._io$_controller = new P._SyncStreamController(null, 0, null, this.get$_io$_start(), null, this.get$_readBlock(), new P._FileStream__setupController_closure(this), [[P.List, P.int]]);
      }, "call$0", "get$_setupController", 0, 0, 6, "_setupController"],
      _closeFile$0: [function() {
        if (this._readInProgress === true || this._closed === true)
          return this._closeCompleter.get$future();
        this._closed = true;
        this._openedFile.close$0().catchError$1(this._io$_controller.get$addError()).whenComplete$1(new P._FileStream__closeFile_done(this));
        return this._closeCompleter.get$future();
      }, "call$0", "get$_closeFile", 0, 0, 18, "_closeFile"],
      _readBlock$0: [function() {
        var t1, t2, readBytes;
        t1 = {};
        if (this._readInProgress === true)
          return;
        if (this._atEnd === true) {
          this._closeFile$0();
          return;
        }
        this._readInProgress = true;
        t1.readBytes = 65536;
        t2 = this._io$_end;
        if (t2 != null) {
          readBytes = P.min(65536, J.$sub$n(t2, this._io$_position));
          t1.readBytes = readBytes;
          if (readBytes < 0) {
            this._readInProgress = false;
            if (this._unsubscribed !== true) {
              this._io$_controller.addError$1(new P.RangeError(null, null, false, null, null, "Bad end position: " + H.S(this._io$_end)));
              this._closeFile$0();
              this._unsubscribed = true;
            }
            return;
          }
          t2 = readBytes;
        } else
          t2 = 65536;
        this._openedFile.read$1(t2).then$1(new P._FileStream__readBlock_closure(t1, this)).catchError$1(new P._FileStream__readBlock_closure0(this));
      }, "call$0", "get$_readBlock", 0, 0, 6, "_readBlock"],
      _io$_start$0: [function() {
        var onOpenFile, openFailed, e, s, t1, exception;
        if (J.$lt$n(this._io$_position, 0)) {
          this._io$_controller.addError$1(new P.RangeError(null, null, false, null, null, "Bad start position: " + H.S(this._io$_position)));
          this._io$_controller.close$0();
          this._closeCompleter.complete$0();
          return;
        }
        onOpenFile = new P._FileStream__start_onOpenFile(this, new P._FileStream__start_onReady(this));
        openFailed = new P._FileStream__start_openFailed(this);
        t1 = this._path;
        if (t1 != null)
          P._File$(t1).open$1$mode(C.FileMode_0).then$2$onError(onOpenFile, openFailed);
        else
          try {
            onOpenFile.call$1(P._File__openStdioSync(0));
          } catch (exception) {
            t1 = H.unwrapException(exception);
            e = t1;
            s = H.getTraceFromException(exception);
            openFailed.call$2(e, s);
          }
      }, "call$0", "get$_io$_start", 0, 0, 6, "_io$_start"],
      $asStream: function() {
        return [[P.List, P.int]];
      },
      "<>": [],
      static: {
        _FileStream$: [function(_path, _position, _end) {
          var t1 = new P._FileStream(null, _path, null, _position, _end, new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]), false, true, false, false);
          if (_position == null)
            t1._io$_position = 0;
          return t1;
        }, null, null, 6, 0, 417, 715, [], 716, [], 717, [], "new _FileStream"],
        _FileStream$forStdin: [function() {
          return new P._FileStream(null, null, null, 0, null, new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]), false, true, false, false);
        }, null, null, 0, 0, 4, "new _FileStream$forStdin"]
      }
    },
    "+_FileStream": [42],
    _FileStream__setupController_closure: {
      "^": "Closure:4;$this",
      call$0: [function() {
        var t1 = this.$this;
        t1._unsubscribed = true;
        return t1._closeFile$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _FileStream__setupController_closure": [2],
    _FileStream__closeFile_done: {
      "^": "Closure:6;$this",
      call$0: [function() {
        var t1 = this.$this;
        t1._closeCompleter.complete$0();
        t1._io$_controller.close$0();
      }, null, null, 0, 0, 6, "call"]
    },
    "+ _FileStream__closeFile_done": [2],
    _FileStream__readBlock_closure: {
      "^": "Closure:3;_box_0,$this",
      call$1: [function(block) {
        var t1, t2;
        t1 = this.$this;
        t1._readInProgress = false;
        if (t1._unsubscribed === true) {
          t1._closeFile$0();
          return;
        }
        t2 = J.getInterceptor$asx(block);
        t1._io$_position = J.$add$ns(t1._io$_position, t2.get$length(block));
        if (!J.$lt$n(t2.get$length(block), this._box_0.readBytes)) {
          t2 = t1._io$_end;
          t2 = t2 != null && J.$eq$(t1._io$_position, t2);
        } else
          t2 = true;
        if (t2)
          t1._atEnd = true;
        if (t1._atEnd !== true && !t1._io$_controller.get$isPaused())
          t1._readBlock$0();
        J.add$1$ax(t1._io$_controller, block);
        if (t1._atEnd === true)
          t1._closeFile$0();
      }, null, null, 2, 0, 3, 858, [], "call"]
    },
    "+ _FileStream__readBlock_closure": [2],
    _FileStream__readBlock_closure0: {
      "^": "Closure:12;$this",
      call$2: [function(e, s) {
        var t1 = this.$this;
        if (t1._unsubscribed !== true) {
          t1._io$_controller.addError$2(e, s);
          t1._closeFile$0();
          t1._unsubscribed = true;
        }
      }, null, null, 4, 0, 12, 47, [], 49, [], "call"]
    },
    "+ _FileStream__readBlock_closure": [2],
    _FileStream__start_onReady: {
      "^": "Closure:177;$this",
      call$1: [function(file) {
        var t1 = this.$this;
        t1._openedFile = file;
        t1._readInProgress = false;
        t1._readBlock$0();
      }, null, null, 2, 0, 177, 158, [], "call"]
    },
    "+ _FileStream__start_onReady": [2],
    _FileStream__start_onOpenFile: {
      "^": "Closure:177;$this,onReady",
      call$1: [function(file) {
        var t1, t2;
        t1 = this.$this;
        t2 = this.onReady;
        if (J.$gt$n(t1._io$_position, 0))
          file.setPosition$1(t1._io$_position).then$2$onError(t2, new P._FileStream__start_onOpenFile_closure(t1));
        else
          t2.call$1(file);
      }, null, null, 2, 0, 177, 158, [], "call"]
    },
    "+ _FileStream__start_onOpenFile": [2],
    _FileStream__start_onOpenFile_closure: {
      "^": "Closure:12;$this",
      call$2: [function(e, s) {
        var t1 = this.$this;
        t1._io$_controller.addError$2(e, s);
        t1._readInProgress = false;
        t1._closeFile$0();
      }, null, null, 4, 0, 12, 47, [], 49, [], "call"]
    },
    "+ _FileStream__start_onOpenFile_closure": [2],
    _FileStream__start_openFailed: {
      "^": "Closure:267;$this",
      call$2: [function(error, stackTrace) {
        var t1 = this.$this;
        t1._io$_controller.addError$2(error, stackTrace);
        t1._io$_controller.close$0();
        t1._closeCompleter.complete$0();
      }, null, null, 4, 0, 267, 8, [], 12, [], "call"]
    },
    "+ _FileStream__start_openFailed": [2],
    _FileStreamConsumer: {
      "^": "StreamConsumer;_file@-489,_openFuture@-1500",
      addStream$1: [function(stream) {
        var t1, t2, completer;
        t1 = P.File;
        t2 = new P._Future(0, $.Zone__current, null, [t1]);
        completer = new P._SyncCompleter(t2, [t1]);
        this._openFuture.then$1(new P._FileStreamConsumer_addStream_closure(this, stream, completer)).catchError$1(completer.get$completeError());
        return t2;
      }, "call$1", "get$addStream", 2, 0, 734, 37, [], "addStream"],
      close$0: [function() {
        return this._openFuture.then$1(new P._FileStreamConsumer_close_closure());
      }, "call$0", "get$close", 0, 0, 741, "close"],
      $asStreamConsumer: function() {
        return [[P.List, P.int]];
      },
      "<>": [],
      static: {
        _FileStreamConsumer$: [function(_file, mode) {
          var t1 = new P._FileStreamConsumer(_file, null);
          t1._openFuture = _file.open$1$mode(mode);
          return t1;
        }, null, null, 4, 0, 827, 718, [], 70, [], "new _FileStreamConsumer"],
        _FileStreamConsumer$fromStdio: [function(fd) {
          var t1, t2, t3;
          t1 = new P._FileStreamConsumer(null, null);
          t2 = P._File__openStdioSync(fd);
          t3 = new P._Future(0, $.Zone__current, null, [null]);
          t3._asyncComplete$1(t2);
          t1._openFuture = t3;
          return t1;
        }, null, null, 2, 0, 22, 103, [], "new _FileStreamConsumer$fromStdio"]
      }
    },
    "+_FileStreamConsumer": [270],
    _FileStreamConsumer_addStream_closure: {
      "^": "Closure:3;$this,stream,completer",
      call$1: [function(openedFile) {
        var t1, t2, t3;
        t1 = {};
        t1._subscription = null;
        t2 = this.completer;
        t3 = new P._FileStreamConsumer_addStream__error(t1, t2, openedFile);
        t1._subscription = this.stream.listen$4$cancelOnError$onDone$onError(new P._FileStreamConsumer_addStream__closure(t1, openedFile, t3), true, new P._FileStreamConsumer_addStream__closure0(this.$this, t2), t3);
      }, null, null, 2, 0, 3, 610, [], "call"]
    },
    "+ _FileStreamConsumer_addStream_closure": [2],
    _FileStreamConsumer_addStream__error: {
      "^": "Closure:81;_box_0,completer,openedFile",
      call$2: [function(e, stackTrace) {
        this._box_0._subscription.cancel$0();
        this.openedFile.close$0();
        this.completer.completeError$2(e, stackTrace);
      }, function(e) {
        return this.call$2(e, null);
      }, "call$1", null, null, null, 2, 2, 81, 0, 47, [], 12, [], "call"]
    },
    "+ _FileStreamConsumer_addStream__error": [2],
    _FileStreamConsumer_addStream__closure: {
      "^": "Closure:3;_box_0,openedFile,error",
      call$1: [function(d) {
        var e, stackTrace, t1, exception;
        t1 = this._box_0;
        t1._subscription.pause$0();
        try {
          this.openedFile.writeFrom$3(d, 0, J.get$length$asx(d)).then$2$onError(new P._FileStreamConsumer_addStream___closure(t1), this.error);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          stackTrace = H.getTraceFromException(exception);
          this.error.call$2(e, stackTrace);
        }
      }, null, null, 2, 0, 3, 306, [], "call"]
    },
    "+ _FileStreamConsumer_addStream__closure": [2],
    _FileStreamConsumer_addStream___closure: {
      "^": "Closure:3;_box_0",
      call$1: [function(_) {
        return this._box_0._subscription.resume$0();
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _FileStreamConsumer_addStream___closure": [2],
    _FileStreamConsumer_addStream__closure0: {
      "^": "Closure:4;$this,completer",
      call$0: [function() {
        this.completer.complete$1(this.$this._file);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _FileStreamConsumer_addStream__closure": [2],
    _FileStreamConsumer_close_closure: {
      "^": "Closure:3;",
      call$1: [function(openedFile) {
        return openedFile.close$0();
      }, null, null, 2, 0, 3, 610, [], "call"]
    },
    "+ _FileStreamConsumer_close_closure": [2],
    _File: {
      "^": "FileSystemEntity;path<-9",
      exists$0: [function() {
        return P._IOService__dispatch(0, [this.path]).then$1(new P._File_exists_closure(this));
      }, "call$0", "get$exists", 0, 0, 129, "exists"],
      existsSync$0: [function() {
        P._File__exists(this.path);
      }, "call$0", "get$existsSync", 0, 0, 5, "existsSync"],
      get$absolute: [function() {
        return P._File$(this.get$_absolutePath());
      }, null, null, 1, 0, 915, "absolute"],
      create$1$recursive: [function(recursive) {
        var result;
        if (recursive === true)
          result = P._Directory$(P.FileSystemEntity_parentOf(this.path)).create$1$recursive(true);
        else {
          result = new P._Future(0, $.Zone__current, null, [null]);
          result._asyncComplete$1(null);
        }
        return result.then$1(new P._File_create_closure(this)).then$1(new P._File_create_closure0(this));
      }, function() {
        return this.create$1$recursive(false);
      }, "create$0", "call$1$recursive", "call$0", "get$create", 0, 3, 330, 4, 51, [], "create"],
      createSync$1$recursive: [function(recursive) {
        if (recursive === true)
          P._Directory$(P.FileSystemEntity_parentOf(this.path)).createSync$1$recursive(true);
        P._File__create(this.path);
      }, function() {
        return this.createSync$1$recursive(false);
      }, "createSync$0", "call$1$recursive", "call$0", "get$createSync", 0, 3, 111, 4, 51, [], "createSync"],
      _delete$1$recursive: [function(recursive) {
        if (recursive === true)
          return P._Directory$(this.path).delete$1$recursive(true).then$1(new P._File__delete_closure(this));
        return P._IOService__dispatch(2, [this.path]).then$1(new P._File__delete_closure0(this));
      }, function() {
        return this._delete$1$recursive(false);
      }, "_delete$0", "call$1$recursive", "call$0", "get$_delete", 0, 3, 330, 4, 51, [], "_delete"],
      _deleteSync$1$recursive: [function(recursive) {
        if (recursive === true)
          return P._Directory$(this.path)._deleteSync$1$recursive(true);
        P._File__deleteNative(this.path);
      }, function() {
        return this._deleteSync$1$recursive(false);
      }, "_deleteSync$0", "call$1$recursive", "call$0", "get$_deleteSync", 0, 3, 111, 4, 51, [], "_deleteSync"],
      rename$1: [function(newPath) {
        return P._IOService__dispatch(3, [this.path, newPath]).then$1(new P._File_rename_closure(this, newPath));
      }, "call$1", "get$rename", 2, 0, 331, 86, [], "rename"],
      renameSync$1: [function(newPath) {
        P._File__rename(this.path, newPath);
      }, "call$1", "get$renameSync", 2, 0, 266, 86, [], "renameSync"],
      copy$1: [function(newPath) {
        return P._IOService__dispatch(4, [this.path, newPath]).then$1(new P._File_copy_closure(this, newPath));
      }, "call$1", "get$copy", 2, 0, 331, 86, [], "copy"],
      copySync$1: [function(newPath) {
        P._File__copy(this.path, newPath);
      }, "call$1", "get$copySync", 2, 0, 266, 86, [], "copySync"],
      open$1$mode: [function(mode) {
        var t1 = J.getInterceptor(mode);
        if (!t1.$eq(mode, C.FileMode_0) && !t1.$eq(mode, C.FileMode_1) && !t1.$eq(mode, C.FileMode_2) && !t1.$eq(mode, C.FileMode_3) && !t1.$eq(mode, C.FileMode_4))
          return P.Future_Future$error(new P.ArgumentError(false, null, null, "Invalid file mode for this operation"), null, null);
        return P._IOService__dispatch(5, [this.path, mode.get$_mode()]).then$1(new P._File_open_closure(this));
      }, function() {
        return this.open$1$mode(C.FileMode_0);
      }, "open$0", "call$1$mode", "call$0", "get$open", 0, 3, 1167, 623, 70, [], "open"],
      length$0: [function(_) {
        return P._IOService__dispatch(12, [this.path]).then$1(new P._File_length_closure(this));
      }, "call$0", "get$length", 0, 0, 160, "length"],
      lengthSync$0: [function() {
        P._File__lengthFromPath(this.path);
      }, "call$0", "get$lengthSync", 0, 0, 11, "lengthSync"],
      lastAccessed$0: [function() {
        return P._IOService__dispatch(13, [this.path]).then$1(new P._File_lastAccessed_closure(this));
      }, "call$0", "get$lastAccessed", 0, 0, 332, "lastAccessed"],
      lastAccessedSync$0: [function() {
        P._File__lastAccessed(this.path);
      }, "call$0", "get$lastAccessedSync", 0, 0, 85, "lastAccessedSync"],
      setLastAccessed$1: [function(time) {
        return P._IOService__dispatch(14, [this.path, time.get$millisecondsSinceEpoch()]).then$1(new P._File_setLastAccessed_closure(this));
      }, "call$1", "get$setLastAccessed", 2, 0, 333, 226, [], "setLastAccessed"],
      setLastAccessedSync$1: [function(time) {
        P._File__setLastAccessed(this.path, time.get$millisecondsSinceEpoch());
      }, "call$1", "get$setLastAccessedSync", 2, 0, 146, 226, [], "setLastAccessedSync"],
      lastModified$0: [function() {
        return P._IOService__dispatch(15, [this.path]).then$1(new P._File_lastModified_closure(this));
      }, "call$0", "get$lastModified", 0, 0, 332, "lastModified"],
      lastModifiedSync$0: [function() {
        P._File__lastModified(this.path);
      }, "call$0", "get$lastModifiedSync", 0, 0, 85, "lastModifiedSync"],
      setLastModified$1: [function(time) {
        return P._IOService__dispatch(16, [this.path, time.get$millisecondsSinceEpoch()]).then$1(new P._File_setLastModified_closure(this));
      }, "call$1", "get$setLastModified", 2, 0, 333, 226, [], "setLastModified"],
      setLastModifiedSync$1: [function(time) {
        P._File__setLastModified(this.path, time.get$millisecondsSinceEpoch());
      }, "call$1", "get$setLastModifiedSync", 2, 0, 146, 226, [], "setLastModifiedSync"],
      openSync$1$mode: [function(mode) {
        var t1 = J.getInterceptor(mode);
        if (!t1.$eq(mode, C.FileMode_0) && !t1.$eq(mode, C.FileMode_1) && !t1.$eq(mode, C.FileMode_2) && !t1.$eq(mode, C.FileMode_3) && !t1.$eq(mode, C.FileMode_4))
          throw H.wrapException(P.ArgumentError$("Invalid file mode for this operation"));
        P._File__open(this.path, mode.get$_mode());
      }, function() {
        return this.openSync$1$mode(C.FileMode_0);
      }, "openSync$0", "call$1$mode", "call$0", "get$openSync", 0, 3, 1206, 623, 70, [], "openSync"],
      openRead$2: [function(start, end) {
        var t1 = new P._FileStream(null, this.path, null, start, end, new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]), false, true, false, false);
        if (start == null)
          t1._io$_position = 0;
        return t1;
      }, function(start) {
        return this.openRead$2(start, null);
      }, "openRead$1", function() {
        return this.openRead$2(null, null);
      }, "openRead$0", "call$2", "call$1", "call$0", "get$openRead", 0, 4, 1213, 0, 0, 3, [], 5, [], "openRead"],
      openWrite$2$encoding$mode: [function(encoding, mode) {
        var t1, consumer;
        t1 = J.getInterceptor(mode);
        if (!t1.$eq(mode, C.FileMode_1) && !t1.$eq(mode, C.FileMode_2) && !t1.$eq(mode, C.FileMode_3) && !t1.$eq(mode, C.FileMode_4))
          throw H.wrapException(P.ArgumentError$("Invalid file mode for this operation"));
        consumer = new P._FileStreamConsumer(this, null);
        consumer._openFuture = this.open$1$mode(mode);
        return new P._IOSinkImpl(encoding, true, consumer, new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]), null, null, false, false, false);
      }, function() {
        return this.openWrite$2$encoding$mode(C.Utf8Codec_false, C.FileMode_1);
      }, "openWrite$0", function(mode) {
        return this.openWrite$2$encoding$mode(C.Utf8Codec_false, mode);
      }, "openWrite$1$mode", "call$2$encoding$mode", "call$0", "call$1$mode", "get$openWrite", 0, 5, 1321, 185, 73, 70, [], 48, [], "openWrite"],
      readAsBytes$0: [function() {
        return this.open$0().then$1(new P._File_readAsBytes_closure(new P._File_readAsBytes_readDataChunked()));
      }, "call$0", "get$readAsBytes", 0, 0, 1343, "readAsBytes"],
      readAsBytesSync$0: [function() {
        var opened, data, $length, builder, t1, result;
        opened = this.openSync$0();
        try {
          data = null;
          t1 = opened;
          t1._checkAvailable$0();
          result = J.length$0$asx(t1.get$_ops());
          if (result instanceof P.OSError)
            H.throwExpression(new P.FileSystemException("length failed", t1.get$path(), result));
          $length = result;
          if (J.$eq$($length, 0)) {
            builder = P.BytesBuilder_BytesBuilder(false);
            do {
              data = opened.readSync$1(65536);
              if (J.get$length$asx(data) > 0)
                J.add$1$ax(builder, data);
            } while (J.get$length$asx(data) > 0);
            data = builder.takeBytes$0();
          } else
            data = opened.readSync$1($length);
          t1 = data;
          return t1;
        } finally {
          opened.closeSync$0();
        }
      }, "call$0", "get$readAsBytesSync", 0, 0, 69, "readAsBytesSync"],
      _tryDecode$2: [function(bytes, encoding) {
        var t1, exception;
        try {
          t1 = encoding.decode$1(bytes);
          return t1;
        } catch (exception) {
          H.unwrapException(exception);
          throw H.wrapException(new P.FileSystemException("Failed to decode data using encoding '" + H.S(encoding.get$name()) + "'", this.path, null));
        }
      }, "call$2", "get$_tryDecode", 4, 0, 1353, 30, [], 48, [], "_tryDecode"],
      readAsString$1$encoding: [function(encoding) {
        return this.readAsBytes$0().then$1(new P._File_readAsString_closure(this, encoding));
      }, function() {
        return this.readAsString$1$encoding(C.Utf8Codec_false);
      }, "readAsString$0", "call$1$encoding", "call$0", "get$readAsString", 0, 3, 1363, 73, 48, [], "readAsString"],
      readAsStringSync$1$encoding: [function(encoding) {
        return this._tryDecode$2(this.readAsBytesSync$0(), encoding);
      }, function() {
        return this.readAsStringSync$1$encoding(C.Utf8Codec_false);
      }, "readAsStringSync$0", "call$1$encoding", "call$0", "get$readAsStringSync", 0, 3, 315, 73, 48, [], "readAsStringSync"],
      readAsLines$1$encoding: [function(encoding) {
        return this.readAsString$1$encoding(encoding).then$1(C.C_LineSplitter.get$convert());
      }, function() {
        return this.readAsLines$1$encoding(C.Utf8Codec_false);
      }, "readAsLines$0", "call$1$encoding", "call$0", "get$readAsLines", 0, 3, 1368, 73, 48, [], "readAsLines"],
      readAsLinesSync$1$encoding: [function(encoding) {
        return C.C_LineSplitter.convert$1(this._tryDecode$2(this.readAsBytesSync$0(), encoding));
      }, function() {
        return this.readAsLinesSync$1$encoding(C.Utf8Codec_false);
      }, "readAsLinesSync$0", "call$1$encoding", "call$0", "get$readAsLinesSync", 0, 3, 1376, 73, 48, [], "readAsLinesSync"],
      writeAsBytes$3$flush$mode: [function(bytes, flush, mode) {
        return this.open$1$mode(mode).then$1(new P._File_writeAsBytes_closure(this, bytes, flush));
      }, function(bytes) {
        return this.writeAsBytes$3$flush$mode(bytes, false, C.FileMode_1);
      }, "writeAsBytes$1", "call$3$flush$mode", "call$1", "get$writeAsBytes", 2, 5, 1378, 185, 4, 30, [], 70, [], 243, [], "writeAsBytes"],
      writeAsBytesSync$3$flush$mode: [function(bytes, flush, mode) {
        var opened, t1;
        opened = this.openSync$1$mode(mode);
        try {
          opened.writeFromSync$3(bytes, 0, J.get$length$asx(bytes));
          if (flush === true) {
            t1 = opened;
            t1._checkAvailable$0();
            t1.get$_ops().flush$0();
          }
        } finally {
          opened.closeSync$0();
        }
      }, function(bytes) {
        return this.writeAsBytesSync$3$flush$mode(bytes, false, C.FileMode_1);
      }, "writeAsBytesSync$1", "call$3$flush$mode", "call$1", "get$writeAsBytesSync", 2, 5, 1442, 185, 4, 30, [], 70, [], 243, [], "writeAsBytesSync"],
      writeAsString$4$encoding$flush$mode: [function(contents, encoding, flush, mode) {
        var e, t1, exception;
        try {
          t1 = this.writeAsBytes$3$flush$mode(encoding.encode$1(contents), flush, mode);
          return t1;
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          return P.Future_Future$error(e, null, null);
        }
      }, function(contents) {
        return this.writeAsString$4$encoding$flush$mode(contents, C.Utf8Codec_false, false, C.FileMode_1);
      }, "writeAsString$1", "call$4$encoding$flush$mode", "call$1", "get$writeAsString", 2, 7, 1483, 185, 73, 4, 604, [], 70, [], 48, [], 243, [], "writeAsString"],
      writeAsStringSync$4$encoding$flush$mode: [function(contents, encoding, flush, mode) {
        this.writeAsBytesSync$3$flush$mode(encoding.encode$1(contents), flush, mode);
      }, function(contents) {
        return this.writeAsStringSync$4$encoding$flush$mode(contents, C.Utf8Codec_false, false, C.FileMode_1);
      }, "writeAsStringSync$1", "call$4$encoding$flush$mode", "call$1", "get$writeAsStringSync", 2, 7, 1496, 185, 73, 4, 604, [], 70, [], 48, [], 243, [], "writeAsStringSync"],
      toString$0: [function(_) {
        return "File: '" + H.S(this.path) + "'";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      _File$1: function(path) {
        var t1 = this.path;
        if (typeof t1 !== "string")
          throw H.wrapException(P.ArgumentError$(H.S(P.Error_safeToString(t1)) + " is not a String"));
      },
      $isFile: 1,
      static: {
        _File$: [function(path) {
          var t1 = new P._File(path);
          t1._File$1(path);
          return t1;
        }, null, null, 2, 0, 13, 10, [], "new _File"],
        _File__exists: [function(path) {
          throw H.wrapException(new P.UnsupportedError("File._exists"));
        }, "call$1", "io__File__exists$closure", 2, 0, 13, 10, [], "_exists"],
        _File__create: [function(path) {
          throw H.wrapException(new P.UnsupportedError("File._create"));
        }, "call$1", "io__File__create$closure", 2, 0, 13, 10, [], "_create"],
        _File__createLink: [function(path, target) {
          throw H.wrapException(new P.UnsupportedError("File._createLink"));
        }, "call$2", "io__File__createLink$closure", 4, 0, 40, 10, [], 79, [], "_createLink"],
        _File__linkTarget: [function(path) {
          throw H.wrapException(new P.UnsupportedError("File._linkTarget"));
        }, "call$1", "io__File__linkTarget$closure", 2, 0, 13, 10, [], "_linkTarget"],
        _File__deleteNative: [function(path) {
          throw H.wrapException(new P.UnsupportedError("File._deleteNative"));
        }, "call$1", "io__File__deleteNative$closure", 2, 0, 13, 10, [], "_deleteNative"],
        _File__deleteLinkNative: [function(path) {
          throw H.wrapException(new P.UnsupportedError("File._deleteLinkNative"));
        }, "call$1", "io__File__deleteLinkNative$closure", 2, 0, 13, 10, [], "_deleteLinkNative"],
        _File__rename: [function(oldPath, newPath) {
          throw H.wrapException(new P.UnsupportedError("File._rename"));
        }, "call$2", "io__File__rename$closure", 4, 0, 40, 370, [], 86, [], "_rename"],
        _File__renameLink: [function(oldPath, newPath) {
          throw H.wrapException(new P.UnsupportedError("File._renameLink"));
        }, "call$2", "io__File__renameLink$closure", 4, 0, 40, 370, [], 86, [], "_renameLink"],
        _File__copy: [function(oldPath, newPath) {
          throw H.wrapException(new P.UnsupportedError("File._copy"));
        }, "call$2", "io__File__copy$closure", 4, 0, 40, 370, [], 86, [], "_copy"],
        _File__lengthFromPath: [function(path) {
          throw H.wrapException(new P.UnsupportedError("File._lengthFromPath"));
        }, "call$1", "io__File__lengthFromPath$closure", 2, 0, 13, 10, [], "_lengthFromPath"],
        _File__lastAccessed: [function(path) {
          throw H.wrapException(new P.UnsupportedError("File._lastAccessed"));
        }, "call$1", "io__File__lastAccessed$closure", 2, 0, 13, 10, [], "_lastAccessed"],
        _File__setLastAccessed: [function(path, millis) {
          throw H.wrapException(new P.UnsupportedError("File._setLastAccessed"));
        }, "call$2", "io__File__setLastAccessed$closure", 4, 0, 147, 10, [], 371, [], "_setLastAccessed"],
        _File__lastModified: [function(path) {
          throw H.wrapException(new P.UnsupportedError("File._lastModified"));
        }, "call$1", "io__File__lastModified$closure", 2, 0, 13, 10, [], "_lastModified"],
        _File__setLastModified: [function(path, millis) {
          throw H.wrapException(new P.UnsupportedError("File._setLastModified"));
        }, "call$2", "io__File__setLastModified$closure", 4, 0, 147, 10, [], 371, [], "_setLastModified"],
        _File__open: [function(path, mode) {
          throw H.wrapException(new P.UnsupportedError("File._open"));
        }, "call$2", "io__File__open$closure", 4, 0, 147, 10, [], 70, [], "_open"],
        _File__openStdio: [function(fd) {
          throw H.wrapException(new P.UnsupportedError("File._openStdio"));
        }, "call$1", "io__File__openStdio$closure", 2, 0, 16, 103, [], "_openStdio"],
        _File__openStdioSync: [function(fd) {
          P._File__openStdio(fd);
        }, "call$1", "io__File__openStdioSync$closure", 2, 0, 828, 103, [], "_openStdioSync"],
        _File_throwIfError: [function(result, msg, path) {
          if (result instanceof P.OSError)
            throw H.wrapException(new P.FileSystemException(msg, path, result));
        }, "call$3", "io__File_throwIfError$closure", 6, 0, 829, 93, [], 92, [], 10, [], "throwIfError"]
      }
    },
    "+_File": [115, 489],
    _File_exists_closure: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        response.$index(0, 0);
        throw H.wrapException(P._exceptionFromResponse(response, "Cannot check existence", this.$this.path));
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _File_exists_closure": [2],
    _File_create_closure: {
      "^": "Closure:3;$this",
      call$1: [function(_) {
        return P._IOService__dispatch(1, [this.$this.path]);
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _File_create_closure": [2],
    _File_create_closure0: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        var t1 = J.getInterceptor(response);
        if (!!t1.$isList && !J.$eq$(t1.$index(response, 0), 0))
          throw H.wrapException(P._exceptionFromResponse(response, "Cannot create file", this.$this.path));
        return this.$this;
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _File_create_closure": [2],
    _File__delete_closure: {
      "^": "Closure:3;$this",
      call$1: [function(_) {
        return this.$this;
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _File__delete_closure": [2],
    _File__delete_closure0: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        response.$index(0, 0);
        throw H.wrapException(P._exceptionFromResponse(response, "Cannot delete file", this.$this.path));
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _File__delete_closure": [2],
    _File_rename_closure: {
      "^": "Closure:3;$this,newPath",
      call$1: [function(response) {
        response.$index(0, 0);
        throw H.wrapException(P._exceptionFromResponse(response, "Cannot rename file to '" + H.S(this.newPath) + "'", this.$this.path));
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _File_rename_closure": [2],
    _File_copy_closure: {
      "^": "Closure:3;$this,newPath",
      call$1: [function(response) {
        response.$index(0, 0);
        throw H.wrapException(P._exceptionFromResponse(response, "Cannot copy file to '" + H.S(this.newPath) + "'", this.$this.path));
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _File_copy_closure": [2],
    _File_open_closure: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        response.$index(0, 0);
        throw H.wrapException(P._exceptionFromResponse(response, "Cannot open file", this.$this.path));
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _File_open_closure": [2],
    _File_length_closure: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        response.$index(0, 0);
        throw H.wrapException(P._exceptionFromResponse(response, "Cannot retrieve length of file", this.$this.path));
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _File_length_closure": [2],
    _File_lastAccessed_closure: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        response.$index(0, 0);
        throw H.wrapException(P._exceptionFromResponse(response, "Cannot retrieve access time", this.$this.path));
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _File_lastAccessed_closure": [2],
    _File_setLastAccessed_closure: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        response.$index(0, 0);
        throw H.wrapException(P._exceptionFromResponse(response, "Cannot set access time", this.$this.path));
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _File_setLastAccessed_closure": [2],
    _File_lastModified_closure: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        response.$index(0, 0);
        throw H.wrapException(P._exceptionFromResponse(response, "Cannot retrieve modification time", this.$this.path));
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _File_lastModified_closure": [2],
    _File_setLastModified_closure: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        response.$index(0, 0);
        throw H.wrapException(P._exceptionFromResponse(response, "Cannot set modification time", this.$this.path));
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _File_setLastModified_closure": [2],
    _File_readAsBytes_readDataChunked: {
      "^": "Closure:334;",
      call$1: [function(file) {
        var builder, t1, t2;
        builder = P.BytesBuilder_BytesBuilder(false);
        t1 = [P.List, P.int];
        t2 = new P._Future(0, $.Zone__current, null, [t1]);
        new P._File_readAsBytes_readDataChunked_read(file, builder, new P._AsyncCompleter(t2, [t1])).call$0();
        return t2;
      }, null, null, 2, 0, 334, 158, [], "call"]
    },
    "+ _File_readAsBytes_readDataChunked": [2],
    _File_readAsBytes_readDataChunked_read: {
      "^": "Closure:6;file,builder,completer",
      call$0: [function() {
        var t1 = this.completer;
        this.file.read$1(65536).then$2$onError(new P._File_readAsBytes_readDataChunked_read_closure(this.builder, t1, this), t1.get$completeError());
      }, null, null, 0, 0, 6, "call"]
    },
    "+ _File_readAsBytes_readDataChunked_read": [2],
    _File_readAsBytes_readDataChunked_read_closure: {
      "^": "Closure:3;builder,completer,read",
      call$1: [function(data) {
        var t1 = this.builder;
        if (J.$gt$n(J.get$length$asx(data), 0)) {
          t1.add$1(0, data);
          this.read.call$0();
        } else
          this.completer.complete$1(t1.takeBytes$0());
      }, null, null, 2, 0, 3, 21, [], "call"]
    },
    "+ _File_readAsBytes_readDataChunked_read_closure": [2],
    _File_readAsBytes_closure: {
      "^": "Closure:3;readDataChunked",
      call$1: [function(file) {
        return J.length$0$asx(file).then$1(new P._File_readAsBytes__closure(this.readDataChunked, file)).whenComplete$1(file.get$close());
      }, null, null, 2, 0, 3, 158, [], "call"]
    },
    "+ _File_readAsBytes_closure": [2],
    _File_readAsBytes__closure: {
      "^": "Closure:3;readDataChunked,file",
      call$1: [function($length) {
        if (J.$eq$($length, 0))
          return this.readDataChunked.call$1(this.file);
        return this.file.read$1($length);
      }, null, null, 2, 0, 3, 15, [], "call"]
    },
    "+ _File_readAsBytes__closure": [2],
    _File_readAsString_closure: {
      "^": "Closure:3;$this,encoding",
      call$1: [function(bytes) {
        return this.$this._tryDecode$2(bytes, this.encoding);
      }, null, null, 2, 0, 3, 30, [], "call"]
    },
    "+ _File_readAsString_closure": [2],
    _File_writeAsBytes_closure: {
      "^": "Closure:3;$this,bytes,flush",
      call$1: [function(file) {
        var t1 = this.bytes;
        return file.writeFrom$3(t1, 0, J.get$length$asx(t1)).then$1(new P._File_writeAsBytes__closure(this.$this, this.flush, file)).whenComplete$1(file.get$close());
      }, null, null, 2, 0, 3, 158, [], "call"]
    },
    "+ _File_writeAsBytes_closure": [2],
    _File_writeAsBytes__closure: {
      "^": "Closure:3;$this,flush,file",
      call$1: [function(_) {
        if (this.flush === true)
          return this.file.flush$0().then$1(new P._File_writeAsBytes___closure(this.$this));
        return this.$this;
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _File_writeAsBytes__closure": [2],
    _File_writeAsBytes___closure: {
      "^": "Closure:3;$this",
      call$1: [function(_) {
        return this.$this;
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _File_writeAsBytes___closure": [2],
    _RandomAccessFileOps: {
      "^": "Object;",
      static: {
        _RandomAccessFileOps__RandomAccessFileOps: [function(pointer) {
          throw H.wrapException(new P.UnsupportedError("RandomAccessFile"));
        }, null, null, 2, 0, 830, 361, [], "new _RandomAccessFileOps"]
      }
    },
    "+_RandomAccessFileOps": [1],
    _RandomAccessFile: {
      "^": "Object;path<-9,_asyncDispatched@-8,_fileService@-491,_resourceInfo@-1503,_ops@-1504,closed@-8",
      _maybePerformCleanup$0: [function() {
        if (this.closed === true) {
          var t1 = this._resourceInfo;
          J.remove$1$ax($.$get$_FileResourceInfo_openFiles(), t1.get$id());
        }
      }, "call$0", "get$_maybePerformCleanup", 0, 0, 6, "_maybePerformCleanup"],
      _maybeConnectHandler$0: [function() {
        if ($._RandomAccessFile__connectedResourceHandler !== true) {
          P.registerExtension("ext.dart.io.getOpenFiles", P.io__FileResourceInfo_getOpenFiles$closure());
          P.registerExtension("ext.dart.io.getFileByID", P.io__FileResourceInfo_getFileInfoMapByID$closure());
          $._RandomAccessFile__connectedResourceHandler = true;
        }
      }, "call$0", "get$_maybeConnectHandler", 0, 0, 4, "_maybeConnectHandler"],
      close$0: [function() {
        return this._dispatch$3$markClosed(7, [null], true).then$1(new P._RandomAccessFile_close_closure(this));
      }, "call$0", "get$close", 0, 0, 335, "close"],
      closeSync$0: [function() {
        var id, t1;
        this._checkAvailable$0();
        id = this._ops.close$0();
        t1 = J.getInterceptor(id);
        if (t1.$eq(id, -1))
          throw H.wrapException(new P.FileSystemException("Cannot close file", this.path, null));
        t1 = this.closed === true || t1.$eq(id, 0);
        this.closed = t1;
        if (t1) {
          t1 = this._resourceInfo;
          J.remove$1$ax($.$get$_FileResourceInfo_openFiles(), t1.get$id());
        }
      }, "call$0", "get$closeSync", 0, 0, 6, "closeSync"],
      readByte$0: [function() {
        return this._dispatch$2(18, [null]).then$1(new P._RandomAccessFile_readByte_closure(this));
      }, "call$0", "get$readByte", 0, 0, 160, "readByte"],
      readByteSync$0: [function() {
        this._checkAvailable$0();
        var result = this._ops.readByte$0();
        this._resourceInfo.addRead$1(1);
        return result;
      }, "call$0", "get$readByteSync", 0, 0, 11, "readByteSync"],
      read$1: [function(bytes) {
        if (typeof bytes !== "number" || Math.floor(bytes) !== bytes)
          throw H.wrapException(P.ArgumentError$(bytes));
        return this._dispatch$2(20, [null, bytes]).then$1(new P._RandomAccessFile_read_closure(this));
      }, "call$1", "get$read", 2, 0, 1511, 30, [], "read"],
      readSync$1: [function(bytes) {
        var result;
        this._checkAvailable$0();
        if (typeof bytes !== "number" || Math.floor(bytes) !== bytes)
          throw H.wrapException(P.ArgumentError$(bytes));
        result = this._ops.read$1(bytes);
        this._resourceInfo.addRead$1(J.get$length$asx(result));
        return result;
      }, "call$1", "get$readSync", 2, 0, 105, 30, [], "readSync"],
      readInto$3: [function(buffer, start, end) {
        var t1, t2;
        t1 = J.getInterceptor(buffer);
        if (!!t1.$isList)
          if (!(start != null && (typeof start !== "number" || Math.floor(start) !== start)))
            t2 = end != null && (typeof end !== "number" || Math.floor(end) !== end);
          else
            t2 = true;
        else
          t2 = true;
        if (t2)
          throw H.wrapException(P.ArgumentError$(null));
        end = P.RangeError_checkValidRange(start, end, t1.get$length(buffer), null, null, null);
        t1 = J.getInterceptor(end);
        if (t1.$eq(end, start)) {
          t1 = new P._Future(0, $.Zone__current, null, [null]);
          t1._asyncComplete$1(0);
          return t1;
        }
        return this._dispatch$2(21, [null, t1.$sub(end, start)]).then$1(new P._RandomAccessFile_readInto_closure(this, buffer, start));
      }, function(buffer) {
        return this.readInto$3(buffer, 0, null);
      }, "readInto$1", function(buffer, start) {
        return this.readInto$3(buffer, start, null);
      }, "readInto$2", "call$3", "call$1", "call$2", "get$readInto", 2, 4, 1551, 7, 0, 41, [], 3, [], 5, [], "readInto"],
      readIntoSync$3: [function(buffer, start, end) {
        var t1, t2, result;
        this._checkAvailable$0();
        t1 = J.getInterceptor(buffer);
        if (!!t1.$isList)
          if (!(start != null && (typeof start !== "number" || Math.floor(start) !== start)))
            t2 = end != null && (typeof end !== "number" || Math.floor(end) !== end);
          else
            t2 = true;
        else
          t2 = true;
        if (t2)
          throw H.wrapException(P.ArgumentError$(null));
        end = P.RangeError_checkValidRange(start, end, t1.get$length(buffer), null, null, null);
        if (J.$eq$(end, start))
          return 0;
        result = this._ops.readInto$3(buffer, start, end);
        this._resourceInfo.addRead$1(result);
        return result;
      }, function(buffer) {
        return this.readIntoSync$3(buffer, 0, null);
      }, "readIntoSync$1", function(buffer, start) {
        return this.readIntoSync$3(buffer, start, null);
      }, "readIntoSync$2", "call$3", "call$1", "call$2", "get$readIntoSync", 2, 4, 336, 7, 0, 41, [], 3, [], 5, [], "readIntoSync"],
      writeByte$1: [function(value) {
        if (typeof value !== "number" || Math.floor(value) !== value)
          throw H.wrapException(P.ArgumentError$(value));
        return this._dispatch$2(19, [null, value]).then$1(new P._RandomAccessFile_writeByte_closure(this));
      }, "call$1", "get$writeByte", 2, 0, 265, 1, [], "writeByte"],
      writeByteSync$1: [function(value) {
        var result;
        this._checkAvailable$0();
        if (typeof value !== "number" || Math.floor(value) !== value)
          throw H.wrapException(P.ArgumentError$(value));
        result = this._ops.writeByte$1(value);
        this._resourceInfo.addWrite$1(1);
        return result;
      }, "call$1", "get$writeByteSync", 2, 0, 16, 1, [], "writeByteSync"],
      writeFrom$3: [function(buffer, start, end) {
        var t1, e, t2, t3, result, exception, request;
        t1 = {};
        t1.end = end;
        t2 = J.getInterceptor(buffer);
        if (!!t2.$isList)
          if (!(start != null && (typeof start !== "number" || Math.floor(start) !== start)))
            t3 = end != null && (typeof end !== "number" || Math.floor(end) !== end);
          else
            t3 = true;
        else
          t3 = true;
        if (t3)
          throw H.wrapException(P.ArgumentError$("Invalid arguments to writeFrom"));
        end = P.RangeError_checkValidRange(start, end, t2.get$length(buffer), null, null, null);
        t1.end = end;
        if (J.$eq$(end, start)) {
          t1 = new P._Future(0, $.Zone__current, null, [null]);
          t1._asyncComplete$1(this);
          return t1;
        }
        t1.result = null;
        try {
          result = P._ensureFastAndSerializableByteData(buffer, start, end);
          t1.result = result;
          t2 = result;
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          return P.Future_Future$error(e, null, null);
        }
        request = new Array(4);
        request.fixed$length = Array;
        request[0] = null;
        request[1] = t2.buffer;
        t2 = t2.start;
        request[2] = t2;
        request[3] = J.$sub$n(end, J.$sub$n(start, t2));
        return this._dispatch$2(22, request).then$1(new P._RandomAccessFile_writeFrom_closure(t1, this, start));
      }, function(buffer) {
        return this.writeFrom$3(buffer, 0, null);
      }, "writeFrom$1", function(buffer, start) {
        return this.writeFrom$3(buffer, start, null);
      }, "writeFrom$2", "call$3", "call$1", "call$2", "get$writeFrom", 2, 4, 1619, 7, 0, 41, [], 3, [], 5, [], "writeFrom"],
      writeFromSync$3: [function(buffer, start, end) {
        var t1, t2, bufferAndStart, t3, t4, t5;
        this._checkAvailable$0();
        t1 = J.getInterceptor(buffer);
        if (!!t1.$isList)
          if (!(start != null && (typeof start !== "number" || Math.floor(start) !== start)))
            t2 = end != null && (typeof end !== "number" || Math.floor(end) !== end);
          else
            t2 = true;
        else
          t2 = true;
        if (t2)
          throw H.wrapException(P.ArgumentError$("Invalid arguments to writeFromSync"));
        end = P.RangeError_checkValidRange(start, end, t1.get$length(buffer), null, null, null);
        t1 = J.getInterceptor(end);
        if (t1.$eq(end, start))
          return;
        bufferAndStart = P._ensureFastAndSerializableByteData(buffer, start, end);
        t2 = this._ops;
        t3 = bufferAndStart.buffer;
        t4 = bufferAndStart.start;
        t5 = J.getInterceptor$n(start);
        t2.writeFrom$3(t3, t4, t1.$sub(end, t5.$sub(start, t4)));
        this._resourceInfo.addWrite$1(t1.$sub(end, t5.$sub(start, bufferAndStart.start)));
      }, function(buffer) {
        return this.writeFromSync$3(buffer, 0, null);
      }, "writeFromSync$1", function(buffer, start) {
        return this.writeFromSync$3(buffer, start, null);
      }, "writeFromSync$2", "call$3", "call$1", "call$2", "get$writeFromSync", 2, 4, 1621, 7, 0, 41, [], 3, [], 5, [], "writeFromSync"],
      writeString$2$encoding: [function(string, encoding) {
        var data;
        if (!(encoding instanceof P.Encoding))
          throw H.wrapException(P.ArgumentError$(encoding));
        data = encoding.encode$1(string);
        return this.writeFrom$3(data, 0, J.get$length$asx(data));
      }, function(string) {
        return this.writeString$2$encoding(string, C.Utf8Codec_false);
      }, "writeString$1", "call$2$encoding", "call$1", "get$writeString", 2, 3, 1629, 73, 39, [], 48, [], "writeString"],
      writeStringSync$2$encoding: [function(string, encoding) {
        var data;
        if (!(encoding instanceof P.Encoding))
          throw H.wrapException(P.ArgumentError$(encoding));
        data = encoding.encode$1(string);
        this.writeFromSync$3(data, 0, J.get$length$asx(data));
      }, function(string) {
        return this.writeStringSync$2$encoding(string, C.Utf8Codec_false);
      }, "writeStringSync$1", "call$2$encoding", "call$1", "get$writeStringSync", 2, 3, 1661, 73, 39, [], 48, [], "writeStringSync"],
      position$0: [function() {
        return this._dispatch$2(8, [null]).then$1(new P._RandomAccessFile_position_closure(this));
      }, "call$0", "get$position", 0, 0, 160, "position"],
      positionSync$0: [function() {
        this._checkAvailable$0();
        var result = this._ops.position$0();
        return result;
      }, "call$0", "get$positionSync", 0, 0, 11, "positionSync"],
      setPosition$1: [function(position) {
        return this._dispatch$2(9, [null, position]).then$1(new P._RandomAccessFile_setPosition_closure(this));
      }, "call$1", "get$setPosition", 2, 0, 265, 253, [], "setPosition"],
      setPositionSync$1: [function(position) {
        this._checkAvailable$0();
        this._ops.setPosition$1(position);
      }, "call$1", "get$setPositionSync", 2, 0, 17, 253, [], "setPositionSync"],
      truncate$1: [function(_, $length) {
        return this._dispatch$2(10, [null, $length]).then$1(new P._RandomAccessFile_truncate_closure(this));
      }, "call$1", "get$truncate", 2, 0, 265, 15, [], "truncate"],
      truncateSync$1: [function($length) {
        this._checkAvailable$0();
        J.truncate$1$n(this._ops, $length);
      }, "call$1", "get$truncateSync", 2, 0, 17, 15, [], "truncateSync"],
      length$0: [function(_) {
        return this._dispatch$2(11, [null]).then$1(new P._RandomAccessFile_length_closure(this));
      }, "call$0", "get$length", 0, 0, 160, "length"],
      lengthSync$0: [function() {
        this._checkAvailable$0();
        var result = J.length$0$asx(this._ops);
        if (result instanceof P.OSError)
          throw H.wrapException(new P.FileSystemException("length failed", this.path, result));
        return result;
      }, "call$0", "get$lengthSync", 0, 0, 11, "lengthSync"],
      flush$0: [function() {
        return this._dispatch$2(17, [null]).then$1(new P._RandomAccessFile_flush_closure(this));
      }, "call$0", "get$flush", 0, 0, 335, "flush"],
      flushSync$0: [function() {
        this._checkAvailable$0();
        this._ops.flush$0();
      }, "call$0", "get$flushSync", 0, 0, 6, "flushSync"],
      _fileLockValue$1: [function(fl) {
        switch (fl) {
          case C.FileLock_0:
            return 1;
          case C.FileLock_1:
            return 2;
          case C.FileLock_2:
            return 3;
          case C.FileLock_3:
            return 4;
          default:
            return -1;
        }
      }, "call$1", "get$_fileLockValue", 2, 0, 539, 865, [], "_fileLockValue"],
      lock$3: [function(mode, start, end) {
        var t1;
        if (!(mode instanceof P.FileLock) || typeof start !== "number" || Math.floor(start) !== start || typeof end !== "number" || Math.floor(end) !== end)
          throw H.wrapException(P.ArgumentError$(null));
        t1 = J.getInterceptor$n(start);
        if (!t1.$lt(start, 0))
          if (!(end < -1))
            t1 = end !== -1 && t1.$ge(start, end);
          else
            t1 = true;
        else
          t1 = true;
        if (t1)
          throw H.wrapException(P.ArgumentError$(null));
        return this._dispatch$2(30, [null, this._fileLockValue$1(mode), start, end]).then$1(new P._RandomAccessFile_lock_closure(this));
      }, function(mode) {
        return this.lock$3(mode, 0, -1);
      }, "lock$1", function(mode, start) {
        return this.lock$3(mode, start, -1);
      }, "lock$2", function() {
        return this.lock$3(C.FileLock_1, 0, -1);
      }, "lock$0", "call$3", "call$1", "call$2", "call$0", "get$lock", 0, 6, 555, 552, 7, 204, 70, [], 3, [], 5, [], "lock"],
      unlock$2: [function(start, end) {
        if (typeof start !== "number" || Math.floor(start) !== start || typeof end !== "number" || Math.floor(end) !== end)
          throw H.wrapException(P.ArgumentError$(null));
        if (J.$eq$(start, end))
          throw H.wrapException(P.ArgumentError$(null));
        return this._dispatch$2(30, [null, 0, start, end]).then$1(new P._RandomAccessFile_unlock_closure(this));
      }, function(start) {
        return this.unlock$2(start, -1);
      }, "unlock$1", function() {
        return this.unlock$2(0, -1);
      }, "unlock$0", "call$2", "call$1", "call$0", "get$unlock", 0, 4, 559, 7, 204, 3, [], 5, [], "unlock"],
      lockSync$3: [function(mode, start, end) {
        var t1, lock;
        this._checkAvailable$0();
        if (!(mode instanceof P.FileLock) || typeof start !== "number" || Math.floor(start) !== start || typeof end !== "number" || Math.floor(end) !== end)
          throw H.wrapException(P.ArgumentError$(null));
        t1 = J.getInterceptor$n(start);
        if (!t1.$lt(start, 0))
          if (!(end < -1))
            t1 = end !== -1 && t1.$ge(start, end);
          else
            t1 = true;
        else
          t1 = true;
        if (t1)
          throw H.wrapException(P.ArgumentError$(null));
        lock = this._fileLockValue$1(mode);
        this._ops.lock$3(lock, start, end);
      }, function(mode) {
        return this.lockSync$3(mode, 0, -1);
      }, "lockSync$1", function(mode, start) {
        return this.lockSync$3(mode, start, -1);
      }, "lockSync$2", function() {
        return this.lockSync$3(C.FileLock_1, 0, -1);
      }, "lockSync$0", "call$3", "call$1", "call$2", "call$0", "get$lockSync", 0, 6, 563, 552, 7, 204, 70, [], 3, [], 5, [], "lockSync"],
      unlockSync$2: [function(start, end) {
        this._checkAvailable$0();
        if (typeof start !== "number" || Math.floor(start) !== start || typeof end !== "number" || Math.floor(end) !== end)
          throw H.wrapException(P.ArgumentError$(null));
        if (J.$eq$(start, end))
          throw H.wrapException(P.ArgumentError$(null));
        this._ops.lock$3(0, start, end);
      }, function(start) {
        return this.unlockSync$2(start, -1);
      }, "unlockSync$1", function() {
        return this.unlockSync$2(0, -1);
      }, "unlockSync$0", "call$2", "call$1", "call$0", "get$unlockSync", 0, 4, 573, 7, 204, 3, [], 5, [], "unlockSync"],
      _pointer$0: [function() {
        return this._ops.getPointer$0();
      }, "call$0", "get$_pointer", 0, 0, 11, "_pointer"],
      _dispatch$3$markClosed: [function(request, data, markClosed) {
        if (this.closed === true)
          return P.Future_Future$error(new P.FileSystemException("File closed", this.path, null), null, null);
        if (this._asyncDispatched === true)
          return P.Future_Future$error(new P.FileSystemException("An async operation is currently pending", this.path, null), null, null);
        if (markClosed === true)
          this.closed = true;
        this._asyncDispatched = true;
        J.$indexSet$ax(data, 0, this._pointer$0());
      }, function(request, data) {
        return this._dispatch$3$markClosed(request, data, false);
      }, "_dispatch$2", "call$3$markClosed", "call$2", "get$_dispatch", 4, 3, 578, 4, 54, [], 21, [], 867, [], "_dispatch"],
      _checkAvailable$0: [function() {
        if (this._asyncDispatched === true)
          throw H.wrapException(new P.FileSystemException("An async operation is currently pending", this.path, null));
        if (this.closed === true)
          throw H.wrapException(new P.FileSystemException("File closed", this.path, null));
      }, "call$0", "get$_checkAvailable", 0, 0, 6, "_checkAvailable"],
      _RandomAccessFile$2: function(pointer, path) {
        this._ops = P._RandomAccessFileOps__RandomAccessFileOps(pointer);
      },
      static: {
        "^": "_RandomAccessFile__connectedResourceHandler@-8,_RandomAccessFile_LOCK_UNLOCK<-0,_RandomAccessFile_LOCK_SHARED<-0,_RandomAccessFile_LOCK_EXCLUSIVE<-0,_RandomAccessFile_LOCK_BLOCKING_SHARED<-0,_RandomAccessFile_LOCK_BLOCKING_EXCLUSIVE<-0",
        _RandomAccessFile$: [function(pointer, path) {
          var t1 = new P._RandomAccessFile(path, false, null, null, null, false);
          t1._RandomAccessFile$2(pointer, path);
          return t1;
        }, null, null, 4, 0, 148, 361, [], 10, [], "new _RandomAccessFile"]
      }
    },
    "+_RandomAccessFile": [1, 488],
    _RandomAccessFile_close_closure: {
      "^": "Closure:3;$this",
      call$1: [function(result) {
        var t1, t2;
        t1 = J.getInterceptor(result);
        t2 = this.$this;
        if (!t1.$eq(result, -1)) {
          t1 = t2.closed === true || t1.$eq(result, 0);
          t2.closed = t1;
          if (t1) {
            t1 = t2._resourceInfo;
            J.remove$1$ax($.$get$_FileResourceInfo_openFiles(), t1.get$id());
          }
          return t2;
        } else
          throw H.wrapException(new P.FileSystemException("Cannot close file", t2.path, null));
      }, null, null, 2, 0, 3, 93, [], "call"]
    },
    "+ _RandomAccessFile_close_closure": [2],
    _RandomAccessFile_readByte_closure: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        var t1 = J.getInterceptor(response);
        if (!!t1.$isList && !J.$eq$(t1.$index(response, 0), 0))
          throw H.wrapException(P._exceptionFromResponse(response, "readByte failed", this.$this.path));
        this.$this._resourceInfo.addRead$1(1);
        return response;
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _RandomAccessFile_readByte_closure": [2],
    _RandomAccessFile_read_closure: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        var t1 = J.getInterceptor(response);
        if (!!t1.$isList && !J.$eq$(t1.$index(response, 0), 0))
          throw H.wrapException(P._exceptionFromResponse(response, "read failed", this.$this.path));
        this.$this._resourceInfo.addRead$1(J.get$length$asx(t1.$index(response, 1)));
        return t1.$index(response, 1);
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _RandomAccessFile_read_closure": [2],
    _RandomAccessFile_readInto_closure: {
      "^": "Closure:3;$this,buffer,start",
      call$1: [function(response) {
        var t1, read, data;
        t1 = J.getInterceptor(response);
        if (!!t1.$isList && !J.$eq$(t1.$index(response, 0), 0))
          throw H.wrapException(P._exceptionFromResponse(response, "readInto failed", this.$this.path));
        read = t1.$index(response, 1);
        data = t1.$index(response, 2);
        t1 = this.start;
        J.setRange$3$ax(this.buffer, t1, J.$add$ns(t1, read), data);
        this.$this._resourceInfo.addRead$1(read);
        return read;
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _RandomAccessFile_readInto_closure": [2],
    _RandomAccessFile_writeByte_closure: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        var t1 = J.getInterceptor(response);
        if (!!t1.$isList && !J.$eq$(t1.$index(response, 0), 0))
          throw H.wrapException(P._exceptionFromResponse(response, "writeByte failed", this.$this.path));
        t1 = this.$this;
        t1._resourceInfo.addWrite$1(1);
        return t1;
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _RandomAccessFile_writeByte_closure": [2],
    _RandomAccessFile_writeFrom_closure: {
      "^": "Closure:3;_box_0,$this,start",
      call$1: [function(response) {
        var t1, t2;
        t1 = J.getInterceptor(response);
        if (!!t1.$isList && !J.$eq$(t1.$index(response, 0), 0))
          throw H.wrapException(P._exceptionFromResponse(response, "writeFrom failed", this.$this.path));
        t1 = this.$this;
        t2 = this._box_0;
        t1._resourceInfo.addWrite$1(J.$sub$n(t2.end, J.$sub$n(this.start, t2.result.start)));
        return t1;
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _RandomAccessFile_writeFrom_closure": [2],
    _RandomAccessFile_position_closure: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        var t1 = J.getInterceptor(response);
        if (!!t1.$isList && !J.$eq$(t1.$index(response, 0), 0))
          throw H.wrapException(P._exceptionFromResponse(response, "position failed", this.$this.path));
        return response;
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _RandomAccessFile_position_closure": [2],
    _RandomAccessFile_setPosition_closure: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        var t1 = J.getInterceptor(response);
        if (!!t1.$isList && !J.$eq$(t1.$index(response, 0), 0))
          throw H.wrapException(P._exceptionFromResponse(response, "setPosition failed", this.$this.path));
        return this.$this;
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _RandomAccessFile_setPosition_closure": [2],
    _RandomAccessFile_truncate_closure: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        var t1 = J.getInterceptor(response);
        if (!!t1.$isList && !J.$eq$(t1.$index(response, 0), 0))
          throw H.wrapException(P._exceptionFromResponse(response, "truncate failed", this.$this.path));
        return this.$this;
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _RandomAccessFile_truncate_closure": [2],
    _RandomAccessFile_length_closure: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        var t1 = J.getInterceptor(response);
        if (!!t1.$isList && !J.$eq$(t1.$index(response, 0), 0))
          throw H.wrapException(P._exceptionFromResponse(response, "length failed", this.$this.path));
        return response;
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _RandomAccessFile_length_closure": [2],
    _RandomAccessFile_flush_closure: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        var t1 = J.getInterceptor(response);
        if (!!t1.$isList && !J.$eq$(t1.$index(response, 0), 0))
          throw H.wrapException(P._exceptionFromResponse(response, "flush failed", this.$this.path));
        return this.$this;
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _RandomAccessFile_flush_closure": [2],
    _RandomAccessFile_lock_closure: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        var t1 = J.getInterceptor(response);
        if (!!t1.$isList && !J.$eq$(t1.$index(response, 0), 0))
          throw H.wrapException(P._exceptionFromResponse(response, "lock failed", this.$this.path));
        return this.$this;
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _RandomAccessFile_lock_closure": [2],
    _RandomAccessFile_unlock_closure: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        var t1 = J.getInterceptor(response);
        if (!!t1.$isList && !J.$eq$(t1.$index(response, 0), 0))
          throw H.wrapException(P._exceptionFromResponse(response, "unlock failed", this.$this.path));
        return this.$this;
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _RandomAccessFile_unlock_closure": [2],
    FileSystemEntityType: {
      "^": "Object;_io$_type<-0",
      toString$0: [function(_) {
        var t1 = this._io$_type;
        if (t1 >>> 0 !== t1 || t1 >= 4)
          return H.ioore(C.List_FILE_DIRECTORY_LINK_NOT_FOUND, t1);
        return C.List_FILE_DIRECTORY_LINK_NOT_FOUND[t1];
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        "^": "FileSystemEntityType_FILE<-10,FileSystemEntityType_DIRECTORY<-10,FileSystemEntityType_LINK<-10,FileSystemEntityType_NOT_FOUND<-10,FileSystemEntityType__typeList<-10",
        FileSystemEntityType$_internal: [function(_type) {
          return new P.FileSystemEntityType(_type);
        }, null, null, 2, 0, 22, 722, [], "new FileSystemEntityType$_internal"],
        FileSystemEntityType__lookup: [function(type) {
          if (type >>> 0 !== type || type >= 4)
            return H.ioore(C.List_CpJ, type);
          return C.List_CpJ[type];
        }, "call$1", "io_FileSystemEntityType__lookup$closure", 2, 0, 831, 65, [], "_io$_lookup"]
      }
    },
    "+FileSystemEntityType": [1],
    FileStat: {
      "^": "Object;changed<-75,modified<-75,accessed<-75,type<-1506,mode<-0,size<-0",
      toString$0: [function(_) {
        var t1, permissions, result, t2;
        t1 = "FileStat: type " + H.S(this.type) + "\r\n          changed " + H.S(this.changed) + "\r\n          modified " + H.S(this.modified) + "\r\n          accessed " + H.S(this.accessed) + "\r\n          mode ";
        permissions = J.$and$n(this.mode, 4095);
        result = [];
        t2 = J.getInterceptor$n(permissions);
        if (t2.$and(permissions, 2048) !== 0)
          result.push("(suid) ");
        if (t2.$and(permissions, 1024) !== 0)
          result.push("(guid) ");
        if (t2.$and(permissions, 512) !== 0)
          result.push("(sticky) ");
        result.push(C.List_NAl[t2.$shr(permissions, 6) & 7]);
        result.push(C.List_NAl[t2.$shr(permissions, 3) & 7]);
        t2 = t2.$and(permissions, 7);
        if (t2 >>> 0 !== t2 || t2 >= 8)
          return H.ioore(C.List_NAl, t2);
        result.push(C.List_NAl[t2]);
        return t1 + C.JSArray_methods.join$0(result) + "\r\n          size " + H.S(this.size);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      modeString$0: [function() {
        var permissions, result, t1;
        permissions = J.$and$n(this.mode, 4095);
        result = [];
        t1 = J.getInterceptor$n(permissions);
        if (t1.$and(permissions, 2048) !== 0)
          result.push("(suid) ");
        if (t1.$and(permissions, 1024) !== 0)
          result.push("(guid) ");
        if (t1.$and(permissions, 512) !== 0)
          result.push("(sticky) ");
        result.push(C.List_NAl[t1.$shr(permissions, 6) & 7]);
        result.push(C.List_NAl[t1.$shr(permissions, 3) & 7]);
        t1 = t1.$and(permissions, 7);
        if (t1 >>> 0 !== t1 || t1 >= 8)
          return H.ioore(C.List_NAl, t1);
        result.push(C.List_NAl[t1]);
        return C.JSArray_methods.join$0(result);
      }, "call$0", "get$modeString", 0, 0, 7, "modeString"],
      static: {
        "^": "FileStat__TYPE<-10,FileStat__CHANGED_TIME<-10,FileStat__MODIFIED_TIME<-10,FileStat__ACCESSED_TIME<-10,FileStat__MODE<-10,FileStat__SIZE<-10,FileStat__notFound<-10",
        FileStat$_internal: [function(changed, modified, accessed, type, mode, size) {
          return new P.FileStat(changed, modified, accessed, type, mode, size);
        }, null, null, 12, 0, 832, 723, [], 724, [], 725, [], 65, [], 70, [], 284, [], "new FileStat$_internal"],
        FileStat$_internalNotFound: [function() {
          return new P.FileStat(null, null, null, C.FileSystemEntityType_3, 0, -1);
        }, null, null, 0, 0, 4, "new FileStat$_internalNotFound"],
        FileStat__statSync: [function(path) {
          throw H.wrapException(new P.UnsupportedError("FileStat.stat"));
        }, "call$1", "io_FileStat__statSync$closure", 2, 0, 13, 10, [], "_statSync"],
        FileStat_statSync: [function(path) {
          P.FileStat__statSync($.$get$Platform_isWindows() ? P.FileSystemEntity__trimTrailingPathSeparators(path) : path);
        }, "call$1", "io_FileStat_statSync$closure", 2, 0, 833, 10, [], "statSync"],
        FileStat_stat: [function(path) {
          return P._IOService__dispatch(29, [$.$get$Platform_isWindows() ? P.FileSystemEntity__trimTrailingPathSeparators(path) : path]).then$1(new P.FileStat_stat_closure());
        }, "call$1", "io_FileStat_stat$closure", 2, 0, 834, 10, [], "stat"]
      }
    },
    "+FileStat": [1],
    FileStat_stat_closure: {
      "^": "Closure:3;",
      call$1: [function(response) {
        response.$index(0, 0);
        return C.FileStat_8qt;
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ FileStat_stat_closure": [2],
    FileSystemEntity: {
      "^": "Object;",
      get$uri: [function() {
        return P._Uri__Uri$file(this.get$path(), null);
      }, null, null, 1, 0, 43, "uri"],
      resolveSymbolicLinks$0: [function() {
        return P._IOService__dispatch(6, [this.get$path()]).then$1(new P.FileSystemEntity_resolveSymbolicLinks_closure(this));
      }, "call$0", "get$resolveSymbolicLinks", 0, 0, 338, "resolveSymbolicLinks"],
      resolveSymbolicLinksSync$0: [function() {
        P.FileSystemEntity__resolveSymbolicLinks(this.get$path());
      }, "call$0", "get$resolveSymbolicLinksSync", 0, 0, 7, "resolveSymbolicLinksSync"],
      stat$0: [function() {
        return P.FileStat_stat(this.get$path());
      }, "call$0", "get$stat", 0, 0, 594, "stat"],
      statSync$0: [function() {
        return P.FileStat_statSync(this.get$path());
      }, "call$0", "get$statSync", 0, 0, 596, "statSync"],
      delete$1$recursive: [function(recursive) {
        return this._delete$1$recursive(recursive);
      }, function() {
        return this.delete$1$recursive(false);
      }, "delete$0", "call$1$recursive", "call$0", "get$$delete", 0, 3, 597, 4, 51, [], "delete"],
      deleteSync$1$recursive: [function(recursive) {
        return this._deleteSync$1$recursive(recursive);
      }, function() {
        return this.deleteSync$1$recursive(false);
      }, "deleteSync$0", "call$1$recursive", "call$0", "get$deleteSync", 0, 3, 111, 4, 51, [], "deleteSync"],
      watch$2$events$recursive: [function(events, recursive) {
        return P._FileSystemWatcher__watch(P.FileSystemEntity__trimTrailingPathSeparators(this.get$path()), events, recursive);
      }, function() {
        return this.watch$2$events$recursive(15, false);
      }, "watch$0", function(recursive) {
        return this.watch$2$events$recursive(15, recursive);
      }, "watch$1$recursive", "call$2$events$recursive", "call$0", "call$1$recursive", "get$watch", 0, 5, 598, 140, 4, 505, [], 51, [], "watch"],
      get$isAbsolute: [function() {
        if ($.$get$Platform_isWindows())
          return J.startsWith$1$s(this.get$path(), $.$get$FileSystemEntity__absoluteWindowsPathPattern());
        else
          return J.startsWith$1$s(this.get$path(), "/");
      }, null, null, 1, 0, 5, "isAbsolute"],
      get$_absolutePath: [function() {
        var current, t1;
        if (this.get$isAbsolute())
          return this.get$path();
        current = P._Directory_current().path;
        t1 = J.getInterceptor$s(current);
        if (!t1.endsWith$1(current, "/"))
          t1 = $.$get$Platform_isWindows() && t1.endsWith$1(current, "\\");
        else
          t1 = true;
        if (t1)
          return H.S(current) + H.S(this.get$path());
        else
          return H.S(current) + H.S($.$get$Platform__pathSeparator()) + H.S(this.get$path());
      }, null, null, 1, 0, 7, "_absolutePath"],
      get$parent: [function() {
        return P._Directory$(P.FileSystemEntity_parentOf(this.get$path()));
      }, null, null, 1, 0, 110, "parent"],
      static: {
        "^": "FileSystemEntity__absoluteWindowsPathPattern<-260,FileSystemEntity__parentRegExp<-260",
        FileSystemEntity$: [function() {
          return new P.FileSystemEntity();
        }, null, null, 0, 0, 835, "new FileSystemEntity"],
        FileSystemEntity_identical: [function(path1, path2) {
          return P._IOService__dispatch(28, [path1, path2]).then$1(new P.FileSystemEntity_identical_closure(path1, path2));
        }, "call$2", "io_FileSystemEntity_identical$closure", 4, 0, 836, 373, [], 389, [], "identical"],
        FileSystemEntity_identicalSync: [function(path1, path2) {
          P.FileSystemEntity__identical(path1, path2);
        }, "call$2", "io_FileSystemEntity_identicalSync$closure", 4, 0, 412, 373, [], 389, [], "identicalSync"],
        FileSystemEntity_isWatchSupported: [function() {
          return P._FileSystemWatcher_isSupported();
        }, null, null, 1, 0, 5, "isWatchSupported"],
        FileSystemEntity_type: [function(path, followLinks) {
          return P.FileSystemEntity__getTypeAsync(path, followLinks).then$1(P.io_FileSystemEntityType__lookup$closure());
        }, function(path) {
          return P.FileSystemEntity_type(path, true);
        }, "call$2$followLinks", "call$1", "io_FileSystemEntity_type$closure", 2, 3, 837, 25, 10, [], 109, [], "type"],
        FileSystemEntity_typeSync: [function(path, followLinks) {
          P.FileSystemEntity__getTypeSync(path, followLinks);
          return;
        }, function(path) {
          return P.FileSystemEntity_typeSync(path, true);
        }, "call$2$followLinks", "call$1", "io_FileSystemEntity_typeSync$closure", 2, 3, 838, 25, 10, [], 109, [], "typeSync"],
        FileSystemEntity_isLink: [function(path) {
          return P.FileSystemEntity__getTypeAsync(path, false).then$1(new P.FileSystemEntity_isLink_closure());
        }, "call$1", "io_FileSystemEntity_isLink$closure", 2, 0, 242, 10, [], "isLink"],
        FileSystemEntity_isFile: [function(path) {
          return P.FileSystemEntity__getTypeAsync(path, true).then$1(new P.FileSystemEntity_isFile_closure());
        }, "call$1", "io_FileSystemEntity_isFile$closure", 2, 0, 242, 10, [], "isFile"],
        FileSystemEntity_isDirectory: [function(path) {
          return P.FileSystemEntity__getTypeAsync(path, true).then$1(new P.FileSystemEntity_isDirectory_closure());
        }, "call$1", "io_FileSystemEntity_isDirectory$closure", 2, 0, 242, 10, [], "isDirectory"],
        FileSystemEntity_isLinkSync: [function(path) {
          P.FileSystemEntity__getTypeSync(path, false);
          return false;
        }, "call$1", "io_FileSystemEntity_isLinkSync$closure", 2, 0, 30, 10, [], "isLinkSync"],
        FileSystemEntity_isFileSync: [function(path) {
          P.FileSystemEntity__getTypeSync(path, true);
          return false;
        }, "call$1", "io_FileSystemEntity_isFileSync$closure", 2, 0, 30, 10, [], "isFileSync"],
        FileSystemEntity_isDirectorySync: [function(path) {
          P.FileSystemEntity__getTypeSync(path, true);
          return false;
        }, "call$1", "io_FileSystemEntity_isDirectorySync$closure", 2, 0, 30, 10, [], "isDirectorySync"],
        FileSystemEntity__getType: [function(path, followLinks) {
          throw H.wrapException(new P.UnsupportedError("FileSystemEntity._getType"));
        }, "call$2", "io_FileSystemEntity__getType$closure", 4, 0, 187, 10, [], 109, [], "_getType"],
        FileSystemEntity__identical: [function(path1, path2) {
          throw H.wrapException(new P.UnsupportedError("FileSystemEntity._identical"));
        }, "call$2", "io_FileSystemEntity__identical$closure", 4, 0, 40, 373, [], 389, [], "_identical"],
        FileSystemEntity__resolveSymbolicLinks: [function(path) {
          throw H.wrapException(new P.UnsupportedError("FileSystemEntity._resolveSymbolicLinks"));
        }, "call$1", "io_FileSystemEntity__resolveSymbolicLinks$closure", 2, 0, 13, 10, [], "_resolveSymbolicLinks"],
        FileSystemEntity_parentOf: [function(path) {
          var t1, rootEnd, pos, t2;
          if ($.$get$Platform_isWindows()) {
            t1 = J.getInterceptor$s(path);
            if (t1.startsWith$1(path, $.$get$FileSystemEntity__absoluteWindowsPathPattern())) {
              rootEnd = t1.indexOf$2(path, P.RegExp_RegExp("[/\\\\]", true, false), 2);
              if (J.$eq$(rootEnd, -1))
                return path;
            } else
              rootEnd = t1.startsWith$1(path, "\\") || t1.startsWith$1(path, "/") ? 0 : -1;
          } else
            rootEnd = J.startsWith$1$s(path, "/") ? 0 : -1;
          t1 = J.getInterceptor$asx(path);
          pos = t1.lastIndexOf$1(path, $.$get$FileSystemEntity__parentRegExp());
          t2 = J.getInterceptor$n(pos);
          if (t2.$gt(pos, rootEnd))
            return t1.substring$2(path, 0, t2.$add(pos, 1));
          else {
            t2 = J.getInterceptor$n(rootEnd);
            if (t2.$gt(rootEnd, -1))
              return t1.substring$2(path, 0, t2.$add(rootEnd, 1));
            else
              return ".";
          }
        }, "call$1", "io_FileSystemEntity_parentOf$closure", 2, 0, 28, 10, [], "parentOf"],
        FileSystemEntity__getTypeSync: [function(path, followLinks) {
          P.FileSystemEntity__getType(path, followLinks);
        }, "call$2", "io_FileSystemEntity__getTypeSync$closure", 4, 0, 840, 10, [], 109, [], "_getTypeSync"],
        FileSystemEntity__getTypeAsync: [function(path, followLinks) {
          return P._IOService__dispatch(27, [path, followLinks]).then$1(new P.FileSystemEntity__getTypeAsync_closure(path));
        }, "call$2", "io_FileSystemEntity__getTypeAsync$closure", 4, 0, 841, 10, [], 109, [], "_getTypeAsync"],
        FileSystemEntity__throwIfError: [function(result, msg, path) {
          var t1 = J.getInterceptor(result);
          if (!!t1.$isOSError)
            throw H.wrapException(new P.FileSystemException(msg, path, result));
          else if (!!t1.$isArgumentError)
            throw H.wrapException(result);
        }, function(result, msg) {
          return P.FileSystemEntity__throwIfError(result, msg, null);
        }, "call$3", "call$2", "io_FileSystemEntity__throwIfError$closure", 4, 2, 419, 0, 93, [], 92, [], 10, [], "_throwIfError"],
        FileSystemEntity__trimTrailingPathSeparators: [function(path) {
          var t1, t2;
          if (typeof path !== "string")
            return path;
          if ($.$get$Platform_isWindows())
            while (true) {
              t1 = path.length;
              if (t1 > 1)
                t2 = C.JSString_methods.endsWith$1(path, $.$get$Platform__pathSeparator()) || C.JSString_methods.endsWith$1(path, "/");
              else
                t2 = false;
              if (!t2)
                break;
              path = C.JSString_methods.substring$2(path, 0, t1 - 1);
            }
          else
            while (true) {
              t1 = path.length;
              if (!(t1 > 1 && C.JSString_methods.endsWith$1(path, $.$get$Platform__pathSeparator())))
                break;
              path = C.JSString_methods.substring$2(path, 0, t1 - 1);
            }
          return path;
        }, "call$1", "io_FileSystemEntity__trimTrailingPathSeparators$closure", 2, 0, 28, 10, [], "_trimTrailingPathSeparators"],
        FileSystemEntity__ensureTrailingPathSeparators: [function(path) {
          var t1;
          if (typeof path !== "string")
            return path;
          if (C.JSString_methods.get$isEmpty(path))
            path = ".";
          if ($.$get$Platform_isWindows())
            while (true) {
              t1 = $.$get$Platform__pathSeparator();
              if (!(!C.JSString_methods.endsWith$1(path, t1) && !C.JSString_methods.endsWith$1(path, "/")))
                break;
              path += H.S(t1);
            }
          else
            for (; t1 = $.$get$Platform__pathSeparator(), !C.JSString_methods.endsWith$1(path, t1);)
              path += H.S(t1);
          return path;
        }, "call$1", "io_FileSystemEntity__ensureTrailingPathSeparators$closure", 2, 0, 28, 10, [], "_ensureTrailingPathSeparators"]
      }
    },
    "+FileSystemEntity": [1],
    FileSystemEntity_resolveSymbolicLinks_closure: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        response.$index(0, 0);
        throw H.wrapException(P._exceptionFromResponse(response, "Cannot resolve symbolic links", this.$this.get$path()));
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ FileSystemEntity_resolveSymbolicLinks_closure": [2],
    FileSystemEntity_identical_closure: {
      "^": "Closure:3;path1,path2",
      call$1: [function(response) {
        response.$index(0, 0);
        throw H.wrapException(P._exceptionFromResponse(response, "Error in FileSystemEntity.identical(" + H.S(this.path1) + ", " + H.S(this.path2) + ")", ""));
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ FileSystemEntity_identical_closure": [2],
    FileSystemEntity_isLink_closure: {
      "^": "Closure:3;",
      call$1: [function(type) {
        return false;
      }, null, null, 2, 0, 3, 65, [], "call"]
    },
    "+ FileSystemEntity_isLink_closure": [2],
    FileSystemEntity_isFile_closure: {
      "^": "Closure:3;",
      call$1: [function(type) {
        return false;
      }, null, null, 2, 0, 3, 65, [], "call"]
    },
    "+ FileSystemEntity_isFile_closure": [2],
    FileSystemEntity_isDirectory_closure: {
      "^": "Closure:3;",
      call$1: [function(type) {
        return false;
      }, null, null, 2, 0, 3, 65, [], "call"]
    },
    "+ FileSystemEntity_isDirectory_closure": [2],
    FileSystemEntity__getTypeAsync_closure: {
      "^": "Closure:3;path",
      call$1: [function(response) {
        response.$index(0, 0);
        throw H.wrapException(P._exceptionFromResponse(response, "Error getting type", this.path));
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ FileSystemEntity__getTypeAsync_closure": [2],
    FileSystemEvent: {
      "^": "Object;type<-0,path<-9,isDirectory<-8",
      static: {
        "^": "FileSystemEvent_CREATE<-0,FileSystemEvent_MODIFY<-0,FileSystemEvent_DELETE<-0,FileSystemEvent_MOVE<-0,FileSystemEvent_ALL<-0,FileSystemEvent__MODIFY_ATTRIBUTES<-0,FileSystemEvent__DELETE_SELF<-0,FileSystemEvent__IS_DIR<-0",
        FileSystemEvent$_: [function(type, path, isDirectory) {
          return new P.FileSystemEvent(type, path, isDirectory);
        }, null, null, 6, 0, 843, 65, [], 10, [], 194, [], "new FileSystemEvent$_"]
      }
    },
    "+FileSystemEvent": [1],
    FileSystemCreateEvent: {
      "^": "FileSystemEvent;type-0,path-9,isDirectory-8",
      toString$0: [function(_) {
        return "FileSystemCreateEvent('" + H.S(this.path) + "')";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        FileSystemCreateEvent$_: [function(path, isDirectory) {
          return new P.FileSystemCreateEvent(1, path, isDirectory);
        }, null, null, 4, 0, 12, 10, [], 194, [], "new FileSystemCreateEvent$_"]
      }
    },
    "+FileSystemCreateEvent": [213],
    FileSystemModifyEvent: {
      "^": "FileSystemEvent;contentChanged<-8,type-0,path-9,isDirectory-8",
      toString$0: [function(_) {
        return "FileSystemModifyEvent('" + H.S(this.path) + "', contentChanged=" + H.S(this.contentChanged) + ")";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        FileSystemModifyEvent$_: [function(path, isDirectory, contentChanged) {
          return new P.FileSystemModifyEvent(contentChanged, 2, path, isDirectory);
        }, null, null, 6, 0, 844, 10, [], 194, [], 729, [], "new FileSystemModifyEvent$_"]
      }
    },
    "+FileSystemModifyEvent": [213],
    FileSystemDeleteEvent: {
      "^": "FileSystemEvent;type-0,path-9,isDirectory-8",
      toString$0: [function(_) {
        return "FileSystemDeleteEvent('" + H.S(this.path) + "')";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        FileSystemDeleteEvent$_: [function(path, isDirectory) {
          return new P.FileSystemDeleteEvent(4, path, isDirectory);
        }, null, null, 4, 0, 12, 10, [], 194, [], "new FileSystemDeleteEvent$_"]
      }
    },
    "+FileSystemDeleteEvent": [213],
    FileSystemMoveEvent: {
      "^": "FileSystemEvent;destination<-9,type-0,path-9,isDirectory-8",
      toString$0: [function(_) {
        var t1, t2;
        t1 = "FileSystemMoveEvent('" + H.S(this.path) + "'";
        t2 = this.destination;
        t1 = (t2 != null ? t1 + (", '" + H.S(t2) + "'") : t1) + ")";
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        FileSystemMoveEvent$_: [function(path, isDirectory, destination) {
          return new P.FileSystemMoveEvent(destination, 8, path, isDirectory);
        }, null, null, 6, 0, 845, 10, [], 194, [], 730, [], "new FileSystemMoveEvent$_"]
      }
    },
    "+FileSystemMoveEvent": [213],
    _FileSystemWatcher: {
      "^": "Object;",
      static: {
        _FileSystemWatcher$: [function() {
          return new P._FileSystemWatcher();
        }, null, null, 0, 0, 846, "new _FileSystemWatcher"],
        _FileSystemWatcher__watch: [function(path, events, recursive) {
          throw H.wrapException(new P.UnsupportedError("_FileSystemWatcher.watch"));
        }, "call$3", "io__FileSystemWatcher__watch$closure", 6, 0, 847, 10, [], 505, [], 51, [], "_watch"],
        _FileSystemWatcher_isSupported: [function() {
          throw H.wrapException(new P.UnsupportedError("_FileSystemWatcher.isSupported"));
        }, null, null, 1, 0, 5, "isSupported"]
      }
    },
    "+_FileSystemWatcher": [1],
    HttpStatus: {
      "^": "Object;",
      static: {
        "^": "HttpStatus_CONTINUE<-0,HttpStatus_SWITCHING_PROTOCOLS<-0,HttpStatus_OK<-0,HttpStatus_CREATED<-0,HttpStatus_ACCEPTED<-0,HttpStatus_NON_AUTHORITATIVE_INFORMATION<-0,HttpStatus_NO_CONTENT<-0,HttpStatus_RESET_CONTENT<-0,HttpStatus_PARTIAL_CONTENT<-0,HttpStatus_MULTIPLE_CHOICES<-0,HttpStatus_MOVED_PERMANENTLY<-0,HttpStatus_FOUND<-0,HttpStatus_MOVED_TEMPORARILY<-0,HttpStatus_SEE_OTHER<-0,HttpStatus_NOT_MODIFIED<-0,HttpStatus_USE_PROXY<-0,HttpStatus_TEMPORARY_REDIRECT<-0,HttpStatus_BAD_REQUEST<-0,HttpStatus_UNAUTHORIZED<-0,HttpStatus_PAYMENT_REQUIRED<-0,HttpStatus_FORBIDDEN<-0,HttpStatus_NOT_FOUND<-0,HttpStatus_METHOD_NOT_ALLOWED<-0,HttpStatus_NOT_ACCEPTABLE<-0,HttpStatus_PROXY_AUTHENTICATION_REQUIRED<-0,HttpStatus_REQUEST_TIMEOUT<-0,HttpStatus_CONFLICT<-0,HttpStatus_GONE<-0,HttpStatus_LENGTH_REQUIRED<-0,HttpStatus_PRECONDITION_FAILED<-0,HttpStatus_REQUEST_ENTITY_TOO_LARGE<-0,HttpStatus_REQUEST_URI_TOO_LONG<-0,HttpStatus_UNSUPPORTED_MEDIA_TYPE<-0,HttpStatus_REQUESTED_RANGE_NOT_SATISFIABLE<-0,HttpStatus_EXPECTATION_FAILED<-0,HttpStatus_INTERNAL_SERVER_ERROR<-0,HttpStatus_NOT_IMPLEMENTED<-0,HttpStatus_BAD_GATEWAY<-0,HttpStatus_SERVICE_UNAVAILABLE<-0,HttpStatus_GATEWAY_TIMEOUT<-0,HttpStatus_HTTP_VERSION_NOT_SUPPORTED<-0,HttpStatus_NETWORK_CONNECT_TIMEOUT_ERROR<-0",
        HttpStatus$: [function() {
          return new P.HttpStatus();
        }, null, null, 0, 0, 848, "new HttpStatus"]
      }
    },
    "+HttpStatus": [1],
    HttpServer: {
      "^": "Object;serverHeader@-9,autoCompress@-8,idleTimeout@-65",
      static: {
        HttpServer_bind: [function(address, port, backlog, shared, v6Only) {
          return P._HttpServer_bind(address, port, backlog, v6Only, shared);
        }, function(address, port) {
          return P.HttpServer_bind(address, port, 0, false, false);
        }, "call$5$backlog$shared$v6Only", "call$2", "io_HttpServer_bind$closure", 4, 7, 849, 7, 4, 4, 81, [], 26, [], 124, [], 121, [], 128, [], "bind"],
        HttpServer_bindSecure: [function(address, port, context, backlog, requestClientCertificate, shared, v6Only) {
          return P._HttpServer_bindSecure(address, port, context, backlog, v6Only, requestClientCertificate, shared);
        }, function(address, port, context) {
          return P.HttpServer_bindSecure(address, port, context, 0, false, false, false);
        }, "call$7$backlog$requestClientCertificate$shared$v6Only", "call$3", "io_HttpServer_bindSecure$closure", 6, 9, 850, 7, 4, 4, 4, 81, [], 26, [], 76, [], 124, [], 121, [], 97, [], 128, [], "bindSecure"],
        HttpServer_HttpServer$listenOn: [function(serverSocket) {
          return P._HttpServer$listenOn(serverSocket);
        }, null, null, 2, 0, 851, 423, [], "new HttpServer$listenOn"]
      }
    },
    "+HttpServer": [1, 1508],
    HttpConnectionsInfo: {
      "^": "Object;total@-0,active@-0,idle@-0,closing@-0",
      static: {
        HttpConnectionsInfo$: [function() {
          return new P.HttpConnectionsInfo(0, 0, 0, 0);
        }, null, null, 0, 0, 360, "new HttpConnectionsInfo"]
      }
    },
    "+HttpConnectionsInfo": [1],
    HttpHeaders: {
      "^": "Object;date@-75,expires@-75,ifModifiedSince@-75,host@-9,port@-0,contentType@-494,contentLength@-0,persistentConnection@-8,chunkedTransferEncoding@-8",
      static: {
        "^": "HttpHeaders_ACCEPT<-10,HttpHeaders_ACCEPT_CHARSET<-10,HttpHeaders_ACCEPT_ENCODING<-10,HttpHeaders_ACCEPT_LANGUAGE<-10,HttpHeaders_ACCEPT_RANGES<-10,HttpHeaders_AGE<-10,HttpHeaders_ALLOW<-10,HttpHeaders_AUTHORIZATION<-10,HttpHeaders_CACHE_CONTROL<-10,HttpHeaders_CONNECTION<-10,HttpHeaders_CONTENT_ENCODING<-10,HttpHeaders_CONTENT_LANGUAGE<-10,HttpHeaders_CONTENT_LENGTH<-10,HttpHeaders_CONTENT_LOCATION<-10,HttpHeaders_CONTENT_MD5<-10,HttpHeaders_CONTENT_RANGE<-10,HttpHeaders_CONTENT_TYPE<-10,HttpHeaders_DATE<-10,HttpHeaders_ETAG<-10,HttpHeaders_EXPECT<-10,HttpHeaders_EXPIRES<-10,HttpHeaders_FROM<-10,HttpHeaders_HOST<-10,HttpHeaders_IF_MATCH<-10,HttpHeaders_IF_MODIFIED_SINCE<-10,HttpHeaders_IF_NONE_MATCH<-10,HttpHeaders_IF_RANGE<-10,HttpHeaders_IF_UNMODIFIED_SINCE<-10,HttpHeaders_LAST_MODIFIED<-10,HttpHeaders_LOCATION<-10,HttpHeaders_MAX_FORWARDS<-10,HttpHeaders_PRAGMA<-10,HttpHeaders_PROXY_AUTHENTICATE<-10,HttpHeaders_PROXY_AUTHORIZATION<-10,HttpHeaders_RANGE<-10,HttpHeaders_REFERER<-10,HttpHeaders_RETRY_AFTER<-10,HttpHeaders_SERVER<-10,HttpHeaders_TE<-10,HttpHeaders_TRAILER<-10,HttpHeaders_TRANSFER_ENCODING<-10,HttpHeaders_UPGRADE<-10,HttpHeaders_USER_AGENT<-10,HttpHeaders_VARY<-10,HttpHeaders_VIA<-10,HttpHeaders_WARNING<-10,HttpHeaders_WWW_AUTHENTICATE<-10,HttpHeaders_COOKIE<-10,HttpHeaders_SET_COOKIE<-10,HttpHeaders_GENERAL_HEADERS<-10,HttpHeaders_ENTITY_HEADERS<-10,HttpHeaders_RESPONSE_HEADERS<-10,HttpHeaders_REQUEST_HEADERS<-10",
        HttpHeaders$: [function() {
          return new P.HttpHeaders(null, null, null, null, null, null, null, null, null);
        }, null, null, 0, 0, 308, "new HttpHeaders"]
      }
    },
    "+HttpHeaders": [1],
    HeaderValue: {
      "^": "Object;",
      value$1: function(arg0) {
        return this.get$value().call$1(arg0);
      },
      static: {
        HeaderValue_HeaderValue: [function(value, parameters) {
          return P._HeaderValue$(value, parameters);
        }, null, null, 0, 4, 853, 32, 0, 1, [], 117, [], "new HeaderValue"],
        HeaderValue_parse: [function(value, parameterSeparator, preserveBackslash, valueSeparator) {
          var result = P._HeaderValue$("", null);
          result._parse$4(value, parameterSeparator, valueSeparator, preserveBackslash);
          return result;
        }, function(value) {
          return P.HeaderValue_parse(value, ";", false, null);
        }, "call$4$parameterSeparator$preserveBackslash$valueSeparator", "call$1", "io_HeaderValue_parse$closure", 2, 7, 854, 480, 0, 4, 1, [], 402, [], 403, [], 404, [], "parse"]
      }
    },
    "+HeaderValue": [1],
    HttpSession: {
      "^": "Object;",
      $isMap: 1,
      $asMap: Isolate.functionThatReturnsNull,
      static: {
        HttpSession$: [function() {
          return new P.HttpSession();
        }, null, null, 0, 0, 344, "new HttpSession"]
      }
    },
    "+HttpSession": [1, 122],
    ContentType: {
      "^": "Object;",
      static: {
        "^": "ContentType_TEXT<-10,ContentType_HTML<-10,ContentType_JSON<-10,ContentType_BINARY<-10",
        ContentType_ContentType: [function(primaryType, subType, charset, parameters) {
          return P._ContentType$(primaryType, subType, charset, parameters);
        }, null, null, 4, 5, 855, 0, 0, 476, [], 475, [], 472, [], 117, [], "new ContentType"],
        ContentType_parse: [function(value) {
          var result, index, t1, t2, t3;
          result = new P._ContentType("", "", "", null, null);
          result._HeaderValue$2("", null);
          result._parse$4(value, ";", null, false);
          index = J.indexOf$1$asx(result._io$_value, "/");
          t1 = J.getInterceptor(index);
          t2 = t1.$eq(index, -1) || t1.$eq(index, J.$sub$n(J.get$length$asx(result._io$_value), 1));
          t3 = result._io$_value;
          if (t2) {
            result._primaryType = J.trim$0$s(t3).toLowerCase();
            result._subType = "";
          } else {
            result._primaryType = C.JSString_methods.trim$0(J.substring$2$s(t3, 0, index)).toLowerCase();
            result._subType = C.JSString_methods.trim$0(J.substring$1$s(result._io$_value, t1.$add(index, 1))).toLowerCase();
          }
          return result;
        }, "call$1", "io_ContentType_parse$closure", 2, 0, 856, 1, [], "parse"]
      }
    },
    "+ContentType": [1, 495],
    Cookie: {
      "^": "Object;name@-9,value@-9,expires@-75,maxAge@-0,domain@-9,path@-9,secure@-8,httpOnly@-8",
      value$1: function(arg0) {
        return this.value.call$1(arg0);
      },
      static: {
        Cookie_Cookie: [function($name, value) {
          var t1 = new P._Cookie($name, value, null, null, null, null, false, false);
          t1.httpOnly = true;
          t1._validate$0();
          return t1;
        }, null, null, 0, 4, 857, 0, 0, 13, [], 1, [], "new Cookie"],
        Cookie_Cookie$fromSetCookieValue: [function(value) {
          var t1 = new P._Cookie(null, null, null, null, null, null, false, false);
          t1._parseSetCookieValue$1(value);
          return t1;
        }, null, null, 2, 0, 858, 1, [], "new Cookie$fromSetCookieValue"]
      }
    },
    "+Cookie": [1],
    HttpRequest: {
      "^": "Object;",
      $isStream: 1,
      $asStream: function() {
        return [[P.List, P.int]];
      },
      static: {
        HttpRequest$: [function() {
          return new P.HttpRequest();
        }, null, null, 0, 0, 859, "new HttpRequest"]
      }
    },
    "+HttpRequest": [1, 42],
    HttpResponse: {
      "^": "Object;contentLength@-0,statusCode@-0,reasonPhrase@-9,persistentConnection@-8,deadline@-65,bufferOutput@-8",
      $isEventSink: 1,
      $asEventSink: function() {
        return [[P.List, P.int]];
      },
      static: {
        HttpResponse$: [function() {
          return new P.HttpResponse(null, null, null, null, null, null);
        }, null, null, 0, 0, 860, "new HttpResponse"]
      }
    },
    "+HttpResponse": [1, 78],
    HttpClient: {
      "^": "Object;idleTimeout@-65,maxConnectionsPerHost@-0,autoUncompress@-8,userAgent@-9",
      static: {
        "^": "HttpClient_DEFAULT_HTTP_PORT<-0,HttpClient_DEFAULT_HTTPS_PORT<-0",
        HttpClient_HttpClient: [function(context) {
          var t1, version;
          t1 = P.HashMap_HashMap(null, null, null, P.String, P._ConnectionTarget);
          version = $.$get$Platform__version();
          return new P._HttpClient(false, false, t1, [], [], context, null, null, P.io_HttpClient_findProxyFromEnvironment$closure(), C.Duration_15000000, null, null, true, "Dart/" + H.S(C.JSNull_methods.substring$2(version, 0, C.JSNull_methods.indexOf$2(version, ".", C.JSNull_methods.indexOf$1(version, ".").$add(0, 1)))) + " (dart:io)");
        }, null, null, 0, 3, 861, 0, 76, [], "new HttpClient"],
        HttpClient_findProxyFromEnvironment: [function(url, environment) {
          return P._HttpClient__findProxyFromEnvironment(url, environment);
        }, function(url) {
          return P.HttpClient_findProxyFromEnvironment(url, null);
        }, "call$2$environment", "call$1", "io_HttpClient_findProxyFromEnvironment$closure", 2, 3, 862, 0, 75, [], 155, [], "findProxyFromEnvironment"]
      }
    },
    "+HttpClient": [1],
    HttpClientRequest: {
      "^": "Object;persistentConnection@-8,followRedirects@-8,maxRedirects@-0,contentLength@-0,bufferOutput@-8",
      static: {
        HttpClientRequest$: [function() {
          return new P.HttpClientRequest(null, null, null, null, null);
        }, null, null, 0, 0, 863, "new HttpClientRequest"]
      }
    },
    "+HttpClientRequest": [1, 78],
    HttpClientResponse: {
      "^": "Object;",
      $isStream: 1,
      $asStream: function() {
        return [[P.List, P.int]];
      },
      static: {
        HttpClientResponse$: [function() {
          return new P.HttpClientResponse();
        }, null, null, 0, 0, 864, "new HttpClientResponse"]
      }
    },
    "+HttpClientResponse": [1, 42],
    HttpClientCredentials: {
      "^": "Object;",
      static: {
        HttpClientCredentials$: [function() {
          return new P.HttpClientCredentials();
        }, null, null, 0, 0, 865, "new HttpClientCredentials"]
      }
    },
    "+HttpClientCredentials": [1],
    HttpClientBasicCredentials: {
      "^": "HttpClientCredentials;",
      static: {
        HttpClientBasicCredentials_HttpClientBasicCredentials: [function(username, password) {
          return new P._HttpClientBasicCredentials(username, password);
        }, null, null, 4, 0, 866, 211, [], 219, [], "new HttpClientBasicCredentials"]
      }
    },
    "+HttpClientBasicCredentials": [274],
    HttpClientDigestCredentials: {
      "^": "HttpClientCredentials;",
      static: {
        HttpClientDigestCredentials_HttpClientDigestCredentials: [function(username, password) {
          return new P._HttpClientDigestCredentials(username, password);
        }, null, null, 4, 0, 867, 211, [], 219, [], "new HttpClientDigestCredentials"]
      }
    },
    "+HttpClientDigestCredentials": [274],
    HttpConnectionInfo: {
      "^": "Object;",
      static: {
        HttpConnectionInfo$: [function() {
          return new P.HttpConnectionInfo();
        }, null, null, 0, 0, 97, "new HttpConnectionInfo"]
      }
    },
    "+HttpConnectionInfo": [1],
    RedirectInfo: {
      "^": "Object;",
      static: {
        RedirectInfo$: [function() {
          return new P.RedirectInfo();
        }, null, null, 0, 0, 868, "new RedirectInfo"]
      }
    },
    "+RedirectInfo": [1],
    DetachedSocket: {
      "^": "Object;",
      static: {
        DetachedSocket$: [function() {
          return new P.DetachedSocket();
        }, null, null, 0, 0, 869, "new DetachedSocket"]
      }
    },
    "+DetachedSocket": [1],
    HttpException: {
      "^": "Object;message<-9,uri<-36",
      toString$0: [function(_) {
        var t1, t2;
        t1 = "HttpException: " + H.S(this.message);
        t2 = this.uri;
        if (t2 != null)
          t1 += ", uri = " + H.S(t2);
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isException: 1,
      static: {
        HttpException$: [function(message, uri) {
          return new P.HttpException(message, uri);
        }, null, null, 2, 3, 870, 0, 17, [], 40, [], "new HttpException"]
      }
    },
    "+HttpException": [1, 74],
    RedirectException: {
      "^": "Object;message<-9,redirects<-497",
      toString$0: [function(_) {
        return "RedirectException: " + H.S(this.message);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      get$uri: [function() {
        return J.get$last$ax(this.redirects).get$location();
      }, null, null, 1, 0, 43, "uri"],
      $isException: 1,
      static: {
        RedirectException$: [function(message, redirects) {
          return new P.RedirectException(message, redirects);
        }, null, null, 4, 0, 871, 17, [], 750, [], "new RedirectException"]
      }
    },
    "+RedirectException": [1, 1514],
    HttpDate: {
      "^": "Object;",
      static: {
        HttpDate$: [function() {
          return new P.HttpDate();
        }, null, null, 0, 0, 872, "new HttpDate"],
        HttpDate_format: [function(date) {
          var d, t1, t2;
          d = date.toUtc$0();
          t1 = C.List_ECn[C.JSInt_methods.$mod((d.isUtc === true ? H.Primitives_lazyAsJsDate(d).getUTCDay() + 0 : H.Primitives_lazyAsJsDate(d).getDay() + 0) + 6, 7) + 1 - 1] + ", ";
          t1 = t1 + (H.Primitives_getDay(d) <= 9 ? "0" : "") + C.JSInt_methods.toString$0(H.Primitives_getDay(d)) + " ";
          t2 = H.Primitives_getMonth(d) - 1;
          if (t2 < 0 || t2 >= 12)
            return H.ioore(C.List_h8w, t2);
          t2 = t1 + C.List_h8w[t2] + " " + C.JSInt_methods.toString$0(H.Primitives_getYear(d));
          t1 = t2 + (H.Primitives_getHours(d) <= 9 ? " 0" : " ") + C.JSInt_methods.toString$0(H.Primitives_getHours(d));
          t1 = t1 + (H.Primitives_getMinutes(d) <= 9 ? ":0" : ":") + C.JSInt_methods.toString$0(H.Primitives_getMinutes(d));
          t1 = t1 + (H.Primitives_getSeconds(d) <= 9 ? ":0" : ":") + C.JSInt_methods.toString$0(H.Primitives_getSeconds(d)) + " GMT";
          return t1.charCodeAt(0) == 0 ? t1 : t1;
        }, "call$1", "io_HttpDate_format$closure", 2, 0, 873, 276, [], "format"],
        HttpDate_parse: [function(date) {
          var t1, t2, t3, t4, month, day, hours, minutes, seconds, year;
          t1 = {};
          t1.index = 0;
          t1.tmp = null;
          t1.format = null;
          t2 = new P.HttpDate_parse_expect(t1, date);
          t3 = new P.HttpDate_parse_expectMonth(t1, date, C.List_h8w);
          t4 = new P.HttpDate_parse_expectNum(t1, date);
          new P.HttpDate_parse_expectWeekday(t1, date, C.List_ECn, C.List_ALf, 0, 1, 2).call$0();
          if (t1.format === 2) {
            month = t3.call$1(" ");
            if (J.codeUnitAt$1$s(date, t1.index) === 32)
              t1.index = J.$add$ns(t1.index, 1);
            day = t4.call$1(" ");
            hours = t4.call$1(":");
            minutes = t4.call$1(":");
            seconds = t4.call$1(" ");
            year = t4.call$1("");
          } else {
            t2.call$1(" ");
            day = t4.call$1(t1.format === 0 ? " " : "-");
            month = t3.call$1(t1.format === 0 ? " " : "-");
            year = t4.call$1(" ");
            hours = t4.call$1(":");
            minutes = t4.call$1(":");
            seconds = t4.call$1(" ");
            t2.call$1("GMT");
          }
          new P.HttpDate_parse_expectEnd(t1, date).call$0();
          t1 = J.$add$ns(month, 1);
          return new P.DateTime(H.checkInt(H.Primitives_valueFromDecomposedDate(year, t1, day, hours, minutes, seconds, 0, true)), true);
        }, "call$1", "io_HttpDate_parse$closure", 2, 0, 246, 276, [], "parse"],
        HttpDate__parseCookieDate: [function(date) {
          var t1, t2, t3, t4, t5, t6, t7, t8, tokens, t9, start, timeStr, dayOfMonthStr, monthStr, yearStr, _i, token, year, dayOfMonth, month, timeList, hour, minute, second;
          t1 = {};
          t1.position = 0;
          t2 = new P.HttpDate__parseCookieDate_error(date);
          t3 = new P.HttpDate__parseCookieDate_isEnd(t1, date);
          t4 = new P.HttpDate__parseCookieDate_isDelimiter();
          t5 = new P.HttpDate__parseCookieDate_isNonDelimiter();
          t6 = new P.HttpDate__parseCookieDate_isDigit();
          t7 = new P.HttpDate__parseCookieDate_getMonth(C.List_UI5);
          t8 = new P.HttpDate__parseCookieDate_toInt(t6);
          tokens = [];
          for (t9 = J.getInterceptor$asx(date); t3.call$0() !== true;) {
            while (true) {
              if (!(t3.call$0() !== true && t4.call$1(t9.$index(date, t1.position)) === true))
                break;
              ++t1.position;
            }
            start = t1.position;
            while (true) {
              if (!(t3.call$0() !== true && t5.call$1(t9.$index(date, t1.position)) === true))
                break;
              ++t1.position;
            }
            tokens.push(t9.substring$2(date, start, t1.position).toLowerCase());
            while (true) {
              if (!(t3.call$0() !== true && t4.call$1(t9.$index(date, t1.position)) === true))
                break;
              ++t1.position;
            }
          }
          for (t1 = tokens.length, timeStr = null, dayOfMonthStr = null, monthStr = null, yearStr = null, _i = 0; _i < tokens.length; tokens.length === t1 || (0, H.throwConcurrentModificationError)(tokens), ++_i) {
            token = tokens[_i];
            t3 = token.length;
            if (t3 < 1)
              continue;
            if (timeStr == null)
              if (t3 >= 5)
                if (t6.call$1(token[0]) === true) {
                  t4 = token[1];
                  if (t4 !== ":")
                    t4 = t6.call$1(t4) === true && token[2] === ":";
                  else
                    t4 = true;
                } else
                  t4 = false;
              else
                t4 = false;
            else
              t4 = false;
            if (t4)
              timeStr = token;
            else if (dayOfMonthStr == null && t6.call$1(token[0]) === true)
              dayOfMonthStr = token;
            else if (monthStr == null && J.$ge$n(t7.call$1(token), 0))
              monthStr = token;
            else if (yearStr == null && t3 >= 2 && t6.call$1(token[0]) === true && t6.call$1(token[1]) === true)
              yearStr = token;
          }
          if (timeStr == null || dayOfMonthStr == null || monthStr == null || yearStr == null)
            t2.call$0();
          year = t8.call$1(yearStr);
          t1 = J.getInterceptor$n(year);
          if (t1.$ge(year, 70) && t1.$le(year, 99))
            year = t1.$add(year, 1900);
          else if (t1.$ge(year, 0) && t1.$le(year, 69))
            year = t1.$add(year, 2000);
          if (J.$lt$n(year, 1601))
            t2.call$0();
          dayOfMonth = t8.call$1(dayOfMonthStr);
          t1 = J.getInterceptor$n(dayOfMonth);
          if (t1.$lt(dayOfMonth, 1) || t1.$gt(dayOfMonth, 31))
            t2.call$0();
          month = J.$add$ns(t7.call$1(monthStr), 1);
          timeList = timeStr.split(":");
          if (timeList.length !== 3)
            t2.call$0();
          if (0 >= timeList.length)
            return H.ioore(timeList, 0);
          hour = t8.call$1(timeList[0]);
          if (1 >= timeList.length)
            return H.ioore(timeList, 1);
          minute = t8.call$1(timeList[1]);
          if (2 >= timeList.length)
            return H.ioore(timeList, 2);
          second = t8.call$1(timeList[2]);
          if (J.$gt$n(hour, 23))
            t2.call$0();
          if (J.$gt$n(minute, 59))
            t2.call$0();
          if (J.$gt$n(second, 59))
            t2.call$0();
          t1 = H.Primitives_valueFromDecomposedDate(year, month, dayOfMonth, hour, minute, second, 0, true);
          if (typeof t1 !== "number" || Math.floor(t1) !== t1)
            H.throwExpression(H.argumentErrorValue(t1));
          return new P.DateTime(t1, true);
        }, "call$1", "io_HttpDate__parseCookieDate$closure", 2, 0, 246, 276, [], "_parseCookieDate"]
      }
    },
    "+HttpDate": [1],
    HttpDate_parse_expect: {
      "^": "Closure:19;_box_0,date",
      call$1: [function(s) {
        var t1, t2, t3, t4, t5;
        t1 = this.date;
        t2 = J.getInterceptor$asx(t1);
        t3 = this._box_0;
        t4 = s.length;
        if (J.$lt$n(J.$sub$n(t2.get$length(t1), t3.index), t4))
          throw H.wrapException(new P.HttpException("Invalid HTTP date " + H.S(t1), null));
        t5 = t3.index;
        if (t2.substring$2(t1, t5, J.$add$ns(t5, t4)) !== s)
          throw H.wrapException(new P.HttpException("Invalid HTTP date " + H.S(t1), null));
        t3.index = J.$add$ns(t3.index, t4);
      }, null, null, 2, 0, 19, 49, [], "call"]
    },
    "+ HttpDate_parse_expect": [2],
    HttpDate_parse_expectWeekday: {
      "^": "Closure:11;_box_0,date,wkdays,weekdays,formatRfc1123,formatRfc850,formatAsctime",
      call$0: [function() {
        var t1, t2, t3, pos, t4, t5, t6, weekday;
        t1 = this.date;
        t2 = this._box_0;
        t3 = J.getInterceptor$asx(t1);
        pos = t3.indexOf$2(t1, ",", t2.index);
        t4 = J.getInterceptor(pos);
        t5 = t4.$eq(pos, -1);
        t6 = t2.index;
        if (t5) {
          pos = t3.indexOf$2(t1, " ", t6);
          t4 = J.getInterceptor(pos);
          if (t4.$eq(pos, -1))
            throw H.wrapException(new P.HttpException("Invalid HTTP date " + H.S(t1), null));
          t2.tmp = t3.substring$2(t1, t2.index, pos);
          t2.index = t4.$add(pos, 1);
          weekday = C.JSArray_methods.indexOf$1(this.wkdays, t2.tmp);
          if (!J.$eq$(weekday, -1)) {
            t2.format = this.formatAsctime;
            return weekday;
          }
        } else {
          t2.tmp = t3.substring$2(t1, t6, pos);
          t2.index = t4.$add(pos, 1);
          weekday = C.JSArray_methods.indexOf$1(this.wkdays, t2.tmp);
          if (!J.$eq$(weekday, -1)) {
            t2.format = this.formatRfc1123;
            return weekday;
          }
          weekday = C.JSArray_methods.indexOf$1(this.weekdays, t2.tmp);
          if (!J.$eq$(weekday, -1)) {
            t2.format = this.formatRfc850;
            return weekday;
          }
        }
        throw H.wrapException(new P.HttpException("Invalid HTTP date " + H.S(t1), null));
      }, null, null, 0, 0, 11, "call"]
    },
    "+ HttpDate_parse_expectWeekday": [2],
    HttpDate_parse_expectMonth: {
      "^": "Closure:31;_box_0,date,months",
      call$1: [function(separator) {
        var t1, t2, t3, pos, t4, month;
        t1 = this.date;
        t2 = this._box_0;
        t3 = J.getInterceptor$asx(t1);
        pos = t3.indexOf$2(t1, separator, t2.index);
        t4 = J.getInterceptor$n(pos);
        if (!J.$eq$(t4.$sub(pos, t2.index), 3))
          throw H.wrapException(new P.HttpException("Invalid HTTP date " + H.S(t1), null));
        t2.tmp = t3.substring$2(t1, t2.index, pos);
        t2.index = t4.$add(pos, 1);
        month = C.JSArray_methods.indexOf$1(this.months, t2.tmp);
        if (!J.$eq$(month, -1))
          return month;
        throw H.wrapException(new P.HttpException("Invalid HTTP date " + H.S(t1), null));
      }, null, null, 2, 0, 31, 63, [], "call"]
    },
    "+ HttpDate_parse_expectMonth": [2],
    HttpDate_parse_expectNum: {
      "^": "Closure:31;_box_0,date",
      call$1: [function(separator) {
        var tmp, value, t1, t2, pos, t3, exception;
        t1 = separator.length;
        t2 = this.date;
        pos = t1 > 0 ? J.indexOf$2$asx(t2, separator, this._box_0.index) : J.get$length$asx(t2);
        t3 = this._box_0;
        tmp = J.substring$2$s(t2, t3.index, pos);
        t3.index = J.$add$ns(pos, t1);
        try {
          value = H.Primitives_parseInt(tmp, null, null);
          return value;
        } catch (exception) {
          if (H.unwrapException(exception) instanceof P.FormatException)
            throw H.wrapException(new P.HttpException("Invalid HTTP date " + H.S(t2), null));
          else
            throw exception;
        }
      }, null, null, 2, 0, 31, 63, [], "call"]
    },
    "+ HttpDate_parse_expectNum": [2],
    HttpDate_parse_expectEnd: {
      "^": "Closure:6;_box_0,date",
      call$0: [function() {
        var t1 = this.date;
        if (!J.$eq$(this._box_0.index, J.get$length$asx(t1)))
          throw H.wrapException(new P.HttpException("Invalid HTTP date " + H.S(t1), null));
      }, null, null, 0, 0, 6, "call"]
    },
    "+ HttpDate_parse_expectEnd": [2],
    HttpDate__parseCookieDate_error: {
      "^": "Closure:6;date",
      call$0: [function() {
        throw H.wrapException(new P.HttpException("Invalid cookie date " + H.S(this.date), null));
      }, null, null, 0, 0, 6, "call"]
    },
    "+ HttpDate__parseCookieDate_error": [2],
    HttpDate__parseCookieDate_isEnd: {
      "^": "Closure:5;_box_0,date",
      call$0: [function() {
        return this._box_0.position === J.get$length$asx(this.date);
      }, null, null, 0, 0, 5, "call"]
    },
    "+ HttpDate__parseCookieDate_isEnd": [2],
    HttpDate__parseCookieDate_isDelimiter: {
      "^": "Closure:30;",
      call$1: [function(s) {
        var char = J.codeUnitAt$1$s(s, 0);
        if (char === 9)
          return true;
        if (char >= 32 && char <= 47)
          return true;
        if (char >= 59 && char <= 64)
          return true;
        if (char >= 91 && char <= 96)
          return true;
        if (char >= 123 && char <= 126)
          return true;
        return false;
      }, null, null, 2, 0, 30, 49, [], "call"]
    },
    "+ HttpDate__parseCookieDate_isDelimiter": [2],
    HttpDate__parseCookieDate_isNonDelimiter: {
      "^": "Closure:30;",
      call$1: [function(s) {
        var char = J.codeUnitAt$1$s(s, 0);
        if (char <= 8)
          return true;
        if (char >= 10 && char <= 31)
          return true;
        if (char >= 48 && char <= 57)
          return true;
        if (char === 58)
          return true;
        if (char >= 65 && char <= 90)
          return true;
        if (char >= 97 && char <= 122)
          return true;
        if (char >= 127 && char <= 255)
          return true;
        return false;
      }, null, null, 2, 0, 30, 49, [], "call"]
    },
    "+ HttpDate__parseCookieDate_isNonDelimiter": [2],
    HttpDate__parseCookieDate_isDigit: {
      "^": "Closure:30;",
      call$1: [function(s) {
        var char = J.codeUnitAt$1$s(s, 0);
        if (char > 47 && char < 58)
          return true;
        return false;
      }, null, null, 2, 0, 30, 49, [], "call"]
    },
    "+ HttpDate__parseCookieDate_isDigit": [2],
    HttpDate__parseCookieDate_getMonth: {
      "^": "Closure:31;monthsLowerCase",
      call$1: [function(month) {
        var t1 = J.getInterceptor$asx(month);
        if (J.$lt$n(t1.get$length(month), 3))
          return -1;
        return C.JSArray_methods.indexOf$1(this.monthsLowerCase, t1.substring$2(month, 0, 3));
      }, null, null, 2, 0, 31, 196, [], "call"]
    },
    "+ HttpDate__parseCookieDate_getMonth": [2],
    HttpDate__parseCookieDate_toInt: {
      "^": "Closure:31;isDigit",
      call$1: [function(s) {
        var t1, t2, index, t3;
        t1 = J.getInterceptor$asx(s);
        t2 = this.isDigit;
        index = 0;
        while (true) {
          t3 = t1.get$length(s);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(index < t3 && t2.call$1(t1.$index(s, index)) === true))
            break;
          ++index;
        }
        return H.Primitives_parseInt(t1.substring$2(s, 0, index), null, null);
      }, null, null, 2, 0, 31, 49, [], "call"]
    },
    "+ HttpDate__parseCookieDate_toInt": [2],
    _HttpHeaders: {
      "^": "Object;_headers<-259,protocolVersion<-9,_mutable@-8,_noFoldingHeaders@-61,_contentLength@-0,_persistentConnection@-8,_chunkedTransferEncoding@-8,_io$_host@-9,_io$_port@-0,_defaultPortForScheme<-0",
      $index: [function(_, $name) {
        return J.$index$asx(this._headers, J.toLowerCase$0$s($name));
      }, null, "get$[]", 2, 0, 281, 13, [], "[]"],
      value$1: [function($name) {
        var values, t1;
        $name = J.toLowerCase$0$s($name);
        values = J.$index$asx(this._headers, $name);
        if (values == null)
          return;
        t1 = J.getInterceptor$asx(values);
        if (J.$gt$n(t1.get$length(values), 1))
          throw H.wrapException(new P.HttpException("More than one value for header " + $name, null));
        return t1.$index(values, 0);
      }, "call$1", "get$value", 2, 0, 28, 13, [], "value"],
      add$2: [function(_, $name, value) {
        if (this._mutable !== true)
          H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
        this._addAll$2(P._HttpHeaders__validateField($name), value);
      }, "call$2", "get$add", 4, 0, 60, 13, [], 1, [], "add"],
      _addAll$2: [function($name, value) {
        var t1 = J.getInterceptor(value);
        if (!!t1.$isIterable)
          for (t1 = t1.get$iterator(value); t1.moveNext$0();)
            this._io$_add$2($name, P._HttpHeaders__validateValue(t1.get$current()));
        else
          this._io$_add$2($name, P._HttpHeaders__validateValue(value));
      }, "call$2", "get$_addAll", 4, 0, 60, 13, [], 1, [], "_addAll"],
      $set$2: [function($name, value) {
        if (this._mutable !== true)
          H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
        $name = P._HttpHeaders__validateField($name);
        J.remove$1$ax(this._headers, $name);
        if ($name === "transfer-encoding")
          this._chunkedTransferEncoding = false;
        this._addAll$2($name, value);
      }, "call$2", "get$set", 4, 0, 264, 13, [], 1, [], "set"],
      remove$2: [function(_, $name, value) {
        var t1, t2, values, t3, index, t4;
        if (this._mutable !== true)
          H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
        $name = P._HttpHeaders__validateField($name);
        value = P._HttpHeaders__validateValue(value);
        t1 = this._headers;
        t2 = J.getInterceptor$asx(t1);
        values = t2.$index(t1, $name);
        if (values != null) {
          t3 = J.getInterceptor$asx(values);
          index = t3.indexOf$1(values, value);
          t4 = J.getInterceptor(index);
          if (!t4.$eq(index, -1))
            t3.removeRange$2(values, index, t4.$add(index, 1));
          if (J.$eq$(t3.get$length(values), 0))
            t2.remove$1(t1, $name);
        }
        if ($name === "transfer-encoding" && J.$eq$(value, "chunked"))
          this._chunkedTransferEncoding = false;
      }, "call$2", "get$remove", 4, 0, 264, 13, [], 1, [], "remove"],
      removeAll$1: [function($name) {
        if (this._mutable !== true)
          H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
        J.remove$1$ax(this._headers, P._HttpHeaders__validateField($name));
      }, "call$1", "get$removeAll", 2, 0, 19, 13, [], "removeAll"],
      forEach$1: [function(_, f) {
        J.forEach$1$ax(this._headers, f);
      }, "call$1", "get$forEach", 2, 0, 605, 9, [], "forEach"],
      noFolding$1: [function($name) {
        var t1 = this._noFoldingHeaders;
        if (t1 == null) {
          t1 = H.setRuntimeTypeInfo([], [P.String]);
          this._noFoldingHeaders = t1;
        }
        J.add$1$ax(t1, $name);
      }, "call$1", "get$noFolding", 2, 0, 19, 13, [], "noFolding"],
      get$persistentConnection: [function() {
        return this._persistentConnection;
      }, null, null, 1, 0, 5, "persistentConnection"],
      set$persistentConnection: [function(persistentConnection) {
        if (this._mutable !== true)
          H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
        if (J.$eq$(persistentConnection, this._persistentConnection))
          return;
        if (persistentConnection === true)
          if (J.$eq$(this.protocolVersion, "1.1"))
            this.remove$2(0, "connection", "close");
          else {
            if (J.$eq$(this._contentLength, -1))
              throw H.wrapException(new P.HttpException("Trying to set 'Connection: Keep-Alive' on HTTP 1.0 headers with no ContentLength", null));
            if (this._mutable !== true)
              H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
            this._addAll$2(P._HttpHeaders__validateField("connection"), "keep-alive");
          }
        else if (J.$eq$(this.protocolVersion, "1.1")) {
          if (this._mutable !== true)
            H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
          this._addAll$2(P._HttpHeaders__validateField("connection"), "close");
        } else
          this.remove$2(0, "connection", "keep-alive");
        this._persistentConnection = persistentConnection;
      }, null, null, 3, 0, 35, 989, [], "persistentConnection"],
      get$contentLength: [function() {
        return this._contentLength;
      }, null, null, 1, 0, 11, "contentLength"],
      set$contentLength: [function(contentLength) {
        var t1, t2;
        if (this._mutable !== true)
          H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
        t1 = this.protocolVersion;
        t2 = J.getInterceptor(t1);
        if (t2.$eq(t1, "1.0") && this._persistentConnection === true && J.$eq$(contentLength, -1))
          throw H.wrapException(new P.HttpException("Trying to clear ContentLength on HTTP 1.0 headers with 'Connection: Keep-Alive' set", null));
        if (J.$eq$(this._contentLength, contentLength))
          return;
        this._contentLength = contentLength;
        if (J.$ge$n(contentLength, 0)) {
          if (this._chunkedTransferEncoding === true)
            this.set$chunkedTransferEncoding(false);
          this._io$_set$2("content-length", J.toString$0$(contentLength));
        } else {
          if (this._mutable !== true)
            H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
          J.remove$1$ax(this._headers, P._HttpHeaders__validateField("content-length"));
          if (t2.$eq(t1, "1.1"))
            this.set$chunkedTransferEncoding(true);
        }
      }, null, null, 3, 0, 17, 495, [], "contentLength"],
      get$chunkedTransferEncoding: [function() {
        return this._chunkedTransferEncoding;
      }, null, null, 1, 0, 5, "chunkedTransferEncoding"],
      set$chunkedTransferEncoding: [function(chunkedTransferEncoding) {
        var t1, values;
        if (this._mutable !== true)
          H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
        t1 = chunkedTransferEncoding === true;
        if (t1 && J.$eq$(this.protocolVersion, "1.0"))
          throw H.wrapException(new P.HttpException("Trying to set 'Transfer-Encoding: Chunked' on HTTP 1.0 headers", null));
        if (J.$eq$(chunkedTransferEncoding, this._chunkedTransferEncoding))
          return;
        if (t1) {
          values = J.$index$asx(this._headers, "transfer-encoding");
          if (values == null || !J.$eq$(J.get$last$ax(values), "chunked"))
            this._addValue$2("transfer-encoding", "chunked");
          this.set$contentLength(-1);
        } else
          this.remove$2(0, "transfer-encoding", "chunked");
        this._chunkedTransferEncoding = chunkedTransferEncoding;
      }, null, null, 3, 0, 35, 870, [], "chunkedTransferEncoding"],
      get$host: [function() {
        return this._io$_host;
      }, null, null, 1, 0, 7, "host"],
      set$host: [function(host) {
        if (this._mutable !== true)
          H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
        this._io$_host = host;
        this._updateHostHeader$0();
      }, null, null, 3, 0, 19, 29, [], "host"],
      get$port: [function() {
        return this._io$_port;
      }, null, null, 1, 0, 11, "port"],
      set$port: [function(port) {
        if (this._mutable !== true)
          H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
        this._io$_port = port;
        this._updateHostHeader$0();
      }, null, null, 3, 0, 17, 26, [], "port"],
      get$ifModifiedSince: [function() {
        var values, t1, exception;
        values = J.$index$asx(this._headers, "if-modified-since");
        if (values != null)
          try {
            t1 = P.HttpDate_parse(J.$index$asx(values, 0));
            return t1;
          } catch (exception) {
            if (!!J.getInterceptor(H.unwrapException(exception)).$isException)
              return;
            else
              throw exception;
          }
        return;
      }, null, null, 1, 0, 85, "ifModifiedSince"],
      set$ifModifiedSince: [function(ifModifiedSince) {
        if (this._mutable !== true)
          H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
        this._io$_set$2("if-modified-since", P.HttpDate_format(ifModifiedSince.toUtc$0()));
      }, null, null, 3, 0, 146, 871, [], "ifModifiedSince"],
      get$date: [function() {
        var values, t1, exception;
        values = J.$index$asx(this._headers, "date");
        if (values != null)
          try {
            t1 = P.HttpDate_parse(J.$index$asx(values, 0));
            return t1;
          } catch (exception) {
            if (!!J.getInterceptor(H.unwrapException(exception)).$isException)
              return;
            else
              throw exception;
          }
        return;
      }, null, null, 1, 0, 85, "date"],
      set$date: [function(date) {
        if (this._mutable !== true)
          H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
        this._io$_set$2("date", P.HttpDate_format(date.toUtc$0()));
      }, null, null, 3, 0, 146, 276, [], "date"],
      get$expires: [function() {
        var values, t1, exception;
        values = J.$index$asx(this._headers, "expires");
        if (values != null)
          try {
            t1 = P.HttpDate_parse(J.$index$asx(values, 0));
            return t1;
          } catch (exception) {
            if (!!J.getInterceptor(H.unwrapException(exception)).$isException)
              return;
            else
              throw exception;
          }
        return;
      }, null, null, 1, 0, 85, "expires"],
      set$expires: [function(expires) {
        if (this._mutable !== true)
          H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
        this._io$_set$2("expires", P.HttpDate_format(expires.toUtc$0()));
      }, null, null, 3, 0, 146, 546, [], "expires"],
      get$contentType: [function() {
        var values, t1, result, index, t2, t3;
        values = J.$index$asx(this._headers, "content-type");
        if (values != null) {
          t1 = J.$index$asx(values, 0);
          result = new P._ContentType("", "", "", null, null);
          result._HeaderValue$2("", null);
          result._parse$4(t1, ";", null, false);
          index = J.indexOf$1$asx(result._io$_value, "/");
          t1 = J.getInterceptor(index);
          t2 = t1.$eq(index, -1) || t1.$eq(index, J.$sub$n(J.get$length$asx(result._io$_value), 1));
          t3 = result._io$_value;
          if (t2) {
            result._primaryType = J.trim$0$s(t3).toLowerCase();
            result._subType = "";
          } else {
            result._primaryType = C.JSString_methods.trim$0(J.substring$2$s(t3, 0, index)).toLowerCase();
            result._subType = C.JSString_methods.trim$0(J.substring$1$s(result._io$_value, t1.$add(index, 1))).toLowerCase();
          }
          return result;
        } else
          return;
      }, null, null, 1, 0, 607, "contentType"],
      set$contentType: [function(contentType) {
        if (this._mutable !== true)
          H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
        this._io$_set$2("content-type", J.toString$0$(contentType));
      }, null, null, 3, 0, 612, 872, [], "contentType"],
      clear$0: [function(_) {
        if (this._mutable !== true)
          H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
        J.clear$0$ax(this._headers);
        this._contentLength = -1;
        this._persistentConnection = true;
        this._chunkedTransferEncoding = false;
        this._io$_host = null;
        this._io$_port = null;
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      _io$_add$2: [function($name, value) {
        var formatted, values, lowerCaseValue;
        switch (J.get$length$asx($name)) {
          case 4:
            if ("date" === $name) {
              if (value instanceof P.DateTime) {
                if (this._mutable !== true)
                  H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
                formatted = P.HttpDate_format(value.toUtc$0());
                values = H.setRuntimeTypeInfo([], [P.String]);
                J.$indexSet$ax(this._headers, "date", values);
                values.push(formatted);
              } else if (typeof value === "string") {
                values = H.setRuntimeTypeInfo([], [P.String]);
                J.$indexSet$ax(this._headers, "date", values);
                values.push(value);
              } else
                H.throwExpression(new P.HttpException("Unexpected type for header named " + H.S($name), null));
              return;
            }
            if ("host" === $name) {
              this._addHost$2($name, value);
              return;
            }
            break;
          case 7:
            if ("expires" === $name) {
              if (value instanceof P.DateTime) {
                if (this._mutable !== true)
                  H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
                formatted = P.HttpDate_format(value.toUtc$0());
                values = H.setRuntimeTypeInfo([], [P.String]);
                J.$indexSet$ax(this._headers, "expires", values);
                values.push(formatted);
              } else if (typeof value === "string") {
                values = H.setRuntimeTypeInfo([], [P.String]);
                J.$indexSet$ax(this._headers, "expires", values);
                values.push(value);
              } else
                H.throwExpression(new P.HttpException("Unexpected type for header named " + H.S($name), null));
              return;
            }
            break;
          case 10:
            if ("connection" === $name) {
              lowerCaseValue = J.toLowerCase$0$s(value);
              if (lowerCaseValue === "close")
                this._persistentConnection = false;
              else if (lowerCaseValue === "keep-alive")
                this._persistentConnection = true;
              this._addValue$2($name, value);
              return;
            }
            break;
          case 12:
            if ("content-type" === $name) {
              values = H.setRuntimeTypeInfo([], [P.String]);
              J.$indexSet$ax(this._headers, "content-type", values);
              values.push(value);
              return;
            }
            break;
          case 14:
            if ("content-length" === $name) {
              if (typeof value === "number" && Math.floor(value) === value)
                this.set$contentLength(value);
              else if (typeof value === "string")
                this.set$contentLength(H.Primitives_parseInt(value, null, null));
              else
                H.throwExpression(new P.HttpException("Unexpected type for header named " + H.S($name), null));
              return;
            }
            break;
          case 17:
            if ("transfer-encoding" === $name) {
              if (J.$eq$(value, "chunked"))
                this.set$chunkedTransferEncoding(true);
              else
                this._addValue$2("transfer-encoding", value);
              return;
            }
            if ("if-modified-since" === $name) {
              if (value instanceof P.DateTime) {
                if (this._mutable !== true)
                  H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
                formatted = P.HttpDate_format(value.toUtc$0());
                values = H.setRuntimeTypeInfo([], [P.String]);
                J.$indexSet$ax(this._headers, "if-modified-since", values);
                values.push(formatted);
              } else if (typeof value === "string") {
                values = H.setRuntimeTypeInfo([], [P.String]);
                J.$indexSet$ax(this._headers, "if-modified-since", values);
                values.push(value);
              } else
                H.throwExpression(new P.HttpException("Unexpected type for header named " + H.S($name), null));
              return;
            }
            break;
        }
        this._addValue$2($name, value);
      }, "call$2", "get$_io$_add", 4, 0, 60, 13, [], 1, [], "_io$_add"],
      _addContentLength$2: [function($name, value) {
        if (typeof value === "number" && Math.floor(value) === value)
          this.set$contentLength(value);
        else if (typeof value === "string")
          this.set$contentLength(H.Primitives_parseInt(value, null, null));
        else
          throw H.wrapException(new P.HttpException("Unexpected type for header named " + H.S($name), null));
      }, "call$2", "get$_addContentLength", 4, 0, 60, 13, [], 1, [], "_addContentLength"],
      _addTransferEncoding$2: [function($name, value) {
        if (J.$eq$(value, "chunked"))
          this.set$chunkedTransferEncoding(true);
        else
          this._addValue$2("transfer-encoding", value);
      }, "call$2", "get$_addTransferEncoding", 4, 0, 60, 13, [], 1, [], "_addTransferEncoding"],
      _addDate$2: [function($name, value) {
        if (value instanceof P.DateTime) {
          if (this._mutable !== true)
            H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
          this._io$_set$2("date", P.HttpDate_format(value.toUtc$0()));
        } else if (typeof value === "string")
          this._io$_set$2("date", value);
        else
          throw H.wrapException(new P.HttpException("Unexpected type for header named " + H.S($name), null));
      }, "call$2", "get$_addDate", 4, 0, 60, 13, [], 1, [], "_addDate"],
      _addExpires$2: [function($name, value) {
        if (value instanceof P.DateTime) {
          if (this._mutable !== true)
            H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
          this._io$_set$2("expires", P.HttpDate_format(value.toUtc$0()));
        } else if (typeof value === "string")
          this._io$_set$2("expires", value);
        else
          throw H.wrapException(new P.HttpException("Unexpected type for header named " + H.S($name), null));
      }, "call$2", "get$_addExpires", 4, 0, 60, 13, [], 1, [], "_addExpires"],
      _addIfModifiedSince$2: [function($name, value) {
        if (value instanceof P.DateTime) {
          if (this._mutable !== true)
            H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
          this._io$_set$2("if-modified-since", P.HttpDate_format(value.toUtc$0()));
        } else if (typeof value === "string")
          this._io$_set$2("if-modified-since", value);
        else
          throw H.wrapException(new P.HttpException("Unexpected type for header named " + H.S($name), null));
      }, "call$2", "get$_addIfModifiedSince", 4, 0, 60, 13, [], 1, [], "_addIfModifiedSince"],
      _addHost$2: [function($name, value) {
        var pos, exception;
        if (typeof value === "string") {
          pos = C.JSString_methods.indexOf$1(value, ":");
          if (J.$eq$(pos, -1)) {
            this._io$_host = value;
            this._io$_port = 80;
          } else {
            if (J.$gt$n(pos, 0))
              this._io$_host = C.JSString_methods.substring$2(value, 0, pos);
            else
              this._io$_host = null;
            if (J.$add$ns(pos, 1) === value.length)
              this._io$_port = 80;
            else
              try {
                this._io$_port = H.Primitives_parseInt(C.JSString_methods.substring$1(value, J.$add$ns(pos, 1)), null, null);
              } catch (exception) {
                if (H.unwrapException(exception) instanceof P.FormatException)
                  this._io$_port = null;
                else
                  throw exception;
              }
          }
          this._io$_set$2("host", value);
        } else
          throw H.wrapException(new P.HttpException("Unexpected type for header named " + H.S($name), null));
      }, "call$2", "get$_addHost", 4, 0, 60, 13, [], 1, [], "_addHost"],
      _addConnection$2: [function($name, value) {
        var lowerCaseValue = J.toLowerCase$0$s(value);
        if (lowerCaseValue === "close")
          this._persistentConnection = false;
        else if (lowerCaseValue === "keep-alive")
          this._persistentConnection = true;
        this._addValue$2($name, value);
      }, "call$2", "get$_addConnection", 4, 0, 60, 13, [], 1, [], "_addConnection"],
      _addContentType$2: [function($name, value) {
        this._io$_set$2("content-type", value);
      }, "call$2", "get$_addContentType", 4, 0, 60, 13, [], 1, [], "_addContentType"],
      _addValue$2: [function($name, value) {
        var t1, t2, values;
        t1 = this._headers;
        t2 = J.getInterceptor$asx(t1);
        values = t2.$index(t1, $name);
        if (values == null) {
          values = H.setRuntimeTypeInfo([], [P.String]);
          t2.$indexSet(t1, $name, values);
        }
        t1 = J.getInterceptor(value);
        if (!!t1.$isDateTime)
          J.add$1$ax(values, P.HttpDate_format(value));
        else {
          t2 = J.getInterceptor$ax(values);
          if (typeof value === "string")
            t2.add$1(values, value);
          else
            t2.add$1(values, P._HttpHeaders__validateValue(t1.toString$0(value)));
        }
      }, "call$2", "get$_addValue", 4, 0, 264, 13, [], 1, [], "_addValue"],
      _io$_set$2: [function($name, value) {
        var values = H.setRuntimeTypeInfo([], [P.String]);
        J.$indexSet$ax(this._headers, $name, values);
        values.push(value);
      }, "call$2", "get$_io$_set", 4, 0, 215, 13, [], 1, [], "_io$_set"],
      _checkMutable$0: [function() {
        if (this._mutable !== true)
          throw H.wrapException(new P.HttpException("HTTP headers are not mutable", null));
      }, "call$0", "get$_checkMutable", 0, 0, 4, "_checkMutable"],
      _updateHostHeader$0: [function() {
        var t1, defaultPort;
        t1 = this._io$_port;
        defaultPort = t1 == null || J.$eq$(t1, this._defaultPortForScheme);
        t1 = this._io$_host;
        this._io$_set$2("host", defaultPort ? t1 : H.S(t1) + ":" + H.S(this._io$_port));
      }, "call$0", "get$_updateHostHeader", 0, 0, 4, "_updateHostHeader"],
      _foldHeader$1: [function($name) {
        var t1;
        if (!J.$eq$($name, "set-cookie")) {
          t1 = this._noFoldingHeaders;
          t1 = t1 != null && !J.$eq$(J.indexOf$1$asx(t1, $name), -1);
        } else
          t1 = true;
        if (t1)
          return false;
        return true;
      }, "call$1", "get$_foldHeader", 2, 0, 13, 13, [], "_foldHeader"],
      _finalize$0: [function() {
        this._mutable = false;
      }, "call$0", "get$_finalize", 0, 0, 6, "_finalize"],
      _build$1: [function(builder) {
        var t1, t2, t3, t4, $name, values, fold, nameData, t5, i, t6;
        for (t1 = this._headers, t2 = t1.get$keys(), t2 = t2.get$iterator(t2), t3 = J.getInterceptor$ax(builder), t4 = J.getInterceptor$asx(t1); t2.moveNext$0();) {
          $name = t2.get$current();
          values = t4.$index(t1, $name);
          fold = this._foldHeader$1($name);
          nameData = J.get$codeUnits$s($name);
          t3.add$1(builder, nameData);
          builder.addByte$1(58);
          builder.addByte$1(32);
          t5 = J.getInterceptor$asx(values);
          i = 0;
          while (true) {
            t6 = t5.get$length(values);
            if (typeof t6 !== "number")
              return H.iae(t6);
            if (!(i < t6))
              break;
            if (i > 0)
              if (fold) {
                builder.addByte$1(44);
                builder.addByte$1(32);
              } else {
                builder.addByte$1(13);
                builder.addByte$1(10);
                t3.add$1(builder, nameData);
                builder.addByte$1(58);
                builder.addByte$1(32);
              }
            t3.add$1(builder, J.get$codeUnits$s(t5.$index(values, i)));
            ++i;
          }
          builder.addByte$1(13);
          builder.addByte$1(10);
        }
      }, "call$1", "get$_build", 2, 0, 615, 873, [], "_build"],
      toString$0: [function(_) {
        var sb, t1;
        sb = new P.StringBuffer("");
        J.forEach$1$ax(this._headers, new P._HttpHeaders_toString_closure(this, sb));
        t1 = sb._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      _parseCookies$0: [function() {
        var cookies, values;
        cookies = H.setRuntimeTypeInfo([], [P.Cookie]);
        values = J.$index$asx(this._headers, "cookie");
        if (values != null)
          J.forEach$1$ax(values, new P._HttpHeaders__parseCookies_closure(new P._HttpHeaders__parseCookies_parseCookieString(cookies)));
        return cookies;
      }, "call$0", "get$_parseCookies", 0, 0, 191, "_parseCookies"],
      _HttpHeaders$3$defaultPortForScheme$initialHeaders: function(protocolVersion, defaultPortForScheme, initialHeaders) {
        if (initialHeaders != null) {
          J.forEach$1$ax(initialHeaders.get$_headers(), new P._HttpHeaders_closure(this));
          this._contentLength = initialHeaders.get$_contentLength();
          this._persistentConnection = initialHeaders.get$_persistentConnection();
          this._chunkedTransferEncoding = initialHeaders.get$_chunkedTransferEncoding();
          this._io$_host = initialHeaders.get$_io$_host();
          this._io$_port = initialHeaders.get$_io$_port();
        }
        if (J.$eq$(this.protocolVersion, "1.0")) {
          this._persistentConnection = false;
          this._chunkedTransferEncoding = false;
        }
      },
      static: {
        _HttpHeaders$: [function(protocolVersion, defaultPortForScheme, initialHeaders) {
          var t1 = new P._HttpHeaders(P.HashMap_HashMap(null, null, null, P.String, [P.List, P.String]), protocolVersion, true, null, -1, true, false, null, null, defaultPortForScheme);
          t1._HttpHeaders$3$defaultPortForScheme$initialHeaders(protocolVersion, defaultPortForScheme, initialHeaders);
          return t1;
        }, null, null, 2, 5, 874, 752, 0, 413, [], 754, [], 463, [], "new _HttpHeaders"],
        _HttpHeaders__validateField: [function(field) {
          var t1, i, t2;
          t1 = J.getInterceptor$asx(field);
          i = 0;
          while (true) {
            t2 = t1.get$length(field);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            t2 = t1.codeUnitAt$1(field, i);
            if (!(t2 > 31 && t2 < 128 && !C.List_NUU[t2]))
              throw H.wrapException(new P.FormatException("Invalid HTTP header field name: " + C.JsonCodec_null_null.encode$1(field), null, null));
            ++i;
          }
          return t1.toLowerCase$0(field);
        }, "call$1", "io__HttpHeaders__validateField$closure", 2, 0, 28, 460, [], "_validateField"],
        _HttpHeaders__validateValue: [function(value) {
          var t1, i, t2;
          if (typeof value !== "string")
            return value;
          for (t1 = value.length, i = 0; i < t1; ++i) {
            t2 = C.JSString_methods._codeUnitAt$1(value, i);
            if (!(t2 > 31 && t2 < 128 || t2 === 32 || t2 === 9))
              throw H.wrapException(new P.FormatException("Invalid HTTP header field value: " + C.JsonCodec_null_null.encode$1(value), null, null));
          }
          return value;
        }, "call$1", "io__HttpHeaders__validateValue$closure", 2, 0, 3, 1, [], "_validateValue"]
      }
    },
    "+_HttpHeaders": [1, 498],
    _HttpHeaders_closure: {
      "^": "Closure:12;$this",
      call$2: [function($name, value) {
        J.$indexSet$ax(this.$this._headers, $name, value);
        return value;
      }, null, null, 4, 0, 12, 13, [], 1, [], "call"]
    },
    "+ _HttpHeaders_closure": [2],
    _HttpHeaders_toString_closure: {
      "^": "Closure:342;$this,sb",
      call$2: [function($name, values) {
        var t1, t2, fold, i, t3;
        t1 = this.sb;
        t2 = t1._contents += H.S($name);
        t1._contents = t2 + ": ";
        fold = this.$this._foldHeader$1($name);
        t2 = J.getInterceptor$asx(values);
        i = 0;
        while (true) {
          t3 = t2.get$length(values);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          if (i > 0) {
            t3 = t1._contents;
            if (fold)
              t1._contents = t3 + ", ";
            else {
              t1._contents = t3 + "\n";
              t3 = t1._contents += H.S($name);
              t1._contents = t3 + ": ";
            }
          }
          t1._contents += H.S(t2.$index(values, i));
          ++i;
        }
        t1._contents += "\n";
      }, null, null, 4, 0, 342, 13, [], 166, [], "call"]
    },
    "+ _HttpHeaders_toString_closure": [2],
    _HttpHeaders__parseCookies_parseCookieString: {
      "^": "Closure:19;cookies",
      call$1: [function(s) {
        var t1, $name, value, t2, t3, t4, t5, t6, t7, t8, t9, exception;
        t1 = {};
        t1.index = 0;
        t2 = new P._HttpHeaders__parseCookies_parseCookieString_done(t1, s);
        t3 = new P._HttpHeaders__parseCookies_parseCookieString_skipWS(t1, s, t2);
        t4 = new P._HttpHeaders__parseCookies_parseCookieString_parseName(t1, s, t2);
        t5 = new P._HttpHeaders__parseCookies_parseCookieString_parseValue(t1, s, t2);
        t6 = new P._HttpHeaders__parseCookies_parseCookieString_expect(t1, s, t2);
        for (t7 = this.cookies, t8 = J.getInterceptor$asx(s); t2.call$0() !== true;) {
          t3.call$0();
          if (t2.call$0() === true)
            return;
          $name = t4.call$0();
          t3.call$0();
          if (t6.call$1("=") !== true) {
            t1.index = t8.indexOf$2(s, ";", t1.index);
            continue;
          }
          t3.call$0();
          value = t5.call$0();
          try {
            t9 = new P._Cookie($name, value, null, null, null, null, false, false);
            t9.httpOnly = true;
            t9._validate$0();
            t7.push(t9);
          } catch (exception) {
            H.unwrapException(exception);
          }
          t3.call$0();
          if (t2.call$0() === true)
            return;
          if (t6.call$1(";") !== true) {
            t1.index = t8.indexOf$2(s, ";", t1.index);
            continue;
          }
        }
      }, null, null, 2, 0, 19, 49, [], "call"]
    },
    "+ _HttpHeaders__parseCookies_parseCookieString": [2],
    _HttpHeaders__parseCookies_parseCookieString_done: {
      "^": "Closure:5;_box_0,s",
      call$0: [function() {
        var t1 = this._box_0;
        return J.$eq$(t1.index, -1) || J.$eq$(t1.index, J.get$length$asx(this.s));
      }, null, null, 0, 0, 5, "call"]
    },
    "+ _HttpHeaders__parseCookies_parseCookieString_done": [2],
    _HttpHeaders__parseCookies_parseCookieString_skipWS: {
      "^": "Closure:6;_box_0,s,done",
      call$0: [function() {
        var t1, t2, t3, t4;
        for (t1 = this.done, t2 = this._box_0, t3 = this.s, t4 = J.getInterceptor$asx(t3); t1.call$0() !== true;) {
          if (!J.$eq$(t4.$index(t3, t2.index), " ") && !J.$eq$(t4.$index(t3, t2.index), "\t"))
            return;
          t2.index = J.$add$ns(t2.index, 1);
        }
      }, null, null, 0, 0, 6, "call"]
    },
    "+ _HttpHeaders__parseCookies_parseCookieString_skipWS": [2],
    _HttpHeaders__parseCookies_parseCookieString_parseName: {
      "^": "Closure:7;_box_0,s,done",
      call$0: [function() {
        var t1, start, t2, t3, t4;
        t1 = this._box_0;
        start = t1.index;
        for (t2 = this.done, t3 = this.s, t4 = J.getInterceptor$asx(t3); t2.call$0() !== true;) {
          if (J.$eq$(t4.$index(t3, t1.index), " ") || J.$eq$(t4.$index(t3, t1.index), "\t") || J.$eq$(t4.$index(t3, t1.index), "="))
            break;
          t1.index = J.$add$ns(t1.index, 1);
        }
        return t4.substring$2(t3, start, t1.index);
      }, null, null, 0, 0, 7, "call"]
    },
    "+ _HttpHeaders__parseCookies_parseCookieString_parseName": [2],
    _HttpHeaders__parseCookies_parseCookieString_parseValue: {
      "^": "Closure:7;_box_0,s,done",
      call$0: [function() {
        var t1, start, t2, t3, t4;
        t1 = this._box_0;
        start = t1.index;
        for (t2 = this.done, t3 = this.s, t4 = J.getInterceptor$asx(t3); t2.call$0() !== true;) {
          if (J.$eq$(t4.$index(t3, t1.index), " ") || J.$eq$(t4.$index(t3, t1.index), "\t") || J.$eq$(t4.$index(t3, t1.index), ";"))
            break;
          t1.index = J.$add$ns(t1.index, 1);
        }
        return t4.substring$2(t3, start, t1.index);
      }, null, null, 0, 0, 7, "call"]
    },
    "+ _HttpHeaders__parseCookies_parseCookieString_parseValue": [2],
    _HttpHeaders__parseCookies_parseCookieString_expect: {
      "^": "Closure:30;_box_0,s,done",
      call$1: [function(expected) {
        var t1;
        if (this.done.call$0() === true)
          return false;
        t1 = this._box_0;
        if (!J.$eq$(J.$index$asx(this.s, t1.index), expected))
          return false;
        t1.index = J.$add$ns(t1.index, 1);
        return true;
      }, null, null, 2, 0, 30, 238, [], "call"]
    },
    "+ _HttpHeaders__parseCookies_parseCookieString_expect": [2],
    _HttpHeaders__parseCookies_closure: {
      "^": "Closure:3;parseCookieString",
      call$1: [function(headerValue) {
        return this.parseCookieString.call$1(headerValue);
      }, null, null, 2, 0, 3, 349, [], "call"]
    },
    "+ _HttpHeaders__parseCookies_closure": [2],
    _HeaderValue: {
      "^": "Object;_io$_value@-9,_io$_parameters@-82,_unmodifiableParameters@-82",
      get$value: [function() {
        return this._io$_value;
      }, null, null, 1, 0, 7, "value"],
      _ensureParameters$0: [function() {
        if (this._io$_parameters == null) {
          var t1 = P.String;
          this._io$_parameters = P.HashMap_HashMap(null, null, null, t1, t1);
        }
      }, "call$0", "get$_ensureParameters", 0, 0, 6, "_ensureParameters"],
      get$parameters: [function() {
        this._ensureParameters$0();
        var t1 = this._unmodifiableParameters;
        if (t1 == null) {
          t1 = new P.UnmodifiableMapView(this._io$_parameters, [null, null]);
          this._unmodifiableParameters = t1;
        }
        return t1;
      }, null, null, 1, 0, 106, "parameters"],
      toString$0: [function(_) {
        var sb, t1;
        sb = new P.StringBuffer("");
        sb._contents = H.S(this._io$_value);
        if (this.get$parameters() != null && J.$gt$n(J.get$length$asx(this.get$parameters()), 0))
          J.forEach$1$ax(this._io$_parameters, new P._HeaderValue_toString_closure(sb));
        t1 = sb._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      _parse$4: [function(s, parameterSeparator, valueSeparator, preserveBackslash) {
        var t1, t2, t3, t4, t5;
        t1 = {};
        t1.index = 0;
        t2 = new P._HeaderValue__parse_done(t1, s);
        t3 = new P._HeaderValue__parse_skipWS(t1, s, t2);
        t4 = new P._HeaderValue__parse_parseValue(t1, s, parameterSeparator, valueSeparator, t2);
        t5 = new P._HeaderValue__parse_maybeExpect(t1, s);
        t3.call$0();
        this._io$_value = t4.call$0();
        t3.call$0();
        if (t2.call$0() === true)
          return;
        t5.call$1(parameterSeparator);
        new P._HeaderValue__parse_parseParameters(t1, this, s, parameterSeparator, valueSeparator, preserveBackslash, t2, t3, t4, new P._HeaderValue__parse_expect(t1, s, t2), t5).call$0();
      }, "call$4", "get$_parse", 8, 0, 653, 49, [], 402, [], 403, [], 404, [], "_parse"],
      _HeaderValue$2: function(_value, parameters) {
        var t1;
        if (parameters != null) {
          t1 = P.String;
          this._io$_parameters = P.HashMap_HashMap$from(parameters, t1, t1);
        }
      },
      value$1: function(arg0) {
        return this.get$value().call$1(arg0);
      },
      static: {
        _HeaderValue$: [function(_value, parameters) {
          var t1 = new P._HeaderValue(_value, null, null);
          t1._HeaderValue$2(_value, parameters);
          return t1;
        }, null, null, 0, 4, 875, 32, 0, 174, [], 117, [], "new _HeaderValue"],
        _HeaderValue_parse: [function(value, parameterSeparator, preserveBackslash, valueSeparator) {
          var result = P._HeaderValue$("", null);
          result._parse$4(value, parameterSeparator, valueSeparator, preserveBackslash);
          return result;
        }, function(value) {
          return P._HeaderValue_parse(value, ";", false, null);
        }, "call$4$parameterSeparator$preserveBackslash$valueSeparator", "call$1", "io__HeaderValue_parse$closure", 2, 7, 876, 480, 0, 4, 1, [], 402, [], 403, [], 404, [], "parse"]
      }
    },
    "+_HeaderValue": [1, 495],
    _HeaderValue_toString_closure: {
      "^": "Closure:40;sb",
      call$2: [function($name, value) {
        var t1, t2;
        t1 = this.sb;
        t1._contents += "; ";
        t2 = t1._contents += H.S($name);
        t1._contents = t2 + "=";
        t1._contents += H.S(value);
      }, null, null, 4, 0, 40, 13, [], 1, [], "call"]
    },
    "+ _HeaderValue_toString_closure": [2],
    _HeaderValue__parse_done: {
      "^": "Closure:5;_box_0,s",
      call$0: [function() {
        return this._box_0.index === J.get$length$asx(this.s);
      }, null, null, 0, 0, 5, "call"]
    },
    "+ _HeaderValue__parse_done": [2],
    _HeaderValue__parse_skipWS: {
      "^": "Closure:6;_box_0,s,done",
      call$0: [function() {
        var t1, t2, t3, t4;
        for (t1 = this.done, t2 = this._box_0, t3 = this.s, t4 = J.getInterceptor$asx(t3); t1.call$0() !== true;) {
          if (!J.$eq$(t4.$index(t3, t2.index), " ") && !J.$eq$(t4.$index(t3, t2.index), "\t"))
            return;
          ++t2.index;
        }
      }, null, null, 0, 0, 6, "call"]
    },
    "+ _HeaderValue__parse_skipWS": [2],
    _HeaderValue__parse_parseValue: {
      "^": "Closure:7;_box_0,s,parameterSeparator,valueSeparator,done",
      call$0: [function() {
        var t1, start, t2, t3, t4, t5, t6;
        t1 = this._box_0;
        start = t1.index;
        for (t2 = this.done, t3 = this.s, t4 = J.getInterceptor$asx(t3), t5 = this.valueSeparator, t6 = this.parameterSeparator; t2.call$0() !== true;) {
          if (J.$eq$(t4.$index(t3, t1.index), " ") || J.$eq$(t4.$index(t3, t1.index), "\t") || J.$eq$(t4.$index(t3, t1.index), t5) || J.$eq$(t4.$index(t3, t1.index), t6))
            break;
          ++t1.index;
        }
        return t4.substring$2(t3, start, t1.index);
      }, null, null, 0, 0, 7, "call"]
    },
    "+ _HeaderValue__parse_parseValue": [2],
    _HeaderValue__parse_expect: {
      "^": "Closure:19;_box_0,s,done",
      call$1: [function(expected) {
        if (this.done.call$0() === true || !J.$eq$(J.$index$asx(this.s, this._box_0.index), expected))
          throw H.wrapException(new P.HttpException("Failed to parse header value", null));
        ++this._box_0.index;
      }, null, null, 2, 0, 19, 238, [], "call"]
    },
    "+ _HeaderValue__parse_expect": [2],
    _HeaderValue__parse_maybeExpect: {
      "^": "Closure:19;_box_0,s",
      call$1: [function(expected) {
        var t1 = this._box_0;
        if (J.$eq$(J.$index$asx(this.s, t1.index), expected))
          ++t1.index;
      }, null, null, 2, 0, 19, 238, [], "call"]
    },
    "+ _HeaderValue__parse_maybeExpect": [2],
    _HeaderValue__parse_parseParameters: {
      "^": "Closure:6;_box_0,$this,s,parameterSeparator,valueSeparator,preserveBackslash,done,skipWS,parseValue,expect,maybeExpect",
      call$0: [function() {
        var t1, parameters, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, $name, value;
        t1 = P.String;
        parameters = P.HashMap_HashMap(null, null, null, t1, t1);
        t1 = this.$this;
        t1._io$_parameters = new P.UnmodifiableMapView(parameters, [null, null]);
        t2 = this._box_0;
        t3 = this.s;
        t4 = this.parameterSeparator;
        t5 = this.valueSeparator;
        t6 = this.done;
        t7 = new P._HeaderValue__parse_parseParameters_parseParameterName(t2, t3, t4, t5, t6);
        t8 = new P._HeaderValue__parse_parseParameters_parseParameterValue(t2, t3, this.preserveBackslash, t6, this.parseValue);
        for (t9 = this.expect, t10 = J.getInterceptor$asx(t3), t11 = this.skipWS, t12 = this.maybeExpect, t1 = !!t1.$is_ContentType; t6.call$0() !== true;) {
          t11.call$0();
          if (t6.call$0() === true)
            return;
          $name = t7.call$0();
          t11.call$0();
          if (t6.call$0() === true) {
            parameters.$indexSet(0, $name, null);
            return;
          }
          t12.call$1("=");
          t11.call$0();
          if (t6.call$0() === true) {
            parameters.$indexSet(0, $name, null);
            return;
          }
          value = t8.call$0();
          parameters.$indexSet(0, $name, J.$eq$($name, "charset") && t1 && value != null ? value.toLowerCase() : value);
          t11.call$0();
          if (t6.call$0() === true)
            return;
          if (J.$eq$(t10.$index(t3, t2.index), t5))
            return;
          t9.call$1(t4);
        }
      }, null, null, 0, 0, 6, "call"]
    },
    "+ _HeaderValue__parse_parseParameters": [2],
    _HeaderValue__parse_parseParameters_parseParameterName: {
      "^": "Closure:7;_box_0,s,parameterSeparator,valueSeparator,done",
      call$0: [function() {
        var t1, start, t2, t3, t4, t5, t6;
        t1 = this._box_0;
        start = t1.index;
        for (t2 = this.done, t3 = this.s, t4 = J.getInterceptor$asx(t3), t5 = this.parameterSeparator, t6 = this.valueSeparator; t2.call$0() !== true;) {
          if (J.$eq$(t4.$index(t3, t1.index), " ") || J.$eq$(t4.$index(t3, t1.index), "\t") || J.$eq$(t4.$index(t3, t1.index), "=") || J.$eq$(t4.$index(t3, t1.index), t5) || J.$eq$(t4.$index(t3, t1.index), t6))
            break;
          ++t1.index;
        }
        return t4.substring$2(t3, start, t1.index).toLowerCase();
      }, null, null, 0, 0, 7, "call"]
    },
    "+ _HeaderValue__parse_parseParameters_parseParameterName": [2],
    _HeaderValue__parse_parseParameters_parseParameterValue: {
      "^": "Closure:7;_box_0,s,preserveBackslash,done,parseValue",
      call$0: [function() {
        var t1, t2, t3, t4, t5, t6, val;
        t1 = this.done;
        if (t1.call$0() !== true && J.$eq$(J.$index$asx(this.s, this._box_0.index), '"')) {
          t2 = this._box_0;
          ++t2.index;
          for (t3 = this.s, t4 = J.getInterceptor$asx(t3), t5 = this.preserveBackslash === true, t6 = ""; t1.call$0() !== true;) {
            if (J.$eq$(t4.$index(t3, t2.index), "\\")) {
              if (t2.index + 1 === t4.get$length(t3))
                throw H.wrapException(new P.HttpException("Failed to parse header value", null));
              if (t5 && !J.$eq$(t4.$index(t3, t2.index + 1), '"'))
                t6 += H.S(t4.$index(t3, t2.index));
              ++t2.index;
            } else if (J.$eq$(t4.$index(t3, t2.index), '"')) {
              ++t2.index;
              break;
            }
            t6 += H.S(t4.$index(t3, t2.index));
            ++t2.index;
          }
          return t6.charCodeAt(0) == 0 ? t6 : t6;
        } else {
          val = this.parseValue.call$0();
          return J.$eq$(val, "") ? null : val;
        }
      }, null, null, 0, 0, 7, "call"]
    },
    "+ _HeaderValue__parse_parseParameters_parseParameterValue": [2],
    _ContentType: {
      "^": "_HeaderValue;_primaryType@-9,_subType@-9,_io$_value-9,_io$_parameters-82,_unmodifiableParameters-82",
      get$mimeType: [function() {
        return H.S(this._primaryType) + "/" + H.S(this._subType);
      }, null, null, 1, 0, 7, "mimeType"],
      get$primaryType: [function() {
        return this._primaryType;
      }, null, null, 1, 0, 7, "primaryType"],
      get$subType: [function() {
        return this._subType;
      }, null, null, 1, 0, 7, "subType"],
      get$charset: [function() {
        return J.$index$asx(this.get$parameters(), "charset");
      }, null, null, 1, 0, 7, "charset"],
      _ContentType$4: function(primaryType, subType, charset, parameters) {
        var t1 = this._primaryType;
        if (t1 == null) {
          this._primaryType = "";
          t1 = "";
        }
        if (this._subType == null)
          this._subType = "";
        this._io$_value = H.S(t1) + "/" + H.S(this._subType);
        if (parameters != null) {
          this._ensureParameters$0();
          J.forEach$1$ax(parameters, new P._ContentType_closure(this));
        }
        if (charset != null) {
          this._ensureParameters$0();
          J.$indexSet$ax(this._io$_parameters, "charset", J.toLowerCase$0$s(charset));
        }
      },
      static: {
        _ContentType$: [function(primaryType, subType, charset, parameters) {
          var t1 = new P._ContentType(primaryType, subType, "", null, null);
          t1._HeaderValue$2("", null);
          t1._ContentType$4(primaryType, subType, charset, parameters);
          return t1;
        }, null, null, 8, 0, 877, 476, [], 475, [], 472, [], 117, [], "new _ContentType"],
        _ContentType$_: [function() {
          var t1 = new P._ContentType("", "", "", null, null);
          t1._HeaderValue$2("", null);
          return t1;
        }, null, null, 0, 0, 4, "new _ContentType$_"],
        _ContentType_parse: [function(value) {
          var result, index, t1, t2, t3;
          result = new P._ContentType("", "", "", null, null);
          result._HeaderValue$2("", null);
          result._parse$4(value, ";", null, false);
          index = J.indexOf$1$asx(result._io$_value, "/");
          t1 = J.getInterceptor(index);
          t2 = t1.$eq(index, -1) || t1.$eq(index, J.$sub$n(J.get$length$asx(result._io$_value), 1));
          t3 = result._io$_value;
          if (t2) {
            result._primaryType = J.trim$0$s(t3).toLowerCase();
            result._subType = "";
          } else {
            result._primaryType = C.JSString_methods.trim$0(J.substring$2$s(t3, 0, index)).toLowerCase();
            result._subType = C.JSString_methods.trim$0(J.substring$1$s(result._io$_value, t1.$add(index, 1))).toLowerCase();
          }
          return result;
        }, "call$1", "io__ContentType_parse$closure", 2, 0, 878, 1, [], "parse"]
      }
    },
    "+_ContentType": [1516, 494],
    _ContentType_closure: {
      "^": "Closure:40;$this",
      call$2: [function(key, value) {
        var lowerCaseKey = J.toLowerCase$0$s(key);
        if (lowerCaseKey === "charset")
          value = J.toLowerCase$0$s(value);
        J.$indexSet$ax(this.$this._io$_parameters, lowerCaseKey, value);
      }, null, null, 4, 0, 40, 6, [], 1, [], "call"]
    },
    "+ _ContentType_closure": [2],
    _Cookie: {
      "^": "Object;name@-9,value@-9,expires@-75,maxAge@-0,domain@-9,path@-9,httpOnly@-8,secure@-8",
      _parseSetCookieValue$1: [function(s) {
        var t1, t2;
        t1 = {};
        t1.index = 0;
        t2 = new P._Cookie__parseSetCookieValue_done(t1, s);
        this.name = new P._Cookie__parseSetCookieValue_parseName(t1, s, t2).call$0();
        if (t2.call$0() === true || J.$eq$(J.get$length$asx(this.name), 0))
          throw H.wrapException(new P.HttpException("Failed to parse header value [" + H.S(s) + "]", null));
        ++t1.index;
        this.value = new P._Cookie__parseSetCookieValue_parseValue(t1, s, t2).call$0();
        this._validate$0();
        if (t2.call$0() === true)
          return;
        ++t1.index;
        new P._Cookie__parseSetCookieValue_parseAttributes(t1, this, s, t2).call$0();
      }, "call$1", "get$_parseSetCookieValue", 2, 0, 19, 49, [], "_parseSetCookieValue"],
      toString$0: [function(_) {
        var t1, t2;
        t1 = H.S(this.name) + "=" + H.S(this.value);
        t2 = this.expires;
        if (t2 != null)
          t1 = t1 + "; Expires=" + P.HttpDate_format(t2);
        t2 = this.maxAge;
        if (t2 != null)
          t1 = t1 + "; Max-Age=" + H.S(t2);
        t2 = this.domain;
        if (t2 != null)
          t1 = t1 + "; Domain=" + H.S(t2);
        t2 = this.path;
        if (t2 != null)
          t1 = t1 + "; Path=" + H.S(t2);
        if (this.secure === true)
          t1 += "; Secure";
        if (this.httpOnly === true)
          t1 += "; HttpOnly";
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      _validate$0: [function() {
        var i, t1, codeUnit;
        i = 0;
        while (true) {
          t1 = J.get$length$asx(this.name);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          codeUnit = C.JSString_methods._codeUnitAt$1(J.get$codeUnits$s(this.name).__internal$_string, i);
          if (codeUnit <= 32 || codeUnit >= 127 || J.$ge$n(C.JSArray_methods.indexOf$1(C.List_A8J, J.$index$asx(this.name, i)), 0))
            throw H.wrapException(new P.FormatException("Invalid character in cookie name, code unit: '" + codeUnit + "'", null, null));
          ++i;
        }
        i = 0;
        while (true) {
          t1 = J.get$length$asx(this.value);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          codeUnit = C.JSString_methods._codeUnitAt$1(J.get$codeUnits$s(this.value).__internal$_string, i);
          if (codeUnit !== 33)
            if (!(codeUnit >= 35 && codeUnit <= 43))
              if (!(codeUnit >= 45 && codeUnit <= 58))
                if (!(codeUnit >= 60 && codeUnit <= 91))
                  t1 = codeUnit >= 93 && codeUnit <= 126;
                else
                  t1 = true;
              else
                t1 = true;
            else
              t1 = true;
          else
            t1 = true;
          if (!t1)
            throw H.wrapException(new P.FormatException("Invalid character in cookie value, code unit: '" + codeUnit + "'", null, null));
          ++i;
        }
      }, "call$0", "get$_validate", 0, 0, 6, "_validate"],
      value$1: function(arg0) {
        return this.value.call$1(arg0);
      },
      $isCookie: 1,
      static: {
        _Cookie$: [function($name, value) {
          var t1 = new P._Cookie($name, value, null, null, null, null, false, false);
          t1.httpOnly = true;
          t1._validate$0();
          return t1;
        }, null, null, 0, 4, 879, 0, 0, 13, [], 1, [], "new _Cookie"],
        _Cookie$fromSetCookieValue: [function(value) {
          var t1 = new P._Cookie(null, null, null, null, null, null, false, false);
          t1._parseSetCookieValue$1(value);
          return t1;
        }, null, null, 2, 0, 13, 1, [], "new _Cookie$fromSetCookieValue"]
      }
    },
    "+_Cookie": [1, 1517],
    _Cookie__parseSetCookieValue_done: {
      "^": "Closure:5;_box_0,s",
      call$0: [function() {
        return this._box_0.index === J.get$length$asx(this.s);
      }, null, null, 0, 0, 5, "call"]
    },
    "+ _Cookie__parseSetCookieValue_done": [2],
    _Cookie__parseSetCookieValue_parseName: {
      "^": "Closure:7;_box_0,s,done",
      call$0: [function() {
        var t1, start, t2, t3, t4;
        t1 = this._box_0;
        start = t1.index;
        for (t2 = this.done, t3 = this.s, t4 = J.getInterceptor$asx(t3); t2.call$0() !== true;) {
          if (J.$eq$(t4.$index(t3, t1.index), "="))
            break;
          ++t1.index;
        }
        return C.JSString_methods.trim$0(t4.substring$2(t3, start, t1.index));
      }, null, null, 0, 0, 7, "call"]
    },
    "+ _Cookie__parseSetCookieValue_parseName": [2],
    _Cookie__parseSetCookieValue_parseValue: {
      "^": "Closure:7;_box_0,s,done",
      call$0: [function() {
        var t1, start, t2, t3, t4;
        t1 = this._box_0;
        start = t1.index;
        for (t2 = this.done, t3 = this.s, t4 = J.getInterceptor$asx(t3); t2.call$0() !== true;) {
          if (J.$eq$(t4.$index(t3, t1.index), ";"))
            break;
          ++t1.index;
        }
        return C.JSString_methods.trim$0(t4.substring$2(t3, start, t1.index));
      }, null, null, 0, 0, 7, "call"]
    },
    "+ _Cookie__parseSetCookieValue_parseValue": [2],
    _Cookie__parseSetCookieValue_parseAttributes: {
      "^": "Closure:6;_box_0,$this,s,done",
      call$0: [function() {
        var t1, t2, t3, t4, t5, t6, t7, $name, value, t8;
        t1 = this._box_0;
        t2 = this.s;
        t3 = this.done;
        t4 = new P._Cookie__parseSetCookieValue_parseAttributes_parseAttributeName(t1, t2, t3);
        t5 = new P._Cookie__parseSetCookieValue_parseAttributes_parseAttributeValue(t1, t2, t3);
        for (t6 = J.getInterceptor$asx(t2), t7 = this.$this; t3.call$0() !== true;) {
          $name = t4.call$0();
          if (t3.call$0() !== true && J.$eq$(t6.$index(t2, t1.index), "=")) {
            ++t1.index;
            value = t5.call$0();
          } else
            value = "";
          t8 = J.getInterceptor($name);
          if (t8.$eq($name, "expires"))
            t7.expires = P.HttpDate__parseCookieDate(value);
          else if (t8.$eq($name, "max-age"))
            t7.maxAge = H.Primitives_parseInt(value, null, null);
          else if (t8.$eq($name, "domain"))
            t7.domain = value;
          else if (t8.$eq($name, "path"))
            t7.path = value;
          else if (t8.$eq($name, "httponly"))
            t7.httpOnly = true;
          else if (t8.$eq($name, "secure"))
            t7.secure = true;
          if (t3.call$0() !== true)
            ++t1.index;
        }
      }, null, null, 0, 0, 6, "call"]
    },
    "+ _Cookie__parseSetCookieValue_parseAttributes": [2],
    _Cookie__parseSetCookieValue_parseAttributes_parseAttributeName: {
      "^": "Closure:7;_box_0,s,done",
      call$0: [function() {
        var t1, start, t2, t3, t4;
        t1 = this._box_0;
        start = t1.index;
        for (t2 = this.done, t3 = this.s, t4 = J.getInterceptor$asx(t3); t2.call$0() !== true;) {
          if (J.$eq$(t4.$index(t3, t1.index), "=") || J.$eq$(t4.$index(t3, t1.index), ";"))
            break;
          ++t1.index;
        }
        return C.JSString_methods.trim$0(t4.substring$2(t3, start, t1.index)).toLowerCase();
      }, null, null, 0, 0, 7, "call"]
    },
    "+ _Cookie__parseSetCookieValue_parseAttributes_parseAttributeName": [2],
    _Cookie__parseSetCookieValue_parseAttributes_parseAttributeValue: {
      "^": "Closure:7;_box_0,s,done",
      call$0: [function() {
        var t1, start, t2, t3, t4;
        t1 = this._box_0;
        start = t1.index;
        for (t2 = this.done, t3 = this.s, t4 = J.getInterceptor$asx(t3); t2.call$0() !== true;) {
          if (J.$eq$(t4.$index(t3, t1.index), ";"))
            break;
          ++t1.index;
        }
        return C.JSString_methods.trim$0(t4.substring$2(t3, start, t1.index)).toLowerCase();
      }, null, null, 0, 0, 7, "call"]
    },
    "+ _Cookie__parseSetCookieValue_parseAttributes_parseAttributeValue": [2],
    _HttpIncoming: {
      "^": "Stream;_transferLength<-0,_dataCompleter<-41,_io$_stream@-42,fullBodyRead@-8,headers<-139,upgraded@-8,statusCode@-0,reasonPhrase@-9,method@-9,uri@-36,hasSubscriber@-8",
      get$transferLength: [function() {
        return this._transferLength;
      }, null, null, 1, 0, 11, "transferLength"],
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        this.hasSubscriber = true;
        return this._io$_stream.handleError$1(new P._HttpIncoming_listen_closure(this)).listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, onError);
      }, "listen$2$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, null);
      }, "listen$2$onDone", function(onData, cancelOnError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, null, null);
      }, "listen$2$cancelOnError", "call$4$cancelOnError$onDone$onError", "call$1", "call$2$onError", "call$3$onDone$onError", "call$3$onDone$onError", "call$2$onDone", "call$2$cancelOnError", "get$listen", 2, 7, 94, 0, 0, 0, 27, [], 20, [], 28, [], 24, [], "listen"],
      get$dataDone: [function() {
        return this._dataCompleter.get$future();
      }, null, null, 1, 0, 18, "dataDone"],
      close$1: [function(closing) {
        this.fullBodyRead = true;
        this.hasSubscriber = true;
        this._dataCompleter.complete$1(closing);
      }, "call$1", "get$close", 2, 0, 35, 237, [], "close"],
      $asStream: function() {
        return [[P.List, P.int]];
      },
      "<>": [],
      static: {
        _HttpIncoming$: [function(headers, _transferLength, _stream) {
          return new P._HttpIncoming(_transferLength, new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]), _stream, false, headers, false, null, null, null, null, false);
        }, null, null, 6, 0, 880, 414, [], 758, [], 163, [], "new _HttpIncoming"]
      }
    },
    "+_HttpIncoming": [42],
    _HttpIncoming_listen_closure: {
      "^": "Closure:3;$this",
      call$1: [function(error) {
        throw H.wrapException(new P.HttpException(error.get$message(), this.$this.uri));
      }, null, null, 2, 0, 3, 8, [], "call"]
    },
    "+ _HttpIncoming_listen_closure": [2],
    _HttpInboundMessage: {
      "^": "Stream;_incoming<-185,_cookies@-137",
      get$cookies: [function() {
        var t1 = this._cookies;
        if (t1 != null)
          return t1;
        t1 = this._incoming.get$headers()._parseCookies$0();
        this._cookies = t1;
        return t1;
      }, null, null, 1, 0, 191, "cookies"],
      get$headers: [function() {
        return this._incoming.get$headers();
      }, null, null, 1, 0, 660, "headers"],
      get$protocolVersion: [function() {
        return this._incoming.get$headers().get$protocolVersion();
      }, null, null, 1, 0, 7, "protocolVersion"],
      get$contentLength: [function() {
        return this._incoming.get$headers().get$contentLength();
      }, null, null, 1, 0, 11, "contentLength"],
      get$persistentConnection: [function() {
        return this._incoming.get$headers().get$persistentConnection();
      }, null, null, 1, 0, 5, "persistentConnection"],
      $asStream: function() {
        return [[P.List, P.int]];
      },
      "<>": [],
      static: {
        _HttpInboundMessage$: [function(_incoming) {
          return new P._HttpInboundMessage(_incoming, null);
        }, null, null, 2, 0, 881, 275, [], "new _HttpInboundMessage"]
      }
    },
    "+_HttpInboundMessage": [42],
    _HttpRequest: {
      "^": "_HttpInboundMessage;response<-499,_httpServer<-500,_httpConnection<-1523,_session@-154,_requestedUri@-36,_incoming-185,_cookies-137",
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        return this._incoming.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, onError);
      }, "listen$2$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, null);
      }, "listen$2$onDone", function(onData, cancelOnError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, null, null);
      }, "listen$2$cancelOnError", "call$4$cancelOnError$onDone$onError", "call$1", "call$2$onError", "call$3$onDone$onError", "call$3$onDone$onError", "call$2$onDone", "call$2$cancelOnError", "get$listen", 2, 7, 94, 0, 0, 0, 27, [], 20, [], 28, [], 24, [], "listen"],
      get$uri: [function() {
        return this._incoming.get$uri();
      }, null, null, 1, 0, 43, "uri"],
      get$requestedUri: [function() {
        var t1, proto, scheme, hostList, host, t2;
        t1 = this._requestedUri;
        if (t1 == null) {
          t1 = this._incoming;
          proto = J.$index$asx(t1.get$headers(), "x-forwarded-proto");
          if (proto != null)
            scheme = J.get$first$ax(proto);
          else
            scheme = this._httpConnection.get$_socket() instanceof P.SecureSocket ? "https" : "http";
          hostList = J.$index$asx(t1.get$headers(), "x-forwarded-host");
          if (hostList != null)
            host = J.get$first$ax(hostList);
          else {
            hostList = J.$index$asx(t1.get$headers(), "host");
            if (hostList != null)
              host = J.get$first$ax(hostList);
            else {
              t2 = this._httpServer;
              host = H.S(t2.get$address().get$host()) + ":" + H.S(t2.get$port());
            }
          }
          t1 = P.Uri_parse(H.S(scheme) + "://" + H.S(host) + H.S(t1.get$uri()), 0, null);
          this._requestedUri = t1;
        }
        return t1;
      }, null, null, 1, 0, 43, "requestedUri"],
      get$method: [function() {
        return this._incoming.get$method();
      }, null, null, 1, 0, 7, "method"],
      get$session: [function() {
        var t1 = this._session;
        if (t1 != null) {
          if (t1.get$_destroyed() === true) {
            this._session = null;
            return this.get$session();
          }
          return this._session;
        }
        t1 = this._httpServer.get$_sessionManager().createSession$0();
        this._session = t1;
        return t1;
      }, null, null, 1, 0, 344, "session"],
      get$connectionInfo: [function() {
        return this._httpConnection.get$connectionInfo();
      }, null, null, 1, 0, 97, "connectionInfo"],
      get$certificate: [function() {
        var socket = this._httpConnection.get$_socket();
        if (socket instanceof P.SecureSocket)
          return socket.get$peerCertificate();
        return;
      }, null, null, 1, 0, 233, "certificate"],
      _HttpRequest$4: function(response, _incoming, _httpServer, _httpConnection) {
        var t1, t2, sessionIds, sessionId, t3;
        t1 = this._incoming;
        if (J.$eq$(t1.get$headers().get$protocolVersion(), "1.1")) {
          t2 = this.response.get$headers();
          t2.set$chunkedTransferEncoding(true);
          t2.set$persistentConnection(t1.get$headers().get$persistentConnection());
        }
        t1 = this._httpServer;
        if (t1.get$_sessionManagerInstance() != null) {
          sessionIds = J.where$1$ax(this.get$cookies(), new P._HttpRequest_closure()).map$1(0, new P._HttpRequest_closure0());
          for (t2 = sessionIds.get$iterator(sessionIds); t2.moveNext$0();) {
            sessionId = t2.get$current();
            t3 = t1.get$_sessionManager().getSession$1(sessionId);
            this._session = t3;
            if (t3 != null) {
              t3._markSeen$0();
              break;
            }
          }
        }
      },
      $isHttpRequest: 1,
      static: {
        _HttpRequest$: [function(response, _incoming, _httpServer, _httpConnection) {
          var t1 = new P._HttpRequest(response, _httpServer, _httpConnection, null, null, _incoming, null);
          t1._HttpRequest$4(response, _incoming, _httpServer, _httpConnection);
          return t1;
        }, null, null, 8, 0, 882, 18, [], 275, [], 456, [], 761, [], "new _HttpRequest"]
      }
    },
    "+_HttpRequest": [501, 1526],
    _HttpRequest_closure: {
      "^": "Closure:3;",
      call$1: [function(cookie) {
        return J.toUpperCase$0$s(cookie.get$name()) === "DARTSESSID";
      }, null, null, 2, 0, 3, 408, [], "call"]
    },
    "+ _HttpRequest_closure": [2],
    _HttpRequest_closure0: {
      "^": "Closure:3;",
      call$1: [function(cookie) {
        return cookie.get$value();
      }, null, null, 2, 0, 3, 408, [], "call"]
    },
    "+ _HttpRequest_closure": [2],
    _HttpClientResponse: {
      "^": "_HttpInboundMessage;_httpClient<-279,_httpRequest<-1528,_incoming-185,_cookies-137",
      get$redirects: [function() {
        return this._httpRequest.get$_responseRedirects();
      }, null, null, 1, 0, 688, "redirects"],
      get$statusCode: [function() {
        return this._incoming.get$statusCode();
      }, null, null, 1, 0, 11, "statusCode"],
      get$reasonPhrase: [function() {
        return this._incoming.get$reasonPhrase();
      }, null, null, 1, 0, 7, "reasonPhrase"],
      get$certificate: [function() {
        var socket = this._httpRequest.get$_httpClientConnection().get$_socket();
        if (socket instanceof P.SecureSocket)
          return socket.get$peerCertificate();
        throw H.wrapException(new P.UnsupportedError("Socket is not a SecureSocket"));
      }, null, null, 1, 0, 233, "certificate"],
      get$cookies: [function() {
        var t1, values;
        t1 = this._cookies;
        if (t1 != null)
          return t1;
        this._cookies = H.setRuntimeTypeInfo([], [P.Cookie]);
        values = J.$index$asx(this._incoming.get$headers(), "set-cookie");
        if (values != null)
          J.forEach$1$ax(values, new P._HttpClientResponse_cookies_closure(this));
        return this._cookies;
      }, null, null, 1, 0, 191, "cookies"],
      get$isRedirect: [function() {
        var t1 = this._httpRequest;
        if (J.$eq$(t1.get$method(), "GET") || J.$eq$(t1.get$method(), "HEAD")) {
          t1 = this._incoming;
          return J.$eq$(t1.get$statusCode(), 301) || J.$eq$(t1.get$statusCode(), 302) || J.$eq$(t1.get$statusCode(), 303) || J.$eq$(t1.get$statusCode(), 307);
        } else if (J.$eq$(t1.get$method(), "POST"))
          return J.$eq$(this._incoming.get$statusCode(), 303);
        return false;
      }, null, null, 1, 0, 5, "isRedirect"],
      redirect$3: [function(method, url, followLoops) {
        var t1, $location, t2, t3;
        t1 = {};
        t1.method = method;
        t1.url = url;
        if (method == null)
          if (J.$eq$(this._incoming.get$statusCode(), 303) && J.$eq$(this._httpRequest.get$method(), "POST"))
            t1.method = "GET";
          else
            t1.method = this._httpRequest.get$method();
        if (url == null) {
          $location = this._incoming.get$headers().value$1("location");
          if ($location == null)
            throw H.wrapException(new P.StateError("Response has no Location header for redirect"));
          t1.url = P.Uri_parse($location, 0, null);
        }
        if (!J.$eq$(followLoops, true))
          for (t2 = this._httpRequest, t3 = J.get$iterator$ax(t2.get$_responseRedirects()); t3.moveNext$0();)
            if (J.$eq$(t3.get$current().get$location(), t1.url))
              return P.Future_Future$error(new P.RedirectException("Redirect loop detected", t2.get$_responseRedirects()), null, null);
        return this._httpClient._openUrlFromRequest$3(t1.method, t1.url, this._httpRequest).then$1(new P._HttpClientResponse_redirect_closure(t1, this));
      }, function(method) {
        return this.redirect$3(method, null, null);
      }, "redirect$1", function(method, url) {
        return this.redirect$3(method, url, null);
      }, "redirect$2", function() {
        return this.redirect$3(null, null, null);
      }, "redirect$0", "call$3", "call$1", "call$2", "call$0", "get$redirect", 0, 6, 698, 0, 0, 0, 98, [], 75, [], 877, [], "redirect"],
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        var stream, t1;
        stream = this._incoming;
        if (stream.get$upgraded() === true) {
          this._httpRequest.get$_httpClientConnection().destroy$0();
          t1 = new P._DoneStreamSubscription($.Zone__current, 0, onDone, [[P.List, P.int]]);
          t1._schedule$0();
          return t1;
        }
        if (this._httpClient.get$autoUncompress() === true && J.$eq$(stream.get$headers().value$1("content-encoding"), "gzip")) {
          P._validateZLibWindowBits(15);
          stream = stream.transform$1(new P.ZLibDecoder(15, null, false));
        }
        return stream.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, onError);
      }, "listen$2$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, null);
      }, "listen$2$onDone", function(onData, cancelOnError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, null, null);
      }, "listen$2$cancelOnError", "call$4$cancelOnError$onDone$onError", "call$1", "call$2$onError", "call$3$onDone$onError", "call$3$onDone$onError", "call$2$onDone", "call$2$cancelOnError", "get$listen", 2, 7, 94, 0, 0, 0, 27, [], 20, [], 28, [], 24, [], "listen"],
      detachSocket$0: [function() {
        var t1 = this._httpRequest;
        this._httpClient._connectionClosed$1(t1.get$_httpClientConnection());
        return t1.get$_httpClientConnection().detachSocket$0();
      }, "call$0", "get$detachSocket", 0, 0, 104, "detachSocket"],
      get$connectionInfo: [function() {
        return this._httpRequest.get$connectionInfo();
      }, null, null, 1, 0, 97, "connectionInfo"],
      get$_shouldAuthenticateProxy: [function() {
        var t1, challenge;
        t1 = this._incoming;
        challenge = J.$index$asx(t1.get$headers(), "proxy-authenticate");
        return J.$eq$(t1.get$statusCode(), 407) && challenge != null && J.$eq$(J.get$length$asx(challenge), 1);
      }, null, null, 1, 0, 5, "_shouldAuthenticateProxy"],
      get$_shouldAuthenticate: [function() {
        var t1, challenge;
        t1 = this._incoming;
        challenge = J.$index$asx(t1.get$headers(), "www-authenticate");
        return J.$eq$(t1.get$statusCode(), 401) && challenge != null && J.$eq$(J.get$length$asx(challenge), 1);
      }, null, null, 1, 0, 5, "_shouldAuthenticate"],
      _authenticate$1: [function(proxyAuth) {
        var t1, t2, t3, result, scheme, realm, cr, t4;
        t1 = {};
        t2 = new P._HttpClientResponse__authenticate_retry(this);
        t3 = J.$index$asx(new P._HttpClientResponse__authenticate_authChallenge(this, proxyAuth).call$0(), 0);
        result = P._HeaderValue$("", null);
        result._parse$4(t3, ",", null, false);
        scheme = P._AuthenticationScheme__AuthenticationScheme$fromString(result._io$_value);
        realm = J.$index$asx(result.get$parameters(), "realm");
        cr = new P._HttpClientResponse__authenticate_findCredentials(this, proxyAuth).call$1(scheme);
        t1.cr = cr;
        t3 = cr != null;
        if (t3) {
          if (J.$eq$(cr.get$scheme(), C._AuthenticationScheme_0) && cr.get$used() !== true)
            return t2.call$0();
          if (J.$eq$(cr.get$scheme(), C._AuthenticationScheme_1))
            t4 = J.$index$asx(result.get$parameters(), "algorithm") == null || J.toLowerCase$0$s(J.$index$asx(result.get$parameters(), "algorithm")) === "md5";
          else
            t4 = false;
          if (t4)
            if (cr.get$nonce() == null || J.$eq$(cr.get$nonce(), J.$index$asx(result.get$parameters(), "nonce"))) {
              if (cr.get$nonce() == null) {
                cr.set$nonce(J.$index$asx(result.get$parameters(), "nonce"));
                cr.set$algorithm("MD5");
                cr.set$qop(J.$index$asx(result.get$parameters(), "qop"));
                cr.set$nonceCount(0);
              }
              return t2.call$0();
            } else if (J.$index$asx(result.get$parameters(), "stale") != null && J.toLowerCase$0$s(J.$index$asx(result.get$parameters(), "stale")) === "true") {
              cr.set$nonce(J.$index$asx(result.get$parameters(), "nonce"));
              return t2.call$0();
            }
        }
        if (t3) {
          new P._HttpClientResponse__authenticate_removeCredentials(this, proxyAuth).call$1(cr);
          t1.cr = null;
        }
        return new P._HttpClientResponse__authenticate_requestAuthentication(this, proxyAuth).call$2(scheme, realm).then$1(new P._HttpClientResponse__authenticate_closure(t1, this, t2, scheme));
      }, "call$1", "get$_authenticate", 2, 0, 729, 878, [], "_authenticate"],
      $isHttpClientResponse: 1,
      static: {
        _HttpClientResponse$: [function(_incoming, _httpRequest, _httpClient) {
          _incoming.set$uri(_httpRequest.get$uri());
          return new P._HttpClientResponse(_httpClient, _httpRequest, _incoming, null);
        }, null, null, 6, 0, 883, 275, [], 762, [], 415, [], "new _HttpClientResponse"]
      }
    },
    "+_HttpClientResponse": [501, 1529],
    _HttpClientResponse_cookies_closure: {
      "^": "Closure:3;$this",
      call$1: [function(value) {
        var t1, t2;
        t1 = this.$this._cookies;
        t2 = new P._Cookie(null, null, null, null, null, null, false, false);
        t2._parseSetCookieValue$1(value);
        J.add$1$ax(t1, t2);
      }, null, null, 2, 0, 3, 1, [], "call"]
    },
    "+ _HttpClientResponse_cookies_closure": [2],
    _HttpClientResponse_redirect_closure: {
      "^": "Closure:3;_box_0,$this",
      call$1: [function(request) {
        var t1, t2, t3, t4;
        t1 = request.get$_responseRedirects();
        t2 = this.$this;
        t3 = J.getInterceptor$ax(t1);
        t3.addAll$1(t1, t2._httpRequest.get$_responseRedirects());
        t4 = this._box_0;
        t3.add$1(t1, new P._RedirectInfo(t2._incoming.get$statusCode(), t4.method, t4.url));
        return request.close$0();
      }, null, null, 2, 0, 3, 54, [], "call"]
    },
    "+ _HttpClientResponse_redirect_closure": [2],
    _HttpClientResponse__authenticate_retry: {
      "^": "Closure:205;$this",
      call$0: [function() {
        var t1 = this.$this;
        return t1.listen$2$cancelOnError(null, true).asFuture$1(null).then$1(new P._HttpClientResponse__authenticate_retry_closure(t1));
      }, null, null, 0, 0, 205, "call"]
    },
    "+ _HttpClientResponse__authenticate_retry": [2],
    _HttpClientResponse__authenticate_retry_closure: {
      "^": "Closure:3;$this",
      call$1: [function(_) {
        var t1, t2;
        t1 = this.$this;
        t2 = t1._httpRequest;
        return t1._httpClient._openUrlFromRequest$3(t2.get$method(), t2.get$uri(), t2).then$1(new P._HttpClientResponse__authenticate_retry__closure());
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _HttpClientResponse__authenticate_retry_closure": [2],
    _HttpClientResponse__authenticate_retry__closure: {
      "^": "Closure:3;",
      call$1: [function(request) {
        return request.close$0();
      }, null, null, 2, 0, 3, 54, [], "call"]
    },
    "+ _HttpClientResponse__authenticate_retry__closure": [2],
    _HttpClientResponse__authenticate_authChallenge: {
      "^": "Closure:93;$this,proxyAuth",
      call$0: [function() {
        var t1 = this.$this._incoming;
        return this.proxyAuth === true ? J.$index$asx(t1.get$headers(), "proxy-authenticate") : J.$index$asx(t1.get$headers(), "www-authenticate");
      }, null, null, 0, 0, 93, "call"]
    },
    "+ _HttpClientResponse__authenticate_authChallenge": [2],
    _HttpClientResponse__authenticate_findCredentials: {
      "^": "Closure:348;$this,proxyAuth",
      call$1: [function(scheme) {
        var t1, t2;
        t1 = this.$this;
        t2 = t1._httpClient;
        t1 = t1._httpRequest;
        return this.proxyAuth === true ? t2._findProxyCredentials$2(t1.get$_proxy(), scheme) : t2._findCredentials$2(t1.get$uri(), scheme);
      }, null, null, 2, 0, 348, 44, [], "call"]
    },
    "+ _HttpClientResponse__authenticate_findCredentials": [2],
    _HttpClientResponse__authenticate_removeCredentials: {
      "^": "Closure:206;$this,proxyAuth",
      call$1: [function(cr) {
        var t1 = this.$this._httpClient;
        if (this.proxyAuth === true)
          t1._removeProxyCredentials$1(cr);
        else
          t1._removeCredentials$1(cr);
      }, null, null, 2, 0, 206, 190, [], "call"]
    },
    "+ _HttpClientResponse__authenticate_removeCredentials": [2],
    _HttpClientResponse__authenticate_requestAuthentication: {
      "^": "Closure:349;$this,proxyAuth",
      call$2: [function(scheme, realm) {
        var t1, t2, proxy;
        if (this.proxyAuth === true) {
          t1 = this.$this;
          t2 = t1._httpClient;
          if (t2.get$_authenticateProxy() == null) {
            t1 = new P._Future(0, $.Zone__current, null, [null]);
            t1._asyncComplete$1(false);
            return t1;
          }
          proxy = t1._httpRequest.get$_proxy();
          return t2._authenticateProxy$4(proxy.get$host(), proxy.get$port(), scheme.toString$0(0), realm);
        } else {
          t1 = this.$this;
          t2 = t1._httpClient;
          if (t2.get$_authenticate() == null) {
            t1 = new P._Future(0, $.Zone__current, null, [null]);
            t1._asyncComplete$1(false);
            return t1;
          }
          return t2._authenticate$3(t1._httpRequest.get$uri(), scheme.toString$0(0), realm);
        }
      }, null, null, 4, 0, 349, 44, [], 152, [], "call"]
    },
    "+ _HttpClientResponse__authenticate_requestAuthentication": [2],
    _HttpClientResponse__authenticate_closure: {
      "^": "Closure:3;_box_0,$this,retry,scheme",
      call$1: [function(credsAvailable) {
        var t1 = this.$this;
        if (credsAvailable === true) {
          this._box_0.cr = t1._httpClient._findCredentials$2(t1._httpRequest.get$uri(), this.scheme);
          return this.retry.call$0();
        } else
          return t1;
      }, null, null, 2, 0, 3, 880, [], "call"]
    },
    "+ _HttpClientResponse__authenticate_closure": [2],
    _HttpOutboundMessage: {
      "^": "_IOSinkImpl;_encodingSet@-8,_bufferOutput@-8,_io$_uri<-36,_outgoing<-280,headers<-139,_encoding-79,_encodingMutable-8,_io$_target-153,_doneCompleter-41,_controllerInstance-156,_controllerCompleter-41,_io$_isClosed-8,_isBound-8,_io$_hasError-8,$ti",
      get$contentLength: [function() {
        return this.headers.get$contentLength();
      }, null, null, 1, 0, 11, "contentLength"],
      set$contentLength: [function(contentLength) {
        this.headers.set$contentLength(contentLength);
      }, null, null, 3, 0, 17, 495, [], "contentLength"],
      get$persistentConnection: [function() {
        return this.headers.get$persistentConnection();
      }, null, null, 1, 0, 5, "persistentConnection"],
      set$persistentConnection: [function(p) {
        this.headers.set$persistentConnection(p);
      }, null, null, 3, 0, 35, 881, [], "persistentConnection"],
      get$bufferOutput: [function() {
        return this._bufferOutput;
      }, null, null, 1, 0, 5, "bufferOutput"],
      set$bufferOutput: [function(bufferOutput) {
        if (this._outgoing.get$headersWritten() === true)
          throw H.wrapException(new P.StateError("Header already sent"));
        this._bufferOutput = bufferOutput;
      }, null, null, 3, 0, 35, 882, [], "bufferOutput"],
      get$encoding: [function() {
        if (this._encodingSet === true && this._outgoing.get$headersWritten() === true)
          return this._encoding;
        var t1 = this.headers;
        return P.Encoding_getByName(t1.get$contentType() != null && t1.get$contentType().get$charset() != null ? t1.get$contentType().get$charset() : "iso-8859-1");
      }, null, null, 1, 0, 207, "encoding"],
      add$1: [function(_, data) {
        if (J.$eq$(J.get$length$asx(data), 0))
          return;
        this.super$_StreamSinkImpl$add(0, data);
      }, "call$1", "get$add", 2, 0, 26, 21, [], "add"],
      write$1: [function(obj) {
        if (this._encodingSet !== true) {
          this._encoding = this.get$encoding();
          this._encodingSet = true;
        }
        this.super$_IOSinkImpl$write(obj);
      }, "call$1", "get$write", 2, 0, 64, 143, [], "write"],
      get$_isConnectionClosed: [function() {
        return false;
      }, null, null, 1, 0, 5, "_isConnectionClosed"],
      _HttpOutboundMessage$4$initialHeaders: function(uri, protocolVersion, outgoing, initialHeaders, $T) {
        this._outgoing.set$outbound(this);
        this._encodingMutable = false;
      },
      "<>": [909],
      static: {
        _HttpOutboundMessage$: [function(uri, protocolVersion, outgoing, initialHeaders, $T) {
          var t1 = new P._HttpOutboundMessage(false, true, uri, outgoing, P._HttpHeaders$(protocolVersion, J.$eq$(uri.get$scheme(), "https") ? 443 : 80, initialHeaders), null, true, outgoing, new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]), null, null, false, false, false, [$T]);
          t1._HttpOutboundMessage$4$initialHeaders(uri, protocolVersion, outgoing, initialHeaders, $T);
          return t1;
        }, null, null, 6, 3, 884, 0, 40, [], 413, [], 416, [], 463, [], "new _HttpOutboundMessage"]
      }
    },
    "+_HttpOutboundMessage": [1533],
    _HttpResponse: {
      "^": "_HttpOutboundMessage;_statusCode@-0,_reasonPhrase@-9,_cookies@-137,_httpRequest@-1534,_deadline@-65,_deadlineTimer@-128,_encodingSet-8,_bufferOutput-8,_io$_uri-36,_outgoing-280,headers-139,_encoding-79,_encodingMutable-8,_io$_target-153,_doneCompleter-41,_controllerInstance-156,_controllerCompleter-41,_io$_isClosed-8,_isBound-8,_io$_hasError-8",
      get$_isConnectionClosed: [function() {
        return this._httpRequest.get$_httpConnection().get$_isClosing();
      }, null, null, 1, 0, 5, "_isConnectionClosed"],
      get$cookies: [function() {
        var t1 = this._cookies;
        if (t1 == null) {
          t1 = H.setRuntimeTypeInfo([], [P.Cookie]);
          this._cookies = t1;
        }
        return t1;
      }, null, null, 1, 0, 191, "cookies"],
      get$statusCode: [function() {
        return this._statusCode;
      }, null, null, 1, 0, 11, "statusCode"],
      set$statusCode: [function(statusCode) {
        if (this._outgoing.get$headersWritten() === true)
          throw H.wrapException(new P.StateError("Header already sent"));
        this._statusCode = statusCode;
      }, null, null, 3, 0, 17, 350, [], "statusCode"],
      get$reasonPhrase: [function() {
        return this._findReasonPhrase$1(this._statusCode);
      }, null, null, 1, 0, 7, "reasonPhrase"],
      set$reasonPhrase: [function(reasonPhrase) {
        if (this._outgoing.get$headersWritten() === true)
          throw H.wrapException(new P.StateError("Header already sent"));
        this._reasonPhrase = reasonPhrase;
      }, null, null, 3, 0, 19, 883, [], "reasonPhrase"],
      redirect$2$status: [function($location, $status) {
        var t1 = this._outgoing;
        if (t1.get$headersWritten() === true)
          throw H.wrapException(new P.StateError("Header already sent"));
        if (t1.get$headersWritten() === true)
          H.throwExpression(new P.StateError("Header already sent"));
        this._statusCode = $status;
        this.headers.$set$2("location", J.toString$0$($location));
        return this.close$0();
      }, function($location) {
        return this.redirect$2$status($location, 302);
      }, "redirect$1", "call$2$status", "call$1", "get$redirect", 2, 3, 761, 884, 444, [], 256, [], "redirect"],
      detachSocket$1$writeHeaders: [function(writeHeaders) {
        var t1, future;
        t1 = this._outgoing;
        if (t1.get$headersWritten() === true)
          throw H.wrapException(new P.StateError("Headers already sent"));
        this.set$deadline(null);
        future = this._httpRequest.get$_httpConnection().detachSocket$0();
        if (writeHeaders === true)
          t1.writeHeaders$2$drainRequest$setOutgoing(false, false);
        else
          t1.set$headersWritten(true);
        this.close$0();
        this._doneCompleter.get$future().catchError$1(new P._HttpResponse_detachSocket_closure());
        return future;
      }, function() {
        return this.detachSocket$1$writeHeaders(true);
      }, "detachSocket$0", "call$1$writeHeaders", "call$0", "get$detachSocket", 0, 3, 774, 25, 885, [], "detachSocket"],
      get$connectionInfo: [function() {
        return this._httpRequest.get$connectionInfo();
      }, null, null, 1, 0, 97, "connectionInfo"],
      get$deadline: [function() {
        return this._deadline;
      }, null, null, 1, 0, 83, "deadline"],
      set$deadline: [function(d) {
        var t1 = this._deadlineTimer;
        if (t1 != null)
          t1.cancel$0();
        this._deadline = d;
        if (d == null)
          return;
        this._deadlineTimer = P.Timer_Timer(d, new P._HttpResponse_deadline_closure(this));
      }, null, null, 3, 0, 162, 306, [], "deadline"],
      _writeHeader$0: [function() {
        var buffer, t1, session, t2, found, i, t3, cookie, headerBytes;
        buffer = P._CopyingBytesBuilder$(8192);
        t1 = this.headers;
        if (J.$eq$(t1.get$protocolVersion(), "1.1"))
          buffer.add$1(0, C.List_2Vk0);
        else
          buffer.add$1(0, C.List_2Vk1);
        buffer.addByte$1(32);
        buffer.add$1(0, J.get$codeUnits$s(J.toString$0$(this._statusCode)));
        buffer.addByte$1(32);
        buffer.add$1(0, J.get$codeUnits$s(this._findReasonPhrase$1(this._statusCode)));
        buffer.addByte$1(13);
        buffer.addByte$1(10);
        session = this._httpRequest.get$_session();
        if (session != null && session.get$_destroyed() !== true) {
          session.set$_isNew(false);
          t2 = [P.Cookie];
          found = false;
          i = 0;
          while (true) {
            t3 = this._cookies;
            if (t3 == null) {
              t3 = H.setRuntimeTypeInfo([], t2);
              this._cookies = t3;
            }
            t3 = J.get$length$asx(t3);
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (!(i < t3))
              break;
            t3 = this._cookies;
            if (t3 == null) {
              t3 = H.setRuntimeTypeInfo([], t2);
              this._cookies = t3;
            }
            if (J.toUpperCase$0$s(J.$index$asx(t3, i).get$name()) === "DARTSESSID") {
              t3 = this._cookies;
              if (t3 == null) {
                t3 = H.setRuntimeTypeInfo([], t2);
                this._cookies = t3;
              }
              t3 = J.$index$asx(t3, i);
              t3.set$value(session.get$id());
              t3.set$httpOnly(true);
              t3.set$path("/");
              found = true;
            }
            ++i;
          }
          if (!found) {
            cookie = new P._Cookie("DARTSESSID", session.get$id(), null, null, null, null, false, false);
            cookie.httpOnly = true;
            cookie._validate$0();
            t2 = this.get$cookies();
            cookie.httpOnly = true;
            cookie.path = "/";
            J.add$1$ax(t2, cookie);
          }
        }
        t2 = this._cookies;
        if (t2 != null)
          J.forEach$1$ax(t2, new P._HttpResponse__writeHeader_closure(this));
        t1._finalize$0();
        t1._build$1(buffer);
        buffer.addByte$1(13);
        buffer.addByte$1(10);
        headerBytes = buffer.takeBytes$0();
        this._outgoing.setHeader$2(headerBytes, headerBytes.length);
      }, "call$0", "get$_writeHeader", 0, 0, 6, "_writeHeader"],
      _findReasonPhrase$1: [function(statusCode) {
        var t1 = this._reasonPhrase;
        if (t1 != null)
          return t1;
        switch (statusCode) {
          case 100:
            return "Continue";
          case 101:
            return "Switching Protocols";
          case 200:
            return "OK";
          case 201:
            return "Created";
          case 202:
            return "Accepted";
          case 203:
            return "Non-Authoritative Information";
          case 204:
            return "No Content";
          case 205:
            return "Reset Content";
          case 206:
            return "Partial Content";
          case 300:
            return "Multiple Choices";
          case 301:
            return "Moved Permanently";
          case 302:
            return "Found";
          case 303:
            return "See Other";
          case 304:
            return "Not Modified";
          case 305:
            return "Use Proxy";
          case 307:
            return "Temporary Redirect";
          case 400:
            return "Bad Request";
          case 401:
            return "Unauthorized";
          case 402:
            return "Payment Required";
          case 403:
            return "Forbidden";
          case 404:
            return "Not Found";
          case 405:
            return "Method Not Allowed";
          case 406:
            return "Not Acceptable";
          case 407:
            return "Proxy Authentication Required";
          case 408:
            return "Request Time-out";
          case 409:
            return "Conflict";
          case 410:
            return "Gone";
          case 411:
            return "Length Required";
          case 412:
            return "Precondition Failed";
          case 413:
            return "Request Entity Too Large";
          case 414:
            return "Request-URI Too Large";
          case 415:
            return "Unsupported Media Type";
          case 416:
            return "Requested range not satisfiable";
          case 417:
            return "Expectation Failed";
          case 500:
            return "Internal Server Error";
          case 501:
            return "Not Implemented";
          case 502:
            return "Bad Gateway";
          case 503:
            return "Service Unavailable";
          case 504:
            return "Gateway Time-out";
          case 505:
            return "Http Version not supported";
          default:
            return "Status " + H.S(statusCode);
        }
      }, "call$1", "get$_findReasonPhrase", 2, 0, 25, 350, [], "_findReasonPhrase"],
      $as_HttpOutboundMessage: function() {
        return [P.HttpResponse];
      },
      $as_StreamSinkImpl: function() {
        return [[P.List, P.int]];
      },
      $isHttpResponse: 1,
      "<>": [],
      static: {
        _HttpResponse$: [function(uri, protocolVersion, outgoing, defaultHeaders, serverHeader) {
          var t1, t2;
          t1 = P._HttpHeaders$(protocolVersion, J.$eq$(uri.get$scheme(), "https") ? 443 : 80, defaultHeaders);
          t2 = new P._HttpResponse(200, null, null, null, null, null, false, true, uri, outgoing, t1, null, true, outgoing, new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]), null, null, false, false, false);
          t2._HttpOutboundMessage$4$initialHeaders(uri, protocolVersion, outgoing, defaultHeaders, P.HttpResponse);
          if (serverHeader != null)
            t1.$set$2("server", serverHeader);
          return t2;
        }, null, null, 10, 0, 885, 40, [], 413, [], 416, [], 765, [], 766, [], "new _HttpResponse"]
      }
    },
    "+_HttpResponse": [1536, 499],
    _HttpResponse_detachSocket_closure: {
      "^": "Closure:3;",
      call$1: [function(_) {
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _HttpResponse_detachSocket_closure": [2],
    _HttpResponse_deadline_closure: {
      "^": "Closure:4;$this",
      call$0: [function() {
        this.$this._httpRequest.get$_httpConnection().destroy$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _HttpResponse_deadline_closure": [2],
    _HttpResponse__writeHeader_closure: {
      "^": "Closure:3;$this",
      call$1: [function(cookie) {
        J.add$2$ax(this.$this.headers, "set-cookie", cookie);
      }, null, null, 2, 0, 3, 408, [], "call"]
    },
    "+ _HttpResponse__writeHeader_closure": [2],
    _HttpClientRequest: {
      "^": "_HttpOutboundMessage;method<-9,uri<-36,cookies<-137,_httpClient<-279,_httpClientConnection<-504,_responseCompleter<-1538,_proxy<-505,_response@-1540,_followRedirects@-8,_maxRedirects@-0,_responseRedirects@-497,_encodingSet-8,_bufferOutput-8,_io$_uri-36,_outgoing-280,headers-139,_encoding-79,_encodingMutable-8,_io$_target-153,_doneCompleter-41,_controllerInstance-156,_controllerCompleter-41,_io$_isClosed-8,_isBound-8,_io$_hasError-8",
      get$done: [function() {
        var t1 = this._response;
        if (t1 == null) {
          t1 = P.Future_wait([this._responseCompleter.get$future(), P._StreamSinkImpl.prototype.get$done.call(this)], null, true).then$1(new P._HttpClientRequest_done_closure());
          this._response = t1;
        }
        return t1;
      }, null, null, 1, 0, 205, "done"],
      close$0: [function() {
        this.super$_StreamSinkImpl$close();
        return this.get$done();
      }, "call$0", "get$close", 0, 0, 205, "close"],
      get$maxRedirects: [function() {
        return this._maxRedirects;
      }, null, null, 1, 0, 11, "maxRedirects"],
      set$maxRedirects: [function(maxRedirects) {
        if (this._outgoing.get$headersWritten() === true)
          throw H.wrapException(new P.StateError("Request already sent"));
        this._maxRedirects = maxRedirects;
      }, null, null, 3, 0, 17, 886, [], "maxRedirects"],
      get$followRedirects: [function() {
        return this._followRedirects;
      }, null, null, 1, 0, 5, "followRedirects"],
      set$followRedirects: [function(followRedirects) {
        if (this._outgoing.get$headersWritten() === true)
          throw H.wrapException(new P.StateError("Request already sent"));
        this._followRedirects = followRedirects;
      }, null, null, 3, 0, 35, 887, [], "followRedirects"],
      get$connectionInfo: [function() {
        return this._httpClientConnection.get$connectionInfo();
      }, null, null, 1, 0, 97, "connectionInfo"],
      _onIncoming$1: [function(incoming) {
        var response, future, challenge;
        response = new P._HttpClientResponse(this._httpClient, this, incoming, null);
        incoming.set$uri(this.uri);
        if (this._followRedirects === true && response.get$isRedirect())
          future = J.$lt$n(J.get$length$asx(this._responseRedirects), this._maxRedirects) ? response.listen$2$cancelOnError(null, true).asFuture$1(null).then$1(new P._HttpClientRequest__onIncoming_closure(response)) : response.listen$2$cancelOnError(null, true).asFuture$1(null).then$1(new P._HttpClientRequest__onIncoming_closure0(response));
        else {
          challenge = J.$index$asx(incoming.get$headers(), "proxy-authenticate");
          if (J.$eq$(incoming.get$statusCode(), 407) && challenge != null && J.$eq$(J.get$length$asx(challenge), 1))
            future = response._authenticate$1(true);
          else {
            challenge = J.$index$asx(incoming.get$headers(), "www-authenticate");
            if (J.$eq$(incoming.get$statusCode(), 401) && challenge != null && J.$eq$(J.get$length$asx(challenge), 1))
              future = response._authenticate$1(false);
            else {
              future = new P._Future(0, $.Zone__current, null, [P.HttpClientResponse]);
              future._asyncComplete$1(response);
            }
          }
        }
        future.then$2$onError(new P._HttpClientRequest__onIncoming_closure1(this), this._responseCompleter.get$completeError());
      }, "call$1", "get$_onIncoming", 2, 0, 794, 236, [], "_onIncoming"],
      _io$_onError$2: [function(error, stackTrace) {
        this._responseCompleter.completeError$2(error, stackTrace);
      }, "call$2", "get$_io$_onError", 4, 0, 71, 8, [], 12, [], "_io$_onError"],
      _requestUri$0: [function() {
        var t1 = new P._HttpClientRequest__requestUri_uriStartingFromPath(this);
        if (this._proxy.get$isDirect() === true)
          return t1.call$0();
        else if (J.$eq$(this.method, "CONNECT")) {
          t1 = this.uri;
          return H.S(t1.get$host()) + ":" + H.S(t1.get$port());
        } else if (this._httpClientConnection.get$_proxyTunnel() === true)
          return t1.call$0();
        else
          return this.uri.removeFragment$0().toString$0(0);
      }, "call$0", "get$_requestUri", 0, 0, 7, "_requestUri"],
      _writeHeader$0: [function() {
        var buffer, t1, t2, i, t3, t4, headerBytes;
        buffer = P._CopyingBytesBuilder$(8192);
        buffer.add$1(0, J.get$codeUnits$s(this.method));
        buffer.addByte$1(32);
        buffer.add$1(0, J.get$codeUnits$s(this._requestUri$0()));
        buffer.addByte$1(32);
        buffer.add$1(0, C.List_2Vk0);
        buffer.addByte$1(13);
        buffer.addByte$1(10);
        t1 = this.cookies;
        t2 = J.getInterceptor$asx(t1);
        if (t2.get$isEmpty(t1) !== true) {
          i = 0;
          t3 = "";
          while (true) {
            t4 = t2.get$length(t1);
            if (typeof t4 !== "number")
              return H.iae(t4);
            if (!(i < t4))
              break;
            if (i > 0)
              t3 += "; ";
            t3 = t3 + H.S(t2.$index(t1, i).get$name()) + "=" + H.S(t2.$index(t1, i).get$value());
            ++i;
          }
          J.add$2$ax(this.headers, "cookie", t3.charCodeAt(0) == 0 ? t3 : t3);
        }
        t1 = this.headers;
        t1._finalize$0();
        t1._build$1(buffer);
        buffer.addByte$1(13);
        buffer.addByte$1(10);
        headerBytes = buffer.takeBytes$0();
        this._outgoing.setHeader$2(headerBytes, headerBytes.length);
      }, "call$0", "get$_writeHeader", 0, 0, 6, "_writeHeader"],
      $isEventSink: 1,
      $asEventSink: function() {
        return [[P.List, P.int]];
      },
      $as_HttpOutboundMessage: function() {
        return [P.HttpClientResponse];
      },
      $as_StreamSinkImpl: function() {
        return [[P.List, P.int]];
      },
      "<>": [],
      static: {
        _HttpClientRequest$: [function(outgoing, uri, method, _proxy, _httpClient, _httpClientConnection) {
          var t1, t2, t3, t4;
          t1 = H.setRuntimeTypeInfo([], [P.Cookie]);
          t2 = P.HttpClientResponse;
          t3 = $.Zone__current;
          t4 = P._HttpHeaders$("1.1", J.$eq$(uri.get$scheme(), "https") ? 443 : 80, null);
          t3 = new P._HttpClientRequest(method, uri, t1, _httpClient, _httpClientConnection, new P._AsyncCompleter(new P._Future(0, t3, null, [t2]), [t2]), _proxy, null, true, 5, [], false, true, uri, outgoing, t4, null, true, outgoing, new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]), null, null, false, false, false);
          t3._HttpOutboundMessage$4$initialHeaders(uri, "1.1", outgoing, null, t2);
          t1 = J.getInterceptor(method);
          if (t1.$eq(method, "GET") || t1.$eq(method, "HEAD"))
            t4.set$contentLength(0);
          else
            t4.set$chunkedTransferEncoding(true);
          return t3;
        }, null, null, 12, 0, 886, 416, [], 40, [], 98, [], 767, [], 415, [], 768, [], "new _HttpClientRequest"]
      }
    },
    "+_HttpClientRequest": [1541, 1542],
    _HttpClientRequest_done_closure: {
      "^": "Closure:3;",
      call$1: [function(list) {
        return J.$index$asx(list, 0);
      }, null, null, 2, 0, 3, 125, [], "call"]
    },
    "+ _HttpClientRequest_done_closure": [2],
    _HttpClientRequest__onIncoming_closure: {
      "^": "Closure:3;response",
      call$1: [function(_) {
        return this.response.redirect$0();
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _HttpClientRequest__onIncoming_closure": [2],
    _HttpClientRequest__onIncoming_closure0: {
      "^": "Closure:3;response",
      call$1: [function(_) {
        return P.Future_Future$error(new P.RedirectException("Redirect limit exceeded", this.response._httpRequest.get$_responseRedirects()), null, P.HttpClientResponse);
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _HttpClientRequest__onIncoming_closure": [2],
    _HttpClientRequest__onIncoming_closure1: {
      "^": "Closure:3;$this",
      call$1: [function(v) {
        return this.$this._responseCompleter.complete$1(v);
      }, null, null, 2, 0, 3, 56, [], "call"]
    },
    "+ _HttpClientRequest__onIncoming_closure": [2],
    _HttpClientRequest__requestUri_uriStartingFromPath: {
      "^": "Closure:7;$this",
      call$0: [function() {
        var t1, result;
        t1 = this.$this.uri;
        result = t1.get$path();
        if (J.get$isEmpty$asx(result) === true)
          result = "/";
        return t1.get$hasQuery() ? H.S(result) + "?" + H.S(t1.get$query()) : result;
      }, null, null, 0, 0, 7, "call"]
    },
    "+ _HttpClientRequest__requestUri_uriStartingFromPath": [2],
    _HttpGZipSink: {
      "^": "ByteConversionSink;_consume<-506",
      add$1: [function(_, chunk) {
        this._consume.call$1(chunk);
      }, "call$1", "get$add", 2, 0, 26, 57, [], "add"],
      addSlice$4: [function(chunk, start, end, isLast) {
        var t1, t2, t3;
        t1 = J.getInterceptor(chunk);
        t2 = this._consume;
        t3 = J.getInterceptor$n(end);
        if (!!t1.$isUint8List)
          t2.call$1(J.asUint8List$2$x(t1.get$buffer(chunk), start, t3.$sub(end, start)));
        else
          t2.call$1(t1.sublist$2(chunk, start, t3.$sub(end, start)));
      }, "call$4", "get$addSlice", 8, 0, 44, 57, [], 3, [], 5, [], 46, [], "addSlice"],
      close$0: [function() {
      }, "call$0", "get$close", 0, 0, 6, "close"],
      static: {
        _HttpGZipSink$: [function(_consume) {
          return new P._HttpGZipSink(_consume);
        }, null, null, 2, 0, 887, 769, [], "new _HttpGZipSink"]
      }
    },
    "+_HttpGZipSink": [39],
    _HttpOutgoing: {
      "^": "Object;_doneCompleter<-1544,socket<-127,ignoreBody@-8,headersWritten@-8,_io$_buffer@-89,_io$_length@-0,_closeFuture@-86,chunked@-8,_pendingChunkedFooter@-0,contentLength@-0,_bytesWritten@-0,_gzip@-8,_gzipSink@-39,_gzipAdd@-506,_gzipBuffer@-89,_gzipBufferLength@-0,_socketError@-8,outbound@-1546",
      writeHeaders$2$drainRequest$setOutgoing: [function(drainRequest, setOutgoing) {
        var t1, acceptEncodings, contentEncoding, gzip, drainFuture, contentLength;
        if (this.headersWritten === true)
          return;
        this.headersWritten = true;
        t1 = this.outbound;
        if (t1 instanceof P._HttpResponse) {
          if (t1._httpRequest.get$_httpServer().get$autoCompress() === true && this.outbound.get$bufferOutput() === true && this.outbound.get$headers().get$chunkedTransferEncoding() === true) {
            acceptEncodings = J.$index$asx(t1._httpRequest.get$headers(), "accept-encoding");
            contentEncoding = J.$index$asx(this.outbound.get$headers(), "content-encoding");
            if (acceptEncodings != null && J.expand$1$ax(acceptEncodings, new P._HttpOutgoing_writeHeaders_closure()).any$1(0, new P._HttpOutgoing_writeHeaders_closure0()) === true && contentEncoding == null) {
              this.outbound.get$headers().$set$2("content-encoding", "gzip");
              gzip = true;
            } else
              gzip = false;
          } else
            gzip = false;
          drainFuture = drainRequest === true && t1._httpRequest.get$_incoming().get$hasSubscriber() !== true ? t1._httpRequest.drain$0().catchError$1(new P._HttpOutgoing_writeHeaders_closure1()) : null;
        } else {
          drainFuture = null;
          gzip = false;
        }
        if (this.ignoreBody !== true) {
          if (setOutgoing === true) {
            contentLength = this.outbound.get$headers().get$contentLength();
            if (this.outbound.get$headers().get$chunkedTransferEncoding() === true) {
              this.chunked = true;
              if (gzip)
                this.set$gzip(true);
            } else if (J.$ge$n(contentLength, 0))
              this.contentLength = contentLength;
          }
          if (drainFuture != null)
            return drainFuture.then$1(new P._HttpOutgoing_writeHeaders_closure2(this));
        }
        this.outbound._writeHeader$0();
        return;
      }, function() {
        return this.writeHeaders$2$drainRequest$setOutgoing(true, true);
      }, "writeHeaders$0", "call$2$drainRequest$setOutgoing", "call$0", "get$writeHeaders", 0, 5, 801, 25, 25, 889, [], 890, [], "writeHeaders"],
      addStream$1: [function(stream) {
        var t1, t2, future, controller;
        t1 = {};
        if (this._socketError === true) {
          stream.listen$1(null).cancel$0();
          t1 = this.outbound;
          t2 = new P._Future(0, $.Zone__current, null, [null]);
          t2._asyncComplete$1(t1);
          return t2;
        }
        if (this.ignoreBody === true) {
          stream.drain$0().catchError$1(new P._HttpOutgoing_addStream_closure());
          future = this.writeHeaders$0();
          if (future != null)
            return future.then$1(new P._HttpOutgoing_addStream_closure0(this));
          return this.close$0();
        }
        t1.sub = null;
        controller = new P._SyncStreamController(null, 0, null, null, new P._HttpOutgoing_addStream_closure1(t1), new P._HttpOutgoing_addStream_closure2(t1), null, [[P.List, P.int]]);
        t1.sub = stream.listen$4$cancelOnError$onDone$onError(new P._HttpOutgoing_addStream_onData(this, controller), true, controller.get$close(), controller.get$addError());
        if (this.headersWritten !== true) {
          future = this.writeHeaders$0();
          if (future != null)
            t1.sub.pause$1(future);
        }
        return this.socket.addStream$1(new P._ControllerStream(controller, [H.getTypeArgumentByIndex(controller, 0)])).then$2$onError(new P._HttpOutgoing_addStream_closure3(this), new P._HttpOutgoing_addStream_closure4(this));
      }, "call$1", "get$addStream", 2, 0, 212, 37, [], "addStream"],
      close$0: [function() {
        var t1, t2, error, future;
        t1 = this._closeFuture;
        if (t1 != null)
          return t1;
        if (this._socketError === true) {
          t1 = this.outbound;
          t2 = new P._Future(0, $.Zone__current, null, [null]);
          t2._asyncComplete$1(t1);
          return t2;
        }
        if (this.outbound.get$_isConnectionClosed()) {
          t1 = this.outbound;
          t2 = new P._Future(0, $.Zone__current, null, [null]);
          t2._asyncComplete$1(t1);
          return t2;
        }
        if (this.headersWritten !== true && this.ignoreBody !== true)
          if (J.$eq$(this.outbound.get$headers().get$contentLength(), -1)) {
            this.outbound.get$headers().set$chunkedTransferEncoding(false);
            this.outbound.get$headers().set$contentLength(0);
          } else if (J.$gt$n(this.outbound.get$headers().get$contentLength(), 0)) {
            error = new P.HttpException("No content even though contentLength was specified to be greater than 0: " + H.S(this.outbound.get$headers().get$contentLength()) + ".", this.outbound.get$_io$_uri());
            this._doneCompleter.completeError$1(error);
            t1 = P.Future_Future$error(error, null, null);
            this._closeFuture = t1;
            return t1;
          }
        t1 = this.contentLength;
        if (t1 != null)
          if (J.$lt$n(this._bytesWritten, t1)) {
            error = new P.HttpException("Content size below specified contentLength.  " + H.S(this._bytesWritten) + " bytes written but expected " + H.S(this.contentLength) + ".", this.outbound.get$_io$_uri());
            this._doneCompleter.completeError$1(error);
            t1 = P.Future_Future$error(error, null, null);
            this._closeFuture = t1;
            return t1;
          }
        t1 = new P._HttpOutgoing_close_finalize(this);
        future = this.writeHeaders$0();
        if (future != null) {
          t1 = future.whenComplete$1(t1);
          this._closeFuture = t1;
          return t1;
        }
        t1 = t1.call$0();
        this._closeFuture = t1;
        return t1;
      }, "call$0", "get$close", 0, 0, 18, "close"],
      get$done: [function() {
        return this._doneCompleter.get$future();
      }, null, null, 1, 0, 104, "done"],
      setHeader$2: [function(data, $length) {
        this._io$_buffer = data;
        this._io$_length = $length;
      }, "call$2", "get$setHeader", 4, 0, 852, 21, [], 15, [], "setHeader"],
      set$gzip: [function(value) {
        this._gzip = value;
        if (value === true) {
          this._gzipBuffer = new Uint8Array(H._checkLength(8192));
          P._validateZLibeLevel(6);
          P._validateZLibMemLevel(8);
          P._validateZLibStrategy(0);
          P._validateZLibWindowBits(15);
          this._gzipSink = new P.ZLibEncoder(true, 6, 8, 0, 15, null, false).startChunkedConversion$1(new P._HttpGZipSink(new P._HttpOutgoing_gzip_closure(this)));
        }
      }, null, null, 3, 0, 35, 1, [], "gzip"],
      _ignoreError$1: [function(error) {
        var t1 = J.getInterceptor(error);
        return (!!t1.$isSocketException || !!t1.$isTlsException) && !!J.getInterceptor(this.outbound).$isHttpResponse;
      }, "call$1", "get$_ignoreError", 2, 0, 24, 8, [], "_ignoreError"],
      _addGZipChunk$2: [function(chunk, add) {
        var t1, t2, t3;
        if (this.outbound.get$bufferOutput() !== true) {
          add.call$1(chunk);
          return;
        }
        t1 = J.getInterceptor$asx(chunk);
        if (J.$gt$n(t1.get$length(chunk), J.$sub$n(J.get$length$asx(this._gzipBuffer), this._gzipBufferLength))) {
          add.call$1(J.asUint8List$2$x(J.get$buffer$x(this._gzipBuffer), 0, this._gzipBufferLength));
          this._gzipBuffer = new Uint8Array(H._checkLength(8192));
          this._gzipBufferLength = 0;
        }
        if (J.$gt$n(t1.get$length(chunk), 8192))
          add.call$1(chunk);
        else {
          t2 = this._gzipBuffer;
          t3 = this._gzipBufferLength;
          J.setRange$3$ax(t2, t3, J.$add$ns(t3, t1.get$length(chunk)), chunk);
          this._gzipBufferLength = J.$add$ns(this._gzipBufferLength, t1.get$length(chunk));
        }
      }, "call$2", "get$_addGZipChunk", 4, 0, 350, 57, [], 455, [], "_addGZipChunk"],
      _addChunk$2: [function(chunk, add) {
        var t1, t2, t3;
        if (this.outbound.get$bufferOutput() !== true) {
          t1 = this._io$_buffer;
          if (t1 != null) {
            add.call$1(J.asUint8List$2$x(J.get$buffer$x(t1), 0, this._io$_length));
            this._io$_buffer = null;
            this._io$_length = 0;
          }
          add.call$1(chunk);
          return;
        }
        t1 = J.getInterceptor$asx(chunk);
        if (J.$gt$n(t1.get$length(chunk), J.$sub$n(J.get$length$asx(this._io$_buffer), this._io$_length))) {
          add.call$1(J.asUint8List$2$x(J.get$buffer$x(this._io$_buffer), 0, this._io$_length));
          this._io$_buffer = new Uint8Array(H._checkLength(8192));
          this._io$_length = 0;
        }
        if (J.$gt$n(t1.get$length(chunk), 8192))
          add.call$1(chunk);
        else {
          t2 = this._io$_buffer;
          t3 = this._io$_length;
          J.setRange$3$ax(t2, t3, J.$add$ns(t3, t1.get$length(chunk)), chunk);
          this._io$_length = J.$add$ns(this._io$_length, t1.get$length(chunk));
        }
      }, "call$2", "get$_addChunk", 4, 0, 350, 57, [], 455, [], "_addChunk"],
      _chunkHeader$1: [function($length) {
        var size, len, t1, t2, footerAndHeader, index, t3, t4;
        if (J.$eq$($length, 0)) {
          if (J.$eq$(this._pendingChunkedFooter, 2))
            return C.List_E7y;
          return C.List_yTu;
        }
        size = this._pendingChunkedFooter;
        for (len = $length; t1 = J.getInterceptor$n(len), t1.$gt(len, 0);) {
          size = J.$add$ns(size, 1);
          len = t1.$shr(len, 4);
        }
        t1 = J.getInterceptor$ns(size);
        t2 = H._checkLength(t1.$add(size, 2));
        footerAndHeader = new Uint8Array(t2);
        if (J.$eq$(this._pendingChunkedFooter, 2)) {
          if (0 >= t2)
            return H.ioore(footerAndHeader, 0);
          footerAndHeader[0] = 13;
          if (1 >= t2)
            return H.ioore(footerAndHeader, 1);
          footerAndHeader[1] = 10;
        }
        for (index = size; t3 = J.getInterceptor$n(index), t3.$gt(index, this._pendingChunkedFooter);) {
          index = t3.$sub(index, 1);
          t3 = J.getInterceptor$n($length);
          t4 = t3.$and($length, 15);
          if (t4 >>> 0 !== t4 || t4 >= 16)
            return H.ioore(C.List_cGl, t4);
          t4 = C.List_cGl[t4];
          if (index >>> 0 !== index || index >= t2)
            return H.ioore(footerAndHeader, index);
          footerAndHeader[index] = t4;
          $length = t3.$shr($length, 4);
        }
        t3 = t1.$add(size, 0);
        if (t3 >>> 0 !== t3 || t3 >= t2)
          return H.ioore(footerAndHeader, t3);
        footerAndHeader[t3] = 13;
        t1 = t1.$add(size, 1);
        if (t1 >>> 0 !== t1 || t1 >= t2)
          return H.ioore(footerAndHeader, t1);
        footerAndHeader[t1] = 10;
        return footerAndHeader;
      }, "call$1", "get$_chunkHeader", 2, 0, 105, 15, [], "_chunkHeader"],
      static: {
        "^": "_HttpOutgoing__footerAndChunk0Length<-14,_HttpOutgoing__chunk0Length<-14",
        _HttpOutgoing$: [function(socket) {
          var t1 = P.Socket;
          return new P._HttpOutgoing(new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [t1]), [t1]), socket, false, false, null, 0, null, false, 0, null, 0, false, null, null, null, 0, false, null);
        }, null, null, 2, 0, 161, 52, [], "new _HttpOutgoing"]
      }
    },
    "+_HttpOutgoing": [1, 270],
    _HttpOutgoing_writeHeaders_closure: {
      "^": "Closure:3;",
      call$1: [function(list) {
        return J.split$1$s(list, ",");
      }, null, null, 2, 0, 3, 125, [], "call"]
    },
    "+ _HttpOutgoing_writeHeaders_closure": [2],
    _HttpOutgoing_writeHeaders_closure0: {
      "^": "Closure:3;",
      call$1: [function(encoding) {
        return J.trim$0$s(encoding).toLowerCase() === "gzip";
      }, null, null, 2, 0, 3, 48, [], "call"]
    },
    "+ _HttpOutgoing_writeHeaders_closure": [2],
    _HttpOutgoing_writeHeaders_closure1: {
      "^": "Closure:3;",
      call$1: [function(_) {
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _HttpOutgoing_writeHeaders_closure": [2],
    _HttpOutgoing_writeHeaders_closure2: {
      "^": "Closure:3;$this",
      call$1: [function(_) {
        return this.$this.outbound._writeHeader$0();
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _HttpOutgoing_writeHeaders_closure": [2],
    _HttpOutgoing_addStream_closure: {
      "^": "Closure:3;",
      call$1: [function(_) {
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _HttpOutgoing_addStream_closure": [2],
    _HttpOutgoing_addStream_closure0: {
      "^": "Closure:3;$this",
      call$1: [function(_) {
        return this.$this.close$0();
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _HttpOutgoing_addStream_closure": [2],
    _HttpOutgoing_addStream_closure1: {
      "^": "Closure:4;_box_0",
      call$0: [function() {
        return this._box_0.sub.pause$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _HttpOutgoing_addStream_closure": [2],
    _HttpOutgoing_addStream_closure2: {
      "^": "Closure:4;_box_0",
      call$0: [function() {
        return this._box_0.sub.resume$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _HttpOutgoing_addStream_closure": [2],
    _HttpOutgoing_addStream_onData: {
      "^": "Closure:26;$this,controller",
      call$1: [function(data) {
        var t1, t2, t3;
        t1 = this.$this;
        if (t1._socketError === true)
          return;
        t2 = J.getInterceptor$asx(data);
        if (J.$eq$(t2.get$length(data), 0))
          return;
        if (t1.chunked === true) {
          if (t1._gzip === true) {
            t2 = this.controller;
            t1._gzipAdd = t2.get$add(t2);
            t1._addGZipChunk$2(data, J.get$add$ax(t1._gzipSink));
            t1._gzipAdd = null;
            return;
          }
          t3 = this.controller;
          t1._addChunk$2(t1._chunkHeader$1(t2.get$length(data)), t3.get$add(t3));
          t1._pendingChunkedFooter = 2;
        } else if (t1.contentLength != null) {
          t2 = J.$add$ns(t1._bytesWritten, t2.get$length(data));
          t1._bytesWritten = t2;
          if (J.$gt$n(t2, t1.contentLength)) {
            this.controller.addError$1(new P.HttpException("Content size exceeds specified contentLength. " + H.S(t1._bytesWritten) + " bytes written while expected " + H.S(t1.contentLength) + ". [" + P.String_String$fromCharCodes(data, 0, null) + "]", null));
            return;
          }
        }
        t2 = this.controller;
        t1._addChunk$2(data, t2.get$add(t2));
      }, null, null, 2, 0, 26, 21, [], "call"]
    },
    "+ _HttpOutgoing_addStream_onData": [2],
    _HttpOutgoing_addStream_closure3: {
      "^": "Closure:3;$this",
      call$1: [function(_) {
        return this.$this.outbound;
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _HttpOutgoing_addStream_closure": [2],
    _HttpOutgoing_addStream_closure4: {
      "^": "Closure:12;$this",
      call$2: [function(error, stackTrace) {
        var t1 = this.$this;
        if (t1._gzip === true)
          t1._gzipSink.close$0();
        t1._socketError = true;
        t1._doneCompleter.completeError$2(error, stackTrace);
        if (t1._ignoreError$1(error))
          return t1.outbound;
        else
          throw H.wrapException(error);
      }, null, null, 4, 0, 12, 8, [], 12, [], "call"]
    },
    "+ _HttpOutgoing_addStream_closure": [2],
    _HttpOutgoing_close_finalize: {
      "^": "Closure:18;$this",
      call$0: [function() {
        var t1 = this.$this;
        if (t1.chunked === true) {
          if (t1._gzip === true) {
            t1._gzipAdd = J.get$add$ax(t1.socket);
            if (J.$gt$n(t1._gzipBufferLength, 0))
              J.add$1$ax(t1._gzipSink, J.asUint8List$2$x(J.get$buffer$x(t1._gzipBuffer), 0, t1._gzipBufferLength));
            t1._gzipBuffer = null;
            t1._gzipSink.close$0();
            t1._gzipAdd = null;
          }
          t1._addChunk$2(t1._chunkHeader$1(0), J.get$add$ax(t1.socket));
        }
        if (J.$gt$n(t1._io$_length, 0))
          J.add$1$ax(t1.socket, J.asUint8List$2$x(J.get$buffer$x(t1._io$_buffer), 0, t1._io$_length));
        t1._io$_buffer = null;
        return t1.socket.flush$0().then$2$onError(new P._HttpOutgoing_close_finalize_closure(t1), new P._HttpOutgoing_close_finalize_closure0(t1));
      }, null, null, 0, 0, 18, "call"]
    },
    "+ _HttpOutgoing_close_finalize": [2],
    _HttpOutgoing_close_finalize_closure: {
      "^": "Closure:3;$this",
      call$1: [function(_) {
        var t1 = this.$this;
        t1._doneCompleter.complete$1(t1.socket);
        return t1.outbound;
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _HttpOutgoing_close_finalize_closure": [2],
    _HttpOutgoing_close_finalize_closure0: {
      "^": "Closure:12;$this",
      call$2: [function(error, stackTrace) {
        var t1 = this.$this;
        t1._doneCompleter.completeError$2(error, stackTrace);
        if (t1._ignoreError$1(error))
          return t1.outbound;
        else
          throw H.wrapException(error);
      }, null, null, 4, 0, 12, 8, [], 12, [], "call"]
    },
    "+ _HttpOutgoing_close_finalize_closure": [2],
    _HttpOutgoing_gzip_closure: {
      "^": "Closure:3;$this",
      call$1: [function(data) {
        var t1 = this.$this;
        if (t1._gzipAdd == null)
          return;
        t1._addChunk$2(t1._chunkHeader$1(J.get$length$asx(data)), t1._gzipAdd);
        t1._pendingChunkedFooter = 2;
        t1._addChunk$2(data, t1._gzipAdd);
      }, null, null, 2, 0, 3, 21, [], "call"]
    },
    "+ _HttpOutgoing_gzip_closure": [2],
    _HttpClientConnection: {
      "^": "Object;key<-9,_socket<-127,_proxyTunnel<-8,_context<-138,_httpParser<-507,_io$_subscription@-103,_httpClient<-279,_dispose@-8,_idleTimer@-128,closed@-8,_currentUri@-36,_nextResponseCompleter@-1549,_streamFuture@-1550",
      send$4: [function(uri, port, method, proxy) {
        var t1, t2, outgoing, t3, t4, t5, t6, t7, request, host, proxyCreds, creds;
        t1 = {};
        if (this.closed === true)
          throw H.wrapException(new P.HttpException("Socket closed before request was sent", uri));
        this._currentUri = uri;
        this._io$_subscription.pause$0();
        t1.proxyCreds = null;
        t1.creds = null;
        t2 = P.Socket;
        t2 = new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [t2]), [t2]);
        outgoing = new P._HttpOutgoing(t2, this._socket, false, false, null, 0, null, false, 0, null, 0, false, null, null, null, 0, false, null);
        t3 = this._httpClient;
        t4 = H.setRuntimeTypeInfo([], [P.Cookie]);
        t5 = P.HttpClientResponse;
        t6 = $.Zone__current;
        t7 = P._HttpHeaders$("1.1", J.$eq$(uri.get$scheme(), "https") ? 443 : 80, null);
        request = new P._HttpClientRequest(method, uri, t4, t3, this, new P._AsyncCompleter(new P._Future(0, t6, null, [t5]), [t5]), proxy, null, true, 5, [], false, true, uri, outgoing, t7, null, true, outgoing, new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]), null, null, false, false, false);
        request._HttpOutboundMessage$4$initialHeaders(uri, "1.1", outgoing, null, t5);
        t4 = J.getInterceptor(method);
        if (t4.$eq(method, "GET") || t4.$eq(method, "HEAD"))
          t7.set$contentLength(0);
        else
          t7.set$chunkedTransferEncoding(true);
        host = uri.get$host();
        t7.set$host(J.contains$1$asx(host, ":") === true ? "[" + H.S(host) + "]" : host);
        t7.set$port(port);
        t7._io$_add$2("accept-encoding", "gzip");
        if (t3.get$userAgent() != null)
          t7._io$_add$2("user-agent", t3.get$userAgent());
        if (proxy.get$isAuthenticated()) {
          t4 = H.S(proxy.get$username()) + ":" + H.S(proxy.get$password());
          t7.$set$2("proxy-authorization", "Basic " + P._CryptoUtils_bytesToBase64(C.Utf8Codec_false.get$encoder().convert$1(t4), false, false));
        } else if (proxy.get$isDirect() !== true && J.$gt$n(J.get$length$asx(t3.get$_proxyCredentials()), 0)) {
          proxyCreds = t3._findProxyCredentials$1(proxy);
          t1.proxyCreds = proxyCreds;
          if (proxyCreds != null)
            proxyCreds.authorize$1(request);
        }
        if (uri.get$userInfo() != null && J.get$isEmpty$asx(uri.get$userInfo()) !== true) {
          t3 = uri.get$userInfo();
          t7.$set$2("authorization", "Basic " + P._CryptoUtils_bytesToBase64(C.Utf8Codec_false.get$encoder().convert$1(t3), false, false));
        } else {
          creds = t3._findCredentials$1(uri);
          t1.creds = creds;
          if (creds != null)
            creds.authorize$1(request);
        }
        this._httpParser.set$isHead(J.$eq$(method, "HEAD"));
        this._streamFuture = t2.future.then$2$onError(new P._HttpClientConnection_send_closure(t1, this, uri, request), new P._HttpClientConnection_send_closure0(this));
        return request;
      }, "call$4", "get$send", 8, 0, 917, 40, [], 26, [], 98, [], 142, [], "send"],
      detachSocket$0: [function() {
        return this._streamFuture.then$1(new P._HttpClientConnection_detachSocket_closure(this));
      }, "call$0", "get$detachSocket", 0, 0, 104, "detachSocket"],
      destroy$0: [function() {
        this.closed = true;
        this._httpClient._connectionClosed$1(this);
        this._socket.destroy$0();
      }, "call$0", "get$destroy", 0, 0, 6, "destroy"],
      close$0: [function() {
        this.closed = true;
        this._httpClient._connectionClosed$1(this);
        this._streamFuture.then$1(new P._HttpClientConnection_close_closure(this));
      }, "call$0", "get$close", 0, 0, 6, "close"],
      createProxyTunnel$4: [function(host, port, proxy, callback) {
        var request, t1;
        request = this.send$4(P._Uri__Uri(null, host, null, null, port, null, null, null, null), port, "CONNECT", proxy);
        if (proxy.get$isAuthenticated()) {
          t1 = H.S(proxy.get$username()) + ":" + H.S(proxy.get$password());
          request.headers.$set$2("proxy-authorization", "Basic " + P._CryptoUtils_bytesToBase64(C.Utf8Codec_false.get$encoder().convert$1(t1), false, false));
        }
        request.super$_StreamSinkImpl$close();
        return request.get$done().then$1(new P._HttpClientConnection_createProxyTunnel_closure(this, host, callback)).then$1(new P._HttpClientConnection_createProxyTunnel_closure0(host, port, request));
      }, "call$4", "get$createProxyTunnel", 8, 0, 920, 29, [], 26, [], 142, [], 33, [], "createProxyTunnel"],
      get$connectionInfo: [function() {
        return P._HttpConnectionInfo_create(this._socket);
      }, null, null, 1, 0, 97, "connectionInfo"],
      stopTimer$0: [function() {
        var t1 = this._idleTimer;
        if (t1 != null) {
          t1.cancel$0();
          this._idleTimer = null;
        }
      }, "call$0", "get$stopTimer", 0, 0, 6, "stopTimer"],
      startTimer$0: [function() {
        this._idleTimer = P.Timer_Timer(this._httpClient.get$idleTimeout(), new P._HttpClientConnection_startTimer_closure(this));
      }, "call$0", "get$startTimer", 0, 0, 6, "startTimer"],
      _HttpClientConnection$5: function(key, _socket, _httpClient, _proxyTunnel, _context) {
        var t1 = this._httpParser;
        t1.listenToStream$1(this._socket);
        this._io$_subscription = t1.listen$3$onDone$onError(new P._HttpClientConnection_closure(this), new P._HttpClientConnection_closure0(this), new P._HttpClientConnection_closure1(this));
      },
      static: {
        _HttpClientConnection$: [function(key, _socket, _httpClient, _proxyTunnel, _context) {
          var t1 = new P._HttpClientConnection(key, _socket, _proxyTunnel, _context, P._HttpParser$_(false), null, _httpClient, false, null, false, null, null, null);
          t1._HttpClientConnection$5(key, _socket, _httpClient, _proxyTunnel, _context);
          return t1;
        }, null, null, 6, 4, 888, 4, 0, 6, [], 148, [], 415, [], 772, [], 418, [], "new _HttpClientConnection"],
        _HttpClientConnection_makeKey: [function(isSecure, host, port) {
          return isSecure === true ? "ssh:" + H.S(host) + ":" + H.S(port) : H.S(host) + ":" + H.S(port);
        }, "call$3", "io__HttpClientConnection_makeKey$closure", 6, 0, 889, 270, [], 29, [], 26, [], "makeKey"]
      }
    },
    "+_HttpClientConnection": [1],
    _HttpClientConnection_closure: {
      "^": "Closure:3;$this",
      call$1: [function(incoming) {
        var t1 = this.$this;
        t1._io$_subscription.pause$0();
        if (t1._nextResponseCompleter == null)
          throw H.wrapException(new P.HttpException("Unexpected response (unsolicited response without request).", t1._currentUri));
        if (J.$eq$(incoming.get$statusCode(), 100))
          incoming.drain$0().then$1(new P._HttpClientConnection__closure(t1)).catchError$1(new P._HttpClientConnection__closure0(t1));
        else {
          t1._nextResponseCompleter.complete$1(incoming);
          t1._nextResponseCompleter = null;
        }
      }, null, null, 2, 0, 3, 236, [], "call"]
    },
    "+ _HttpClientConnection_closure": [2],
    _HttpClientConnection__closure: {
      "^": "Closure:3;$this",
      call$1: [function(_) {
        this.$this._io$_subscription.resume$0();
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _HttpClientConnection__closure": [2],
    _HttpClientConnection__closure0: {
      "^": "Closure:163;$this",
      call$2: [function(error, stackTrace) {
        var t1 = this.$this;
        t1._nextResponseCompleter.completeError$2(new P.HttpException(error.get$message(), t1._currentUri), stackTrace);
        t1._nextResponseCompleter = null;
      }, function(error) {
        return this.call$2(error, null);
      }, "call$1", null, null, null, 2, 2, 163, 0, 8, [], 12, [], "call"]
    },
    "+ _HttpClientConnection__closure": [2],
    _HttpClientConnection_closure1: {
      "^": "Closure:163;$this",
      call$2: [function(error, stackTrace) {
        var t1, t2;
        t1 = this.$this;
        t2 = t1._nextResponseCompleter;
        if (t2 != null) {
          t2.completeError$2(new P.HttpException(error.get$message(), t1._currentUri), stackTrace);
          t1._nextResponseCompleter = null;
        }
      }, function(error) {
        return this.call$2(error, null);
      }, "call$1", null, null, null, 2, 2, 163, 0, 8, [], 12, [], "call"]
    },
    "+ _HttpClientConnection_closure": [2],
    _HttpClientConnection_closure0: {
      "^": "Closure:4;$this",
      call$0: [function() {
        var t1, t2;
        t1 = this.$this;
        t2 = t1._nextResponseCompleter;
        if (t2 != null) {
          t2.completeError$1(new P.HttpException("Connection closed before response was received", t1._currentUri));
          t1._nextResponseCompleter = null;
        }
        t1.close$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _HttpClientConnection_closure": [2],
    _HttpClientConnection_send_closure: {
      "^": "Closure:161;_box_0,$this,uri,request",
      call$1: [function(s) {
        var t1, t2, t3;
        t1 = this.$this;
        t2 = new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]);
        t1._nextResponseCompleter = t2;
        t3 = this.request;
        t2.future.then$1(new P._HttpClientConnection_send__closure(this._box_0, t1, t3)).catchError$2$test(new P._HttpClientConnection_send__closure0(this.uri), new P._HttpClientConnection_send__closure1()).catchError$1(new P._HttpClientConnection_send__closure2(t1, t3));
        t1._io$_subscription.resume$0();
        return s;
      }, null, null, 2, 0, 161, 49, [], "call"]
    },
    "+ _HttpClientConnection_send_closure": [2],
    _HttpClientConnection_send__closure: {
      "^": "Closure:3;_box_0,$this,request",
      call$1: [function(incoming) {
        var t1, t2, t3, authInfo, result, nextnonce;
        t1 = this.$this;
        t1._currentUri = null;
        t2 = this.request;
        incoming.get$dataDone().then$1(new P._HttpClientConnection_send___closure(t1, t2, incoming));
        t1 = this._box_0;
        t3 = t1.proxyCreds;
        if (t3 != null && J.$eq$(t3.get$scheme(), C._AuthenticationScheme_1)) {
          authInfo = J.$index$asx(incoming.get$headers(), "proxy-authentication-info");
          if (authInfo != null && J.$eq$(J.get$length$asx(authInfo), 1)) {
            t3 = J.$index$asx(authInfo, 0);
            result = P._HeaderValue$("", null);
            result._parse$4(t3, ",", null, false);
            nextnonce = J.$index$asx(result.get$parameters(), "nextnonce");
            if (nextnonce != null)
              t1.proxyCreds.set$nonce(nextnonce);
          }
        }
        t3 = t1.creds;
        if (t3 != null && J.$eq$(t3.get$scheme(), C._AuthenticationScheme_1)) {
          authInfo = J.$index$asx(incoming.get$headers(), "authentication-info");
          if (authInfo != null && J.$eq$(J.get$length$asx(authInfo), 1)) {
            t3 = J.$index$asx(authInfo, 0);
            result = P._HeaderValue$("", null);
            result._parse$4(t3, ",", null, false);
            nextnonce = J.$index$asx(result.get$parameters(), "nextnonce");
            if (nextnonce != null)
              t1.creds.set$nonce(nextnonce);
          }
        }
        t2._onIncoming$1(incoming);
      }, null, null, 2, 0, 3, 236, [], "call"]
    },
    "+ _HttpClientConnection_send__closure": [2],
    _HttpClientConnection_send___closure: {
      "^": "Closure:3;$this,request,incoming",
      call$1: [function(closing) {
        var t1, t2;
        t1 = this.incoming;
        if (t1.get$upgraded() === true) {
          t1 = this.$this;
          t1._httpClient._connectionClosed$1(t1);
          t1.startTimer$0();
          return;
        }
        t2 = this.$this;
        if (t2.closed === true)
          return;
        if (closing !== true && t2._dispose !== true && t1.get$headers().get$persistentConnection() === true && this.request.headers.get$persistentConnection() === true) {
          t2._httpClient._returnConnection$1(t2);
          t2._io$_subscription.resume$0();
        } else
          t2.destroy$0();
      }, null, null, 2, 0, 3, 237, [], "call"]
    },
    "+ _HttpClientConnection_send___closure": [2],
    _HttpClientConnection_send__closure0: {
      "^": "Closure:3;uri",
      call$1: [function(error) {
        throw H.wrapException(new P.HttpException("Connection closed before data was received", this.uri));
      }, null, null, 2, 0, 3, 8, [], "call"]
    },
    "+ _HttpClientConnection_send__closure": [2],
    _HttpClientConnection_send__closure1: {
      "^": "Closure:3;",
      call$1: [function(error) {
        return error instanceof P.StateError;
      }, null, null, 2, 0, 3, 8, [], "call"]
    },
    "+ _HttpClientConnection_send__closure": [2],
    _HttpClientConnection_send__closure2: {
      "^": "Closure:12;$this,request",
      call$2: [function(error, stackTrace) {
        this.$this.destroy$0();
        this.request._responseCompleter.completeError$2(error, stackTrace);
      }, null, null, 4, 0, 12, 8, [], 12, [], "call"]
    },
    "+ _HttpClientConnection_send__closure": [2],
    _HttpClientConnection_send_closure0: {
      "^": "Closure:3;$this",
      call$1: [function(e) {
        this.$this.destroy$0();
      }, null, null, 2, 0, 3, 47, [], "call"]
    },
    "+ _HttpClientConnection_send_closure": [2],
    _HttpClientConnection_detachSocket_closure: {
      "^": "Closure:3;$this",
      call$1: [function(_) {
        var t1 = this.$this;
        return new P._DetachedSocket(t1._httpParser.detachIncoming$0(), t1._socket);
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _HttpClientConnection_detachSocket_closure": [2],
    _HttpClientConnection_close_closure: {
      "^": "Closure:3;$this",
      call$1: [function(_) {
        return this.$this._socket.destroy$0();
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _HttpClientConnection_close_closure": [2],
    _HttpClientConnection_createProxyTunnel_closure: {
      "^": "Closure:3;$this,host,callback",
      call$1: [function(response) {
        if (!J.$eq$(response.get$statusCode(), 200))
          throw H.wrapException("Proxy failed to establish tunnel (" + H.S(response.get$statusCode()) + " " + H.S(response.get$reasonPhrase()) + ")");
        return P.SecureSocket_secure(H.interceptedTypeCast(response, "$is_HttpClientResponse")._httpRequest.get$_httpClientConnection().get$_socket(), this.$this._context, this.host, this.callback);
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _HttpClientConnection_createProxyTunnel_closure": [2],
    _HttpClientConnection_createProxyTunnel_closure0: {
      "^": "Closure:3;host,port,request",
      call$1: [function(secureSocket) {
        var key = "ssh:" + H.S(this.host) + ":" + H.S(this.port);
        return P._HttpClientConnection$(key, secureSocket, this.request._httpClient, true, null);
      }, null, null, 2, 0, 3, 892, [], "call"]
    },
    "+ _HttpClientConnection_createProxyTunnel_closure": [2],
    _HttpClientConnection_startTimer_closure: {
      "^": "Closure:4;$this",
      call$0: [function() {
        var t1 = this.$this;
        t1._idleTimer = null;
        t1.close$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _HttpClientConnection_startTimer_closure": [2],
    _ConnectionInfo: {
      "^": "Object;connection<-504,proxy<-505",
      static: {
        _ConnectionInfo$: [function(connection, proxy) {
          return new P._ConnectionInfo(connection, proxy);
        }, null, null, 4, 0, 890, 99, [], 142, [], "new _ConnectionInfo"]
      }
    },
    "+_ConnectionInfo": [1],
    _ConnectionTarget: {
      "^": "Object;key<-9,host<-9,port<-0,isSecure<-8,context<-138,_idle<-508,_active<-508,_io$_pending<-1552,_connecting@-0",
      get$isEmpty: [function(_) {
        return J.get$isEmpty$asx(this._idle) === true && J.get$isEmpty$asx(this._active) === true && J.$eq$(this._connecting, 0);
      }, null, null, 1, 0, 5, "isEmpty"],
      get$hasIdle: [function() {
        return J.get$isNotEmpty$asx(this._idle);
      }, null, null, 1, 0, 5, "hasIdle"],
      get$hasActive: [function() {
        return J.get$isNotEmpty$asx(this._active) || J.$gt$n(this._connecting, 0);
      }, null, null, 1, 0, 5, "hasActive"],
      takeIdle$0: [function() {
        var t1, t2, connection;
        t1 = this._idle;
        t2 = J.getInterceptor$ax(t1);
        connection = t2.get$first(t1);
        t2.remove$1(t1, connection);
        connection.stopTimer$0();
        J.add$1$ax(this._active, connection);
        return connection;
      }, "call$0", "get$takeIdle", 0, 0, 960, "takeIdle"],
      _checkPending$0: [function() {
        var t1 = this._io$_pending;
        if (J.get$isNotEmpty$asx(t1))
          t1.removeFirst$0().call$0();
      }, "call$0", "get$_checkPending", 0, 0, 4, "_checkPending"],
      addNewActive$1: [function(connection) {
        J.add$1$ax(this._active, connection);
      }, "call$1", "get$addNewActive", 2, 0, 165, 99, [], "addNewActive"],
      returnConnection$1: [function(connection) {
        var t1;
        J.remove$1$ax(this._active, connection);
        J.add$1$ax(this._idle, connection);
        connection.startTimer$0();
        t1 = this._io$_pending;
        if (J.get$isNotEmpty$asx(t1))
          t1.removeFirst$0().call$0();
      }, "call$1", "get$returnConnection", 2, 0, 165, 99, [], "returnConnection"],
      connectionClosed$1: [function(connection) {
        var t1;
        J.remove$1$ax(this._active, connection);
        J.remove$1$ax(this._idle, connection);
        t1 = this._io$_pending;
        if (J.get$isNotEmpty$asx(t1))
          t1.removeFirst$0().call$0();
      }, "call$1", "get$connectionClosed", 2, 0, 165, 99, [], "connectionClosed"],
      close$1: [function(force) {
        var t1;
        for (t1 = J.get$iterator$ax(J.toList$0$ax(this._idle)); t1.moveNext$0();)
          t1.__interceptors$_current.close$0();
        if (force === true)
          for (t1 = J.get$iterator$ax(J.toList$0$ax(this._active)); t1.moveNext$0();)
            t1.__interceptors$_current.destroy$0();
      }, "call$1", "get$close", 2, 0, 35, 235, [], "close"],
      connect$4: [function(uriHost, uriPort, proxy, client) {
        var t1, t2, connection, t3, t4, socketFuture;
        t1 = this._idle;
        t2 = J.getInterceptor$asx(t1);
        if (t2.get$isNotEmpty(t1)) {
          connection = t2.get$first(t1);
          t2.remove$1(t1, connection);
          connection.stopTimer$0();
          J.add$1$ax(this._active, connection);
          client._connectionsChanged$0();
          t1 = new P._Future(0, $.Zone__current, null, [null]);
          t1._asyncComplete$1(new P._ConnectionInfo(connection, proxy));
          return t1;
        }
        if (client.get$maxConnectionsPerHost() != null && J.$ge$n(J.$add$ns(J.get$length$asx(this._active), this._connecting), client.get$maxConnectionsPerHost())) {
          t1 = P._ConnectionInfo;
          t2 = new P._Future(0, $.Zone__current, null, [t1]);
          J.add$1$ax(this._io$_pending, new P._ConnectionTarget_connect_closure(this, uriHost, uriPort, proxy, client, new P._AsyncCompleter(t2, [t1])));
          return t2;
        }
        t1 = new P._ConnectionTarget_connect_callback(uriHost, uriPort, client.get$_badCertificateCallback());
        t2 = this.isSecure === true && proxy.get$isDirect() === true;
        t3 = this.host;
        t4 = this.port;
        socketFuture = t2 ? P.SecureSocket_connect(t3, t4, this.context, t1, null) : P.Socket_connect(t3, t4, null);
        this._connecting = J.$add$ns(this._connecting, 1);
        return socketFuture.then$2$onError(new P._ConnectionTarget_connect_closure0(this, uriHost, uriPort, proxy, client, t1), new P._ConnectionTarget_connect_closure1(this));
      }, "call$4", "get$connect", 8, 0, 982, 489, [], 510, [], 142, [], 896, [], "connect"],
      static: {
        _ConnectionTarget$: [function(key, host, port, isSecure, context) {
          return new P._ConnectionTarget(key, host, port, isSecure, context, P.HashSet_HashSet(null, null, null, null), P.HashSet_HashSet(null, null, null, null), P.ListQueue$(null, null), 0);
        }, null, null, 10, 0, 891, 6, [], 29, [], 26, [], 270, [], 76, [], "new _ConnectionTarget"]
      }
    },
    "+_ConnectionTarget": [1],
    _ConnectionTarget_connect_closure: {
      "^": "Closure:4;$this,uriHost,uriPort,proxy,client,completer",
      call$0: [function() {
        this.completer.complete$1(this.$this.connect$4(this.uriHost, this.uriPort, this.proxy, this.client));
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _ConnectionTarget_connect_closure": [2],
    _ConnectionTarget_connect_callback: {
      "^": "Closure:263;uriHost,uriPort,currentBadCertificateCallback",
      call$1: [function(certificate) {
        var t1 = this.currentBadCertificateCallback;
        if (t1 == null)
          return false;
        return t1.call$3(certificate, this.uriHost, this.uriPort);
      }, null, null, 2, 0, 263, 486, [], "call"]
    },
    "+ _ConnectionTarget_connect_callback": [2],
    _ConnectionTarget_connect_closure0: {
      "^": "Closure:3;$this,uriHost,uriPort,proxy,client,callback",
      call$1: [function(socket) {
        var t1, t2, connection, t3, t4;
        t1 = this.$this;
        t1._connecting = J.$sub$n(t1._connecting, 1);
        socket.setOption$2(C.SocketOption_0, true);
        t2 = this.client;
        connection = P._HttpClientConnection$(t1.key, socket, t2, false, t1.context);
        t3 = t1.isSecure === true && this.proxy.get$isDirect() !== true;
        t4 = this.proxy;
        if (t3) {
          connection._dispose = true;
          t1 = this.uriHost;
          t3 = this.uriPort;
          return connection.createProxyTunnel$4(t1, t3, t4, this.callback).then$1(new P._ConnectionTarget_connect__closure(t1, t3, t4, t2));
        } else {
          J.add$1$ax(t1._active, connection);
          return new P._ConnectionInfo(connection, t4);
        }
      }, null, null, 2, 0, 3, 52, [], "call"]
    },
    "+ _ConnectionTarget_connect_closure": [2],
    _ConnectionTarget_connect__closure: {
      "^": "Closure:3;uriHost,uriPort,proxy,client",
      call$1: [function(tunnel) {
        this.client._getConnectionTarget$3(this.uriHost, this.uriPort, true).addNewActive$1(tunnel);
        return new P._ConnectionInfo(tunnel, this.proxy);
      }, null, null, 2, 0, 3, 898, [], "call"]
    },
    "+ _ConnectionTarget_connect__closure": [2],
    _ConnectionTarget_connect_closure1: {
      "^": "Closure:3;$this",
      call$1: [function(error) {
        var t1 = this.$this;
        t1._connecting = J.$sub$n(t1._connecting, 1);
        t1 = t1._io$_pending;
        if (J.get$isNotEmpty$asx(t1))
          t1.removeFirst$0().call$0();
        throw H.wrapException(error);
      }, null, null, 2, 0, 3, 8, [], "call"]
    },
    "+ _ConnectionTarget_connect_closure": [2],
    _HttpClient: {
      "^": "Object;_closing@-8,_closingForcefully@-8,_connectionTargets<-1553,_credentials<-1554,_proxyCredentials<-1555,_context<-138,_authenticate@-29,_authenticateProxy@-29,_findProxy@-29,_idleTimeout@-65,_badCertificateCallback@-1556,maxConnectionsPerHost@-0,autoUncompress@-8,userAgent@-9",
      get$idleTimeout: [function() {
        return this._idleTimeout;
      }, null, null, 1, 0, 83, "idleTimeout"],
      set$idleTimeout: [function(timeout) {
        var t1, t2, idle;
        this._idleTimeout = timeout;
        for (t1 = this._connectionTargets.get$values(), t1 = t1.get$iterator(t1); t1.moveNext$0();)
          for (t2 = J.get$iterator$ax(t1.get$current().get$_idle()); t2.moveNext$0();) {
            idle = t2.get$current();
            idle.stopTimer$0();
            idle.startTimer$0();
          }
      }, null, null, 3, 0, 162, 316, [], "idleTimeout"],
      set$badCertificateCallback: [function(callback) {
        this._badCertificateCallback = callback;
      }, null, null, 3, 0, 985, 33, [], "badCertificateCallback"],
      open$4: [function(method, host, port, path) {
        var t1, fragmentStart, queryStart, i, t2, char, query;
        t1 = J.getInterceptor$asx(path);
        fragmentStart = t1.get$length(path);
        queryStart = t1.get$length(path);
        for (i = J.$sub$n(t1.get$length(path), 1); t2 = J.getInterceptor$n(i), t2.$ge(i, 0); i = t2.$sub(i, 1)) {
          char = t1.codeUnitAt$1(path, i);
          if (char === 35) {
            queryStart = i;
            fragmentStart = queryStart;
          } else if (char === 63)
            queryStart = i;
        }
        t2 = J.getInterceptor$n(queryStart);
        if (t2.$lt(queryStart, fragmentStart)) {
          query = t1.substring$2(path, t2.$add(queryStart, 1), fragmentStart);
          path = t1.substring$2(path, 0, queryStart);
        } else
          query = null;
        return this._openUrl$2(method, P._Uri__Uri(null, host, path, null, port, query, null, "http", null));
      }, "call$4", "get$open", 8, 0, 993, 98, [], 29, [], 26, [], 10, [], "open"],
      openUrl$2: [function(method, url) {
        return this._openUrl$2(method, url);
      }, "call$2", "get$openUrl", 4, 0, 999, 98, [], 75, [], "openUrl"],
      $get$3: [function(host, port, path) {
        return this.open$4("get", host, port, path);
      }, "call$3", "get$get", 6, 0, 116, 29, [], 26, [], 10, [], "get"],
      getUrl$1: [function(url) {
        return this._openUrl$2("get", url);
      }, "call$1", "get$getUrl", 2, 0, 117, 75, [], "getUrl"],
      post$3: [function(host, port, path) {
        return this.open$4("post", host, port, path);
      }, "call$3", "get$post", 6, 0, 116, 29, [], 26, [], 10, [], "post"],
      postUrl$1: [function(url) {
        return this._openUrl$2("post", url);
      }, "call$1", "get$postUrl", 2, 0, 117, 75, [], "postUrl"],
      put$3: [function(host, port, path) {
        return this.open$4("put", host, port, path);
      }, "call$3", "get$put", 6, 0, 116, 29, [], 26, [], 10, [], "put"],
      putUrl$1: [function(url) {
        return this._openUrl$2("put", url);
      }, "call$1", "get$putUrl", 2, 0, 117, 75, [], "putUrl"],
      delete$3: [function(host, port, path) {
        return this.open$4("delete", host, port, path);
      }, "call$3", "get$$delete", 6, 0, 116, 29, [], 26, [], 10, [], "delete"],
      deleteUrl$1: [function(url) {
        return this._openUrl$2("delete", url);
      }, "call$1", "get$deleteUrl", 2, 0, 117, 75, [], "deleteUrl"],
      head$3: [function(host, port, path) {
        return this.open$4("head", host, port, path);
      }, "call$3", "get$head", 6, 0, 116, 29, [], 26, [], 10, [], "head"],
      headUrl$1: [function(url) {
        return this._openUrl$2("head", url);
      }, "call$1", "get$headUrl", 2, 0, 117, 75, [], "headUrl"],
      patch$3: [function(host, port, path) {
        return this.open$4("patch", host, port, path);
      }, "call$3", "get$patch", 6, 0, 116, 29, [], 26, [], 10, [], "patch"],
      patchUrl$1: [function(url) {
        return this._openUrl$2("patch", url);
      }, "call$1", "get$patchUrl", 2, 0, 117, 75, [], "patchUrl"],
      close$1$force: [function(force) {
        this._closing = true;
        this._closingForcefully = force;
        this._closeConnections$1(force);
      }, function() {
        return this.close$1$force(false);
      }, "close$0", "call$1$force", "call$0", "get$close", 0, 3, 1111, 4, 235, [], "close"],
      set$authenticate: [function(f) {
        this._authenticate = f;
      }, null, null, 3, 0, 1116, 9, [], "authenticate"],
      addCredentials$3: [function(url, realm, cr) {
        var t1 = new P._SiteCredentials(url, cr, realm, false, null, null, null, null, null);
        t1._Credentials$2(cr, realm);
        J.add$1$ax(this._credentials, t1);
      }, "call$3", "get$addCredentials", 6, 0, 1119, 75, [], 152, [], 190, [], "addCredentials"],
      set$authenticateProxy: [function(f) {
        this._authenticateProxy = f;
      }, null, null, 3, 0, 1121, 9, [], "authenticateProxy"],
      addProxyCredentials$4: [function(host, port, realm, cr) {
        var t1 = new P._ProxyCredentials(host, port, cr, realm, false, null, null, null, null, null);
        t1._Credentials$2(cr, realm);
        J.add$1$ax(this._proxyCredentials, t1);
      }, "call$4", "get$addProxyCredentials", 8, 0, 1123, 29, [], 26, [], 152, [], 190, [], "addProxyCredentials"],
      set$findProxy: [function(f) {
        this._findProxy = f;
        return f;
      }, null, null, 3, 0, 1125, 9, [], "findProxy"],
      _openUrl$2: [function(method, uri) {
        var t1, error, stackTrace, isSecure, port, t2, t3, proxyConf, exception;
        t1 = {};
        t1.uri = uri;
        uri = uri.removeFragment$0();
        t1.uri = uri;
        if (method == null)
          throw H.wrapException(P.ArgumentError$(method));
        if (!J.$eq$(method, "CONNECT"))
          if (J.get$isEmpty$asx(uri.get$host()) === true)
            throw H.wrapException(P.ArgumentError$("No host specified in URI " + H.S(uri)));
          else if (!J.$eq$(uri.get$scheme(), "http") && !J.$eq$(uri.get$scheme(), "https"))
            throw H.wrapException(P.ArgumentError$("Unsupported scheme '" + H.S(uri.get$scheme()) + "' in URI " + H.S(uri)));
        isSecure = J.$eq$(uri.get$scheme(), "https");
        port = uri.get$port();
        t1.port = port;
        if (J.$eq$(port, 0)) {
          port = isSecure ? 443 : 80;
          t1.port = port;
          t2 = port;
        } else
          t2 = port;
        t1.proxyConf = C._ProxyConfiguration_8Zd;
        t3 = this._findProxy;
        if (t3 != null)
          try {
            proxyConf = P._ProxyConfiguration$(t3.call$1(uri));
            t1.proxyConf = proxyConf;
            t3 = proxyConf;
          } catch (exception) {
            t1 = H.unwrapException(exception);
            error = t1;
            stackTrace = H.getTraceFromException(exception);
            return P.Future_Future$error(error, stackTrace, null);
          }
        else
          t3 = C._ProxyConfiguration_8Zd;
        return this._getConnection$4(uri.get$host(), t2, t3, isSecure).then$1(new P._HttpClient__openUrl_closure(t1, this, method, isSecure));
      }, "call$2", "get$_openUrl", 4, 0, 1126, 98, [], 40, [], "_openUrl"],
      _openUrlFromRequest$3: [function(method, uri, previous) {
        return this._openUrl$2(method, previous.get$uri().resolveUri$1(uri)).then$1(new P._HttpClient__openUrlFromRequest_closure(previous));
      }, "call$3", "get$_openUrlFromRequest", 6, 0, 1127, 98, [], 40, [], 340, [], "_openUrlFromRequest"],
      _returnConnection$1: [function(connection) {
        J.$index$asx(this._connectionTargets, connection.get$key()).returnConnection$1(connection);
        if (this._closing === true)
          this._closeConnections$1(this._closingForcefully);
      }, "call$1", "get$_returnConnection", 2, 0, 165, 99, [], "_returnConnection"],
      _connectionClosed$1: [function(connection) {
        var t1, t2, connectionTarget;
        connection.stopTimer$0();
        t1 = this._connectionTargets;
        t2 = J.getInterceptor$asx(t1);
        connectionTarget = t2.$index(t1, connection.get$key());
        if (connectionTarget != null) {
          connectionTarget.connectionClosed$1(connection);
          if (J.get$isEmpty$asx(connectionTarget) === true)
            t2.remove$1(t1, connection.get$key());
          if (this._closing === true)
            this._closeConnections$1(this._closingForcefully);
        }
      }, "call$1", "get$_connectionClosed", 2, 0, 165, 99, [], "_connectionClosed"],
      _connectionsChanged$0: [function() {
        if (this._closing === true)
          this._closeConnections$1(this._closingForcefully);
      }, "call$0", "get$_connectionsChanged", 0, 0, 6, "_connectionsChanged"],
      _closeConnections$1: [function(force) {
        var t1, t2, _i;
        for (t1 = this._connectionTargets.get$values().toList$0(0), t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
          t1[_i].close$1(force);
      }, "call$1", "get$_closeConnections", 2, 0, 35, 235, [], "_closeConnections"],
      _getConnectionTarget$3: [function(host, port, isSecure) {
        var key = isSecure === true ? "ssh:" + H.S(host) + ":" + H.S(port) : H.S(host) + ":" + H.S(port);
        return this._connectionTargets.putIfAbsent$2(key, new P._HttpClient__getConnectionTarget_closure(this, host, port, isSecure, key));
      }, "call$3", "get$_getConnectionTarget", 6, 0, 1129, 29, [], 26, [], 270, [], "_getConnectionTarget"],
      _getConnection$4: [function(uriHost, uriPort, proxyConf, isSecure) {
        return P.Future_Future(new P._HttpClient__getConnection_closure(new P._HttpClient__getConnection_connect(this, uriHost, uriPort, isSecure, J.get$iterator$ax(proxyConf.get$proxies()))), P._ConnectionInfo);
      }, "call$4", "get$_getConnection", 8, 0, 1131, 489, [], 510, [], 900, [], 270, [], "_getConnection"],
      _findCredentials$2: [function(url, scheme) {
        return J.fold$2$ax(this._credentials, null, new P._HttpClient__findCredentials_closure(url, scheme));
      }, function(url) {
        return this._findCredentials$2(url, null);
      }, "_findCredentials$1", "call$2", "call$1", "get$_findCredentials", 2, 2, 1132, 0, 75, [], 44, [], "_findCredentials"],
      _findProxyCredentials$2: [function(proxy, scheme) {
        var it = J.get$iterator$ax(this._proxyCredentials);
        for (; it.moveNext$0();)
          if (it.get$current().applies$2(proxy, scheme))
            return it.get$current();
        return;
      }, function(proxy) {
        return this._findProxyCredentials$2(proxy, null);
      }, "_findProxyCredentials$1", "call$2", "call$1", "get$_findProxyCredentials", 2, 2, 1134, 0, 142, [], 44, [], "_findProxyCredentials"],
      _removeCredentials$1: [function(cr) {
        var t1, t2, index;
        t1 = this._credentials;
        t2 = J.getInterceptor$asx(t1);
        index = t2.indexOf$1(t1, cr);
        if (!J.$eq$(index, -1))
          t2.removeAt$1(t1, index);
      }, "call$1", "get$_removeCredentials", 2, 0, 206, 190, [], "_removeCredentials"],
      _removeProxyCredentials$1: [function(cr) {
        var t1, t2, index;
        t1 = this._proxyCredentials;
        t2 = J.getInterceptor$asx(t1);
        index = t2.indexOf$1(t1, cr);
        if (!J.$eq$(index, -1))
          t2.removeAt$1(t1, index);
      }, "call$1", "get$_removeProxyCredentials", 2, 0, 206, 190, [], "_removeProxyCredentials"],
      _authenticate$1: function(arg0) {
        return this._authenticate.call$1(arg0);
      },
      _authenticate$3: function(arg0, arg1, arg2) {
        return this._authenticate.call$3(arg0, arg1, arg2);
      },
      _authenticateProxy$4: function(arg0, arg1, arg2, arg3) {
        return this._authenticateProxy.call$4(arg0, arg1, arg2, arg3);
      },
      static: {
        "^": "_HttpClient__platformEnvironmentCache@-82",
        _HttpClient$: [function(_context) {
          var t1, version;
          t1 = P.HashMap_HashMap(null, null, null, P.String, P._ConnectionTarget);
          version = $.$get$Platform__version();
          return new P._HttpClient(false, false, t1, [], [], _context, null, null, P.io_HttpClient_findProxyFromEnvironment$closure(), C.Duration_15000000, null, null, true, "Dart/" + H.S(C.JSNull_methods.substring$2(version, 0, C.JSNull_methods.indexOf$2(version, ".", C.JSNull_methods.indexOf$1(version, ".").$add(0, 1)))) + " (dart:io)");
        }, null, null, 2, 0, 892, 418, [], "new _HttpClient"],
        _HttpClient__findProxyFromEnvironment: [function(url, environment) {
          var t1, t2, noProxy, proxyCfg, proxy;
          t1 = new P._HttpClient__findProxyFromEnvironment_checkProxy();
          if (environment == null)
            environment = $.$get$_HttpClient__platformEnvironmentCache();
          t2 = J.getInterceptor$asx(environment);
          noProxy = t2.$index(environment, "no_proxy");
          if (noProxy == null)
            noProxy = t2.$index(environment, "NO_PROXY");
          proxyCfg = new P._HttpClient__findProxyFromEnvironment_checkNoProxy(url).call$1(noProxy);
          if (proxyCfg != null)
            return proxyCfg;
          if (J.$eq$(url.get$scheme(), "http")) {
            proxy = t2.$index(environment, "http_proxy");
            proxyCfg = t1.call$1(proxy == null ? t2.$index(environment, "HTTP_PROXY") : proxy);
            if (proxyCfg != null)
              return proxyCfg;
          } else if (J.$eq$(url.get$scheme(), "https")) {
            proxy = t2.$index(environment, "https_proxy");
            proxyCfg = t1.call$1(proxy == null ? t2.$index(environment, "HTTPS_PROXY") : proxy);
            if (proxyCfg != null)
              return proxyCfg;
          }
          return "DIRECT";
        }, "call$2", "io__HttpClient__findProxyFromEnvironment$closure", 4, 0, 893, 75, [], 155, [], "_findProxyFromEnvironment"]
      }
    },
    "+_HttpClient": [1, 509],
    _HttpClient__openUrl_closure: {
      "^": "Closure:354;_box_0,$this,method,isSecure",
      call$1: [function(info) {
        var t1, t2;
        t1 = this._box_0;
        t2 = new P._HttpClient__openUrl__send(t1, this.method);
        if (info.get$connection().get$closed() === true)
          return this.$this._getConnection$4(t1.uri.get$host(), t1.port, t1.proxyConf, this.isSecure).then$1(t2);
        return t2.call$1(info);
      }, null, null, 2, 0, 354, 131, [], "call"]
    },
    "+ _HttpClient__openUrl_closure": [2],
    _HttpClient__openUrl__send: {
      "^": "Closure:355;_box_0,method",
      call$1: [function(info) {
        var t1 = this._box_0;
        return info.get$connection().send$4(t1.uri, t1.port, J.toUpperCase$0$s(this.method), info.get$proxy());
      }, null, null, 2, 0, 355, 131, [], "call"]
    },
    "+ _HttpClient__openUrl__send": [2],
    _HttpClient__openUrlFromRequest_closure: {
      "^": "Closure:356;previous",
      call$1: [function(request) {
        var t1, t2, header;
        t1 = this.previous;
        request.set$followRedirects(t1.get$followRedirects());
        request.set$maxRedirects(t1.get$maxRedirects());
        for (t2 = t1.get$headers().get$_headers().get$keys(), t2 = t2.get$iterator(t2); t2.moveNext$0();) {
          header = t2.get$current();
          if (J.$index$asx(request.get$headers(), header) == null)
            request.get$headers().$set$2(header, J.$index$asx(t1.get$headers(), header));
        }
        request.get$headers().set$chunkedTransferEncoding(false);
        request.set$contentLength(0);
        return request;
      }, null, null, 2, 0, 356, 54, [], "call"]
    },
    "+ _HttpClient__openUrlFromRequest_closure": [2],
    _HttpClient__getConnectionTarget_closure: {
      "^": "Closure:4;$this,host,port,isSecure,key",
      call$0: [function() {
        return new P._ConnectionTarget(this.key, this.host, this.port, this.isSecure, this.$this._context, P.HashSet_HashSet(null, null, null, null), P.HashSet_HashSet(null, null, null, null), P.ListQueue$(null, null), 0);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _HttpClient__getConnectionTarget_closure": [2],
    _HttpClient__getConnection_connect: {
      "^": "Closure:357;$this,uriHost,uriPort,isSecure,proxies",
      call$1: [function(error) {
        var t1, proxy, host, port;
        t1 = this.proxies;
        if (!t1.moveNext$0())
          return P.Future_Future$error(error, null, null);
        proxy = t1.get$current();
        host = proxy.get$isDirect() === true ? this.uriHost : proxy.get$host();
        port = proxy.get$isDirect() === true ? this.uriPort : proxy.get$port();
        t1 = this.$this;
        return t1._getConnectionTarget$3(host, port, this.isSecure).connect$4(this.uriHost, this.uriPort, proxy, t1).catchError$1(this);
      }, null, null, 2, 0, 357, 8, [], "call"]
    },
    "+ _HttpClient__getConnection_connect": [2],
    _HttpClient__getConnection_closure: {
      "^": "Closure:4;connect",
      call$0: [function() {
        return this.connect.call$1(new P.HttpException("No proxies given", null));
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _HttpClient__getConnection_closure": [2],
    _HttpClient__findCredentials_closure: {
      "^": "Closure:358;url,scheme",
      call$2: [function(prev, value) {
        H.interceptedTypeCast(value, "$is_SiteCredentials");
        if (value.applies$2(this.url, this.scheme)) {
          if (prev == null)
            return value;
          return J.$gt$n(J.get$length$asx(value.uri.get$path()), J.get$length$asx(prev.get$uri().get$path())) ? value : prev;
        } else
          return prev;
      }, null, null, 4, 0, 358, 901, [], 1, [], "call"]
    },
    "+ _HttpClient__findCredentials_closure": [2],
    _HttpClient__findProxyFromEnvironment_checkNoProxy: {
      "^": "Closure:13;url",
      call$1: [function(option) {
        var t1, names, $name, t2;
        if (option == null)
          return;
        t1 = new H.MappedListIterable(J.split$1$s(option, ","), new P._HttpClient__findProxyFromEnvironment_checkNoProxy_closure(), [null, null]);
        names = new H.ListIterator(t1, t1.get$length(t1), 0, null, [null]);
        for (t1 = this.url; names.moveNext$0();) {
          $name = names.__internal$_current;
          t2 = J.getInterceptor$s($name);
          if (!(t2.startsWith$1($name, "[") && t2.endsWith$1($name, "]") && "[" + H.S(t1.get$host()) + "]" === $name))
            t2 = t2.get$isNotEmpty($name) && J.endsWith$1$s(t1.get$host(), $name);
          else
            t2 = true;
          if (t2)
            return "DIRECT";
        }
        return;
      }, null, null, 2, 0, 13, 66, [], "call"]
    },
    "+ _HttpClient__findProxyFromEnvironment_checkNoProxy": [2],
    _HttpClient__findProxyFromEnvironment_checkNoProxy_closure: {
      "^": "Closure:3;",
      call$1: [function(s) {
        return J.trim$0$s(s);
      }, null, null, 2, 0, 3, 49, [], "call"]
    },
    "+ _HttpClient__findProxyFromEnvironment_checkNoProxy_closure": [2],
    _HttpClient__findProxyFromEnvironment_checkProxy: {
      "^": "Closure:13;",
      call$1: [function(option) {
        var pos;
        if (option == null)
          return;
        option = J.trim$0$s(option);
        if (option.length === 0)
          return;
        pos = C.JSString_methods.indexOf$1(option, "://");
        if (pos >= 0)
          option = C.JSString_methods.substring$1(option, pos + 3);
        pos = C.JSString_methods.indexOf$1(option, "/");
        if (pos >= 0)
          option = C.JSString_methods.substring$2(option, 0, pos);
        if (C.JSString_methods.indexOf$1(option, "[") === 0) {
          pos = C.JSString_methods.lastIndexOf$1(option, ":");
          if (C.JSString_methods.indexOf$1(option, "]") > pos)
            option += ":1080";
        } else if (C.JSString_methods.indexOf$1(option, ":") === -1)
          option += ":1080";
        return "PROXY " + option;
      }, null, null, 2, 0, 13, 66, [], "call"]
    },
    "+ _HttpClient__findProxyFromEnvironment_checkProxy": [2],
    _HttpConnection: {
      "^": "LinkedListEntry__ServiceObject;_socket<-10,_httpServer<-500,_httpParser<-507,_io$_state@-0,_io$_subscription@-103,_idleMark@-8,_streamFuture@-86,_ServiceObject___serviceId-0,_list-258,_collection$_next-120,_collection$_previous-120",
      markIdle$0: [function() {
        this._idleMark = true;
      }, "call$0", "get$markIdle", 0, 0, 6, "markIdle"],
      get$isMarkedIdle: [function() {
        return this._idleMark;
      }, null, null, 1, 0, 5, "isMarkedIdle"],
      destroy$0: [function() {
        if (J.$eq$(this._io$_state, 2) || J.$eq$(this._io$_state, 3))
          return;
        this._io$_state = 2;
        this._socket.destroy$0();
        this._httpServer._connectionClosed$1(this);
        J.remove$1$ax($.$get$_HttpConnection__connections(), this.get$_serviceId());
      }, "call$0", "get$destroy", 0, 0, 6, "destroy"],
      detachSocket$0: [function() {
        this._io$_state = 3;
        this._httpServer._connectionClosed$1(this);
        var detachedIncoming = this._httpParser.detachIncoming$0();
        return this._streamFuture.then$1(new P._HttpConnection_detachSocket_closure(this, detachedIncoming));
      }, "call$0", "get$detachSocket", 0, 0, 104, "detachSocket"],
      get$connectionInfo: [function() {
        return P._HttpConnectionInfo_create(this._socket);
      }, null, null, 1, 0, 97, "connectionInfo"],
      get$_isActive: [function() {
        return J.$eq$(this._io$_state, 0);
      }, null, null, 1, 0, 5, "_isActive"],
      get$_isIdle: [function() {
        return J.$eq$(this._io$_state, 1);
      }, null, null, 1, 0, 5, "_isIdle"],
      get$_isClosing: [function() {
        return J.$eq$(this._io$_state, 2);
      }, null, null, 1, 0, 5, "_isClosing"],
      get$_isDetached: [function() {
        return J.$eq$(this._io$_state, 3);
      }, null, null, 1, 0, 5, "_isDetached"],
      get$_serviceTypePath: [function() {
        return "io/http/serverconnections";
      }, null, null, 1, 0, 7, "_serviceTypePath"],
      get$_serviceTypeName: [function() {
        return "HttpServerConnection";
      }, null, null, 1, 0, 7, "_serviceTypeName"],
      _io$_toJSON$1: [function(ref) {
        var r, t1, $name, exception;
        t1 = this._socket;
        $name = H.S(t1.get$address().get$host()) + ":" + H.S(t1.get$port()) + " <-> " + H.S(t1.get$remoteAddress().get$host()) + ":" + H.S(t1.get$remotePort());
        r = P.LinkedHashMap_LinkedHashMap$_literal(["id", this.get$_serviceTypePath() + "/" + H.S(this.get$_serviceId()), "type", this._serviceType$1(ref), "name", $name, "user_name", $name], P.String, null);
        if (ref === true)
          return r;
        J.$indexSet$ax(r, "server", this._httpServer._io$_toJSON$1(true));
        try {
          J.$indexSet$ax(r, "socket", t1._io$_toJSON$1(true));
        } catch (exception) {
          H.unwrapException(exception);
          J.$indexSet$ax(r, "socket", P.LinkedHashMap__makeLiteral(["id", this.get$_serviceTypePath() + "/" + H.S(this.get$_serviceId()), "type", "@Socket", "name", "UserSocket", "user_name", "UserSocket"]));
        }
        switch (this._io$_state) {
          case 0:
            J.$indexSet$ax(r, "state", "Active");
            break;
          case 1:
            J.$indexSet$ax(r, "state", "Idle");
            break;
          case 2:
            J.$indexSet$ax(r, "state", "Closing");
            break;
          case 3:
            J.$indexSet$ax(r, "state", "Detached");
            break;
          default:
            J.$indexSet$ax(r, "state", "Unknown");
            break;
        }
        return r;
      }, "call$1", "get$_io$_toJSON", 2, 0, 359, 151, [], "_io$_toJSON"],
      _HttpConnection$2: function(_socket, _httpServer) {
        var _, exception, t1;
        try {
          this._socket.set$_io$_owner(this);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          _ = t1;
          P.print(_);
        }
        J.$indexSet$ax($.$get$_HttpConnection__connections(), this.get$_serviceId(), this);
        t1 = this._httpParser;
        t1.listenToStream$1(this._socket);
        this._io$_subscription = t1.listen$3$onDone$onError(new P._HttpConnection_closure(this), new P._HttpConnection_closure0(this), new P._HttpConnection_closure1(this));
      },
      static: {
        "^": "_HttpConnection__ACTIVE<-10,_HttpConnection__IDLE<-10,_HttpConnection__CLOSING<-10,_HttpConnection__DETACHED<-10,_HttpConnection__connections@-1558",
        _HttpConnection$: [function(_socket, _httpServer) {
          var t1 = new P._HttpConnection(_socket, _httpServer, P._HttpParser$_(true), 1, null, false, null, 0, null, null, null);
          t1._HttpConnection$2(_socket, _httpServer);
          return t1;
        }, null, null, 4, 0, 894, 148, [], 456, [], "new _HttpConnection"]
      }
    },
    "+_HttpConnection": [1559],
    LinkedListEntry__ServiceObject: {
      "^": "LinkedListEntry+_ServiceObject;__serviceId:_ServiceObject___serviceId@-0,_list-258,_collection$_next-120,_collection$_previous-120",
      $asLinkedListEntry: function() {
        return [P._HttpConnection];
      },
      "<>": [],
      static: {
        "LinkedListEntry+_ServiceObject$": [function() {
          return new P.LinkedListEntry__ServiceObject(0, null, null, null);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(E) {
            return {func: 1, ret: [P.LinkedListEntry, E]};
          }, this.$receiver, "LinkedListEntry");
        }, "new LinkedListEntry+_ServiceObject"]
      }
    },
    _HttpConnection_closure: {
      "^": "Closure:3;$this",
      call$1: [function(incoming) {
        var t1, t2, t3, outgoing, t4, t5, t6, t7, t8, response, request;
        t1 = this.$this;
        t2 = t1._httpServer;
        t2._markActive$1(t1);
        incoming.get$dataDone().then$1(new P._HttpConnection__closure(t1));
        t1._io$_subscription.pause$0();
        t1._io$_state = 0;
        t3 = P.Socket;
        t3 = new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [t3]), [t3]);
        outgoing = new P._HttpOutgoing(t3, t1._socket, false, false, null, 0, null, false, 0, null, 0, false, null, null, null, 0, false, null);
        t4 = incoming.get$uri();
        t5 = incoming.get$headers().get$protocolVersion();
        t6 = t2.get$defaultResponseHeaders();
        t7 = t2.get$serverHeader();
        t8 = P._HttpHeaders$(t5, J.$eq$(t4.get$scheme(), "https") ? 443 : 80, t6);
        response = new P._HttpResponse(200, null, null, null, null, null, false, true, t4, outgoing, t8, null, true, outgoing, new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]), null, null, false, false, false);
        response._HttpOutboundMessage$4$initialHeaders(t4, t5, outgoing, t6, P.HttpResponse);
        if (t7 != null)
          t8.$set$2("server", t7);
        request = P._HttpRequest$(response, incoming, t2, t1);
        t1._streamFuture = t3.future.then$2$onError(new P._HttpConnection__closure0(t1, incoming, response, request), new P._HttpConnection__closure1(t1));
        outgoing.ignoreBody = J.$eq$(request._incoming.get$method(), "HEAD");
        response._httpRequest = request;
        t2._handleRequest$1(request);
      }, null, null, 2, 0, 3, 236, [], "call"]
    },
    "+ _HttpConnection_closure": [2],
    _HttpConnection__closure: {
      "^": "Closure:3;$this",
      call$1: [function(closing) {
        if (closing === true)
          this.$this.destroy$0();
      }, null, null, 2, 0, 3, 237, [], "call"]
    },
    "+ _HttpConnection__closure": [2],
    _HttpConnection__closure0: {
      "^": "Closure:3;$this,incoming,response,request",
      call$1: [function(_) {
        var t1, t2;
        t1 = this.response;
        t1.set$deadline(null);
        t2 = this.$this;
        if (J.$eq$(t2._io$_state, 3))
          return;
        if (t1.headers.get$persistentConnection() === true && this.request._incoming.get$headers().get$persistentConnection() === true && this.incoming.get$fullBodyRead() === true && !t2._httpParser.get$upgrade() && t2._httpServer.get$closed() !== true) {
          t2._io$_state = 1;
          t2._idleMark = false;
          t2._httpServer._markIdle$1(t2);
          t2._io$_subscription.resume$0();
        } else
          t2.destroy$0();
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _HttpConnection__closure": [2],
    _HttpConnection__closure1: {
      "^": "Closure:3;$this",
      call$1: [function(_) {
        this.$this.destroy$0();
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _HttpConnection__closure": [2],
    _HttpConnection_closure0: {
      "^": "Closure:4;$this",
      call$0: [function() {
        this.$this.destroy$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _HttpConnection_closure": [2],
    _HttpConnection_closure1: {
      "^": "Closure:3;$this",
      call$1: [function(error) {
        this.$this.destroy$0();
      }, null, null, 2, 0, 3, 8, [], "call"]
    },
    "+ _HttpConnection_closure": [2],
    _HttpConnection_detachSocket_closure: {
      "^": "Closure:3;$this,detachedIncoming",
      call$1: [function(_) {
        var t1 = this.$this;
        J.remove$1$ax($.$get$_HttpConnection__connections(), t1.get$_serviceId());
        return new P._DetachedSocket(this.detachedIncoming, t1._socket);
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _HttpConnection_detachSocket_closure": [2],
    _HttpServer: {
      "^": "Stream__ServiceObject;serverHeader@-9,defaultResponseHeaders<-498,autoCompress@-8,_idleTimeout@-65,_idleTimer@-128,_sessionManagerInstance@-510,closed@-8,_serverSocket<-10,_closeServer<-8,_activeConnections<-511,_idleConnections<-511,_io$_controller@-1562,_ServiceObject___serviceId-0",
      get$idleTimeout: [function() {
        return this._idleTimeout;
      }, null, null, 1, 0, 83, "idleTimeout"],
      set$idleTimeout: [function(duration) {
        var t1 = this._idleTimer;
        if (t1 != null) {
          t1.cancel$0();
          this._idleTimer = null;
        }
        this._idleTimeout = duration;
        if (duration != null)
          this._idleTimer = P.Timer_Timer$periodic(duration, new P._HttpServer_idleTimeout_closure(this));
      }, null, null, 3, 0, 162, 59, [], "idleTimeout"],
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        this._serverSocket.listen$3$onDone$onError(new P._HttpServer_listen_closure(this), this._io$_controller.get$close(), new P._HttpServer_listen_closure0(this));
        return this._io$_controller.get$stream().listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, onError);
      }, "listen$2$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, null);
      }, "listen$2$onDone", function(onData, cancelOnError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, null, null);
      }, "listen$2$cancelOnError", "call$4$cancelOnError$onDone$onError", "call$1", "call$2$onError", "call$3$onDone$onError", "call$3$onDone$onError", "call$2$onDone", "call$2$cancelOnError", "get$listen", 2, 7, 1215, 0, 0, 0, 27, [], 20, [], 28, [], 24, [], "listen"],
      close$1$force: [function(force) {
        var t1, result;
        this.closed = true;
        t1 = this._serverSocket;
        if (t1 != null && this._closeServer === true)
          result = t1.close$0();
        else {
          result = new P._Future(0, $.Zone__current, null, [null]);
          result._asyncComplete$1(null);
        }
        this.set$idleTimeout(null);
        if (force === true)
          for (t1 = J.get$iterator$ax(J.toList$0$ax(this._activeConnections)); t1.moveNext$0();)
            t1.__interceptors$_current.destroy$0();
        for (t1 = J.get$iterator$ax(J.toList$0$ax(this._idleConnections)); t1.moveNext$0();)
          t1.__interceptors$_current.destroy$0();
        this._maybePerformCleanup$0();
        return result;
      }, function() {
        return this.close$1$force(false);
      }, "close$0", "call$1$force", "call$0", "get$close", 0, 3, 1216, 4, 235, [], "close"],
      _maybePerformCleanup$0: [function() {
        if (this.closed === true && J.get$isEmpty$asx(this._idleConnections) === true && J.get$isEmpty$asx(this._activeConnections) === true && this._sessionManagerInstance != null) {
          this._sessionManagerInstance.close$0();
          this._sessionManagerInstance = null;
          J.remove$1$ax($.$get$_HttpServer__servers(), this.get$_serviceId());
        }
      }, "call$0", "get$_maybePerformCleanup", 0, 0, 6, "_maybePerformCleanup"],
      get$port: [function() {
        if (this.closed === true)
          throw H.wrapException(new P.HttpException("HttpServer is not bound to a socket", null));
        return this._serverSocket.get$port();
      }, null, null, 1, 0, 11, "port"],
      get$address: [function() {
        if (this.closed === true)
          throw H.wrapException(new P.HttpException("HttpServer is not bound to a socket", null));
        return this._serverSocket.get$address();
      }, null, null, 1, 0, 68, "address"],
      set$sessionTimeout: [function(timeout) {
        this.get$_sessionManager().set$sessionTimeout(timeout);
      }, null, null, 3, 0, 22, 316, [], "sessionTimeout"],
      _handleRequest$1: [function(request) {
        if (this.closed !== true)
          J.add$1$ax(this._io$_controller, request);
        else
          request.get$_httpConnection().destroy$0();
      }, "call$1", "get$_handleRequest", 2, 0, 1257, 54, [], "_handleRequest"],
      _connectionClosed$1: [function(connection) {
        connection.unlink$0();
        this._maybePerformCleanup$0();
      }, "call$1", "get$_connectionClosed", 2, 0, 262, 99, [], "_connectionClosed"],
      _markIdle$1: [function(connection) {
        J.remove$1$ax(this._activeConnections, connection);
        J.add$1$ax(this._idleConnections, connection);
      }, "call$1", "get$_markIdle", 2, 0, 262, 99, [], "_markIdle"],
      _markActive$1: [function(connection) {
        J.remove$1$ax(this._idleConnections, connection);
        J.add$1$ax(this._activeConnections, connection);
      }, "call$1", "get$_markActive", 2, 0, 262, 99, [], "_markActive"],
      get$_sessionManager: [function() {
        var t1 = this._sessionManagerInstance;
        if (t1 == null) {
          t1 = new P._HttpSessionManager(P.LinkedHashMap__makeEmpty(), 1200, null, null, null);
          this._sessionManagerInstance = t1;
        }
        return t1;
      }, null, null, 1, 0, 1304, "_sessionManager"],
      connectionsInfo$0: [function() {
        var result, t1, t2, t3, t4;
        result = new P.HttpConnectionsInfo(0, 0, 0, 0);
        t1 = this._activeConnections;
        t2 = J.getInterceptor$asx(t1);
        t3 = this._idleConnections;
        t4 = J.getInterceptor$asx(t3);
        result.total = J.$add$ns(t2.get$length(t1), t4.get$length(t3));
        t2.forEach$1(t1, new P._HttpServer_connectionsInfo_closure(result));
        t4.forEach$1(t3, new P._HttpServer_connectionsInfo_closure0(result));
        return result;
      }, "call$0", "get$connectionsInfo", 0, 0, 360, "connectionsInfo"],
      get$_serviceTypePath: [function() {
        return "io/http/servers";
      }, null, null, 1, 0, 7, "_serviceTypePath"],
      get$_serviceTypeName: [function() {
        return "HttpServer";
      }, null, null, 1, 0, 7, "_serviceTypeName"],
      _io$_toJSON$1: [function(ref) {
        var r, t1, t2, t3, t4, t5, exception;
        t1 = this.get$_serviceTypePath() + "/" + H.S(this.get$_serviceId());
        t2 = this._serviceType$1(ref);
        if (this.closed === true)
          H.throwExpression(new P.HttpException("HttpServer is not bound to a socket", null));
        t3 = this._serverSocket;
        t4 = H.S(t3.get$address().get$host()) + ":";
        if (this.closed === true)
          H.throwExpression(new P.HttpException("HttpServer is not bound to a socket", null));
        t4 += H.S(t3.get$port());
        if (this.closed === true)
          H.throwExpression(new P.HttpException("HttpServer is not bound to a socket", null));
        t5 = H.S(t3.get$address().get$host()) + ":";
        if (this.closed === true)
          H.throwExpression(new P.HttpException("HttpServer is not bound to a socket", null));
        r = P.LinkedHashMap_LinkedHashMap$_literal(["id", t1, "type", t2, "name", t4, "user_name", t5 + H.S(t3.get$port())], P.String, null);
        if (ref === true)
          return r;
        try {
          J.$indexSet$ax(r, "socket", t3._io$_toJSON$1(true));
        } catch (exception) {
          H.unwrapException(exception);
          J.$indexSet$ax(r, "socket", P.LinkedHashMap__makeLiteral(["id", this.get$_serviceTypePath() + "/" + H.S(this.get$_serviceId()), "type", "@Socket", "name", "UserSocket", "user_name", "UserSocket"]));
        }
        if (this.closed === true)
          H.throwExpression(new P.HttpException("HttpServer is not bound to a socket", null));
        J.$indexSet$ax(r, "port", t3.get$port());
        if (this.closed === true)
          H.throwExpression(new P.HttpException("HttpServer is not bound to a socket", null));
        J.$indexSet$ax(r, "address", t3.get$address().get$host());
        J.$indexSet$ax(r, "active", J.map$1$ax(this._activeConnections, new P._HttpServer__toJSON_closure()).toList$0(0));
        J.$indexSet$ax(r, "idle", J.map$1$ax(this._idleConnections, new P._HttpServer__toJSON_closure0()).toList$0(0));
        J.$indexSet$ax(r, "closed", this.closed);
        return r;
      }, "call$1", "get$_io$_toJSON", 2, 0, 361, 151, [], "_io$_toJSON"],
      _HttpServer$listenOn$1: function(_serverSocket) {
        var exception;
        this._io$_controller = new P._SyncStreamController(null, 0, null, null, null, null, this.get$close(), [P.HttpRequest]);
        this.set$idleTimeout(C.Duration_120000000);
        J.$indexSet$ax($.$get$_HttpServer__servers(), this.get$_serviceId(), this);
        try {
          this._serverSocket.set$_io$_owner(this);
        } catch (exception) {
          H.unwrapException(exception);
        }
      },
      _HttpServer$_$2: function(_serverSocket, _closeServer) {
        this._io$_controller = new P._SyncStreamController(null, 0, null, null, null, null, this.get$close(), [P.HttpRequest]);
        this.set$idleTimeout(C.Duration_120000000);
        J.$indexSet$ax($.$get$_HttpServer__servers(), this.get$_serviceId(), this);
        this._serverSocket.set$_io$_owner(this);
      },
      $asStream: function() {
        return [P.HttpRequest];
      },
      static: {
        "^": "_HttpServer__servers@-1563",
        _HttpServer_bind: [function(address, port, backlog, v6Only, shared) {
          return P.ServerSocket_bind(address, port, backlog, shared, v6Only).then$1(new P._HttpServer_bind_closure());
        }, "call$5", "io__HttpServer_bind$closure", 10, 0, 895, 81, [], 26, [], 124, [], 121, [], 128, [], "bind"],
        _HttpServer_bindSecure: [function(address, port, context, backlog, v6Only, requestClientCertificate, shared) {
          return P.SecureServerSocket_bind(address, port, context, backlog, requestClientCertificate, false, shared, null, v6Only).then$1(new P._HttpServer_bindSecure_closure());
        }, "call$7", "io__HttpServer_bindSecure$closure", 14, 0, 896, 81, [], 26, [], 76, [], 124, [], 121, [], 97, [], 128, [], "bindSecure"],
        _HttpServer$_: [function(_serverSocket, _closeServer) {
          var defaultResponseHeaders, t1;
          defaultResponseHeaders = P._HttpHeaders$("1.1", 80, null);
          t1 = $.$get$ContentType_TEXT();
          if (defaultResponseHeaders._mutable !== true)
            H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
          defaultResponseHeaders._io$_set$2("content-type", J.toString$0$(t1));
          defaultResponseHeaders.$set$2("X-Frame-Options", "SAMEORIGIN");
          defaultResponseHeaders.$set$2("X-Content-Type-Options", "nosniff");
          defaultResponseHeaders.$set$2("X-XSS-Protection", "1; mode=block");
          t1 = [P._HttpConnection];
          t1 = new P._HttpServer(null, defaultResponseHeaders, false, null, null, null, false, _serverSocket, _closeServer, new P.LinkedList(0, 0, null, t1), new P.LinkedList(0, 0, null, t1), null, 0);
          t1._HttpServer$_$2(_serverSocket, _closeServer);
          return t1;
        }, null, null, 4, 0, 897, 426, [], 778, [], "new _HttpServer$_"],
        _HttpServer$listenOn: [function(_serverSocket) {
          var defaultResponseHeaders, t1;
          defaultResponseHeaders = P._HttpHeaders$("1.1", 80, null);
          t1 = $.$get$ContentType_TEXT();
          if (defaultResponseHeaders._mutable !== true)
            H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
          defaultResponseHeaders._io$_set$2("content-type", J.toString$0$(t1));
          defaultResponseHeaders.$set$2("X-Frame-Options", "SAMEORIGIN");
          defaultResponseHeaders.$set$2("X-Content-Type-Options", "nosniff");
          defaultResponseHeaders.$set$2("X-XSS-Protection", "1; mode=block");
          t1 = [P._HttpConnection];
          t1 = new P._HttpServer(null, defaultResponseHeaders, false, null, null, null, false, _serverSocket, false, new P.LinkedList(0, 0, null, t1), new P.LinkedList(0, 0, null, t1), null, 0);
          t1._HttpServer$listenOn$1(_serverSocket);
          return t1;
        }, null, null, 2, 0, 3, 426, [], "new _HttpServer$listenOn"],
        _HttpServer__initDefaultResponseHeaders: [function() {
          var defaultResponseHeaders, t1;
          defaultResponseHeaders = P._HttpHeaders$("1.1", 80, null);
          t1 = $.$get$ContentType_TEXT();
          if (defaultResponseHeaders._mutable !== true)
            H.throwExpression(new P.HttpException("HTTP headers are not mutable", null));
          defaultResponseHeaders._io$_set$2("content-type", J.toString$0$(t1));
          defaultResponseHeaders.$set$2("X-Frame-Options", "SAMEORIGIN");
          defaultResponseHeaders.$set$2("X-Content-Type-Options", "nosniff");
          defaultResponseHeaders.$set$2("X-XSS-Protection", "1; mode=block");
          return defaultResponseHeaders;
        }, "call$0", "io__HttpServer__initDefaultResponseHeaders$closure", 0, 0, 308, "_initDefaultResponseHeaders"]
      }
    },
    "+_HttpServer": [1564, 1565],
    Stream__ServiceObject: {
      "^": "Stream+_ServiceObject;__serviceId:_ServiceObject___serviceId@-0",
      $asStream: function() {
        return [P.HttpRequest];
      },
      "<>": [],
      static: {
        "Stream+_ServiceObject$": [function() {
          return new P.Stream__ServiceObject(0);
        }, null, null, 0, 0, 4, "new Stream+_ServiceObject"]
      }
    },
    _HttpServer_bind_closure: {
      "^": "Closure:3;",
      call$1: [function(socket) {
        return P._HttpServer$_(socket, true);
      }, null, null, 2, 0, 3, 52, [], "call"]
    },
    "+ _HttpServer_bind_closure": [2],
    _HttpServer_bindSecure_closure: {
      "^": "Closure:3;",
      call$1: [function(socket) {
        return P._HttpServer$_(socket, true);
      }, null, null, 2, 0, 3, 52, [], "call"]
    },
    "+ _HttpServer_bindSecure_closure": [2],
    _HttpServer_idleTimeout_closure: {
      "^": "Closure:3;$this",
      call$1: [function(_) {
        var t1, idle;
        for (t1 = J.get$iterator$ax(J.toList$0$ax(this.$this._idleConnections)); t1.moveNext$0();) {
          idle = t1.__interceptors$_current;
          if (idle.get$isMarkedIdle() === true)
            idle.destroy$0();
          else
            idle.markIdle$0();
        }
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _HttpServer_idleTimeout_closure": [2],
    _HttpServer_listen_closure: {
      "^": "Closure:161;$this",
      call$1: [function(socket) {
        var t1;
        socket.setOption$2(C.SocketOption_0, true);
        t1 = this.$this;
        J.add$1$ax(t1._idleConnections, P._HttpConnection$(socket, t1));
      }, null, null, 2, 0, 161, 52, [], "call"]
    },
    "+ _HttpServer_listen_closure": [2],
    _HttpServer_listen_closure0: {
      "^": "Closure:12;$this",
      call$2: [function(error, stackTrace) {
        if (!(error instanceof P.HandshakeException))
          this.$this._io$_controller.addError$2(error, stackTrace);
      }, null, null, 4, 0, 12, 8, [], 12, [], "call"]
    },
    "+ _HttpServer_listen_closure": [2],
    _HttpServer_connectionsInfo_closure: {
      "^": "Closure:228;result",
      call$1: [function(conn) {
        var t1 = this.result;
        if (conn.get$_isActive())
          t1.set$active(J.$add$ns(t1.get$active(), 1));
        else
          t1.set$closing(J.$add$ns(t1.get$closing(), 1));
      }, null, null, 2, 0, 228, 550, [], "call"]
    },
    "+ _HttpServer_connectionsInfo_closure": [2],
    _HttpServer_connectionsInfo_closure0: {
      "^": "Closure:228;result",
      call$1: [function(conn) {
        var t1 = this.result;
        t1.set$idle(J.$add$ns(t1.get$idle(), 1));
      }, null, null, 2, 0, 228, 550, [], "call"]
    },
    "+ _HttpServer_connectionsInfo_closure": [2],
    _HttpServer__toJSON_closure: {
      "^": "Closure:3;",
      call$1: [function(c) {
        return c._io$_toJSON$1(true);
      }, null, null, 2, 0, 3, 301, [], "call"]
    },
    "+ _HttpServer__toJSON_closure": [2],
    _HttpServer__toJSON_closure0: {
      "^": "Closure:3;",
      call$1: [function(c) {
        return c._io$_toJSON$1(true);
      }, null, null, 2, 0, 3, 301, [], "call"]
    },
    "+ _HttpServer__toJSON_closure": [2],
    _ProxyConfiguration: {
      "^": "Object;proxies<-1566",
      _ProxyConfiguration$1: function(configuration) {
        if (configuration == null)
          throw H.wrapException(new P.HttpException("Invalid proxy configuration " + H.S(configuration), null));
        C.JSArray_methods.forEach$1(J.split$1$s(configuration, ";"), new P._ProxyConfiguration_closure(this, configuration));
      },
      static: {
        "^": "_ProxyConfiguration_PROXY_PREFIX<-9,_ProxyConfiguration_DIRECT_PREFIX<-9",
        _ProxyConfiguration$: [function(configuration) {
          var t1 = new P._ProxyConfiguration(H.setRuntimeTypeInfo([], [P._Proxy]));
          t1._ProxyConfiguration$1(configuration);
          return t1;
        }, null, null, 2, 0, 13, 779, [], "new _ProxyConfiguration"],
        _ProxyConfiguration$direct: [function() {
          return new P._ProxyConfiguration(C.List_jqP);
        }, null, null, 0, 0, 4, "new _ProxyConfiguration$direct"]
      }
    },
    "+_ProxyConfiguration": [1],
    _ProxyConfiguration_closure: {
      "^": "Closure:13;$this,configuration",
      call$1: [function(proxy) {
        var portString, port, at, userinfo, colon, username, password, host, exception;
        proxy = J.trim$0$s(proxy);
        if (proxy.length !== 0)
          if (C.JSString_methods.startsWith$1(proxy, "PROXY ")) {
            proxy = C.JSString_methods.trim$0(C.JSString_methods.substring$1(proxy, 6));
            at = C.JSString_methods.indexOf$1(proxy, "@");
            if (at !== -1) {
              userinfo = C.JSString_methods.trim$0(C.JSString_methods.substring$2(proxy, 0, at));
              proxy = C.JSString_methods.trim$0(C.JSString_methods.substring$1(proxy, at + 1));
              colon = C.JSString_methods.indexOf$1(userinfo, ":");
              if (colon === -1 || colon === 0 || colon === proxy.length - 1)
                throw H.wrapException(new P.HttpException("Invalid proxy configuration " + H.S(this.configuration), null));
              username = C.JSString_methods.trim$0(C.JSString_methods.substring$2(userinfo, 0, colon));
              password = C.JSString_methods.trim$0(C.JSString_methods.substring$1(userinfo, colon + 1));
            } else {
              username = null;
              password = null;
            }
            colon = C.JSString_methods.lastIndexOf$1(proxy, ":");
            if (colon === -1 || colon === 0 || colon === proxy.length - 1)
              throw H.wrapException(new P.HttpException("Invalid proxy configuration " + H.S(this.configuration), null));
            host = C.JSString_methods.trim$0(C.JSString_methods.substring$2(proxy, 0, colon));
            if (C.JSString_methods.startsWith$1(host, "[") && C.JSString_methods.endsWith$1(host, "]"))
              host = C.JSString_methods.substring$2(host, 1, host.length - 1);
            portString = C.JSString_methods.trim$0(C.JSString_methods.substring$1(proxy, colon + 1));
            port = null;
            try {
              port = H.Primitives_parseInt(portString, null, null);
            } catch (exception) {
              if (H.unwrapException(exception) instanceof P.FormatException)
                throw H.wrapException(new P.HttpException("Invalid proxy configuration " + H.S(this.configuration) + ", invalid port '" + H.S(portString) + "'", null));
              else
                throw exception;
            }
            J.add$1$ax(this.$this.proxies, new P._Proxy(host, port, username, password, false));
          } else if (C.JSString_methods.trim$0(proxy) === "DIRECT")
            J.add$1$ax(this.$this.proxies, P._Proxy$direct());
          else
            throw H.wrapException(new P.HttpException("Invalid proxy configuration " + H.S(this.configuration), null));
      }, null, null, 2, 0, 13, 142, [], "call"]
    },
    "+ _ProxyConfiguration_closure": [2],
    _Proxy: {
      "^": "Object;host<-9,port<-0,username<-9,password<-9,isDirect<-8",
      get$isAuthenticated: [function() {
        return this.username != null;
      }, null, null, 1, 0, 5, "isAuthenticated"],
      static: {
        _Proxy$: [function(host, port, username, password) {
          return new P._Proxy(host, port, username, password, false);
        }, null, null, 8, 0, 898, 29, [], 26, [], 211, [], 219, [], "new _Proxy"],
        _Proxy$direct: [function() {
          return new P._Proxy(null, null, null, null, true);
        }, null, null, 0, 0, 4, "new _Proxy$direct"]
      }
    },
    "+_Proxy": [1],
    _HttpConnectionInfo: {
      "^": "Object;remoteAddress@-186,remotePort@-0,localPort@-0",
      static: {
        _HttpConnectionInfo$: [function() {
          return new P._HttpConnectionInfo(null, null, null);
        }, null, null, 0, 0, 899, "new _HttpConnectionInfo"],
        _HttpConnectionInfo_create: [function(socket) {
          var info, t1, exception;
          if (socket == null)
            return;
          try {
            info = new P._HttpConnectionInfo(null, null, null);
            t1 = info;
            t1.set$remoteAddress(socket.get$remoteAddress());
            t1.set$remotePort(socket.get$remotePort());
            t1.set$localPort(socket.get$port());
            return t1;
          } catch (exception) {
            H.unwrapException(exception);
          }
          return;
        }, "call$1", "io__HttpConnectionInfo_create$closure", 2, 0, 900, 52, [], "create"]
      }
    },
    "+_HttpConnectionInfo": [1, 1568],
    _DetachedSocket: {
      "^": "Stream;_incoming<-42,_socket<-127",
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        return this._incoming.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, onError);
      }, "listen$2$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, null);
      }, "listen$2$onDone", function(onData, cancelOnError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, null, null);
      }, "listen$2$cancelOnError", "call$4$cancelOnError$onDone$onError", "call$1", "call$2$onError", "call$3$onDone$onError", "call$3$onDone$onError", "call$2$onDone", "call$2$cancelOnError", "get$listen", 2, 7, 94, 0, 0, 0, 27, [], 20, [], 28, [], 24, [], "listen"],
      get$encoding: [function() {
        return this._socket.get$encoding();
      }, null, null, 1, 0, 207, "encoding"],
      set$encoding: [function(value) {
        this._socket.set$encoding(value);
      }, null, null, 3, 0, 261, 1, [], "encoding"],
      write$1: [function(obj) {
        this._socket.write$1(obj);
      }, "call$1", "get$write", 2, 0, 64, 143, [], "write"],
      writeln$1: [function(obj) {
        this._socket.writeln$1(obj);
      }, function() {
        return this.writeln$1("");
      }, "writeln$0", "call$1", "call$0", "get$writeln", 0, 2, 134, 32, 143, [], "writeln"],
      writeCharCode$1: [function(charCode) {
        this._socket.writeCharCode$1(charCode);
      }, "call$1", "get$writeCharCode", 2, 0, 17, 84, [], "writeCharCode"],
      writeAll$2: [function(objects, separator) {
        this._socket.writeAll$2(objects, separator);
      }, function(objects) {
        return this.writeAll$2(objects, "");
      }, "writeAll$1", "call$2", "call$1", "get$writeAll", 2, 2, 135, 32, 119, [], 63, [], "writeAll"],
      add$1: [function(_, bytes) {
        J.add$1$ax(this._socket, bytes);
      }, "call$1", "get$add", 2, 0, 26, 30, [], "add"],
      addError$2: [function(error, stackTrace) {
        return this._socket.addError$2(error, stackTrace);
      }, function(error) {
        return this.addError$2(error, null);
      }, "addError$1", "call$2", "call$1", "get$addError", 2, 2, 81, 0, 8, [], 12, [], "addError"],
      addStream$1: [function(stream) {
        return this._socket.addStream$1(stream);
      }, "call$1", "get$addStream", 2, 0, 212, 37, [], "addStream"],
      destroy$0: [function() {
        this._socket.destroy$0();
      }, "call$0", "get$destroy", 0, 0, 6, "destroy"],
      flush$0: [function() {
        return this._socket.flush$0();
      }, "call$0", "get$flush", 0, 0, 18, "flush"],
      close$0: [function() {
        return this._socket.close$0();
      }, "call$0", "get$close", 0, 0, 104, "close"],
      get$done: [function() {
        return this._socket.get$done();
      }, null, null, 1, 0, 104, "done"],
      get$port: [function() {
        return this._socket.get$port();
      }, null, null, 1, 0, 11, "port"],
      get$address: [function() {
        return this._socket.get$address();
      }, null, null, 1, 0, 68, "address"],
      get$remoteAddress: [function() {
        return this._socket.get$remoteAddress();
      }, null, null, 1, 0, 68, "remoteAddress"],
      get$remotePort: [function() {
        return this._socket.get$remotePort();
      }, null, null, 1, 0, 11, "remotePort"],
      setOption$2: [function(option, enabled) {
        this._socket.setOption$2(option, enabled);
        return false;
      }, "call$2", "get$setOption", 4, 0, 362, 66, [], 189, [], "setOption"],
      _io$_toJSON$1: [function(ref) {
        return this._socket._io$_toJSON$1(ref);
      }, "call$1", "get$_io$_toJSON", 2, 0, 359, 151, [], "_io$_toJSON"],
      set$_io$_owner: [function(owner) {
        this._socket.set$_io$_owner(owner);
      }, null, null, 3, 0, 27, 294, [], "_io$_owner"],
      $asStream: function() {
        return [[P.List, P.int]];
      },
      $isSocket: 1,
      "<>": [],
      static: {
        _DetachedSocket$: [function(_socket, _incoming) {
          return new P._DetachedSocket(_incoming, _socket);
        }, null, null, 4, 0, 901, 148, [], 275, [], "new _DetachedSocket"]
      }
    },
    "+_DetachedSocket": [42, 127],
    _AuthenticationScheme: {
      "^": "Object;_scheme<-0",
      toString$0: [function(_) {
        if (this === C._AuthenticationScheme_0)
          return "Basic";
        if (this === C._AuthenticationScheme_1)
          return "Digest";
        return "Unknown";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        "^": "_AuthenticationScheme_UNKNOWN<-10,_AuthenticationScheme_BASIC<-10,_AuthenticationScheme_DIGEST<-10",
        _AuthenticationScheme$: [function(_scheme) {
          return new P._AuthenticationScheme(_scheme);
        }, null, null, 2, 0, 22, 780, [], "new _AuthenticationScheme"],
        _AuthenticationScheme__AuthenticationScheme$fromString: [function(scheme) {
          var t1 = J.getInterceptor$s(scheme);
          if (t1.toLowerCase$0(scheme) === "basic")
            return C._AuthenticationScheme_0;
          if (t1.toLowerCase$0(scheme) === "digest")
            return C._AuthenticationScheme_1;
          return C._AuthenticationScheme_m1;
        }, null, null, 2, 0, 902, 44, [], "new _AuthenticationScheme$fromString"]
      }
    },
    "+_AuthenticationScheme": [1],
    _Credentials: {
      "^": "Object;credentials@-142,realm@-9,used@-8,ha1@-9,nonce@-9,algorithm@-9,qop@-9,nonceCount@-0",
      get$scheme: [function() {
        return this.credentials.get$scheme();
      }, null, null, 1, 0, 234, "scheme"],
      _Credentials$2: function(credentials, realm) {
        var creds, hasher, t1;
        if (J.$eq$(this.credentials.get$scheme(), C._AuthenticationScheme_1)) {
          creds = this.credentials;
          hasher = P._MD5$();
          t1 = creds.get$username();
          hasher.add$1(0, C.Utf8Codec_false.get$encoder().convert$1(t1));
          hasher.add$1(0, [58]);
          hasher.add$1(0, J.get$codeUnits$s(this.realm));
          hasher.add$1(0, [58]);
          t1 = creds.get$password();
          hasher.add$1(0, C.Utf8Codec_false.get$encoder().convert$1(t1));
          this.ha1 = P._CryptoUtils_bytesToHex(hasher.close$0());
        }
      },
      static: {
        _Credentials$: [function(credentials, realm) {
          var t1 = new P._Credentials(credentials, realm, false, null, null, null, null, null);
          t1._Credentials$2(credentials, realm);
          return t1;
        }, null, null, 4, 0, 903, 267, [], 152, [], "new _Credentials"]
      }
    },
    "+_Credentials": [1],
    _SiteCredentials: {
      "^": "_Credentials;uri@-36,credentials-142,realm-9,used-8,ha1-9,nonce-9,algorithm-9,qop-9,nonceCount-0",
      applies$2: [function(uri, scheme) {
        var thisPort;
        if (scheme != null && !J.$eq$(this.credentials.get$scheme(), scheme))
          return false;
        if (!J.$eq$(uri.get$host(), this.uri.get$host()))
          return false;
        thisPort = J.$eq$(this.uri.get$port(), 0) ? 80 : this.uri.get$port();
        if (!J.$eq$(J.$eq$(uri.get$port(), 0) ? 80 : uri.get$port(), thisPort))
          return false;
        return J.startsWith$1$s(uri.get$path(), this.uri.get$path());
      }, "call$2", "get$applies", 4, 0, 1366, 40, [], 44, [], "applies"],
      authorize$1: [function(request) {
        if (J.$eq$(this.credentials.get$scheme(), C._AuthenticationScheme_1) && this.nonce == null)
          return;
        this.credentials.authorize$2(this, request);
        this.used = true;
      }, "call$1", "get$authorize", 2, 0, 364, 54, [], "authorize"],
      static: {
        _SiteCredentials$: [function(uri, realm, creds) {
          var t1 = new P._SiteCredentials(uri, creds, realm, false, null, null, null, null, null);
          t1._Credentials$2(creds, realm);
          return t1;
        }, null, null, 6, 0, 904, 40, [], 152, [], 434, [], "new _SiteCredentials"]
      }
    },
    "+_SiteCredentials": [513],
    _ProxyCredentials: {
      "^": "_Credentials;host@-9,port@-0,credentials-142,realm-9,used-8,ha1-9,nonce-9,algorithm-9,qop-9,nonceCount-0",
      applies$2: [function(proxy, scheme) {
        if (scheme != null && !J.$eq$(this.credentials.get$scheme(), scheme))
          return false;
        return J.$eq$(proxy.get$host(), this.host) && J.$eq$(proxy.get$port(), this.port);
      }, "call$2", "get$applies", 4, 0, 1371, 142, [], 44, [], "applies"],
      authorize$1: [function(request) {
        if (J.$eq$(this.credentials.get$scheme(), C._AuthenticationScheme_1) && this.nonce == null)
          return;
        this.credentials.authorizeProxy$2(this, request);
      }, "call$1", "get$authorize", 2, 0, 364, 54, [], "authorize"],
      static: {
        _ProxyCredentials$: [function(host, port, realm, creds) {
          var t1 = new P._ProxyCredentials(host, port, creds, realm, false, null, null, null, null, null);
          t1._Credentials$2(creds, realm);
          return t1;
        }, null, null, 8, 0, 905, 29, [], 26, [], 152, [], 434, [], "new _ProxyCredentials"]
      }
    },
    "+_ProxyCredentials": [513],
    _HttpClientCredentials: {
      "^": "Object;",
      static: {
        _HttpClientCredentials$: [function() {
          return new P._HttpClientCredentials();
        }, null, null, 0, 0, 906, "new _HttpClientCredentials"]
      }
    },
    "+_HttpClientCredentials": [1, 274],
    _HttpClientBasicCredentials: {
      "^": "_HttpClientCredentials;username@-9,password@-9",
      get$scheme: [function() {
        return C._AuthenticationScheme_0;
      }, null, null, 1, 0, 234, "scheme"],
      authorization$0: [function() {
        var t1 = H.S(this.username) + ":" + H.S(this.password);
        return "Basic " + P._CryptoUtils_bytesToBase64(C.Utf8Codec_false.get$encoder().convert$1(t1), false, false);
      }, "call$0", "get$authorization", 0, 0, 7, "authorization"],
      authorize$2: [function(_, request) {
        request.get$headers().$set$2("authorization", this.authorization$0());
      }, "call$2", "get$authorize", 4, 0, 365, 16, [], 54, [], "authorize"],
      authorizeProxy$2: [function(_, request) {
        request.get$headers().$set$2("proxy-authorization", this.authorization$0());
      }, "call$2", "get$authorizeProxy", 4, 0, 366, 16, [], 54, [], "authorizeProxy"],
      static: {
        _HttpClientBasicCredentials$: [function(username, password) {
          return new P._HttpClientBasicCredentials(username, password);
        }, null, null, 4, 0, 40, 211, [], 219, [], "new _HttpClientBasicCredentials"]
      }
    },
    "+_HttpClientBasicCredentials": [142, 1571],
    _HttpClientDigestCredentials: {
      "^": "_HttpClientCredentials;username@-9,password@-9",
      get$scheme: [function() {
        return C._AuthenticationScheme_1;
      }, null, null, 1, 0, 234, "scheme"],
      authorization$2: [function(credentials, request) {
        var requestUri, hasher, ha2, qop, cnonce, response, t1;
        requestUri = request._requestUri$0();
        hasher = P._MD5$();
        hasher.add$1(0, J.get$codeUnits$s(request.get$method()));
        hasher.add$1(0, [58]);
        hasher.add$1(0, J.get$codeUnits$s(requestUri));
        ha2 = P._CryptoUtils_bytesToHex(hasher.close$0());
        hasher = P._MD5$();
        hasher.add$1(0, J.get$codeUnits$s(credentials.get$ha1()));
        hasher.add$1(0, [58]);
        if (J.$eq$(credentials.get$qop(), "auth")) {
          qop = credentials.get$qop();
          cnonce = P._CryptoUtils_bytesToHex(P._IOCrypto_getRandomBytes(4));
        } else {
          hasher.add$1(0, J.get$codeUnits$s(credentials.get$nonce()));
          hasher.add$1(0, [58]);
          hasher.add$1(0, new H.CodeUnits(ha2));
          qop = null;
          cnonce = null;
        }
        response = P._CryptoUtils_bytesToHex(hasher.close$0());
        t1 = "Digest " + ('username="' + H.S(this.username) + '"') + (', realm="' + H.S(credentials.get$realm()) + '"') + (', nonce="' + H.S(credentials.get$nonce()) + '"') + (', uri="' + H.S(requestUri) + '"') + (', algorithm="' + H.S(credentials.get$algorithm()) + '"');
        if (J.$eq$(qop, "auth"))
          t1 = t1 + (', qop="' + H.S(qop) + '"') + (', cnonce="' + H.S(cnonce) + '"') + ', nc="null"';
        t1 += ', response="' + response + '"';
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, "call$2", "get$authorization", 4, 0, 1384, 267, [], 54, [], "authorization"],
      authorize$2: [function(credentials, request) {
        request.get$headers().$set$2("authorization", this.authorization$2(credentials, request));
      }, "call$2", "get$authorize", 4, 0, 365, 267, [], 54, [], "authorize"],
      authorizeProxy$2: [function(credentials, request) {
        request.get$headers().$set$2("proxy-authorization", this.authorization$2(credentials, request));
      }, "call$2", "get$authorizeProxy", 4, 0, 366, 267, [], 54, [], "authorizeProxy"],
      static: {
        _HttpClientDigestCredentials$: [function(username, password) {
          return new P._HttpClientDigestCredentials(username, password);
        }, null, null, 4, 0, 40, 211, [], 219, [], "new _HttpClientDigestCredentials"]
      }
    },
    "+_HttpClientDigestCredentials": [142, 1572],
    _RedirectInfo: {
      "^": "Object;statusCode<-0,method<-9,location<-36",
      static: {
        _RedirectInfo$: [function(statusCode, method, $location) {
          return new P._RedirectInfo(statusCode, method, $location);
        }, null, null, 6, 0, 907, 350, [], 98, [], 444, [], "new _RedirectInfo"]
      }
    },
    "+_RedirectInfo": [1, 1573],
    _Const: {
      "^": "Object;",
      static: {
        "^": "_Const_HTTP<-10,_Const_HTTP1DOT<-10,_Const_HTTP10<-10,_Const_HTTP11<-10,_Const_T<-8,_Const_F<-8,_Const_SEPARATOR_MAP<-10",
        _Const$: [function() {
          return new P._Const();
        }, null, null, 0, 0, 908, "new _Const"]
      }
    },
    "+_Const": [1],
    _CharCode: {
      "^": "Object;",
      static: {
        "^": "_CharCode_HT<-0,_CharCode_LF<-0,_CharCode_CR<-0,_CharCode_SP<-0,_CharCode_AMPERSAND<-0,_CharCode_COMMA<-0,_CharCode_DASH<-0,_CharCode_SLASH<-0,_CharCode_ZERO<-0,_CharCode_ONE<-0,_CharCode_COLON<-0,_CharCode_SEMI_COLON<-0,_CharCode_EQUAL<-0",
        _CharCode$: [function() {
          return new P._CharCode();
        }, null, null, 0, 0, 909, "new _CharCode"]
      }
    },
    "+_CharCode": [1],
    _State: {
      "^": "Object;",
      static: {
        "^": "_State_START<-0,_State_METHOD_OR_RESPONSE_HTTP_VERSION<-0,_State_RESPONSE_HTTP_VERSION<-0,_State_REQUEST_LINE_METHOD<-0,_State_REQUEST_LINE_URI<-0,_State_REQUEST_LINE_HTTP_VERSION<-0,_State_REQUEST_LINE_ENDING<-0,_State_RESPONSE_LINE_STATUS_CODE<-0,_State_RESPONSE_LINE_REASON_PHRASE<-0,_State_RESPONSE_LINE_ENDING<-0,_State_HEADER_START<-0,_State_HEADER_FIELD<-0,_State_HEADER_VALUE_START<-0,_State_HEADER_VALUE<-0,_State_HEADER_VALUE_FOLDING_OR_ENDING<-0,_State_HEADER_VALUE_FOLD_OR_END<-0,_State_HEADER_ENDING<-0,_State_CHUNK_SIZE_STARTING_CR<-0,_State_CHUNK_SIZE_STARTING_LF<-0,_State_CHUNK_SIZE<-0,_State_CHUNK_SIZE_EXTENSION<-0,_State_CHUNK_SIZE_ENDING<-0,_State_CHUNKED_BODY_DONE_CR<-0,_State_CHUNKED_BODY_DONE_LF<-0,_State_BODY<-0,_State_CLOSED<-0,_State_UPGRADED<-0,_State_FAILURE<-0,_State_FIRST_BODY_STATE<-0",
        _State$: [function() {
          return new P._State();
        }, null, null, 0, 0, 910, "new _State"]
      }
    },
    "+_State": [1],
    _HttpVersion: {
      "^": "Object;",
      static: {
        "^": "_HttpVersion_UNDETERMINED<-0,_HttpVersion_HTTP10<-0,_HttpVersion_HTTP11<-0",
        _HttpVersion$: [function() {
          return new P._HttpVersion();
        }, null, null, 0, 0, 911, "new _HttpVersion"]
      }
    },
    "+_HttpVersion": [1],
    _MessageType: {
      "^": "Object;",
      static: {
        "^": "_MessageType_UNDETERMINED<-0,_MessageType_REQUEST<-0,_MessageType_RESPONSE<-0",
        _MessageType$: [function() {
          return new P._MessageType();
        }, null, null, 0, 0, 912, "new _MessageType"]
      }
    },
    "+_MessageType": [1],
    _HttpDetachedStreamSubscription: {
      "^": "Object;_io$_subscription@-175,_injectData@-14,_isCanceled@-8,_pauseCount@-0,_userOnData@-29,_scheduled@-8",
      get$isPaused: [function() {
        return this._io$_subscription.get$isPaused();
      }, null, null, 1, 0, 5, "isPaused"],
      asFuture$1: [function(futureValue) {
        return this._io$_subscription.asFuture$1(futureValue);
      }, function() {
        return this.asFuture$1(null);
      }, "asFuture$0", "call$1", "call$0", "get$asFuture", 0, 2, function() {
        return {func: 1, ret: P.Future, opt: [,]};
      }, 0, 206, [], "asFuture"],
      cancel$0: [function() {
        this._isCanceled = true;
        this._injectData = null;
        return this._io$_subscription.cancel$0();
      }, "call$0", "get$cancel", 0, 0, 18, "cancel"],
      onData$1: [function(handleData) {
        this._userOnData = handleData;
        this._io$_subscription.onData$1(handleData);
      }, "call$1", "get$onData", 2, 0, 1410, 175, [], "onData"],
      onDone$1: [function(handleDone) {
        this._io$_subscription.onDone$1(handleDone);
      }, "call$1", "get$onDone", 2, 0, 37, 164, [], "onDone"],
      onError$1: [function(handleError) {
        this._io$_subscription.onError$1(handleError);
      }, "call$1", "get$onError", 2, 0, 164, 157, [], "onError"],
      pause$1: [function(resumeSignal) {
        if (this._injectData == null)
          this._io$_subscription.pause$1(resumeSignal);
        else {
          this._pauseCount = J.$add$ns(this._pauseCount, 1);
          if (resumeSignal != null)
            resumeSignal.whenComplete$1(this.get$resume());
        }
      }, function() {
        return this.pause$1(null);
      }, "pause$0", "call$1", "call$0", "get$pause", 0, 2, 217, 0, 221, [], "pause"],
      resume$0: [function() {
        if (this._injectData == null)
          this._io$_subscription.resume$0();
        else {
          this._pauseCount = J.$sub$n(this._pauseCount, 1);
          this._maybeScheduleData$0();
        }
      }, "call$0", "get$resume", 0, 0, 6, "resume"],
      _maybeScheduleData$0: [function() {
        if (this._scheduled === true)
          return;
        if (!J.$eq$(this._pauseCount, 0))
          return;
        this._scheduled = true;
        P.scheduleMicrotask(new P._HttpDetachedStreamSubscription__maybeScheduleData_closure(this));
      }, "call$0", "get$_maybeScheduleData", 0, 0, 6, "_maybeScheduleData"],
      $isStreamSubscription: 1,
      $asStreamSubscription: function() {
        return [[P.List, P.int]];
      },
      static: {
        _HttpDetachedStreamSubscription$: [function(_subscription, _injectData, _userOnData) {
          return new P._HttpDetachedStreamSubscription(_subscription, _injectData, false, 1, _userOnData, false);
        }, null, null, 6, 0, 913, 786, [], 787, [], 788, [], "new _HttpDetachedStreamSubscription"]
      }
    },
    "+_HttpDetachedStreamSubscription": [1, 175],
    _HttpDetachedStreamSubscription__maybeScheduleData_closure: {
      "^": "Closure:4;$this",
      call$0: [function() {
        var t1, data;
        t1 = this.$this;
        t1._scheduled = false;
        if (J.$gt$n(t1._pauseCount, 0) || t1._isCanceled === true)
          return;
        data = t1._injectData;
        t1._injectData = null;
        t1._io$_subscription.resume$0();
        t1 = t1._userOnData;
        if (t1 != null)
          t1.call$1(data);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _HttpDetachedStreamSubscription__maybeScheduleData_closure": [2],
    _HttpDetachedIncoming: {
      "^": "Stream;subscription<-175,bufferedData<-14",
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        var t1, t2;
        t1 = this.subscription;
        if (t1 != null) {
          t1.onData$1(onData);
          t1.onError$1(onError);
          t1.onDone$1(onDone);
          t2 = this.bufferedData;
          if (t2 == null) {
            t1.resume$0();
            return t1;
          }
          t1 = new P._HttpDetachedStreamSubscription(t1, t2, false, 1, onData, false);
          t1.resume$0();
          return t1;
        } else
          return P.Stream_Stream$fromIterable([this.bufferedData], [P.List, P.int]).listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, onError);
      }, "listen$2$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, null);
      }, "listen$2$onDone", function(onData, cancelOnError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, null, null);
      }, "listen$2$cancelOnError", "call$4$cancelOnError$onDone$onError", "call$1", "call$2$onError", "call$3$onDone$onError", "call$3$onDone$onError", "call$2$onDone", "call$2$cancelOnError", "get$listen", 2, 7, 94, 0, 0, 0, 27, [], 20, [], 28, [], 24, [], "listen"],
      $asStream: function() {
        return [[P.List, P.int]];
      },
      "<>": [],
      static: {
        _HttpDetachedIncoming$: [function(subscription, bufferedData) {
          return new P._HttpDetachedIncoming(subscription, bufferedData);
        }, null, null, 4, 0, 914, 50, [], 262, [], "new _HttpDetachedIncoming"]
      }
    },
    "+_HttpDetachedIncoming": [42],
    _HttpParser: {
      "^": "Stream;_parserCalled@-8,_io$_buffer@-89,_io$_index@-0,_requestParser<-8,_io$_state@-0,_httpVersionIndex@-0,_messageType@-0,_statusCode@-0,_statusCodeLength@-0,_io$_method<-14,_uri_or_reason_phrase<-14,_headerField<-14,_headerValue<-14,_httpVersion@-0,_transferLength@-0,_persistentConnection@-8,_connectionUpgrade@-8,_chunked@-8,_noMessageBody@-8,_remainingContent@-0,_headers@-139,_incoming@-185,_socketSubscription@-175,_paused@-8,_bodyPaused@-8,_io$_controller@-1575,_bodyController@-487",
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        return this._io$_controller.get$stream().listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, onError);
      }, "listen$2$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, null);
      }, "listen$2$onDone", function(onData, cancelOnError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, null, null);
      }, "listen$2$cancelOnError", "call$4$cancelOnError$onDone$onError", "call$1", "call$2$onError", "call$3$onDone$onError", "call$3$onDone$onError", "call$2$onDone", "call$2$cancelOnError", "get$listen", 2, 7, 1413, 0, 0, 0, 27, [], 20, [], 28, [], 24, [], "listen"],
      listenToStream$1: [function(stream) {
        this._socketSubscription = stream.listen$3$onDone$onError(this.get$_io$_onData(), this.get$_io$_onDone(), this._io$_controller.get$addError());
      }, "call$1", "get$listenToStream", 2, 0, 1416, 37, [], "listenToStream"],
      _parse$0: [function() {
        var e, s, exception, t1;
        try {
          this._doParse$0();
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          this._io$_state = 27;
          this._reportError$2(e, s);
        }
      }, "call$0", "get$_parse", 0, 0, 6, "_parse"],
      _headersEnd$0: [function() {
        var t1, t2, tmp;
        this._headers.set$_mutable(false);
        this._transferLength = this._headers.get$contentLength();
        if (this._chunked === true)
          this._transferLength = -1;
        if (J.$eq$(this._messageType, 1) && J.$lt$n(this._transferLength, 0) && J.$eq$(this._chunked, false))
          this._transferLength = 0;
        if (this._connectionUpgrade === true) {
          this._io$_state = 26;
          this._transferLength = 0;
        }
        this._createIncoming$1(this._transferLength);
        t1 = this._incoming;
        t2 = this._uri_or_reason_phrase;
        if (this._requestParser === true) {
          t1.set$method(P.String_String$fromCharCodes(this._io$_method, 0, null));
          this._incoming.set$uri(P.Uri_parse(P.String_String$fromCharCodes(t2, 0, null), 0, null));
        } else {
          t1.set$statusCode(this._statusCode);
          this._incoming.set$reasonPhrase(P.String_String$fromCharCodes(t2, 0, null));
        }
        J.clear$0$ax(this._io$_method);
        J.clear$0$ax(t2);
        if (this._connectionUpgrade === true) {
          this._incoming.set$upgraded(true);
          this._parserCalled = false;
          tmp = this._incoming;
          this._closeIncoming$0();
          J.add$1$ax(this._io$_controller, tmp);
          return true;
        }
        if (!J.$eq$(this._transferLength, 0))
          t1 = J.$eq$(this._messageType, 0) && this._noMessageBody === true;
        else
          t1 = true;
        if (t1) {
          this._reset$0();
          tmp = this._incoming;
          this._closeIncoming$0();
          J.add$1$ax(this._io$_controller, tmp);
          return false;
        } else if (this._chunked === true) {
          this._io$_state = 19;
          this._remainingContent = 0;
        } else if (J.$gt$n(this._transferLength, 0)) {
          this._remainingContent = this._transferLength;
          this._io$_state = 24;
        } else
          this._io$_state = 24;
        this._parserCalled = false;
        J.add$1$ax(this._io$_controller, this._incoming);
        return true;
      }, "call$0", "get$_headersEnd", 0, 0, 5, "_headersEnd"],
      _doParse$0: [function() {
        var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, byte, i, headerField, headerValue, tokens, value, dataAvailable, data;
        this._parserCalled = true;
        if (J.$eq$(this._io$_state, 25))
          throw H.wrapException(new P.HttpException("Data on closed connection", null));
        if (J.$eq$(this._io$_state, 27))
          throw H.wrapException(new P.HttpException("Data on failed connection", null));
        t1 = this._headerField;
        t2 = J.getInterceptor$ax(t1);
        t3 = this._headerValue;
        t4 = J.getInterceptor$ax(t3);
        t5 = this._uri_or_reason_phrase;
        t6 = J.getInterceptor$asx(t5);
        t7 = this._io$_method;
        t8 = J.getInterceptor$ax(t7);
        t9 = this._requestParser === true;
        t10 = !t9;
        while (true) {
          t11 = this._io$_buffer;
          if (!(t11 != null && J.$lt$n(this._io$_index, J.get$length$asx(t11)) && !J.$eq$(this._io$_state, 27) && !J.$eq$(this._io$_state, 26)))
            break;
          t11 = this._incoming == null;
          if (!(!t11 && this._bodyPaused === true))
            t11 = t11 && this._paused === true;
          else
            t11 = true;
          if (t11) {
            this._parserCalled = false;
            return;
          }
          t11 = this._io$_buffer;
          t12 = this._io$_index;
          this._io$_index = J.$add$ns(t12, 1);
          byte = J.$index$asx(t11, t12);
          switch (this._io$_state) {
            case 0:
              t11 = J.getInterceptor(byte);
              if (t11.$eq(byte, 72)) {
                this._httpVersionIndex = 1;
                this._io$_state = 1;
              } else {
                if (t11.$gt(byte, 31))
                  if (t11.$lt(byte, 128)) {
                    if (byte >>> 0 !== byte || byte >= 256)
                      return H.ioore(C.List_NUU, byte);
                    t11 = !C.List_NUU[byte];
                  } else
                    t11 = false;
                else
                  t11 = false;
                if (!t11)
                  throw H.wrapException(new P.HttpException("Invalid request method", null));
                t8.add$1(t7, byte);
                if (t10)
                  throw H.wrapException(new P.HttpException("Invalid response line", null));
                this._io$_state = 3;
              }
              break;
            case 1:
              if (J.$lt$n(this._httpVersionIndex, 4)) {
                t11 = this._httpVersionIndex;
                if (t11 >>> 0 !== t11 || t11 >= 4)
                  return H.ioore(C.List_72_84_84_80, t11);
                t11 = J.$eq$(byte, C.List_72_84_84_80[t11]);
              } else
                t11 = false;
              if (t11)
                this._httpVersionIndex = J.$add$ns(this._httpVersionIndex, 1);
              else if (J.$eq$(this._httpVersionIndex, 4) && J.$eq$(byte, 47)) {
                this._httpVersionIndex = J.$add$ns(this._httpVersionIndex, 1);
                if (t9)
                  throw H.wrapException(new P.HttpException("Invalid request line", null));
                this._io$_state = 2;
              } else {
                i = 0;
                while (true) {
                  t11 = this._httpVersionIndex;
                  if (typeof t11 !== "number")
                    return H.iae(t11);
                  if (!(i < t11))
                    break;
                  if (i >= 4)
                    return H.ioore(C.List_72_84_84_80, i);
                  t8.add$1(t7, C.List_72_84_84_80[i]);
                  ++i;
                }
                if (J.$eq$(byte, 32))
                  this._io$_state = 4;
                else {
                  t8.add$1(t7, byte);
                  this._httpVersion = 0;
                  if (t10)
                    throw H.wrapException(new P.HttpException("Invalid response line", null));
                  this._io$_state = 3;
                }
              }
              break;
            case 2:
              if (J.$lt$n(this._httpVersionIndex, 7)) {
                t11 = this._httpVersionIndex;
                if (t11 >>> 0 !== t11 || t11 >= 7)
                  return H.ioore(C.List_E7y0, t11);
                if (!J.$eq$(byte, C.List_E7y0[t11]))
                  H.throwExpression(new P.HttpException("Failed to parse HTTP", null));
                this._httpVersionIndex = J.$add$ns(this._httpVersionIndex, 1);
              } else if (J.$eq$(this._httpVersionIndex, 7) && J.$eq$(byte, 49)) {
                this._httpVersion = 2;
                this._persistentConnection = true;
                this._httpVersionIndex = J.$add$ns(this._httpVersionIndex, 1);
              } else if (J.$eq$(this._httpVersionIndex, 7) && J.$eq$(byte, 48)) {
                this._httpVersion = 1;
                this._persistentConnection = false;
                this._httpVersionIndex = J.$add$ns(this._httpVersionIndex, 1);
              } else if (J.$eq$(this._httpVersionIndex, 8)) {
                if (!J.$eq$(byte, 32))
                  H.throwExpression(new P.HttpException("Failed to parse HTTP", null));
                this._io$_state = 7;
              } else
                throw H.wrapException(new P.HttpException("Invalid response line", null));
              break;
            case 3:
              if (J.$eq$(byte, 32))
                this._io$_state = 4;
              else {
                if (byte >>> 0 !== byte || byte >= 256)
                  return H.ioore(C.List_NUU, byte);
                if (C.List_NUU[byte] || byte === 13 || byte === 10)
                  throw H.wrapException(new P.HttpException("Invalid request method", null));
                t8.add$1(t7, byte);
              }
              break;
            case 4:
              t11 = J.getInterceptor(byte);
              if (t11.$eq(byte, 32)) {
                if (J.$eq$(t6.get$length(t5), 0))
                  throw H.wrapException(new P.HttpException("Invalid request URI", null));
                this._io$_state = 5;
                this._httpVersionIndex = 0;
              } else {
                if (t11.$eq(byte, 13) || t11.$eq(byte, 10))
                  throw H.wrapException(new P.HttpException("Invalid request URI", null));
                t6.add$1(t5, byte);
              }
              break;
            case 5:
              if (J.$lt$n(this._httpVersionIndex, 7)) {
                t11 = this._httpVersionIndex;
                if (t11 >>> 0 !== t11 || t11 >= 8)
                  return H.ioore(C.List_2Vk0, t11);
                if (!J.$eq$(byte, C.List_2Vk0[t11]))
                  H.throwExpression(new P.HttpException("Failed to parse HTTP", null));
                this._httpVersionIndex = J.$add$ns(this._httpVersionIndex, 1);
              } else if (J.$eq$(this._httpVersionIndex, 7)) {
                t11 = J.getInterceptor(byte);
                if (t11.$eq(byte, 49)) {
                  this._httpVersion = 2;
                  this._persistentConnection = true;
                  this._httpVersionIndex = J.$add$ns(this._httpVersionIndex, 1);
                } else if (t11.$eq(byte, 48)) {
                  this._httpVersion = 1;
                  this._persistentConnection = false;
                  this._httpVersionIndex = J.$add$ns(this._httpVersionIndex, 1);
                } else
                  throw H.wrapException(new P.HttpException("Invalid response line", null));
              } else {
                t11 = J.getInterceptor(byte);
                if (t11.$eq(byte, 13))
                  this._io$_state = 6;
                else {
                  if (!t11.$eq(byte, 10))
                    H.throwExpression(new P.HttpException("Failed to parse HTTP", null));
                  this._messageType = 1;
                  this._io$_state = 10;
                }
              }
              break;
            case 6:
              if (!J.$eq$(byte, 10))
                H.throwExpression(new P.HttpException("Failed to parse HTTP", null));
              this._messageType = 1;
              this._io$_state = 10;
              break;
            case 7:
              t11 = J.getInterceptor(byte);
              if (t11.$eq(byte, 32))
                this._io$_state = 8;
              else if (t11.$eq(byte, 13))
                this._io$_state = 9;
              else {
                this._statusCodeLength = J.$add$ns(this._statusCodeLength, 1);
                if (t11.$lt(byte, 48)) {
                  if (typeof byte !== "number")
                    return H.iae(byte);
                  t11 = 57 < byte;
                } else
                  t11 = false;
                if (t11 || J.$gt$n(this._statusCodeLength, 3))
                  throw H.wrapException(new P.HttpException("Invalid response status code", null));
                else
                  this._statusCode = J.$sub$n(J.$add$ns(J.$mul$ns(this._statusCode, 10), byte), 48);
              }
              break;
            case 8:
              t11 = J.getInterceptor(byte);
              if (t11.$eq(byte, 13))
                this._io$_state = 9;
              else {
                if (t11.$eq(byte, 13) || t11.$eq(byte, 10))
                  throw H.wrapException(new P.HttpException("Invalid response reason phrase", null));
                t6.add$1(t5, byte);
              }
              break;
            case 9:
              if (!J.$eq$(byte, 10))
                H.throwExpression(new P.HttpException("Failed to parse HTTP", null));
              J.$eq$(this._messageType, 0);
              if (J.$lt$n(this._statusCode, 100) || J.$gt$n(this._statusCode, 599))
                throw H.wrapException(new P.HttpException("Invalid response status code", null));
              else if (J.$le$n(this._statusCode, 199) || J.$eq$(this._statusCode, 204) || J.$eq$(this._statusCode, 304))
                this._noMessageBody = true;
              this._io$_state = 10;
              break;
            case 10:
              this._headers = P._HttpHeaders$(this.get$version(), 80, null);
              t11 = J.getInterceptor(byte);
              if (t11.$eq(byte, 13))
                this._io$_state = 16;
              else if (t11.$eq(byte, 10)) {
                this._io$_state = 16;
                this._io$_index = J.$sub$n(this._io$_index, 1);
              } else {
                t2.add$1(t1, J.$lt$n(J.$and$n(t11.$sub(byte, 65), 127), 26) ? t11.$or(byte, 32) : byte);
                this._io$_state = 11;
              }
              break;
            case 11:
              t11 = J.getInterceptor(byte);
              if (t11.$eq(byte, 58))
                this._io$_state = 12;
              else {
                if (t11.$gt(byte, 31))
                  if (t11.$lt(byte, 128)) {
                    if (byte >>> 0 !== byte || byte >= 256)
                      return H.ioore(C.List_NUU, byte);
                    t12 = !C.List_NUU[byte];
                  } else
                    t12 = false;
                else
                  t12 = false;
                if (!t12)
                  throw H.wrapException(new P.HttpException("Invalid header field name", null));
                t2.add$1(t1, J.$lt$n(J.$and$n(t11.$sub(byte, 65), 127), 26) ? t11.$or(byte, 32) : byte);
              }
              break;
            case 12:
              t11 = J.getInterceptor(byte);
              if (t11.$eq(byte, 13))
                this._io$_state = 14;
              else if (t11.$eq(byte, 10))
                this._io$_state = 15;
              else if (!t11.$eq(byte, 32) && !t11.$eq(byte, 9)) {
                t4.add$1(t3, byte);
                this._io$_state = 13;
              }
              break;
            case 13:
              t11 = J.getInterceptor(byte);
              if (t11.$eq(byte, 13))
                this._io$_state = 14;
              else if (t11.$eq(byte, 10))
                this._io$_state = 15;
              else
                t4.add$1(t3, byte);
              break;
            case 14:
              if (!J.$eq$(byte, 10))
                H.throwExpression(new P.HttpException("Failed to parse HTTP", null));
              this._io$_state = 15;
              break;
            case 15:
              t11 = J.getInterceptor(byte);
              if (t11.$eq(byte, 32) || t11.$eq(byte, 9))
                this._io$_state = 12;
              else {
                headerField = P.String_String$fromCharCodes(t1, 0, null);
                headerValue = P.String_String$fromCharCodes(t3, 0, null);
                if (headerField === "transfer-encoding" && this._caseInsensitiveCompare$2(new H.CodeUnits("chunked"), t3))
                  this._chunked = true;
                if (headerField === "connection") {
                  tokens = P._HttpParser__tokenizeFieldValue(headerValue);
                  for (i = 0; i < tokens.length; ++i) {
                    if (this._caseInsensitiveCompare$2(new H.CodeUnits("upgrade"), J.get$codeUnits$s(tokens[i])))
                      this._connectionUpgrade = true;
                    t12 = this._headers;
                    if (i >= tokens.length)
                      return H.ioore(tokens, i);
                    t12._io$_add$2(headerField, tokens[i]);
                  }
                } else
                  this._headers._io$_add$2(headerField, headerValue);
                t2.clear$0(t1);
                t4.clear$0(t3);
                if (t11.$eq(byte, 13))
                  this._io$_state = 16;
                else if (t11.$eq(byte, 10)) {
                  this._io$_state = 16;
                  this._io$_index = J.$sub$n(this._io$_index, 1);
                } else {
                  t2.add$1(t1, J.$lt$n(J.$and$n(t11.$sub(byte, 65), 127), 26) ? t11.$or(byte, 32) : byte);
                  this._io$_state = 11;
                }
              }
              break;
            case 16:
              if (!J.$eq$(byte, 10))
                H.throwExpression(new P.HttpException("Failed to parse HTTP", null));
              if (this._headersEnd$0())
                return;
              else
                break;
            case 17:
              if (!J.$eq$(byte, 13))
                H.throwExpression(new P.HttpException("Failed to parse HTTP", null));
              this._io$_state = 18;
              break;
            case 18:
              if (!J.$eq$(byte, 10))
                H.throwExpression(new P.HttpException("Failed to parse HTTP", null));
              this._io$_state = 19;
              break;
            case 19:
              t11 = J.getInterceptor(byte);
              if (t11.$eq(byte, 13))
                this._io$_state = 21;
              else if (t11.$eq(byte, 59))
                this._io$_state = 20;
              else {
                value = this._expectHexDigit$1(byte);
                this._remainingContent = J.$add$ns(J.$mul$ns(this._remainingContent, 16), value);
              }
              break;
            case 20:
              if (J.$eq$(byte, 13))
                this._io$_state = 21;
              break;
            case 21:
              if (!J.$eq$(byte, 10))
                H.throwExpression(new P.HttpException("Failed to parse HTTP", null));
              if (J.$gt$n(this._remainingContent, 0))
                this._io$_state = 24;
              else
                this._io$_state = 22;
              break;
            case 22:
              if (!J.$eq$(byte, 13))
                H.throwExpression(new P.HttpException("Failed to parse HTTP", null));
              this._io$_state = 23;
              break;
            case 23:
              if (!J.$eq$(byte, 10))
                H.throwExpression(new P.HttpException("Failed to parse HTTP", null));
              this._reset$0();
              this._closeIncoming$0();
              break;
            case 24:
              this._io$_index = J.$sub$n(this._io$_index, 1);
              dataAvailable = J.$sub$n(J.get$length$asx(this._io$_buffer), this._io$_index);
              if (J.$ge$n(this._remainingContent, 0) && J.$gt$n(dataAvailable, this._remainingContent))
                dataAvailable = this._remainingContent;
              data = J.asUint8List$2$x(J.get$buffer$x(this._io$_buffer), J.$add$ns(J.get$offsetInBytes$x(this._io$_buffer), this._io$_index), dataAvailable);
              J.add$1$ax(this._bodyController, data);
              if (!J.$eq$(this._remainingContent, -1))
                this._remainingContent = J.$sub$n(this._remainingContent, data.length);
              this._io$_index = J.$add$ns(this._io$_index, data.length);
              if (J.$eq$(this._remainingContent, 0))
                if (this._chunked !== true) {
                  this._reset$0();
                  this._closeIncoming$0();
                } else
                  this._io$_state = 17;
              break;
            case 27:
              break;
            default:
              break;
          }
        }
        this._parserCalled = false;
        t1 = this._io$_buffer;
        if (t1 != null && J.$eq$(this._io$_index, J.get$length$asx(t1))) {
          this._io$_buffer = null;
          this._io$_index = null;
          if (!J.$eq$(this._io$_state, 26) && !J.$eq$(this._io$_state, 27))
            this._socketSubscription.resume$0();
        }
      }, "call$0", "get$_doParse", 0, 0, 6, "_doParse"],
      _io$_onData$1: [function(buffer) {
        this._socketSubscription.pause$0();
        this._io$_buffer = buffer;
        this._io$_index = 0;
        this._parse$0();
      }, "call$1", "get$_io$_onData", 2, 0, 26, 41, [], "_io$_onData"],
      _io$_onDone$0: [function() {
        this._socketSubscription = null;
        if (J.$eq$(this._io$_state, 25) || J.$eq$(this._io$_state, 27))
          return;
        if (this._incoming != null) {
          if (!J.$eq$(this._io$_state, 26))
            if (!(J.$eq$(this._io$_state, 0) && this._requestParser !== true))
              var t1 = !(J.$eq$(this._io$_state, 24) && this._chunked !== true && J.$eq$(this._transferLength, -1));
            else
              t1 = false;
          else
            t1 = false;
          if (t1)
            this._bodyController.addError$1(new P.HttpException("Connection closed while receiving data", null));
          this._closeIncoming$1(true);
          this._io$_controller.close$0();
          return;
        }
        if (J.$eq$(this._io$_state, 0)) {
          if (this._requestParser !== true)
            this._reportError$1(new P.HttpException("Connection closed before full header was received", null));
          this._io$_controller.close$0();
          return;
        }
        if (J.$eq$(this._io$_state, 26)) {
          this._io$_controller.close$0();
          return;
        }
        if (J.$lt$n(this._io$_state, 17)) {
          this._io$_state = 27;
          this._reportError$1(new P.HttpException("Connection closed before full header was received", null));
          this._io$_controller.close$0();
          return;
        }
        if (this._chunked !== true && J.$eq$(this._transferLength, -1))
          this._io$_state = 25;
        else {
          this._io$_state = 27;
          this._reportError$1(new P.HttpException("Connection closed before full body was received", null));
        }
        this._io$_controller.close$0();
      }, "call$0", "get$_io$_onDone", 0, 0, 6, "_io$_onDone"],
      get$version: [function() {
        switch (this._httpVersion) {
          case 1:
            return "1.0";
          case 2:
            return "1.1";
        }
        return;
      }, null, null, 1, 0, 7, "version"],
      get$messageType: [function() {
        return this._messageType;
      }, null, null, 1, 0, 11, "messageType"],
      get$transferLength: [function() {
        return this._transferLength;
      }, null, null, 1, 0, 11, "transferLength"],
      get$upgrade: [function() {
        return this._connectionUpgrade === true && J.$eq$(this._io$_state, 26);
      }, null, null, 1, 0, 5, "upgrade"],
      get$persistentConnection: [function() {
        return this._persistentConnection;
      }, null, null, 1, 0, 5, "persistentConnection"],
      set$isHead: [function(value) {
        if (value === true)
          this._noMessageBody = true;
      }, null, null, 3, 0, 35, 1, [], "isHead"],
      detachIncoming$0: [function() {
        this._io$_state = 26;
        return new P._HttpDetachedIncoming(this._socketSubscription, this.readUnparsedData$0());
      }, "call$0", "get$detachIncoming", 0, 0, 1423, "detachIncoming"],
      readUnparsedData$0: [function() {
        var t1, result;
        t1 = this._io$_buffer;
        if (t1 == null)
          return;
        if (J.$eq$(this._io$_index, J.get$length$asx(t1)))
          return;
        result = J.sublist$1$ax(this._io$_buffer, this._io$_index);
        this._io$_buffer = null;
        this._io$_index = null;
        return result;
      }, "call$0", "get$readUnparsedData", 0, 0, 69, "readUnparsedData"],
      _reset$0: [function() {
        if (J.$eq$(this._io$_state, 26))
          return;
        this._io$_state = 0;
        this._messageType = 0;
        J.clear$0$ax(this._headerField);
        J.clear$0$ax(this._headerValue);
        J.clear$0$ax(this._io$_method);
        J.clear$0$ax(this._uri_or_reason_phrase);
        this._statusCode = 0;
        this._statusCodeLength = 0;
        this._httpVersion = 0;
        this._transferLength = -1;
        this._persistentConnection = false;
        this._connectionUpgrade = false;
        this._chunked = false;
        this._noMessageBody = false;
        this._remainingContent = -1;
        this._headers = null;
      }, "call$0", "get$_reset", 0, 0, 6, "_reset"],
      _releaseBuffer$0: [function() {
        this._io$_buffer = null;
        this._io$_index = null;
      }, "call$0", "get$_releaseBuffer", 0, 0, 6, "_releaseBuffer"],
      _caseInsensitiveCompare$2: [function(expected, value) {
        var t1, t2, i, t3, t4, t5;
        t1 = J.getInterceptor$asx(expected);
        t2 = J.getInterceptor$asx(value);
        if (!J.$eq$(t1.get$length(expected), t2.get$length(value)))
          return false;
        i = 0;
        while (true) {
          t3 = t1.get$length(expected);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          t3 = t1.$index(expected, i);
          t4 = t2.$index(value, i);
          t5 = J.getInterceptor$n(t4);
          if (!J.$eq$(t3, J.$lt$n(J.$and$n(t5.$sub(t4, 65), 127), 26) ? t5.$or(t4, 32) : t4))
            return false;
          ++i;
        }
        return true;
      }, "call$2", "get$_caseInsensitiveCompare", 4, 0, 1433, 238, [], 1, [], "_caseInsensitiveCompare"],
      _expect$2: [function(val1, val2) {
        if (!J.$eq$(val1, val2))
          throw H.wrapException(new P.HttpException("Failed to parse HTTP", null));
      }, "call$2", "get$_expect", 4, 0, 70, 906, [], 907, [], "_expect"],
      _expectHexDigit$1: [function(byte) {
        if (typeof byte !== "number")
          return H.iae(byte);
        if (48 <= byte && byte <= 57)
          return byte - 48;
        else if (65 <= byte && byte <= 70)
          return byte - 65 + 10;
        else if (97 <= byte && byte <= 102)
          return byte - 97 + 10;
        else
          throw H.wrapException(new P.HttpException("Failed to parse HTTP", null));
      }, "call$1", "get$_expectHexDigit", 2, 0, 16, 149, [], "_expectHexDigit"],
      _createIncoming$1: [function(transferLength) {
        var t1, t2, t3, incoming;
        t1 = {};
        t1.incoming = null;
        t2 = new P._SyncStreamController(null, 0, null, new P._HttpParser__createIncoming_closure(t1, this), new P._HttpParser__createIncoming_closure0(t1, this), new P._HttpParser__createIncoming_closure1(t1, this), new P._HttpParser__createIncoming_closure2(t1, this), [[P.List, P.int]]);
        this._bodyController = t2;
        t3 = this._headers;
        t2 = t2.get$stream();
        incoming = new P._HttpIncoming(transferLength, new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]), t2, false, t3, false, null, null, null, null, false);
        this._incoming = incoming;
        t1.incoming = incoming;
        this._bodyPaused = true;
        this._pauseStateChanged$0();
      }, "call$1", "get$_createIncoming", 2, 0, 17, 908, [], "_createIncoming"],
      _closeIncoming$1: [function(closing) {
        var t1 = this._incoming;
        if (t1 == null)
          return;
        t1.close$1(closing);
        this._incoming = null;
        t1 = this._bodyController;
        if (t1 != null) {
          t1.close$0();
          this._bodyController = null;
        }
        this._bodyPaused = false;
        this._pauseStateChanged$0();
      }, function() {
        return this._closeIncoming$1(false);
      }, "_closeIncoming$0", "call$1", "call$0", "get$_closeIncoming", 0, 2, 1437, 4, 237, [], "_closeIncoming"],
      _pauseStateChanged$0: [function() {
        if (this._incoming != null) {
          if (this._bodyPaused !== true && this._parserCalled !== true)
            this._parse$0();
        } else if (this._paused !== true && this._parserCalled !== true)
          this._parse$0();
      }, "call$0", "get$_pauseStateChanged", 0, 0, 6, "_pauseStateChanged"],
      _reportError$2: [function(error, stackTrace) {
        var t1 = this._socketSubscription;
        if (t1 != null)
          t1.cancel$0();
        this._io$_state = 27;
        this._io$_controller.addError$2(error, stackTrace);
        this._io$_controller.close$0();
      }, function(error) {
        return this._reportError$2(error, null);
      }, "_reportError$1", "call$2", "call$1", "get$_reportError", 2, 2, 291, 0, 8, [], 12, [], "_reportError"],
      _HttpParser$_$1: function(_requestParser) {
        this._io$_controller = new P._SyncStreamController(null, 0, null, new P._HttpParser$__closure(this), new P._HttpParser$__closure0(this), new P._HttpParser$__closure1(this), new P._HttpParser$__closure2(this), [P._HttpIncoming]);
        this._reset$0();
      },
      $asStream: function() {
        return [P._HttpIncoming];
      },
      "<>": [],
      static: {
        _HttpParser__HttpParser$requestParser: [function() {
          return P._HttpParser$_(true);
        }, null, null, 0, 0, 421, "new _HttpParser$requestParser"],
        _HttpParser__HttpParser$responseParser: [function() {
          return P._HttpParser$_(false);
        }, null, null, 0, 0, 421, "new _HttpParser$responseParser"],
        _HttpParser$_: [function(_requestParser) {
          var t1 = new P._HttpParser(false, null, null, _requestParser, null, null, null, 0, 0, [], [], [], [], null, -1, null, null, null, false, -1, null, null, null, true, false, null, null);
          t1._HttpParser$_$1(_requestParser);
          return t1;
        }, null, null, 2, 0, 33, 790, [], "new _HttpParser$_"],
        _HttpParser__isTokenChar: [function(byte) {
          var t1 = J.getInterceptor$n(byte);
          if (t1.$gt(byte, 31))
            if (t1.$lt(byte, 128)) {
              if (byte >>> 0 !== byte || byte >= 256)
                return H.ioore(C.List_NUU, byte);
              t1 = !C.List_NUU[byte];
            } else
              t1 = false;
          else
            t1 = false;
          return t1;
        }, "call$1", "io__HttpParser__isTokenChar$closure", 2, 0, 32, 149, [], "_isTokenChar"],
        _HttpParser__isValueChar: [function(byte) {
          var t1 = J.getInterceptor$n(byte);
          return t1.$gt(byte, 31) && t1.$lt(byte, 128) || t1.$eq(byte, 32) || t1.$eq(byte, 9);
        }, "call$1", "io__HttpParser__isValueChar$closure", 2, 0, 32, 149, [], "_isValueChar"],
        _HttpParser__tokenizeFieldValue: [function(headerValue) {
          var tokens, t1, start, index, t2;
          tokens = H.setRuntimeTypeInfo([], [P.String]);
          t1 = J.getInterceptor$asx(headerValue);
          start = 0;
          index = 0;
          while (true) {
            t2 = t1.get$length(headerValue);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(index < t2))
              break;
            if (J.$eq$(t1.$index(headerValue, index), ",")) {
              tokens.push(t1.substring$2(headerValue, start, index));
              start = index + 1;
            } else if (J.$eq$(t1.$index(headerValue, index), " ") || J.$eq$(t1.$index(headerValue, index), "\t"))
              ++start;
            ++index;
          }
          tokens.push(t1.substring$2(headerValue, start, index));
          return tokens;
        }, "call$1", "io__HttpParser__tokenizeFieldValue$closure", 2, 0, 281, 349, [], "_tokenizeFieldValue"],
        _HttpParser__toLowerCaseByte: [function(x) {
          var t1 = J.getInterceptor$n(x);
          return J.$lt$n(J.$and$n(t1.$sub(x, 65), 127), 26) ? t1.$or(x, 32) : x;
        }, "call$1", "io__HttpParser__toLowerCaseByte$closure", 2, 0, 16, 38, [], "_toLowerCaseByte"]
      }
    },
    "+_HttpParser": [1576],
    _HttpParser$__closure: {
      "^": "Closure:4;$this",
      call$0: [function() {
        this.$this._paused = false;
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _HttpParser$__closure": [2],
    _HttpParser$__closure0: {
      "^": "Closure:4;$this",
      call$0: [function() {
        var t1 = this.$this;
        t1._paused = true;
        t1._pauseStateChanged$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _HttpParser$__closure": [2],
    _HttpParser$__closure1: {
      "^": "Closure:4;$this",
      call$0: [function() {
        var t1 = this.$this;
        t1._paused = false;
        t1._pauseStateChanged$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _HttpParser$__closure": [2],
    _HttpParser$__closure2: {
      "^": "Closure:4;$this",
      call$0: [function() {
        var t1 = this.$this._socketSubscription;
        if (t1 != null)
          t1.cancel$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _HttpParser$__closure": [2],
    _HttpParser__createIncoming_closure: {
      "^": "Closure:4;_box_0,$this",
      call$0: [function() {
        var t1, t2, t3;
        t1 = this._box_0.incoming;
        t2 = this.$this;
        t3 = t2._incoming;
        if (t1 == null ? t3 != null : t1 !== t3)
          return;
        t2._bodyPaused = false;
        t2._pauseStateChanged$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _HttpParser__createIncoming_closure": [2],
    _HttpParser__createIncoming_closure0: {
      "^": "Closure:4;_box_0,$this",
      call$0: [function() {
        var t1, t2, t3;
        t1 = this._box_0.incoming;
        t2 = this.$this;
        t3 = t2._incoming;
        if (t1 == null ? t3 != null : t1 !== t3)
          return;
        t2._bodyPaused = true;
        t2._pauseStateChanged$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _HttpParser__createIncoming_closure": [2],
    _HttpParser__createIncoming_closure1: {
      "^": "Closure:4;_box_0,$this",
      call$0: [function() {
        var t1, t2, t3;
        t1 = this._box_0.incoming;
        t2 = this.$this;
        t3 = t2._incoming;
        if (t1 == null ? t3 != null : t1 !== t3)
          return;
        t2._bodyPaused = false;
        t2._pauseStateChanged$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _HttpParser__createIncoming_closure": [2],
    _HttpParser__createIncoming_closure2: {
      "^": "Closure:4;_box_0,$this",
      call$0: [function() {
        var t1, t2, t3;
        t1 = this._box_0.incoming;
        t2 = this.$this;
        t3 = t2._incoming;
        if (t1 == null ? t3 != null : t1 !== t3)
          return;
        t1 = t2._socketSubscription;
        if (t1 != null)
          t1.cancel$0();
        t2._closeIncoming$1(true);
        t2._io$_controller.close$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _HttpParser__createIncoming_closure": [2],
    _HttpSession: {
      "^": "Object;_destroyed@-8,_isNew@-8,_lastSeen@-75,_timeoutCallback@-29,_sessionManager@-510,_prev@-154,_io$_next@-154,id<-9,_data<-122",
      destroy$0: [function() {
        this._destroyed = true;
        this._sessionManager._removeFromTimeoutQueue$1(this);
        J.remove$1$ax(this._sessionManager.get$_sessions(), this.id);
      }, "call$0", "get$destroy", 0, 0, 6, "destroy"],
      _markSeen$0: [function() {
        this._lastSeen = new P.DateTime(Date.now(), false);
        this._sessionManager._bumpToEnd$1(this);
      }, "call$0", "get$_markSeen", 0, 0, 6, "_markSeen"],
      get$lastSeen: [function() {
        return this._lastSeen;
      }, null, null, 1, 0, 85, "lastSeen"],
      get$isNew: [function() {
        return this._isNew;
      }, null, null, 1, 0, 5, "isNew"],
      set$onTimeout: [function(callback) {
        this._timeoutCallback = callback;
      }, null, null, 3, 0, 37, 33, [], "onTimeout"],
      containsValue$1: [function(value) {
        return this._data.containsValue$1(value);
      }, "call$1", "get$containsValue", 2, 0, 24, 1, [], "containsValue"],
      containsKey$1: [function(key) {
        return this._data.containsKey$1(key);
      }, "call$1", "get$containsKey", 2, 0, 24, 6, [], "containsKey"],
      $index: [function(_, key) {
        return J.$index$asx(this._data, key);
      }, null, "get$[]", 2, 0, 3, 6, [], "[]"],
      $indexSet: [function(_, key, value) {
        J.$indexSet$ax(this._data, key, value);
      }, null, "get$[]=", 4, 0, 267, 6, [], 1, [], "[]="],
      putIfAbsent$2: [function(key, ifAbsent) {
        return this._data.putIfAbsent$2(key, ifAbsent);
      }, "call$2", "get$putIfAbsent", 4, 0, 12, 6, [], 85, [], "putIfAbsent"],
      addAll$1: [function(_, other) {
        return J.addAll$1$ax(this._data, other);
      }, "call$1", "get$addAll", 2, 0, 367, 2, [], "addAll"],
      remove$1: [function(_, key) {
        return J.remove$1$ax(this._data, key);
      }, "call$1", "get$remove", 2, 0, 3, 6, [], "remove"],
      clear$0: [function(_) {
        J.clear$0$ax(this._data);
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      forEach$1: [function(_, f) {
        J.forEach$1$ax(this._data, f);
      }, "call$1", "get$forEach", 2, 0, 458, 9, [], "forEach"],
      get$keys: [function() {
        return this._data.get$keys();
      }, null, null, 1, 0, 220, "keys"],
      get$values: [function() {
        return this._data.get$values();
      }, null, null, 1, 0, 220, "values"],
      get$length: [function(_) {
        return J.get$length$asx(this._data);
      }, null, null, 1, 0, 11, "length"],
      get$isEmpty: [function(_) {
        return J.get$isEmpty$asx(this._data);
      }, null, null, 1, 0, 5, "isEmpty"],
      get$isNotEmpty: [function(_) {
        return J.get$isNotEmpty$asx(this._data);
      }, null, null, 1, 0, 5, "isNotEmpty"],
      toString$0: [function(_) {
        return "HttpSession id:" + H.S(this.id) + " " + H.S(this._data);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      _timeoutCallback$0: function() {
        return this._timeoutCallback.call$0();
      },
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $isMap: 1,
      $asMap: Isolate.functionThatReturnsNull,
      static: {
        _HttpSession$: [function(_sessionManager, id) {
          var t1 = P.HashMap_HashMap(null, null, null, null, null);
          return new P._HttpSession(false, true, new P.DateTime(Date.now(), false), null, _sessionManager, null, null, id, t1);
        }, null, null, 4, 0, 916, 792, [], 352, [], "new _HttpSession"]
      }
    },
    "+_HttpSession": [1, 1577],
    _HttpSessionManager: {
      "^": "Object;_sessions@-1578,_sessionTimeout@-0,_io$_head@-154,_io$_tail@-154,_timer@-128",
      createSessionId$0: [function() {
        P._IOCrypto_getRandomBytes(16);
      }, "call$0", "get$createSessionId", 0, 0, 7, "createSessionId"],
      getSession$1: [function(id) {
        return J.$index$asx(this._sessions, id);
      }, "call$1", "get$getSession", 2, 0, 1447, 352, [], "getSession"],
      createSession$0: [function() {
        var id, t1, t2, session;
        id = this.createSessionId$0();
        for (; this._sessions.containsKey$1(id); id = null)
          P._IOCrypto_getRandomBytes(16);
        t1 = this._sessions;
        t2 = P.HashMap_HashMap(null, null, null, null, null);
        session = new P._HttpSession(false, true, new P.DateTime(Date.now(), false), null, this, null, null, id, t2);
        J.$indexSet$ax(t1, id, session);
        this._addToTimeoutQueue$1(session);
        return session;
      }, "call$0", "get$createSession", 0, 0, 1452, "createSession"],
      set$sessionTimeout: [function(timeout) {
        this._sessionTimeout = timeout;
        this._stopTimer$0();
        this._startTimer$0();
      }, null, null, 3, 0, 17, 316, [], "sessionTimeout"],
      close$0: [function() {
        this._stopTimer$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      _bumpToEnd$1: [function(session) {
        this._removeFromTimeoutQueue$1(session);
        this._addToTimeoutQueue$1(session);
      }, "call$1", "get$_bumpToEnd", 2, 0, 257, 355, [], "_bumpToEnd"],
      _addToTimeoutQueue$1: [function(session) {
        if (this._io$_head == null) {
          this._io$_head = session;
          this._io$_tail = session;
          this._startTimer$0();
        } else {
          this._io$_tail.set$_io$_next(session);
          session.set$_prev(this._io$_tail);
          this._io$_tail = session;
        }
      }, "call$1", "get$_addToTimeoutQueue", 2, 0, 257, 355, [], "_addToTimeoutQueue"],
      _removeFromTimeoutQueue$1: [function(session) {
        if (session.get$_io$_next() != null)
          session.get$_io$_next().set$_prev(session.get$_prev());
        if (session.get$_prev() != null)
          session.get$_prev().set$_io$_next(session.get$_io$_next());
        if (J.$eq$(this._io$_head, session)) {
          this._io$_head = session.get$_io$_next();
          this._stopTimer$0();
          this._startTimer$0();
        }
        if (J.$eq$(this._io$_tail, session))
          this._io$_tail = session.get$_prev();
        session.set$_prev(null);
        session.set$_io$_next(null);
      }, "call$1", "get$_removeFromTimeoutQueue", 2, 0, 257, 355, [], "_removeFromTimeoutQueue"],
      _timerTimeout$0: [function() {
        this._stopTimer$0();
        var session = this._io$_head;
        session.destroy$0();
        if (session.get$_timeoutCallback() != null)
          session._timeoutCallback$0();
      }, "call$0", "get$_timerTimeout", 0, 0, 6, "_timerTimeout"],
      _startTimer$0: [function() {
        var t1, t2, seconds;
        if (this._io$_head != null) {
          t1 = Date.now();
          t2 = this._io$_head.get$lastSeen().get$_core$_value();
          if (typeof t2 !== "number")
            return H.iae(t2);
          seconds = J.$tdiv$n(P.Duration$(0, 0, 0, t1 - t2, 0, 0)._duration, 1000000);
          this._timer = P.Timer_Timer(P.Duration$(0, 0, 0, 0, 0, J.$sub$n(this._sessionTimeout, seconds)), this.get$_timerTimeout());
        }
      }, "call$0", "get$_startTimer", 0, 0, 6, "_startTimer"],
      _stopTimer$0: [function() {
        var t1 = this._timer;
        if (t1 != null) {
          t1.cancel$0();
          this._timer = null;
        }
      }, "call$0", "get$_stopTimer", 0, 0, 6, "_stopTimer"],
      static: {
        _HttpSessionManager$: [function() {
          return new P._HttpSessionManager(P.LinkedHashMap__makeEmpty(), 1200, null, null, null);
        }, null, null, 0, 0, 4, "new _HttpSessionManager"]
      }
    },
    "+_HttpSessionManager": [1],
    _IOResourceInfo: {
      "^": "Object;type<-9,id<-0",
      get$referenceValueMap: [function() {
        return P.LinkedHashMap__makeLiteral(["type", "@" + H.S(this.type), "id", this.id, "name", this.get$name()]);
      }, null, null, 1, 0, 140, "referenceValueMap"],
      static: {
        "^": "_IOResourceInfo__count@-0,_IOResourceInfo__sw<-1579,_IOResourceInfo__startTime<-10",
        _IOResourceInfo_timestamp: [function() {
          var t1, t2, t3;
          t1 = $.$get$_IOResourceInfo__startTime();
          t2 = $.$get$_IOResourceInfo__sw();
          t3 = t2._stop;
          if (t3 == null)
            t3 = $.Primitives_timerTicks.call$0();
          return J.$add$ns(t1, J.$div$n(J.$tdiv$n(J.$mul$ns(J.$sub$n(t3, t2._core$_start), 1000000), $.Stopwatch__frequency), 1000));
        }, null, null, 1, 0, 52, "timestamp"],
        _IOResourceInfo$: [function(type) {
          var t1 = $._IOResourceInfo__count;
          $._IOResourceInfo__count = J.$add$ns(t1, 1);
          return new P._IOResourceInfo(type, t1);
        }, null, null, 2, 0, 13, 65, [], "new _IOResourceInfo"],
        _IOResourceInfo_getNextID: [function() {
          var t1 = $._IOResourceInfo__count;
          $._IOResourceInfo__count = J.$add$ns(t1, 1);
          return t1;
        }, "call$0", "io__IOResourceInfo_getNextID$closure", 0, 0, 11, "getNextID"]
      }
    },
    "+_IOResourceInfo": [1],
    _ReadWriteResourceInfo: {
      "^": "_IOResourceInfo;totalRead@-0,totalWritten@-0,readCount@-0,writeCount@-0,lastRead@-23,lastWrite@-23,type-9,id-0",
      addRead$1: [function(bytes) {
        var t1, t2, t3;
        this.totalRead = J.$add$ns(this.totalRead, bytes);
        this.readCount = J.$add$ns(this.readCount, 1);
        t1 = $.$get$_IOResourceInfo__startTime();
        t2 = $.$get$_IOResourceInfo__sw();
        t3 = t2._stop;
        if (t3 == null)
          t3 = $.Primitives_timerTicks.call$0();
        this.lastRead = J.$add$ns(t1, J.$div$n(J.$tdiv$n(J.$mul$ns(J.$sub$n(t3, t2._core$_start), 1000000), $.Stopwatch__frequency), 1000));
      }, "call$1", "get$addRead", 2, 0, 17, 30, [], "addRead"],
      didRead$0: [function() {
        this.addRead$1(0);
      }, "call$0", "get$didRead", 0, 0, 6, "didRead"],
      addWrite$1: [function(bytes) {
        var t1, t2, t3;
        this.totalWritten = J.$add$ns(this.totalWritten, bytes);
        this.writeCount = J.$add$ns(this.writeCount, 1);
        t1 = $.$get$_IOResourceInfo__startTime();
        t2 = $.$get$_IOResourceInfo__sw();
        t3 = t2._stop;
        if (t3 == null)
          t3 = $.Primitives_timerTicks.call$0();
        this.lastWrite = J.$add$ns(t1, J.$div$n(J.$tdiv$n(J.$mul$ns(J.$sub$n(t3, t2._core$_start), 1000000), $.Stopwatch__frequency), 1000));
      }, "call$1", "get$addWrite", 2, 0, 17, 30, [], "addWrite"],
      get$fullValueMap: [function() {
        return P.LinkedHashMap__makeLiteral(["type", this.type, "id", this.id, "name", this.get$name(), "totalRead", this.totalRead, "totalWritten", this.totalWritten, "readCount", this.readCount, "writeCount", this.writeCount, "lastRead", this.lastRead, "lastWrite", this.lastWrite]);
      }, null, null, 1, 0, 140, "fullValueMap"],
      static: {
        _ReadWriteResourceInfo$: [function(type) {
          var t1 = $._IOResourceInfo__count;
          $._IOResourceInfo__count = J.$add$ns(t1, 1);
          return new P._ReadWriteResourceInfo(0, 0, 0, 0, 0, 0, type, t1);
        }, null, null, 2, 0, 13, 65, [], "new _ReadWriteResourceInfo"]
      }
    },
    "+_ReadWriteResourceInfo": [514],
    _FileResourceInfo: {
      "^": "_ReadWriteResourceInfo;file<-10,totalRead-0,totalWritten-0,readCount-0,writeCount-0,lastRead-23,lastWrite-23,type-9,id-0",
      getFileInfoMap$0: [function() {
        return this.get$fullValueMap();
      }, "call$0", "get$getFileInfoMap", 0, 0, 140, "getFileInfoMap"],
      get$name: [function() {
        return H.S(this.file.get$path());
      }, null, null, 1, 0, 7, "name"],
      static: {
        "^": "_FileResourceInfo_TYPE<-9,_FileResourceInfo_openFiles@-1581",
        _FileResourceInfo$: [function(file) {
          var t1, t2;
          t1 = $._IOResourceInfo__count;
          $._IOResourceInfo__count = J.$add$ns(t1, 1);
          t2 = new P._FileResourceInfo(file, 0, 0, 0, 0, 0, 0, "_file", t1);
          J.$indexSet$ax($.$get$_FileResourceInfo_openFiles(), t1, t2);
          return t2;
        }, null, null, 2, 0, 3, 158, [], "new _FileResourceInfo"],
        _FileResourceInfo_FileOpened: [function(info) {
          J.$indexSet$ax($.$get$_FileResourceInfo_openFiles(), info.get$id(), info);
        }, "call$1", "io__FileResourceInfo_FileOpened$closure", 2, 0, 422, 131, [], "FileOpened"],
        _FileResourceInfo_FileClosed: [function(info) {
          J.remove$1$ax($.$get$_FileResourceInfo_openFiles(), info.get$id());
        }, "call$1", "io__FileResourceInfo_FileClosed$closure", 2, 0, 422, 131, [], "FileClosed"],
        _FileResourceInfo_getOpenFilesList: [function() {
          return P.List_List$from($.$get$_FileResourceInfo_openFiles().get$values().map$1(0, new P._FileResourceInfo_getOpenFilesList_closure()), true, null);
        }, "call$0", "io__FileResourceInfo_getOpenFilesList$closure", 0, 0, 241, "getOpenFilesList"],
        _FileResourceInfo_getOpenFiles: [function($function, params) {
          var t1, t2;
          t1 = P.ServiceExtensionResponse$result(C.JsonCodec_null_null.encode$1(P.LinkedHashMap__makeLiteral(["type", "_openfiles", "data", P._FileResourceInfo_getOpenFilesList()])));
          t2 = new P._Future(0, $.Zone__current, null, [null]);
          t2._asyncComplete$1(t1);
          return t2;
        }, "call$2", "io__FileResourceInfo_getOpenFiles$closure", 4, 0, 240, 115, [], 159, [], "getOpenFiles"],
        _FileResourceInfo_getFileInfoMapByID: [function($function, params) {
          var id, t1, t2;
          id = H.Primitives_parseInt(J.$index$asx(params, "id"), null, null);
          t1 = P.ServiceExtensionResponse$result(C.JsonCodec_null_null.encode$1($.$get$_FileResourceInfo_openFiles().containsKey$1(id) ? J.$index$asx($.$get$_FileResourceInfo_openFiles(), id).getFileInfoMap$0() : P.LinkedHashMap__makeEmpty()));
          t2 = new P._Future(0, $.Zone__current, null, [null]);
          t2._asyncComplete$1(t1);
          return t2;
        }, "call$2", "io__FileResourceInfo_getFileInfoMapByID$closure", 4, 0, 240, 115, [], 159, [], "getFileInfoMapByID"]
      }
    },
    "+_FileResourceInfo": [515],
    _FileResourceInfo_getOpenFilesList_closure: {
      "^": "Closure:3;",
      call$1: [function(e) {
        return e.get$referenceValueMap();
      }, null, null, 2, 0, 3, 47, [], "call"]
    },
    "+ _FileResourceInfo_getOpenFilesList_closure": [2],
    _ProcessResourceInfo: {
      "^": "_IOResourceInfo;process<-10,startedAt<-23,type-9,id-0",
      get$name: [function() {
        return this.process.get$_path();
      }, null, null, 1, 0, 7, "name"],
      stopped$0: [function() {
        J.remove$1$ax($.$get$_ProcessResourceInfo_startedProcesses(), this.id);
      }, "call$0", "get$stopped", 0, 0, 6, "stopped"],
      get$fullValueMap: [function() {
        var t1, t2, t3, t4;
        t1 = this.process;
        t2 = t1.get$_path();
        t3 = t1.get$pid();
        t4 = t1.get$_io$_arguments();
        t1.get$_workingDirectory();
        t1 = t1.get$_workingDirectory();
        return P.LinkedHashMap__makeLiteral(["type", this.type, "id", this.id, "name", t2, "pid", t3, "startedAt", this.startedAt, "arguments", t4, "workingDirectory", t1]);
      }, null, null, 1, 0, 140, "fullValueMap"],
      process$0: function() {
        return this.process.call$0();
      },
      process$3: function(arg0, arg1, arg2) {
        return this.process.call$3(arg0, arg1, arg2);
      },
      static: {
        "^": "_ProcessResourceInfo_TYPE<-9,_ProcessResourceInfo_startedProcesses@-1583",
        _ProcessResourceInfo$: [function(process) {
          var t1, t2, t3;
          t1 = $.$get$_IOResourceInfo__startTime();
          t2 = $.$get$_IOResourceInfo__sw();
          t3 = t2._stop;
          if (t3 == null)
            t3 = $.Primitives_timerTicks.call$0();
          t2 = J.$add$ns(t1, J.$div$n(J.$tdiv$n(J.$mul$ns(J.$sub$n(t3, t2._core$_start), 1000000), $.Stopwatch__frequency), 1000));
          t3 = $._IOResourceInfo__count;
          $._IOResourceInfo__count = J.$add$ns(t3, 1);
          t2 = new P._ProcessResourceInfo(process, t2, "_process", t3);
          J.$indexSet$ax($.$get$_ProcessResourceInfo_startedProcesses(), t3, t2);
          return t2;
        }, null, null, 2, 0, 3, 477, [], "new _ProcessResourceInfo"],
        _ProcessResourceInfo_ProcessStarted: [function(info) {
          J.$indexSet$ax($.$get$_ProcessResourceInfo_startedProcesses(), info.get$id(), info);
        }, "call$1", "io__ProcessResourceInfo_ProcessStarted$closure", 2, 0, 423, 131, [], "ProcessStarted"],
        _ProcessResourceInfo_ProcessStopped: [function(info) {
          J.remove$1$ax($.$get$_ProcessResourceInfo_startedProcesses(), info.get$id());
        }, "call$1", "io__ProcessResourceInfo_ProcessStopped$closure", 2, 0, 423, 131, [], "ProcessStopped"],
        _ProcessResourceInfo_getStartedProcessesList: [function() {
          return P.List_List$from($.$get$_ProcessResourceInfo_startedProcesses().get$values().map$1(0, new P._ProcessResourceInfo_getStartedProcessesList_closure()), true, null);
        }, "call$0", "io__ProcessResourceInfo_getStartedProcessesList$closure", 0, 0, 241, "getStartedProcessesList"],
        _ProcessResourceInfo_getStartedProcesses: [function($function, params) {
          var t1, t2;
          t1 = P.ServiceExtensionResponse$result(C.JsonCodec_null_null.encode$1(P.LinkedHashMap__makeLiteral(["type", "_startedprocesses", "data", P._ProcessResourceInfo_getStartedProcessesList()])));
          t2 = new P._Future(0, $.Zone__current, null, [null]);
          t2._asyncComplete$1(t1);
          return t2;
        }, "call$2", "io__ProcessResourceInfo_getStartedProcesses$closure", 4, 0, 193, 115, [], 159, [], "getStartedProcesses"],
        _ProcessResourceInfo_getProcessInfoMapById: [function($function, params) {
          var id, t1, t2;
          id = H.Primitives_parseInt(J.$index$asx(params, "id"), null, null);
          t1 = P.ServiceExtensionResponse$result(C.JsonCodec_null_null.encode$1($.$get$_ProcessResourceInfo_startedProcesses().containsKey$1(id) ? J.$index$asx($.$get$_ProcessResourceInfo_startedProcesses(), id).get$fullValueMap() : P.LinkedHashMap__makeEmpty()));
          t2 = new P._Future(0, $.Zone__current, null, [null]);
          t2._asyncComplete$1(t1);
          return t2;
        }, "call$2", "io__ProcessResourceInfo_getProcessInfoMapById$closure", 4, 0, 193, 115, [], 159, [], "getProcessInfoMapById"]
      }
    },
    "+_ProcessResourceInfo": [514],
    _ProcessResourceInfo_getStartedProcessesList_closure: {
      "^": "Closure:3;",
      call$1: [function(e) {
        return e.get$referenceValueMap();
      }, null, null, 2, 0, 3, 47, [], "call"]
    },
    "+ _ProcessResourceInfo_getStartedProcessesList_closure": [2],
    _SocketResourceInfo: {
      "^": "_ReadWriteResourceInfo;socket<-10,totalRead-0,totalWritten-0,readCount-0,writeCount-0,lastRead-23,lastWrite-23,type-9,id-0",
      get$name: [function() {
        var remote, remoteHost, remotePort, t1, exception;
        t1 = this.socket;
        if (t1.get$isListening())
          return "listening:" + H.S(t1.get$address().get$host()) + ":" + H.S(t1.get$port());
        remote = "";
        try {
          remoteHost = t1.get$remoteAddress().get$host();
          remotePort = t1.get$remotePort();
          remote = " -> " + H.S(remoteHost) + ":" + H.S(remotePort);
        } catch (exception) {
          H.unwrapException(exception);
        }
        return H.S(t1.get$address().get$host()) + ":" + H.S(t1.get$port()) + H.S(remote);
      }, null, null, 1, 0, 7, "name"],
      getSocketInfoMap$0: [function() {
        var result, t1, t2, exception;
        result = this.get$fullValueMap();
        t1 = this.socket;
        t2 = t1.get$isTcp() ? "TCP" : "UDP";
        J.$indexSet$ax(result, "socketType", t2);
        J.$indexSet$ax(result, "listening", t1.get$isListening());
        J.$indexSet$ax(result, "host", t1.get$address().get$host());
        J.$indexSet$ax(result, "port", t1.get$port());
        if (!t1.get$isListening())
          try {
            J.$indexSet$ax(result, "remoteHost", t1.get$remoteAddress().get$host());
            J.$indexSet$ax(result, "remotePort", t1.get$remotePort());
          } catch (exception) {
            H.unwrapException(exception);
            J.$indexSet$ax(result, "remotePort", "NA");
            J.$indexSet$ax(result, "remoteHost", "NA");
          }
        else {
          J.$indexSet$ax(result, "remotePort", "NA");
          J.$indexSet$ax(result, "remoteHost", "NA");
        }
        J.$indexSet$ax(result, "addressType", t1.get$address().get$type().get$name());
        return result;
      }, "call$0", "get$getSocketInfoMap", 0, 0, 140, "getSocketInfoMap"],
      static: {
        "^": "_SocketResourceInfo_TCP_STRING<-9,_SocketResourceInfo_UDP_STRING<-9,_SocketResourceInfo_TYPE<-9,_SocketResourceInfo_openSockets@-1584",
        _SocketResourceInfo$: [function(socket) {
          var t1, t2;
          t1 = $._IOResourceInfo__count;
          $._IOResourceInfo__count = J.$add$ns(t1, 1);
          t2 = new P._SocketResourceInfo(socket, 0, 0, 0, 0, 0, 0, "_socket", t1);
          J.$indexSet$ax($.$get$_SocketResourceInfo_openSockets(), t1, t2);
          return t2;
        }, null, null, 2, 0, 3, 52, [], "new _SocketResourceInfo"],
        _SocketResourceInfo_getOpenSocketsList: [function() {
          return P.List_List$from($.$get$_SocketResourceInfo_openSockets().get$values().map$1(0, new P._SocketResourceInfo_getOpenSocketsList_closure()), true, null);
        }, "call$0", "io__SocketResourceInfo_getOpenSocketsList$closure", 0, 0, 241, "getOpenSocketsList"],
        _SocketResourceInfo_getSocketInfoMapByID: [function($function, params) {
          var id, t1, t2;
          id = H.Primitives_parseInt(J.$index$asx(params, "id"), null, null);
          t1 = P.ServiceExtensionResponse$result(C.JsonCodec_null_null.encode$1($.$get$_SocketResourceInfo_openSockets().containsKey$1(id) ? J.$index$asx($.$get$_SocketResourceInfo_openSockets(), id).getSocketInfoMap$0() : P.LinkedHashMap__makeEmpty()));
          t2 = new P._Future(0, $.Zone__current, null, [null]);
          t2._asyncComplete$1(t1);
          return t2;
        }, "call$2", "io__SocketResourceInfo_getSocketInfoMapByID$closure", 4, 0, 193, 115, [], 159, [], "getSocketInfoMapByID"],
        _SocketResourceInfo_getOpenSockets: [function($function, params) {
          var t1, t2;
          t1 = P.ServiceExtensionResponse$result(C.JsonCodec_null_null.encode$1(P.LinkedHashMap__makeLiteral(["type", "_opensockets", "data", P._SocketResourceInfo_getOpenSocketsList()])));
          t2 = new P._Future(0, $.Zone__current, null, [null]);
          t2._asyncComplete$1(t1);
          return t2;
        }, "call$2", "io__SocketResourceInfo_getOpenSockets$closure", 4, 0, 240, 115, [], 159, [], "getOpenSockets"],
        _SocketResourceInfo_SocketOpened: [function(info) {
          J.$indexSet$ax($.$get$_SocketResourceInfo_openSockets(), info.get$id(), info);
        }, "call$1", "io__SocketResourceInfo_SocketOpened$closure", 2, 0, 424, 131, [], "SocketOpened"],
        _SocketResourceInfo_SocketClosed: [function(info) {
          J.remove$1$ax($.$get$_SocketResourceInfo_openSockets(), info.get$id());
        }, "call$1", "io__SocketResourceInfo_SocketClosed$closure", 2, 0, 424, 131, [], "SocketClosed"]
      }
    },
    "+_SocketResourceInfo": [515],
    _SocketResourceInfo_getOpenSocketsList_closure: {
      "^": "Closure:3;",
      call$1: [function(e) {
        return e.get$referenceValueMap();
      }, null, null, 2, 0, 3, 47, [], "call"]
    },
    "+ _SocketResourceInfo_getOpenSocketsList_closure": [2],
    _IOService: {
      "^": "Object;",
      static: {
        _IOService$: [function() {
          return new P._IOService();
        }, null, null, 0, 0, 923, "new _IOService"],
        _IOService__dispatch: [function(request, data) {
          throw H.wrapException(new P.UnsupportedError("_IOService._dispatch"));
        }, "call$2", "io__IOService__dispatch$closure", 4, 0, 924, 54, [], 21, [], "_dispatch"]
      }
    },
    "+_IOService": [1],
    IOSink: {
      "^": "Object;encoding@-79",
      static: {
        IOSink_IOSink: [function(target, encoding) {
          return new P._IOSinkImpl(encoding, true, target, new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]), null, null, false, false, false);
        }, null, null, 2, 3, 925, 73, 79, [], 48, [], "new IOSink"]
      }
    },
    "+IOSink": [1, 57, 1585],
    _StreamSinkImpl: {
      "^": "Object;_io$_target<-153,_doneCompleter<-41,_controllerInstance@-156,_controllerCompleter@-41,_io$_isClosed@-8,_isBound@-8,_io$_hasError@-8,$ti",
      add$1: ["super$_StreamSinkImpl$add", function(_, data) {
        if (this._io$_isClosed === true)
          return;
        J.add$1$ax(this.get$_io$_controller(), data);
      }, "call$1", "get$add", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "_StreamSinkImpl");
      }, 21, [], "add"],
      addError$2: [function(error, stackTrace) {
        this.get$_io$_controller().addError$2(error, stackTrace);
      }, function(error) {
        return this.addError$2(error, null);
      }, "addError$1", "call$2", "call$1", "get$addError", 2, 2, 81, 0, 8, [], 12, [], "addError"],
      addStream$1: [function(stream) {
        var t1, future;
        if (this._isBound === true)
          throw H.wrapException(new P.StateError("StreamSink is already bound to a stream"));
        this._isBound = true;
        if (this._io$_hasError === true)
          return this.get$done();
        t1 = new P._StreamSinkImpl_addStream_targetAddStream(this, stream);
        if (this._controllerInstance == null)
          return t1.call$0();
        future = this._controllerCompleter.get$future();
        this._controllerInstance.close$0();
        return future.then$1(new P._StreamSinkImpl_addStream_closure(t1));
      }, "call$1", "get$addStream", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: P.Future, args: [[P.Stream, T]]};
        }, this.$receiver, "_StreamSinkImpl");
      }, 37, [], "addStream"],
      flush$0: [function() {
        var t1, future;
        if (this._isBound === true)
          throw H.wrapException(new P.StateError("StreamSink is bound to a stream"));
        if (this._controllerInstance == null) {
          t1 = new P._Future(0, $.Zone__current, null, [null]);
          t1._asyncComplete$1(this);
          return t1;
        }
        this._isBound = true;
        future = this._controllerCompleter.get$future();
        this._controllerInstance.close$0();
        return future.whenComplete$1(new P._StreamSinkImpl_flush_closure(this));
      }, "call$0", "get$flush", 0, 0, 18, "flush"],
      close$0: ["super$_StreamSinkImpl$close", function() {
        if (this._isBound === true)
          throw H.wrapException(new P.StateError("StreamSink is bound to a stream"));
        if (this._io$_isClosed !== true) {
          this._io$_isClosed = true;
          var t1 = this._controllerInstance;
          if (t1 != null)
            t1.close$0();
          else
            this._io$_target.close$0().then$2$onError(this.get$_completeDoneValue(), this.get$_completeDoneError());
        }
        return this.get$done();
      }, "call$0", "get$close", 0, 0, 18, "close"],
      _closeTarget$0: [function() {
        this._io$_target.close$0().then$2$onError(this.get$_completeDoneValue(), this.get$_completeDoneError());
      }, "call$0", "get$_closeTarget", 0, 0, 6, "_closeTarget"],
      get$done: [function() {
        return this._doneCompleter.get$future();
      }, null, null, 1, 0, 18, "done"],
      _completeDoneValue$1: [function(value) {
        var t1 = this._doneCompleter;
        if (!t1.get$isCompleted())
          t1.complete$1(value);
      }, "call$1", "get$_completeDoneValue", 2, 0, 27, 1, [], "_completeDoneValue"],
      _completeDoneError$2: [function(error, stackTrace) {
        var t1 = this._doneCompleter;
        if (!t1.get$isCompleted()) {
          this._io$_hasError = true;
          t1.completeError$2(error, stackTrace);
        }
      }, "call$2", "get$_completeDoneError", 4, 0, 71, 8, [], 12, [], "_completeDoneError"],
      get$_io$_controller: [function() {
        if (this._isBound === true)
          throw H.wrapException(new P.StateError("StreamSink is bound to a stream"));
        if (this._io$_isClosed === true)
          throw H.wrapException(new P.StateError("StreamSink is closed"));
        if (this._controllerInstance == null) {
          this._controllerInstance = new P._SyncStreamController(null, 0, null, null, null, null, null, [H.getRuntimeTypeArgument(this, "_StreamSinkImpl", 0)]);
          this._controllerCompleter = new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]);
          this._io$_target.addStream$1(this.get$_io$_controller().get$stream()).then$2$onError(new P._StreamSinkImpl__controller_closure(this), new P._StreamSinkImpl__controller_closure0(this));
        }
        return this._controllerInstance;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.StreamController, T]};
        }, this.$receiver, "_StreamSinkImpl");
      }, "_io$_controller"],
      "<>": [285],
      static: {
        _StreamSinkImpl$: [function(_target, $T) {
          return new P._StreamSinkImpl(_target, new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]), null, null, false, false, false, [$T]);
        }, null, null, 2, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [[P.StreamConsumer, T]]};
          }, this.$receiver, "_StreamSinkImpl");
        }, 547, [], "new _StreamSinkImpl"]
      }
    },
    "+_StreamSinkImpl": [1, 1586],
    _StreamSinkImpl_addStream_targetAddStream: {
      "^": "Closure:18;$this,stream",
      call$0: [function() {
        var t1 = this.$this;
        return t1._io$_target.addStream$1(this.stream).whenComplete$1(new P._StreamSinkImpl_addStream_targetAddStream_closure(t1));
      }, null, null, 0, 0, 18, "call"]
    },
    "+ _StreamSinkImpl_addStream_targetAddStream": [2],
    _StreamSinkImpl_addStream_targetAddStream_closure: {
      "^": "Closure:4;$this",
      call$0: [function() {
        this.$this._isBound = false;
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _StreamSinkImpl_addStream_targetAddStream_closure": [2],
    _StreamSinkImpl_addStream_closure: {
      "^": "Closure:3;targetAddStream",
      call$1: [function(_) {
        return this.targetAddStream.call$0();
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _StreamSinkImpl_addStream_closure": [2],
    _StreamSinkImpl_flush_closure: {
      "^": "Closure:4;$this",
      call$0: [function() {
        this.$this._isBound = false;
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _StreamSinkImpl_flush_closure": [2],
    _StreamSinkImpl__controller_closure: {
      "^": "Closure:3;$this",
      call$1: [function(_) {
        var t1 = this.$this;
        if (t1._isBound === true) {
          t1._controllerCompleter.complete$1(t1);
          t1._controllerCompleter = null;
          t1._controllerInstance = null;
        } else
          t1._io$_target.close$0().then$2$onError(t1.get$_completeDoneValue(), t1.get$_completeDoneError());
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _StreamSinkImpl__controller_closure": [2],
    _StreamSinkImpl__controller_closure0: {
      "^": "Closure:12;$this",
      call$2: [function(error, stackTrace) {
        var t1 = this.$this;
        if (t1._isBound === true) {
          t1._controllerCompleter.completeError$2(error, stackTrace);
          t1._controllerCompleter = null;
          t1._controllerInstance = null;
        } else
          t1._completeDoneError$2(error, stackTrace);
      }, null, null, 4, 0, 12, 8, [], 12, [], "call"]
    },
    "+ _StreamSinkImpl__controller_closure": [2],
    _IOSinkImpl: {
      "^": "_StreamSinkImpl;_encoding@-79,_encodingMutable@-8,_io$_target-153,_doneCompleter-41,_controllerInstance-156,_controllerCompleter-41,_io$_isClosed-8,_isBound-8,_io$_hasError-8",
      get$encoding: [function() {
        return this._encoding;
      }, null, null, 1, 0, 207, "encoding"],
      set$encoding: [function(value) {
        if (this._encodingMutable !== true)
          throw H.wrapException(new P.StateError("IOSink encoding is not mutable"));
        this._encoding = value;
      }, null, null, 3, 0, 261, 1, [], "encoding"],
      write$1: ["super$_IOSinkImpl$write", function(obj) {
        var string = H.S(obj);
        if (string.length === 0)
          return;
        this.add$1(0, this._encoding.encode$1(string));
      }, "call$1", "get$write", 2, 0, 64, 143, [], "write"],
      writeAll$2: [function(objects, separator) {
        var iterator = J.get$iterator$ax(objects);
        if (!iterator.moveNext$0())
          return;
        if (J.get$isEmpty$asx(separator) === true) {
          do
            this.write$1(iterator.get$current());
          while (iterator.moveNext$0());
        } else {
          this.write$1(iterator.get$current());
          for (; iterator.moveNext$0();) {
            this.write$1(separator);
            this.write$1(iterator.get$current());
          }
        }
      }, function(objects) {
        return this.writeAll$2(objects, "");
      }, "writeAll$1", "call$2", "call$1", "get$writeAll", 2, 2, 135, 32, 119, [], 63, [], "writeAll"],
      writeln$1: [function(object) {
        this.write$1(object);
        this.write$1("\n");
      }, function() {
        return this.writeln$1("");
      }, "writeln$0", "call$1", "call$0", "get$writeln", 0, 2, 134, 32, 23, [], "writeln"],
      writeCharCode$1: [function(charCode) {
        this.write$1(H.Primitives_stringFromCharCode(charCode));
      }, "call$1", "get$writeCharCode", 2, 0, 17, 84, [], "writeCharCode"],
      $as_StreamSinkImpl: function() {
        return [[P.List, P.int]];
      },
      "<>": [],
      static: {
        _IOSinkImpl$: [function(target, _encoding) {
          return new P._IOSinkImpl(_encoding, true, target, new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]), null, null, false, false, false);
        }, null, null, 4, 0, 926, 79, [], 798, [], "new _IOSinkImpl"]
      }
    },
    "+_IOSinkImpl": [1587, 78],
    Link: {
      "^": "Object;",
      $isFileSystemEntity: 1,
      static: {
        Link_Link: [function(path) {
          if (typeof path !== "string")
            H.throwExpression(P.ArgumentError$(H.S(P.Error_safeToString(path)) + " is not a String"));
          return new P._Link(path);
        }, null, null, 2, 0, 369, 10, [], "new Link"],
        Link_Link$fromUri: [function(uri) {
          return P._Link$(uri.toFilePath$0());
        }, null, null, 2, 0, 927, 40, [], "new Link$fromUri"]
      }
    },
    "+Link": [1, 115],
    _Link: {
      "^": "FileSystemEntity;path<-9",
      toString$0: [function(_) {
        return "Link: '" + H.S(this.path) + "'";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      exists$0: [function() {
        return P.FileSystemEntity_isLink(this.path);
      }, "call$0", "get$exists", 0, 0, 129, "exists"],
      existsSync$0: [function() {
        return P.FileSystemEntity_isLinkSync(this.path);
      }, "call$0", "get$existsSync", 0, 0, 5, "existsSync"],
      get$absolute: [function() {
        return P._Link$(this.get$_absolutePath());
      }, null, null, 1, 0, 1476, "absolute"],
      create$2$recursive: [function(target, recursive) {
        var t1, result;
        t1 = {};
        t1.target = target;
        if ($.$get$Platform_isWindows())
          t1.target = this._makeWindowsLinkTarget$1(target);
        if (recursive === true)
          result = P._Directory$(P.FileSystemEntity_parentOf(this.path)).create$1$recursive(true);
        else {
          result = new P._Future(0, $.Zone__current, null, [null]);
          result._asyncComplete$1(null);
        }
        return result.then$1(new P._Link_create_closure(t1, this)).then$1(new P._Link_create_closure0(t1, this));
      }, function(target) {
        return this.create$2$recursive(target, false);
      }, "create$1", "call$2$recursive", "call$1", "get$create", 2, 3, 1481, 4, 79, [], 51, [], "create"],
      createSync$2$recursive: [function(target, recursive) {
        if (recursive === true)
          P._Directory$(P.FileSystemEntity_parentOf(this.path)).createSync$1$recursive(true);
        if ($.$get$Platform_isWindows())
          target = this._makeWindowsLinkTarget$1(target);
        P._File__createLink(this.path, target);
      }, function(target) {
        return this.createSync$2$recursive(target, false);
      }, "createSync$1", "call$2$recursive", "call$1", "get$createSync", 2, 3, 1482, 4, 79, [], 51, [], "createSync"],
      _makeWindowsLinkTarget$1: [function(target) {
        var base, link, destination, result;
        base = P._Uri__Uri$file(H.S(P._Directory_current().path) + "\\", null);
        link = P._Uri__Uri$file(this.path, null);
        destination = P._Uri__Uri$file(target, null);
        result = base.resolveUri$1(link).resolveUri$1(destination).toFilePath$0();
        if (result.length > 3 && result[1] === ":" && result[2] === "\\")
          return "\\??\\" + result;
        else
          throw H.wrapException(new P.FileSystemException("Target " + result + " of Link.create on Windows cannot be converted to start with a drive letter.  Unexpected error.", "", null));
      }, "call$1", "get$_makeWindowsLinkTarget", 2, 0, 28, 79, [], "_makeWindowsLinkTarget"],
      updateSync$1: [function(target) {
        this._deleteSync$1$recursive(false);
        if ($.$get$Platform_isWindows())
          target = this._makeWindowsLinkTarget$1(target);
        P._File__createLink(this.path, target);
      }, "call$1", "get$updateSync", 2, 0, 19, 79, [], "updateSync"],
      update$1: [function(target) {
        return this.delete$0().then$1(new P._Link_update_closure(this, target));
      }, "call$1", "get$update", 2, 0, 368, 79, [], "update"],
      _delete$1$recursive: [function(recursive) {
        if (recursive === true)
          return P._Directory$(this.path).delete$1$recursive(true).then$1(new P._Link__delete_closure(this));
        return P._IOService__dispatch(24, [this.path]).then$1(new P._Link__delete_closure0(this));
      }, function() {
        return this._delete$1$recursive(false);
      }, "_delete$0", "call$1$recursive", "call$0", "get$_delete", 0, 3, 1486, 4, 51, [], "_delete"],
      _deleteSync$1$recursive: [function(recursive) {
        if (recursive === true)
          return P._Directory$(this.path)._deleteSync$1$recursive(true);
        P._File__deleteLinkNative(this.path);
      }, function() {
        return this._deleteSync$1$recursive(false);
      }, "_deleteSync$0", "call$1$recursive", "call$0", "get$_deleteSync", 0, 3, 111, 4, 51, [], "_deleteSync"],
      rename$1: [function(newPath) {
        return P._IOService__dispatch(25, [this.path, newPath]).then$1(new P._Link_rename_closure(this, newPath));
      }, "call$1", "get$rename", 2, 0, 368, 86, [], "rename"],
      renameSync$1: [function(newPath) {
        P._File__renameLink(this.path, newPath);
      }, "call$1", "get$renameSync", 2, 0, 369, 86, [], "renameSync"],
      target$0: [function() {
        return P._IOService__dispatch(26, [this.path]).then$1(new P._Link_target_closure(this));
      }, "call$0", "get$target", 0, 0, 338, "target"],
      targetSync$0: [function() {
        P._File__linkTarget(this.path);
      }, "call$0", "get$targetSync", 0, 0, 7, "targetSync"],
      _isErrorResponse$1: [function(response) {
        var t1 = J.getInterceptor(response);
        return !!t1.$isList && !J.$eq$(t1.$index(response, 0), 0);
      }, "call$1", "get$_isErrorResponse", 2, 0, 24, 18, [], "_isErrorResponse"],
      _exceptionFromResponse$3: [function(response, message, path) {
        var t1 = J.getInterceptor$asx(response);
        switch (t1.$index(response, 0)) {
          case 1:
            return new P.ArgumentError(false, null, null, null);
          case 2:
            return new P.FileSystemException(message, path, new P.OSError(t1.$index(response, 2), t1.$index(response, 1)));
          default:
            return new P._Exception("Unknown error");
        }
      }, "call$3", "get$_exceptionFromResponse", 6, 0, 370, 18, [], 17, [], 10, [], "_exceptionFromResponse"],
      _Link$1: function(path) {
        var t1 = this.path;
        if (typeof t1 !== "string")
          throw H.wrapException(P.ArgumentError$(H.S(P.Error_safeToString(t1)) + " is not a String"));
      },
      static: {
        _Link$: [function(path) {
          var t1 = new P._Link(path);
          t1._Link$1(path);
          return t1;
        }, null, null, 2, 0, 13, 10, [], "new _Link"],
        _Link_throwIfError: [function(result, msg, path) {
          if (result instanceof P.OSError)
            throw H.wrapException(new P.FileSystemException(msg, path, result));
        }, function(result, msg) {
          return P._Link_throwIfError(result, msg, "");
        }, "call$3", "call$2", "io__Link_throwIfError$closure", 4, 2, 419, 32, 93, [], 92, [], 10, [], "throwIfError"]
      }
    },
    "+_Link": [115, 1588],
    _Link_create_closure: {
      "^": "Closure:3;_box_0,$this",
      call$1: [function(_) {
        return P._IOService__dispatch(23, [this.$this.path, this._box_0.target]);
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _Link_create_closure": [2],
    _Link_create_closure0: {
      "^": "Closure:3;_box_0,$this",
      call$1: [function(response) {
        var t1 = this.$this;
        if (t1._isErrorResponse$1(response))
          throw H.wrapException(t1._exceptionFromResponse$3(response, "Cannot create link to target '" + H.S(this._box_0.target) + "'", t1.path));
        return t1;
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _Link_create_closure": [2],
    _Link_update_closure: {
      "^": "Closure:3;$this,target",
      call$1: [function(_) {
        return this.$this.create$1(this.target);
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _Link_update_closure": [2],
    _Link__delete_closure: {
      "^": "Closure:3;$this",
      call$1: [function(_) {
        return this.$this;
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _Link__delete_closure": [2],
    _Link__delete_closure0: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        var t1 = this.$this;
        if (t1._isErrorResponse$1(response))
          throw H.wrapException(t1._exceptionFromResponse$3(response, "Cannot delete link", t1.path));
        return t1;
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _Link__delete_closure": [2],
    _Link_rename_closure: {
      "^": "Closure:3;$this,newPath",
      call$1: [function(response) {
        var t1 = this.$this;
        if (t1._isErrorResponse$1(response))
          throw H.wrapException(t1._exceptionFromResponse$3(response, "Cannot rename link to '" + H.S(this.newPath) + "'", t1.path));
        return P._Link$(this.newPath);
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _Link_rename_closure": [2],
    _Link_target_closure: {
      "^": "Closure:3;$this",
      call$1: [function(response) {
        var t1 = this.$this;
        if (t1._isErrorResponse$1(response))
          throw H.wrapException(t1._exceptionFromResponse$3(response, "Cannot get target of link", t1.path));
        return response;
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _Link_target_closure": [2],
    Platform: {
      "^": "Object;",
      static: {
        "^": "Platform__numberOfProcessors<-10,Platform__pathSeparator<-10,Platform__operatingSystem<-10,Platform__localHostname<-10,Platform__version<-10,Platform_isLinux<-8,Platform_isMacOS<-8,Platform_isWindows<-8,Platform_isAndroid<-8,Platform_isIOS<-8,Platform_isFuchsia<-8",
        Platform$: [function() {
          return new P.Platform();
        }, null, null, 0, 0, 928, "new Platform"],
        Platform_numberOfProcessors: [function() {
          return $.$get$Platform__numberOfProcessors();
        }, null, null, 1, 0, 11, "numberOfProcessors"],
        Platform_pathSeparator: [function() {
          return $.$get$Platform__pathSeparator();
        }, null, null, 1, 0, 7, "pathSeparator"],
        Platform_operatingSystem: [function() {
          return $.$get$Platform__operatingSystem();
        }, null, null, 1, 0, 7, "operatingSystem"],
        Platform_localHostname: [function() {
          return $.$get$Platform__localHostname();
        }, null, null, 1, 0, 7, "localHostname"],
        Platform_environment: [function() {
          return P._Platform_environment();
        }, null, null, 1, 0, 106, "environment"],
        Platform_executable: [function() {
          return $.$get$_Platform_executable();
        }, null, null, 1, 0, 7, "executable"],
        Platform_resolvedExecutable: [function() {
          return $.$get$_Platform_resolvedExecutable();
        }, null, null, 1, 0, 7, "resolvedExecutable"],
        Platform_script: [function() {
          return $._Platform_script;
        }, null, null, 1, 0, 43, "script"],
        Platform_executableArguments: [function() {
          return P._Platform_executableArguments();
        }, null, null, 1, 0, 93, "executableArguments"],
        Platform_packageRoot: [function() {
          return $.$get$_Platform_packageRoot();
        }, null, null, 1, 0, 7, "packageRoot"],
        Platform_packageConfig: [function() {
          return $.$get$_Platform_packageConfig();
        }, null, null, 1, 0, 7, "packageConfig"],
        Platform_version: [function() {
          return $.$get$Platform__version();
        }, null, null, 1, 0, 7, "version"]
      }
    },
    "+Platform": [1],
    _Platform: {
      "^": "Object;",
      static: {
        "^": "_Platform_executable@-9,_Platform_resolvedExecutable@-9,_Platform_packageRoot@-9,_Platform_packageConfig@-9,_Platform__environmentCache@-10,_Platform_script@-36",
        _Platform$: [function() {
          return new P._Platform();
        }, null, null, 0, 0, 929, "new _Platform"],
        _Platform__numberOfProcessors: [function() {
          throw H.wrapException(new P.UnsupportedError("Platform._numberOfProcessors"));
        }, "call$0", "io__Platform__numberOfProcessors$closure", 0, 0, 11, "_numberOfProcessors"],
        _Platform__pathSeparator: [function() {
          throw H.wrapException(new P.UnsupportedError("Platform._pathSeparator"));
        }, "call$0", "io__Platform__pathSeparator$closure", 0, 0, 7, "_pathSeparator"],
        _Platform__operatingSystem: [function() {
          throw H.wrapException(new P.UnsupportedError("Platform._operatingSystem"));
        }, "call$0", "io__Platform__operatingSystem$closure", 0, 0, 7, "_operatingSystem"],
        _Platform__localHostname: [function() {
          throw H.wrapException(new P.UnsupportedError("Platform._localHostname"));
        }, "call$0", "io__Platform__localHostname$closure", 0, 0, 4, "_localHostname"],
        _Platform__executable: [function() {
          throw H.wrapException(new P.UnsupportedError("Platform._executable"));
        }, "call$0", "io__Platform__executable$closure", 0, 0, 4, "_executable"],
        _Platform__resolvedExecutable: [function() {
          throw H.wrapException(new P.UnsupportedError("Platform._resolvedExecutable"));
        }, "call$0", "io__Platform__resolvedExecutable$closure", 0, 0, 4, "_resolvedExecutable"],
        _Platform__environment: [function() {
          throw H.wrapException(new P.UnsupportedError("Platform._environment"));
        }, "call$0", "io__Platform__environment$closure", 0, 0, 4, "_environment"],
        _Platform__executableArguments: [function() {
          throw H.wrapException(new P.UnsupportedError("Platform._executableArguments"));
        }, "call$0", "io__Platform__executableArguments$closure", 0, 0, 93, "_executableArguments"],
        _Platform__packageRoot: [function() {
          throw H.wrapException(new P.UnsupportedError("Platform._packageRoot"));
        }, "call$0", "io__Platform__packageRoot$closure", 0, 0, 7, "_packageRoot"],
        _Platform__packageConfig: [function() {
          throw H.wrapException(new P.UnsupportedError("Platform._packageConfig"));
        }, "call$0", "io__Platform__packageConfig$closure", 0, 0, 7, "_packageConfig"],
        _Platform__version: [function() {
          throw H.wrapException(new P.UnsupportedError("Platform._version"));
        }, "call$0", "io__Platform__version$closure", 0, 0, 7, "_version"],
        _Platform_numberOfProcessors: [function() {
          return P._Platform__numberOfProcessors();
        }, null, null, 1, 0, 11, "numberOfProcessors"],
        _Platform_pathSeparator: [function() {
          return P._Platform__pathSeparator();
        }, null, null, 1, 0, 7, "pathSeparator"],
        _Platform_operatingSystem: [function() {
          return P._Platform__operatingSystem();
        }, null, null, 1, 0, 7, "operatingSystem"],
        _Platform_localHostname: [function() {
          P._Platform__localHostname();
        }, null, null, 1, 0, 7, "localHostname"],
        _Platform_executableArguments: [function() {
          return P._Platform__executableArguments();
        }, null, null, 1, 0, 93, "executableArguments"],
        _Platform_environment: [function() {
          var t1 = $._Platform__environmentCache;
          if (t1 == null)
            P._Platform__environment();
          if (t1 instanceof P.OSError)
            throw H.wrapException(t1);
          else
            return t1;
        }, null, null, 1, 0, 106, "environment"],
        _Platform_version: [function() {
          return P._Platform__version();
        }, null, null, 1, 0, 7, "version"]
      }
    },
    "+_Platform": [1],
    _CaseInsensitiveStringMap: {
      "^": "Object;_io$_map<-516,$ti",
      containsKey$1: [function(key) {
        return typeof key === "string" && this._io$_map.containsKey$1(C.JSString_methods.toUpperCase$0(key));
      }, "call$1", "get$containsKey", 2, 0, 15, 6, [], "containsKey"],
      containsValue$1: [function(value) {
        return this._io$_map.containsValue$1(value);
      }, "call$1", "get$containsValue", 2, 0, 15, 1, [], "containsValue"],
      $index: [function(_, key) {
        return typeof key === "string" ? J.$index$asx(this._io$_map, C.JSString_methods.toUpperCase$0(key)) : null;
      }, null, "get$[]", 2, 0, function() {
        return H.computeSignature(function(V) {
          return {func: 1, ret: V, args: [P.Object]};
        }, this.$receiver, "_CaseInsensitiveStringMap");
      }, 6, [], "[]"],
      $indexSet: [function(_, key, value) {
        J.$indexSet$ax(this._io$_map, J.toUpperCase$0$s(key), value);
      }, null, "get$[]=", 4, 0, function() {
        return H.computeSignature(function(V) {
          return {func: 1, v: true, args: [P.String, V]};
        }, this.$receiver, "_CaseInsensitiveStringMap");
      }, 6, [], 1, [], "[]="],
      putIfAbsent$2: [function(key, ifAbsent) {
        return this._io$_map.putIfAbsent$2(J.toUpperCase$0$s(key), ifAbsent);
      }, "call$2", "get$putIfAbsent", 4, 0, function() {
        return H.computeSignature(function(V) {
          return {func: 1, ret: V, args: [P.String, {func: 1, ret: V}]};
        }, this.$receiver, "_CaseInsensitiveStringMap");
      }, 6, [], 85, [], "putIfAbsent"],
      addAll$1: [function(_, other) {
        J.forEach$1$ax(other, new P._CaseInsensitiveStringMap_addAll_closure(this));
      }, "call$1", "get$addAll", 2, 0, function() {
        return H.computeSignature(function(V) {
          return {func: 1, v: true, args: [[P.Map, P.String, V]]};
        }, this.$receiver, "_CaseInsensitiveStringMap");
      }, 2, [], "addAll"],
      remove$1: [function(_, key) {
        return typeof key === "string" ? J.remove$1$ax(this._io$_map, C.JSString_methods.toUpperCase$0(key)) : null;
      }, "call$1", "get$remove", 2, 0, function() {
        return H.computeSignature(function(V) {
          return {func: 1, ret: V, args: [P.Object]};
        }, this.$receiver, "_CaseInsensitiveStringMap");
      }, 6, [], "remove"],
      clear$0: [function(_) {
        J.clear$0$ax(this._io$_map);
      }, "call$0", "get$clear", 0, 0, 6, "clear"],
      forEach$1: [function(_, f) {
        J.forEach$1$ax(this._io$_map, f);
      }, "call$1", "get$forEach", 2, 0, function() {
        return H.computeSignature(function(V) {
          return {func: 1, v: true, args: [{func: 1, v: true, args: [P.String, V]}]};
        }, this.$receiver, "_CaseInsensitiveStringMap");
      }, 9, [], "forEach"],
      get$keys: [function() {
        return this._io$_map.get$keys();
      }, null, null, 1, 0, 371, "keys"],
      get$values: [function() {
        return this._io$_map.get$values();
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(V) {
          return {func: 1, ret: [P.Iterable, V]};
        }, this.$receiver, "_CaseInsensitiveStringMap");
      }, "values"],
      get$length: [function(_) {
        return J.get$length$asx(this._io$_map);
      }, null, null, 1, 0, 11, "length"],
      get$isEmpty: [function(_) {
        return J.get$isEmpty$asx(this._io$_map);
      }, null, null, 1, 0, 5, "isEmpty"],
      get$isNotEmpty: [function(_) {
        return J.get$isNotEmpty$asx(this._io$_map);
      }, null, null, 1, 0, 5, "isNotEmpty"],
      toString$0: [function(_) {
        return J.toString$0$(this._io$_map);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      $isMap: 1,
      $asMap: function($V) {
        return [P.String, $V];
      },
      "<>": [535],
      static: {
        _CaseInsensitiveStringMap$: [function($V) {
          var t1 = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [P.String, $V]);
          return new P._CaseInsensitiveStringMap(t1, [$V]);
        }, null, null, 0, 0, function() {
          return H.computeSignature(function(V) {
            return {func: 1, ret: [P._CaseInsensitiveStringMap, V]};
          }, this.$receiver, "_CaseInsensitiveStringMap");
        }, "new _CaseInsensitiveStringMap"]
      }
    },
    "+_CaseInsensitiveStringMap": [1, 516],
    _CaseInsensitiveStringMap_addAll_closure: {
      "^": "Closure:12;$this",
      call$2: [function(key, value) {
        J.$indexSet$ax(this.$this._io$_map, C.JSString_methods.toUpperCase$0(J.toUpperCase$0$s(key)), value);
        return value;
      }, null, null, 4, 0, 12, 6, [], 1, [], "call"]
    },
    "+ _CaseInsensitiveStringMap_addAll_closure": [2],
    _ProcessUtils: {
      "^": "Object;",
      static: {
        _ProcessUtils$: [function() {
          return new P._ProcessUtils();
        }, null, null, 0, 0, 930, "new _ProcessUtils"],
        _ProcessUtils__exit: [function($status) {
          throw H.wrapException(new P.UnsupportedError("ProcessUtils._exit"));
        }, "call$1", "io__ProcessUtils__exit$closure", 2, 0, 17, 256, [], "_exit"],
        _ProcessUtils__setExitCode: [function($status) {
          throw H.wrapException(new P.UnsupportedError("ProcessUtils._setExitCode"));
        }, "call$1", "io__ProcessUtils__setExitCode$closure", 2, 0, 17, 256, [], "_setExitCode"],
        _ProcessUtils__getExitCode: [function() {
          throw H.wrapException(new P.UnsupportedError("ProcessUtils._getExitCode"));
        }, "call$0", "io__ProcessUtils__getExitCode$closure", 0, 0, 11, "_getExitCode"],
        _ProcessUtils__sleep: [function(millis) {
          throw H.wrapException(new P.UnsupportedError("ProcessUtils._sleep"));
        }, "call$1", "io__ProcessUtils__sleep$closure", 2, 0, 17, 371, [], "_sleep"],
        _ProcessUtils__pid: [function(process) {
          throw H.wrapException(new P.UnsupportedError("ProcessUtils._pid"));
        }, "call$1", "io__ProcessUtils__pid$closure", 2, 0, 931, 477, [], "_pid"],
        _ProcessUtils__watchSignal: [function(signal) {
          throw H.wrapException(new P.UnsupportedError("ProcessUtils._watchSignal"));
        }, "call$1", "io__ProcessUtils__watchSignal$closure", 2, 0, 932, 482, [], "_watchSignal"]
      }
    },
    "+_ProcessUtils": [1],
    ProcessStartMode: {
      "^": "Object;index<-0,_io$_name<-9",
      toString$0: [function(_) {
        return this._io$_name;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        "^": "ProcessStartMode_NORMAL<-289,ProcessStartMode_DETACHED<-289,ProcessStartMode_DETACHED_WITH_STDIO<-289,ProcessStartMode_values<-1591",
        ProcessStartMode$: [function(index, _name) {
          return new P.ProcessStartMode(index, _name);
        }, null, null, 4, 0, 148, 14, [], 281, [], "new ProcessStartMode"]
      }
    },
    "+ProcessStartMode": [1],
    Process: {
      "^": "Object;",
      static: {
        Process$: [function() {
          return new P.Process();
        }, null, null, 0, 0, 933, "new Process"],
        Process_start: [function(executable, $arguments, environment, includeParentEnvironment, mode, runInShell, workingDirectory) {
          throw H.wrapException(new P.UnsupportedError("Process.start"));
        }, function(executable, $arguments) {
          return P.Process_start(executable, $arguments, null, true, C.ProcessStartMode_0, false, null);
        }, "call$7$environment$includeParentEnvironment$mode$runInShell$workingDirectory", "call$2", "io_Process_start$closure", 4, 11, 934, 0, 0, 25, 4, 801, 255, [], 69, [], 345, [], 155, [], 344, [], 343, [], 70, [], "start"],
        Process_run: [function(executable, $arguments, environment, includeParentEnvironment, runInShell, stderrEncoding, stdoutEncoding, workingDirectory) {
          throw H.wrapException(new P.UnsupportedError("Process.run"));
        }, function(executable, $arguments) {
          return P.Process_run(executable, $arguments, null, true, false, C.C_SystemEncoding, C.C_SystemEncoding, null);
        }, "call$8$environment$includeParentEnvironment$runInShell$stderrEncoding$stdoutEncoding$workingDirectory", "call$2", "io_Process_run$closure", 4, 13, 935, 0, 0, 25, 4, 201, 201, 255, [], 69, [], 345, [], 155, [], 344, [], 343, [], 513, [], 518, [], "run"],
        Process_runSync: [function(executable, $arguments, environment, includeParentEnvironment, runInShell, stderrEncoding, stdoutEncoding, workingDirectory) {
          throw H.wrapException(new P.UnsupportedError("Process.runSync"));
        }, function(executable, $arguments) {
          return P.Process_runSync(executable, $arguments, null, true, false, C.C_SystemEncoding, C.C_SystemEncoding, null);
        }, "call$8$environment$includeParentEnvironment$runInShell$stderrEncoding$stdoutEncoding$workingDirectory", "call$2", "io_Process_runSync$closure", 4, 13, 936, 0, 0, 25, 4, 201, 201, 255, [], 69, [], 345, [], 155, [], 344, [], 343, [], 513, [], 518, [], "runSync"],
        Process_killPid: [function(pid, signal) {
          throw H.wrapException(new P.UnsupportedError("Process.killPid"));
        }, function(pid) {
          return P.Process_killPid(pid, C.ProcessSignal_15_SIGTERM);
        }, "call$2", "call$1", "io_Process_killPid$closure", 2, 2, 937, 809, 521, [], 482, [], "killPid"]
      }
    },
    "+Process": [1],
    ProcessResult: {
      "^": "Object;exitCode<-0,stdout<-10,stderr<-10,pid<-0",
      static: {
        ProcessResult$: [function(pid, exitCode, stdout, stderr) {
          return new P.ProcessResult(exitCode, stdout, stderr, pid);
        }, null, null, 8, 0, 938, 521, [], 811, [], 812, [], 813, [], "new ProcessResult"]
      }
    },
    "+ProcessResult": [1],
    ProcessSignal: {
      "^": "Object;_signalNumber<-0,_io$_name<-9",
      toString$0: [function(_) {
        return this._io$_name;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      watch$0: [function() {
        return P._ProcessUtils__watchSignal(this);
      }, "call$0", "get$watch", 0, 0, 1501, "watch"],
      static: {
        "^": "ProcessSignal_SIGHUP<-21,ProcessSignal_SIGINT<-21,ProcessSignal_SIGQUIT<-21,ProcessSignal_SIGILL<-21,ProcessSignal_SIGTRAP<-21,ProcessSignal_SIGABRT<-21,ProcessSignal_SIGBUS<-21,ProcessSignal_SIGFPE<-21,ProcessSignal_SIGKILL<-21,ProcessSignal_SIGUSR1<-21,ProcessSignal_SIGSEGV<-21,ProcessSignal_SIGUSR2<-21,ProcessSignal_SIGPIPE<-21,ProcessSignal_SIGALRM<-21,ProcessSignal_SIGTERM<-21,ProcessSignal_SIGCHLD<-21,ProcessSignal_SIGCONT<-21,ProcessSignal_SIGSTOP<-21,ProcessSignal_SIGTSTP<-21,ProcessSignal_SIGTTIN<-21,ProcessSignal_SIGTTOU<-21,ProcessSignal_SIGURG<-21,ProcessSignal_SIGXCPU<-21,ProcessSignal_SIGXFSZ<-21,ProcessSignal_SIGVTALRM<-21,ProcessSignal_SIGPROF<-21,ProcessSignal_SIGWINCH<-21,ProcessSignal_SIGPOLL<-21,ProcessSignal_SIGSYS<-21",
        ProcessSignal$_: [function(_signalNumber, _name) {
          return new P.ProcessSignal(_signalNumber, _name);
        }, null, null, 4, 0, 148, 814, [], 281, [], "new ProcessSignal$_"]
      }
    },
    "+ProcessSignal": [1],
    SignalException: {
      "^": "Object;message<-9,osError<-10",
      toString$0: [function(_) {
        var t1, msg;
        t1 = this.osError;
        msg = t1 != null ? ", osError: " + H.S(t1) : "";
        return "SignalException: " + H.S(this.message) + msg;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isException: 1,
      static: {
        SignalException$: [function(message, osError) {
          return new P.SignalException(message, osError);
        }, null, null, 2, 2, 939, 0, 17, [], 108, [], "new SignalException"]
      }
    },
    "+SignalException": [1, 74],
    ProcessException: {
      "^": "Object;executable<-9,$arguments<-61,message<-9,errorCode<-0",
      toString$0: [function(_) {
        var msg, args;
        msg = this.message;
        if (msg == null)
          msg = "OS error code: " + H.S(this.errorCode);
        args = J.join$1$ax(this.$arguments, " ");
        return "ProcessException: " + H.S(msg) + "\n  Command: " + H.S(this.executable) + " " + H.S(args);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isException: 1,
      static: {
        ProcessException$: [function(executable, $arguments, message, errorCode) {
          return new P.ProcessException(executable, $arguments, message, errorCode);
        }, null, null, 4, 4, 940, 32, 7, 255, [], 69, [], 17, [], 160, [], "new ProcessException"]
      }
    },
    "+ProcessException": [1, 74],
    SecureServerSocket: {
      "^": "Stream;_socket<-1593",
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        return J.map$1$ax(this._socket, new P.SecureServerSocket_listen_closure()).listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, onError);
      }, "listen$2$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, null);
      }, "listen$2$onDone", function(onData, cancelOnError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, null, null);
      }, "listen$2$cancelOnError", "call$4$cancelOnError$onDone$onError", "call$1", "call$2$onError", "call$3$onDone$onError", "call$3$onDone$onError", "call$2$onDone", "call$2$cancelOnError", "get$listen", 2, 7, 1502, 0, 0, 0, 27, [], 20, [], 28, [], 24, [], "listen"],
      get$port: [function() {
        return this._socket.get$port();
      }, null, null, 1, 0, 11, "port"],
      get$address: [function() {
        return this._socket.get$address();
      }, null, null, 1, 0, 68, "address"],
      close$0: [function() {
        return this._socket.close$0().then$1(new P.SecureServerSocket_close_closure(this));
      }, "call$0", "get$close", 0, 0, 1505, "close"],
      set$_io$_owner: [function(owner) {
        this._socket.set$_io$_owner(owner);
      }, null, null, 3, 0, 27, 294, [], "_io$_owner"],
      $asStream: function() {
        return [P.SecureSocket];
      },
      "<>": [],
      static: {
        SecureServerSocket$_: [function(_socket) {
          return new P.SecureServerSocket(_socket);
        }, null, null, 2, 0, 941, 148, [], "new SecureServerSocket$_"],
        SecureServerSocket_bind: [function(address, port, context, backlog, requestClientCertificate, requireClientCertificate, shared, supportedProtocols, v6Only) {
          return P.RawSecureServerSocket_bind(address, port, context, backlog, requestClientCertificate, requireClientCertificate, shared, supportedProtocols, v6Only).then$1(new P.SecureServerSocket_bind_closure());
        }, function(address, port, context) {
          return P.SecureServerSocket_bind(address, port, context, 0, false, false, false, null, false);
        }, "call$9$backlog$requestClientCertificate$requireClientCertificate$shared$supportedProtocols$v6Only", "call$3", "io_SecureServerSocket_bind$closure", 6, 13, 942, 7, 4, 4, 4, 0, 4, 81, [], 26, [], 76, [], 124, [], 121, [], 97, [], 114, [], 105, [], 128, [], "bind"]
      }
    },
    "+SecureServerSocket": [1594],
    SecureServerSocket_bind_closure: {
      "^": "Closure:3;",
      call$1: [function(serverSocket) {
        return new P.SecureServerSocket(serverSocket);
      }, null, null, 2, 0, 3, 423, [], "call"]
    },
    "+ SecureServerSocket_bind_closure": [2],
    SecureServerSocket_listen_closure: {
      "^": "Closure:3;",
      call$1: [function(rawSocket) {
        return P.SecureSocket_SecureSocket$_(rawSocket);
      }, null, null, 2, 0, 3, 327, [], "call"]
    },
    "+ SecureServerSocket_listen_closure": [2],
    SecureServerSocket_close_closure: {
      "^": "Closure:3;$this",
      call$1: [function(_) {
        return this.$this;
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ SecureServerSocket_close_closure": [2],
    RawSecureServerSocket: {
      "^": "Stream;_socket<-1595,_io$_controller@-1596,_io$_subscription@-1597,_context<-138,requestClientCertificate<-8,requireClientCertificate<-8,supportedProtocols<-61,_closed@-8",
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        return this._io$_controller.get$stream().listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, onError);
      }, "listen$2$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, null);
      }, "listen$2$onDone", function(onData, cancelOnError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, null, null);
      }, "listen$2$cancelOnError", "call$4$cancelOnError$onDone$onError", "call$1", "call$2$onError", "call$3$onDone$onError", "call$3$onDone$onError", "call$2$onDone", "call$2$cancelOnError", "get$listen", 2, 7, 1507, 0, 0, 0, 27, [], 20, [], 28, [], 24, [], "listen"],
      get$port: [function() {
        return this._socket.get$port();
      }, null, null, 1, 0, 11, "port"],
      get$address: [function() {
        return this._socket.get$address();
      }, null, null, 1, 0, 68, "address"],
      close$0: [function() {
        this._closed = true;
        return this._socket.close$0().then$1(new P.RawSecureServerSocket_close_closure(this));
      }, "call$0", "get$close", 0, 0, 1509, "close"],
      _io$_onData$1: [function(connection) {
        var remotePort, exception;
        remotePort = null;
        try {
          remotePort = connection.get$remotePort();
        } catch (exception) {
          H.unwrapException(exception);
          return;
        }
        P._RawSecureSocket_connect(connection.get$address(), remotePort, null, this._context, true, null, this.requestClientCertificate, this.requireClientCertificate, connection, null, this.supportedProtocols).then$1(new P.RawSecureServerSocket__onData_closure(this)).catchError$1(new P.RawSecureServerSocket__onData_closure0(this));
      }, "call$1", "get$_io$_onData", 2, 0, 1510, 99, [], "_io$_onData"],
      _onPauseStateChange$0: [function() {
        var t1, t2;
        t1 = this._io$_controller.get$isPaused();
        t2 = this._io$_subscription;
        if (t1)
          t2.pause$0();
        else
          t2.resume$0();
      }, "call$0", "get$_onPauseStateChange", 0, 0, 6, "_onPauseStateChange"],
      _onSubscriptionStateChange$0: [function() {
        if (this._io$_controller.get$hasListener()) {
          var t1 = this._io$_controller.get$addError();
          this._io$_subscription = this._socket.listen$3$onDone$onError(this.get$_io$_onData(), this._io$_controller.get$close(), t1);
        } else
          this.close$0();
      }, "call$0", "get$_onSubscriptionStateChange", 0, 0, 6, "_onSubscriptionStateChange"],
      set$_io$_owner: [function(owner) {
        this._socket.set$_io$_owner(owner);
      }, null, null, 3, 0, 27, 294, [], "_io$_owner"],
      $asStream: function() {
        return [P.RawSecureSocket];
      },
      "<>": [],
      static: {
        RawSecureServerSocket$_: [function(_socket, _context, requestClientCertificate, requireClientCertificate, supportedProtocols) {
          var t1, t2, t3;
          t1 = new P.RawSecureServerSocket(_socket, null, null, _context, requestClientCertificate, requireClientCertificate, supportedProtocols, false);
          t2 = t1.get$_onSubscriptionStateChange();
          t3 = t1.get$_onPauseStateChange();
          t1._io$_controller = new P._SyncStreamController(null, 0, null, t2, t3, t3, t2, [P.RawSecureSocket]);
          return t1;
        }, null, null, 10, 0, 943, 148, [], 418, [], 97, [], 114, [], 105, [], "new RawSecureServerSocket$_"],
        RawSecureServerSocket_bind: [function(address, port, context, backlog, requestClientCertificate, requireClientCertificate, shared, supportedProtocols, v6Only) {
          return P.RawServerSocket_bind(address, port, backlog, shared, v6Only).then$1(new P.RawSecureServerSocket_bind_closure(context, requestClientCertificate, requireClientCertificate, supportedProtocols));
        }, function(address, port, context) {
          return P.RawSecureServerSocket_bind(address, port, context, 0, false, false, false, null, false);
        }, "call$9$backlog$requestClientCertificate$requireClientCertificate$shared$supportedProtocols$v6Only", "call$3", "io_RawSecureServerSocket_bind$closure", 6, 13, 944, 7, 4, 4, 4, 0, 4, 81, [], 26, [], 76, [], 124, [], 121, [], 97, [], 114, [], 105, [], 128, [], "bind"]
      }
    },
    "+RawSecureServerSocket": [1598],
    RawSecureServerSocket_bind_closure: {
      "^": "Closure:3;context,requestClientCertificate,requireClientCertificate,supportedProtocols",
      call$1: [function(serverSocket) {
        var t1, t2, t3;
        t1 = new P.RawSecureServerSocket(serverSocket, null, null, this.context, this.requestClientCertificate, this.requireClientCertificate, this.supportedProtocols, false);
        t2 = t1.get$_onSubscriptionStateChange();
        t3 = t1.get$_onPauseStateChange();
        t1._io$_controller = new P._SyncStreamController(null, 0, null, t2, t3, t3, t2, [P.RawSecureSocket]);
        return t1;
      }, null, null, 2, 0, 3, 423, [], "call"]
    },
    "+ RawSecureServerSocket_bind_closure": [2],
    RawSecureServerSocket_close_closure: {
      "^": "Closure:3;$this",
      call$1: [function(_) {
        return this.$this;
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ RawSecureServerSocket_close_closure": [2],
    RawSecureServerSocket__onData_closure: {
      "^": "Closure:372;$this",
      call$1: [function(secureConnection) {
        var t1 = this.$this;
        if (t1._closed === true)
          secureConnection.close$0();
        else
          J.add$1$ax(t1._io$_controller, secureConnection);
      }, null, null, 2, 0, 372, 910, [], "call"]
    },
    "+ RawSecureServerSocket__onData_closure": [2],
    RawSecureServerSocket__onData_closure0: {
      "^": "Closure:12;$this",
      call$2: [function(e, s) {
        var t1 = this.$this;
        if (t1._closed !== true)
          t1._io$_controller.addError$2(e, s);
      }, null, null, 4, 0, 12, 47, [], 49, [], "call"]
    },
    "+ RawSecureServerSocket__onData_closure": [2],
    SecureSocket: {
      "^": "Object;",
      selectedProtocol$0: function() {
        return this.get$selectedProtocol().call$0();
      },
      $isSocket: 1,
      $isStream: 1,
      $asStream: function() {
        return [[P.List, P.int]];
      },
      $isEventSink: 1,
      $asEventSink: function() {
        return [[P.List, P.int]];
      },
      static: {
        SecureSocket_SecureSocket$_: [function(rawSocket) {
          throw H.wrapException(new P.UnsupportedError("SecureSocket constructor"));
        }, null, null, 2, 0, 945, 327, [], "new SecureSocket$_"],
        SecureSocket_connect: [function(host, port, context, onBadCertificate, supportedProtocols) {
          return P.RawSecureSocket_connect(host, port, context, onBadCertificate, supportedProtocols).then$1(new P.SecureSocket_connect_closure());
        }, function(host, port) {
          return P.SecureSocket_connect(host, port, null, null, null);
        }, "call$5$context$onBadCertificate$supportedProtocols", "call$2", "io_SecureSocket_connect$closure", 4, 7, 946, 0, 0, 0, 29, [], 26, [], 76, [], 134, [], 105, [], "connect"],
        SecureSocket_secure: [function(socket, context, host, onBadCertificate) {
          return socket._detachRaw$0().then$1(new P.SecureSocket_secure_closure(host, context, onBadCertificate)).then$1(new P.SecureSocket_secure_closure0());
        }, function(socket) {
          return P.SecureSocket_secure(socket, null, null, null);
        }, "call$4$context$host$onBadCertificate", "call$1", "io_SecureSocket_secure$closure", 2, 7, 947, 0, 0, 0, 52, [], 29, [], 76, [], 134, [], "secure"],
        SecureSocket_secureServer: [function(socket, context, bufferedData, requestClientCertificate, requireClientCertificate, supportedProtocols) {
          return socket._detachRaw$0().then$1(new P.SecureSocket_secureServer_closure(context, bufferedData, requestClientCertificate, requireClientCertificate, supportedProtocols)).then$1(new P.SecureSocket_secureServer_closure0());
        }, function(socket, context) {
          return P.SecureSocket_secureServer(socket, context, null, false, false, null);
        }, "call$6$bufferedData$requestClientCertificate$requireClientCertificate$supportedProtocols", "call$2", "io_SecureSocket_secureServer$closure", 4, 9, 948, 0, 4, 4, 0, 52, [], 76, [], 262, [], 97, [], 114, [], 105, [], "secureServer"]
      }
    },
    "+SecureSocket": [1, 127],
    SecureSocket_connect_closure: {
      "^": "Closure:3;",
      call$1: [function(rawSocket) {
        return P.SecureSocket_SecureSocket$_(rawSocket);
      }, null, null, 2, 0, 3, 327, [], "call"]
    },
    "+ SecureSocket_connect_closure": [2],
    SecureSocket_secure_closure: {
      "^": "Closure:3;host,context,onBadCertificate",
      call$1: [function(detachedRaw) {
        return P.RawSecureSocket_secure(detachedRaw.$index(0, 0), this.context, this.host, this.onBadCertificate, H.subtypeCast(detachedRaw.$index(0, 1), "$isStreamSubscription", [P.RawSocketEvent], "$asStreamSubscription"), null);
      }, null, null, 2, 0, 3, 492, [], "call"]
    },
    "+ SecureSocket_secure_closure": [2],
    SecureSocket_secure_closure0: {
      "^": "Closure:3;",
      call$1: [function(raw) {
        return P.SecureSocket_SecureSocket$_(raw);
      }, null, null, 2, 0, 3, 100, [], "call"]
    },
    "+ SecureSocket_secure_closure": [2],
    SecureSocket_secureServer_closure: {
      "^": "Closure:3;context,bufferedData,requestClientCertificate,requireClientCertificate,supportedProtocols",
      call$1: [function(detachedRaw) {
        var t1, t2;
        t1 = detachedRaw.$index(0, 0);
        t2 = H.subtypeCast(detachedRaw.$index(0, 1), "$isStreamSubscription", [P.RawSocketEvent], "$asStreamSubscription");
        t1.set$readEventsEnabled(false);
        t1.set$writeEventsEnabled(false);
        return P._RawSecureSocket_connect(t1.get$address(), t1.get$remotePort(), this.bufferedData, this.context, true, null, this.requestClientCertificate, this.requireClientCertificate, t1, t2, this.supportedProtocols);
      }, null, null, 2, 0, 3, 492, [], "call"]
    },
    "+ SecureSocket_secureServer_closure": [2],
    SecureSocket_secureServer_closure0: {
      "^": "Closure:3;",
      call$1: [function(raw) {
        return P.SecureSocket_SecureSocket$_(raw);
      }, null, null, 2, 0, 3, 100, [], "call"]
    },
    "+ SecureSocket_secureServer_closure": [2],
    RawSecureSocket: {
      "^": "Object;",
      selectedProtocol$0: function() {
        return this.get$selectedProtocol().call$0();
      },
      $isRawSocket: 1,
      $isStream: 1,
      $asStream: function() {
        return [P.RawSocketEvent];
      },
      static: {
        RawSecureSocket$: [function() {
          return new P.RawSecureSocket();
        }, null, null, 0, 0, 949, "new RawSecureSocket"],
        RawSecureSocket_connect: [function(host, port, context, onBadCertificate, supportedProtocols) {
          P._RawSecureSocket__verifyFields(host, port, false, false, false, onBadCertificate);
          return P.RawSocket_connect(host, port, null).then$1(new P.RawSecureSocket_connect_closure(context, onBadCertificate, supportedProtocols));
        }, function(host, port) {
          return P.RawSecureSocket_connect(host, port, null, null, null);
        }, "call$5$context$onBadCertificate$supportedProtocols", "call$2", "io_RawSecureSocket_connect$closure", 4, 7, 950, 0, 0, 0, 29, [], 26, [], 76, [], 134, [], 105, [], "connect"],
        RawSecureSocket_secure: [function(socket, context, host, onBadCertificate, subscription, supportedProtocols) {
          var t1;
          socket.set$readEventsEnabled(false);
          socket.set$writeEventsEnabled(false);
          t1 = host != null ? host : socket.get$address().get$host();
          return P._RawSecureSocket_connect(t1, socket.get$port(), null, context, false, onBadCertificate, false, false, socket, subscription, supportedProtocols);
        }, function(socket) {
          return P.RawSecureSocket_secure(socket, null, null, null, null, null);
        }, "call$6$context$host$onBadCertificate$subscription$supportedProtocols", "call$1", "io_RawSecureSocket_secure$closure", 2, 11, 951, 0, 0, 0, 0, 0, 52, [], 50, [], 29, [], 76, [], 134, [], 105, [], "secure"],
        RawSecureSocket_secureServer: [function(socket, context, bufferedData, requestClientCertificate, requireClientCertificate, subscription, supportedProtocols) {
          socket.set$readEventsEnabled(false);
          socket.set$writeEventsEnabled(false);
          return P._RawSecureSocket_connect(socket.get$address(), socket.get$remotePort(), bufferedData, context, true, null, requestClientCertificate, requireClientCertificate, socket, subscription, supportedProtocols);
        }, function(socket, context) {
          return P.RawSecureSocket_secureServer(socket, context, null, false, false, null, null);
        }, "call$7$bufferedData$requestClientCertificate$requireClientCertificate$subscription$supportedProtocols", "call$2", "io_RawSecureSocket_secureServer$closure", 4, 11, 952, 0, 0, 4, 4, 0, 52, [], 76, [], 50, [], 262, [], 97, [], 114, [], 105, [], "secureServer"]
      }
    },
    "+RawSecureSocket": [1, 518],
    RawSecureSocket_connect_closure: {
      "^": "Closure:3;context,onBadCertificate,supportedProtocols",
      call$1: [function(socket) {
        return P.RawSecureSocket_secure(socket, this.context, null, this.onBadCertificate, null, this.supportedProtocols);
      }, null, null, 2, 0, 3, 52, [], "call"]
    },
    "+ RawSecureSocket_connect_closure": [2],
    X509Certificate: {
      "^": "Object;",
      static: {
        X509Certificate_X509Certificate$_: [function() {
          throw H.wrapException(new P.UnsupportedError("X509Certificate constructor"));
        }, null, null, 0, 0, 233, "new X509Certificate$_"]
      }
    },
    "+X509Certificate": [1],
    _FilterStatus: {
      "^": "Object;progress@-8,readEmpty@-8,writeEmpty@-8,readPlaintextNoLongerEmpty@-8,writePlaintextNoLongerFull@-8,readEncryptedNoLongerFull@-8,writeEncryptedNoLongerEmpty@-8",
      static: {
        _FilterStatus$: [function() {
          return new P._FilterStatus(false, true, true, false, false, false, false);
        }, null, null, 0, 0, 4, "new _FilterStatus"]
      }
    },
    "+_FilterStatus": [1],
    _RawSecureSocket: {
      "^": "Stream;_socket@-518,_handshakeComplete<-1600,_io$_controller@-1601,_io$_stream@-223,_socketSubscription@-1603,_bufferedData@-14,_bufferedDataIndex@-0,address<-186,is_server<-8,context@-138,requestClientCertificate<-8,requireClientCertificate<-8,onBadCertificate<-29,_status@-10,_writeEventsEnabled@-8,_readEventsEnabled@-8,_pauseCount@-0,_pendingReadEvent@-8,_socketClosedRead@-8,_socketClosedWrite@-8,_closedRead@-8,_closedWrite@-8,_closeCompleter@-1604,_filterStatus@-1605,_connectPending@-8,_filterPending@-8,_filterActive@-8,_secureFilter@-1606,_selectedProtocol@-9",
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        this._sendWriteEvent$0();
        return this._io$_stream.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, onError);
      }, "listen$2$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, null);
      }, "listen$2$onDone", function(onData, cancelOnError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, null, null);
      }, "listen$2$cancelOnError", "call$4$cancelOnError$onDone$onError", "call$1", "call$2$onError", "call$3$onDone$onError", "call$3$onDone$onError", "call$2$onDone", "call$2$cancelOnError", "get$listen", 2, 7, 1513, 0, 0, 0, 27, [], 20, [], 28, [], 24, [], "listen"],
      get$port: [function() {
        return this._socket.get$port();
      }, null, null, 1, 0, 11, "port"],
      get$remoteAddress: [function() {
        return this._socket.get$remoteAddress();
      }, null, null, 1, 0, 68, "remoteAddress"],
      get$remotePort: [function() {
        return this._socket.get$remotePort();
      }, null, null, 1, 0, 11, "remotePort"],
      set$_io$_owner: [function(owner) {
        this._socket.set$_io$_owner(owner);
      }, null, null, 3, 0, 27, 294, [], "_io$_owner"],
      available$0: [function() {
        if (!J.$eq$(this._status, 202))
          var t1 = 0;
        else {
          t1 = this._secureFilter.get$buffers().$index(0, 0);
          t1 = t1.get$length(t1);
        }
        return t1;
      }, "call$0", "get$available", 0, 0, 11, "available"],
      close$0: [function() {
        this.shutdown$1(C.SocketDirection_2);
        return this._closeCompleter.get$future();
      }, "call$0", "get$close", 0, 0, 1515, "close"],
      _completeCloseCompleter$1: [function(dummy) {
        if (!this._closeCompleter.get$isCompleted())
          this._closeCompleter.complete$1(this);
      }, function() {
        return this._completeCloseCompleter$1(null);
      }, "_completeCloseCompleter$0", "call$1", "call$0", "get$_completeCloseCompleter", 0, 2, 1521, 0, 912, [], "_completeCloseCompleter"],
      _io$_close$0: [function() {
        this._closedWrite = true;
        this._closedRead = true;
        var t1 = this._socket;
        if (t1 != null)
          t1.close$0().then$1(this.get$_completeCloseCompleter());
        else if (!this._closeCompleter.get$isCompleted())
          this._closeCompleter.complete$1(this);
        this._socketClosedWrite = true;
        this._socketClosedRead = true;
        if (this._filterActive !== true && this._secureFilter != null) {
          this._secureFilter.destroy$0();
          this._secureFilter = null;
        }
        t1 = this._socketSubscription;
        if (t1 != null)
          t1.cancel$0();
        this._io$_controller.close$0();
        this._status = 203;
      }, "call$0", "get$_io$_close", 0, 0, 6, "_io$_close"],
      shutdown$1: [function(direction) {
        var t1 = J.getInterceptor(direction);
        if (t1.$eq(direction, C.SocketDirection_1) || t1.$eq(direction, C.SocketDirection_2)) {
          this._closedWrite = true;
          if (this._filterStatus.get$writeEmpty() === true) {
            this._socket.shutdown$1(C.SocketDirection_1);
            this._socketClosedWrite = true;
            if (this._closedRead === true)
              this._io$_close$0();
          }
        }
        if (t1.$eq(direction, C.SocketDirection_0) || t1.$eq(direction, C.SocketDirection_2)) {
          this._closedRead = true;
          this._socketClosedRead = true;
          this._socket.shutdown$1(C.SocketDirection_0);
          if (this._socketClosedWrite === true)
            this._io$_close$0();
        }
      }, "call$1", "get$shutdown", 2, 0, 1522, 913, [], "shutdown"],
      get$writeEventsEnabled: [function() {
        return this._writeEventsEnabled;
      }, null, null, 1, 0, 5, "writeEventsEnabled"],
      set$writeEventsEnabled: [function(value) {
        this._writeEventsEnabled = value;
        if (value === true)
          P.Timer_Timer(C.Duration_0, new P._RawSecureSocket_writeEventsEnabled_closure(this));
      }, null, null, 3, 0, 35, 1, [], "writeEventsEnabled"],
      get$readEventsEnabled: [function() {
        return this._readEventsEnabled;
      }, null, null, 1, 0, 5, "readEventsEnabled"],
      set$readEventsEnabled: [function(value) {
        this._readEventsEnabled = value;
        this._scheduleReadEvent$0();
      }, null, null, 3, 0, 35, 1, [], "readEventsEnabled"],
      read$1: [function($length) {
        var t1, result;
        if ($length != null)
          t1 = typeof $length !== "number" || Math.floor($length) !== $length || $length < 0;
        else
          t1 = false;
        if (t1)
          throw H.wrapException(P.ArgumentError$("Invalid length parameter in SecureSocket.read (length: " + H.S($length) + ")"));
        if (this._closedRead === true)
          throw H.wrapException(new P.SocketException("Reading from a closed socket", null, null, null));
        if (!J.$eq$(this._status, 202))
          return;
        result = this._secureFilter.get$buffers().$index(0, 0).read$1($length);
        this._filterPending = true;
        this._tryFilter$0();
        return result;
      }, function() {
        return this.read$1(null);
      }, "read$0", "call$1", "call$0", "get$read", 0, 2, 1525, 0, 15, [], "read"],
      write$3: [function(data, offset, bytes) {
        var t1, t2, t3, written;
        t1 = bytes == null;
        if (!t1)
          t2 = typeof bytes !== "number" || Math.floor(bytes) !== bytes || bytes < 0;
        else
          t2 = false;
        if (t2)
          throw H.wrapException(P.ArgumentError$("Invalid bytes parameter in SecureSocket.read (bytes: " + H.S(bytes) + ")"));
        t2 = offset == null;
        if (!t2)
          t3 = typeof offset !== "number" || Math.floor(offset) !== offset || offset < 0;
        else
          t3 = false;
        if (t3)
          throw H.wrapException(P.ArgumentError$("Invalid offset parameter in SecureSocket.read (offset: " + H.S(offset) + ")"));
        if (this._closedWrite === true) {
          this._io$_controller.addError$1(new P.SocketException("Writing to a closed socket", null, null, null));
          return 0;
        }
        if (!J.$eq$(this._status, 202))
          return 0;
        if (t2)
          offset = 0;
        if (t1)
          bytes = J.$sub$n(J.get$length$asx(data), offset);
        written = this._secureFilter.get$buffers().$index(0, 1).write$3(data, offset, bytes);
        if (written.$gt(0, 0))
          this._filterStatus.set$writeEmpty(false);
        this._filterPending = true;
        this._tryFilter$0();
        return written;
      }, function(data) {
        return this.write$3(data, null, null);
      }, "write$1", function(data, offset) {
        return this.write$3(data, offset, null);
      }, "write$2", "call$3", "call$1", "call$2", "get$write", 2, 4, 336, 0, 0, 21, [], 220, [], 30, [], "write"],
      get$peerCertificate: [function() {
        return this._secureFilter.get$peerCertificate();
      }, null, null, 1, 0, 233, "peerCertificate"],
      get$selectedProtocol: [function() {
        return this._selectedProtocol;
      }, null, null, 1, 0, 7, "selectedProtocol"],
      _onBadCertificateWrapper$1: [function(certificate) {
        var t1, result;
        t1 = this.onBadCertificate;
        if (t1 == null)
          return false;
        result = t1.call$1(certificate);
        if (typeof result === "boolean")
          return result;
        throw H.wrapException(P.HandshakeException$("onBadCertificate callback returned non-boolean " + H.S(result), null));
      }, "call$1", "get$_onBadCertificateWrapper", 2, 0, 263, 486, [], "_onBadCertificateWrapper"],
      setOption$2: [function(option, enabled) {
        var t1 = this._socket;
        if (t1 == null)
          return false;
        t1.setOption$2(option, enabled);
        return false;
      }, "call$2", "get$setOption", 4, 0, 362, 66, [], 189, [], "setOption"],
      _eventDispatcher$1: [function($event) {
        var e, stackTrace, t1, exception;
        try {
          t1 = J.getInterceptor($event);
          if (t1.$eq($event, C.RawSocketEvent_0)) {
            this._readSocket$0();
            this._filterPending = true;
            this._tryFilter$0();
          } else if (t1.$eq($event, C.RawSocketEvent_1)) {
            this._writeSocket$0();
            this._filterPending = true;
            this._tryFilter$0();
          } else if (t1.$eq($event, C.RawSocketEvent_2))
            this._closeHandler$0();
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          stackTrace = H.getTraceFromException(exception);
          this._reportError$2(e, stackTrace);
        }
      }, "call$1", "get$_eventDispatcher", 2, 0, 1527, 110, [], "_eventDispatcher"],
      _readHandler$0: [function() {
        this._readSocket$0();
        this._filterPending = true;
        this._tryFilter$0();
      }, "call$0", "get$_readHandler", 0, 0, 6, "_readHandler"],
      _writeHandler$0: [function() {
        this._writeSocket$0();
        this._filterPending = true;
        this._tryFilter$0();
      }, "call$0", "get$_writeHandler", 0, 0, 6, "_writeHandler"],
      _doneHandler$0: [function() {
        if (this._filterStatus.get$readEmpty() === true)
          this._io$_close$0();
      }, "call$0", "get$_doneHandler", 0, 0, 6, "_doneHandler"],
      _reportError$2: [function(e, stackTrace) {
        if (J.$eq$(this._status, 203))
          return;
        else if (this._connectPending === true)
          this._handshakeComplete.completeError$2(e, stackTrace);
        else
          this._io$_controller.addError$2(e, stackTrace);
        this._io$_close$0();
      }, function(e) {
        return this._reportError$2(e, null);
      }, "_reportError$1", "call$2", "call$1", "get$_reportError", 2, 2, 81, 0, 47, [], 12, [], "_reportError"],
      _closeHandler$0: [function() {
        if (J.$eq$(this._status, 202)) {
          if (this._closedRead === true)
            return;
          this._socketClosedRead = true;
          if (this._filterStatus.get$readEmpty() === true) {
            this._closedRead = true;
            J.add$1$ax(this._io$_controller, C.RawSocketEvent_2);
            if (this._socketClosedWrite === true)
              this._io$_close$0();
          } else {
            this._filterPending = true;
            this._tryFilter$0();
          }
        } else if (J.$eq$(this._status, 201)) {
          this._socketClosedRead = true;
          if (this._filterStatus.get$readEmpty() === true)
            this._reportError$2(new P.HandshakeException("HandshakeException", "Connection terminated during handshake", null), null);
          else
            this._secureHandshake$0();
        }
      }, "call$0", "get$_closeHandler", 0, 0, 6, "_closeHandler"],
      _secureHandshake$0: [function() {
        var e, stackTrace, exception, t1;
        try {
          this._secureFilter.handshake$0();
          this._filterStatus.set$writeEmpty(false);
          this._readSocket$0();
          this._writeSocket$0();
          this._filterPending = true;
          this._tryFilter$0();
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          stackTrace = H.getTraceFromException(exception);
          this._reportError$2(e, stackTrace);
        }
      }, "call$0", "get$_secureHandshake", 0, 0, 6, "_secureHandshake"],
      renegotiate$3$requestClientCertificate$requireClientCertificate$useSessionCache: [function(requestClientCertificate, requireClientCertificate, useSessionCache) {
        if (!J.$eq$(this._status, 202))
          throw H.wrapException(P.HandshakeException$("Called renegotiate on a non-connected socket", null));
        this._secureFilter.renegotiate$3(useSessionCache, requestClientCertificate, requireClientCertificate);
        this._status = 201;
        this._filterStatus.set$writeEmpty(false);
        this._filterPending = true;
        this._tryFilter$0();
      }, function() {
        return this.renegotiate$3$requestClientCertificate$requireClientCertificate$useSessionCache(false, false, true);
      }, "renegotiate$0", "call$3$requestClientCertificate$requireClientCertificate$useSessionCache", "call$0", "get$renegotiate", 0, 7, 1532, 25, 4, 4, 914, [], 97, [], 114, [], "renegotiate"],
      _secureHandshakeCompleteHandler$0: [function() {
        var error, stack, exception, t1;
        this._status = 202;
        if (this._connectPending === true) {
          this._connectPending = false;
          try {
            this._selectedProtocol = this._secureFilter.selectedProtocol$0();
            P.Timer_Timer(C.Duration_0, new P._RawSecureSocket__secureHandshakeCompleteHandler_closure(this));
          } catch (exception) {
            t1 = H.unwrapException(exception);
            error = t1;
            stack = H.getTraceFromException(exception);
            this._handshakeComplete.completeError$2(error, stack);
          }
        }
      }, "call$0", "get$_secureHandshakeCompleteHandler", 0, 0, 6, "_secureHandshakeCompleteHandler"],
      _onPauseStateChange$0: [function() {
        var t1, t2;
        t1 = this._io$_controller.get$isPaused();
        t2 = this._pauseCount;
        if (t1)
          this._pauseCount = J.$add$ns(t2, 1);
        else {
          t1 = J.$sub$n(t2, 1);
          this._pauseCount = t1;
          if (J.$eq$(t1, 0)) {
            this._scheduleReadEvent$0();
            this._sendWriteEvent$0();
          }
        }
        if (this._socketClosedRead !== true || this._socketClosedWrite !== true) {
          t1 = this._io$_controller.get$isPaused();
          t2 = this._socketSubscription;
          if (t1)
            t2.pause$0();
          else
            t2.resume$0();
        }
      }, "call$0", "get$_onPauseStateChange", 0, 0, 6, "_onPauseStateChange"],
      _onSubscriptionStateChange$0: [function() {
        this._io$_controller.get$hasListener();
      }, "call$0", "get$_onSubscriptionStateChange", 0, 0, 6, "_onSubscriptionStateChange"],
      _scheduleFilter$0: [function() {
        this._filterPending = true;
        this._tryFilter$0();
      }, "call$0", "get$_scheduleFilter", 0, 0, 6, "_scheduleFilter"],
      _tryFilter$0: [function() {
        if (J.$eq$(this._status, 203))
          return;
        if (this._filterPending === true && this._filterActive !== true) {
          this._filterActive = true;
          this._filterPending = false;
          this._pushAllFilterStages$0().then$1(new P._RawSecureSocket__tryFilter_closure(this)).catchError$1(this.get$_reportError());
        }
      }, "call$0", "get$_tryFilter", 0, 0, 6, "_tryFilter"],
      _readSocketOrBufferedData$1: [function(bytes) {
        var t1, t2, result;
        t1 = this._bufferedData;
        if (t1 != null) {
          if (J.$gt$n(bytes, J.$sub$n(J.get$length$asx(t1), this._bufferedDataIndex)))
            bytes = J.$sub$n(J.get$length$asx(this._bufferedData), this._bufferedDataIndex);
          t1 = this._bufferedData;
          t2 = this._bufferedDataIndex;
          result = J.sublist$2$ax(t1, t2, J.$add$ns(t2, bytes));
          this._bufferedDataIndex = J.$add$ns(this._bufferedDataIndex, bytes);
          if (J.$eq$(J.get$length$asx(this._bufferedData), this._bufferedDataIndex))
            this._bufferedData = null;
          return result;
        } else if (this._socketClosedRead !== true)
          return this._socket.read$1(bytes);
        else
          return;
      }, "call$1", "get$_readSocketOrBufferedData", 2, 0, 105, 30, [], "_readSocketOrBufferedData"],
      _readSocket$0: [function() {
        if (J.$eq$(this._status, 203))
          return;
        if (this._secureFilter.get$buffers().$index(0, 2).writeFromSource$1(this.get$_readSocketOrBufferedData()).$gt(0, 0))
          this._filterStatus.set$readEmpty(false);
        else
          this._socket.set$readEventsEnabled(false);
      }, "call$0", "get$_readSocket", 0, 0, 6, "_readSocket"],
      _writeSocket$0: [function() {
        if (this._socketClosedWrite === true)
          return;
        if (this._secureFilter.get$buffers().$index(0, 3).readToSocket$1(this._socket))
          this._socket.set$writeEventsEnabled(true);
      }, "call$0", "get$_writeSocket", 0, 0, 6, "_writeSocket"],
      _scheduleReadEvent$0: [function() {
        if (this._pendingReadEvent !== true)
          if (this._readEventsEnabled === true)
            if (J.$eq$(this._pauseCount, 0)) {
              var t1 = this._secureFilter;
              if (t1 != null) {
                t1 = t1.get$buffers().$index(0, 0);
                t1 = !t1.get$isEmpty(t1);
              } else
                t1 = false;
            } else
              t1 = false;
          else
            t1 = false;
        else
          t1 = false;
        if (t1) {
          this._pendingReadEvent = true;
          P.Timer_Timer(C.Duration_0, this.get$_sendReadEvent());
        }
      }, "call$0", "get$_scheduleReadEvent", 0, 0, 4, "_scheduleReadEvent"],
      _sendReadEvent$0: [function() {
        this._pendingReadEvent = false;
        if (!J.$eq$(this._status, 203))
          if (this._readEventsEnabled === true)
            if (J.$eq$(this._pauseCount, 0)) {
              var t1 = this._secureFilter;
              if (t1 != null) {
                t1 = t1.get$buffers().$index(0, 0);
                t1 = !t1.get$isEmpty(t1);
              } else
                t1 = false;
            } else
              t1 = false;
          else
            t1 = false;
        else
          t1 = false;
        if (t1) {
          J.add$1$ax(this._io$_controller, C.RawSocketEvent_0);
          this._scheduleReadEvent$0();
        }
      }, "call$0", "get$_sendReadEvent", 0, 0, 4, "_sendReadEvent"],
      _sendWriteEvent$0: [function() {
        if (this._closedWrite !== true)
          if (this._writeEventsEnabled === true)
            if (J.$eq$(this._pauseCount, 0)) {
              var t1 = this._secureFilter;
              t1 = t1 != null && t1.get$buffers().$index(0, 1).get$free().$gt(0, 0);
            } else
              t1 = false;
          else
            t1 = false;
        else
          t1 = false;
        if (t1) {
          this._writeEventsEnabled = false;
          J.add$1$ax(this._io$_controller, C.RawSocketEvent_1);
        }
      }, "call$0", "get$_sendWriteEvent", 0, 0, 4, "_sendWriteEvent"],
      _pushAllFilterStages$0: [function() {
        var wasInHandshake, args, bufs, i, t1, t2, t3;
        wasInHandshake = !J.$eq$(this._status, 202);
        args = new Array(10);
        args.fixed$length = Array;
        args[0] = this._secureFilter._pointer$0();
        args[1] = wasInHandshake;
        bufs = this._secureFilter.get$buffers();
        for (i = 0; i < 4; ++i) {
          t1 = 2 * i;
          t2 = t1 + 2;
          t3 = bufs.$index(0, i).get$start();
          if (t2 >= 10)
            return H.ioore(args, t2);
          args[t2] = t3;
          t1 += 3;
          t3 = bufs.$index(0, i).get$end();
          if (t1 >= 10)
            return H.ioore(args, t1);
          args[t1] = t3;
        }
        return P._IOService__dispatch(42, args).then$1(new P._RawSecureSocket__pushAllFilterStages_closure(this, wasInHandshake, bufs));
      }, "call$0", "get$_pushAllFilterStages", 0, 0, 1537, "_pushAllFilterStages"],
      _RawSecureSocket$11: function(address, requestedPort, is_server, context, _socket, _socketSubscription, _bufferedData, requestClientCertificate, requireClientCertificate, onBadCertificate, supportedProtocols) {
        var encodedProtocols, e, s, t1, t2, t3, t4, exception;
        if (this.context == null)
          this.context = P.SecurityContext_defaultContext();
        t1 = this.get$_onSubscriptionStateChange();
        t2 = this.get$_onPauseStateChange();
        t1 = new P._SyncStreamController(null, 0, null, t1, t2, t2, t1, [P.RawSocketEvent]);
        this._io$_controller = t1;
        this._io$_stream = t1.get$stream();
        this._secureFilter.init$0();
        this._secureFilter.registerHandshakeCompleteCallback$1(this.get$_secureHandshakeCompleteHandler());
        if (this.onBadCertificate != null)
          this._secureFilter.registerBadCertificateCallback$1(this.get$_onBadCertificateWrapper());
        this._socket.set$readEventsEnabled(true);
        this._socket.set$writeEventsEnabled(false);
        t1 = this._socketSubscription;
        if (t1 == null)
          this._socketSubscription = this._socket.listen$3$onDone$onError(this.get$_eventDispatcher(), this.get$_doneHandler(), this.get$_reportError());
        else {
          if (t1.get$isPaused()) {
            this._socket.close$0();
            throw H.wrapException(P.ArgumentError$("Subscription passed to TLS upgrade is paused"));
          }
          if (this._socket.get$_socket().get$closedReadEventSent())
            this._eventDispatcher$1(C.RawSocketEvent_2);
          t1 = this._socketSubscription;
          t1.onData$1(this.get$_eventDispatcher());
          t1.onError$1(this.get$_reportError());
          t1.onDone$1(this.get$_doneHandler());
        }
        try {
          encodedProtocols = P.SecurityContext__protocolsToLengthEncoding(supportedProtocols);
          t1 = this._secureFilter;
          t2 = this.address.get$host();
          t3 = this.context;
          t4 = this.requestClientCertificate === true || this.requireClientCertificate === true;
          t1.connect$6(t2, t3, this.is_server, t4, this.requireClientCertificate, encodedProtocols);
          this._secureHandshake$0();
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          this._reportError$2(e, s);
        }
      },
      selectedProtocol$0: function() {
        return this.get$selectedProtocol().call$0();
      },
      $asStream: function() {
        return [P.RawSocketEvent];
      },
      $isRawSecureSocket: 1,
      $isRawSocket: 1,
      "<>": [],
      static: {
        "^": "_RawSecureSocket_HANDSHAKE<-0,_RawSecureSocket_CONNECTED<-0,_RawSecureSocket_CLOSED<-0,_RawSecureSocket_READ_PLAINTEXT<-0,_RawSecureSocket_WRITE_PLAINTEXT<-0,_RawSecureSocket_READ_ENCRYPTED<-0,_RawSecureSocket_WRITE_ENCRYPTED<-0,_RawSecureSocket_NUM_BUFFERS<-0",
        _RawSecureSocket__isBufferEncrypted: [function(identifier) {
          return J.$ge$n(identifier, 2);
        }, "call$1", "io__RawSecureSocket__isBufferEncrypted$closure", 2, 0, 32, 819, [], "_isBufferEncrypted"],
        _RawSecureSocket_connect: [function(host, requestedPort, bufferedData, context, is_server, onBadCertificate, requestClientCertificate, requireClientCertificate, socket, subscription, supportedProtocols) {
          var address;
          P._RawSecureSocket__verifyFields(host, requestedPort, is_server, requestClientCertificate, requireClientCertificate, onBadCertificate);
          if (host instanceof P.InternetAddress)
            host = host.get$host();
          address = socket.get$address();
          return P._RawSecureSocket$(host != null ? P.InternetAddress__cloneWithNewHost(address, host) : address, requestedPort, is_server, context, socket, subscription, bufferedData, requestClientCertificate, requireClientCertificate, onBadCertificate, supportedProtocols)._handshakeComplete.get$future();
        }, function(host, requestedPort) {
          return P._RawSecureSocket_connect(host, requestedPort, null, null, null, null, false, false, null, null, null);
        }, "call$11$bufferedData$context$is_server$onBadCertificate$requestClientCertificate$requireClientCertificate$socket$subscription$supportedProtocols", "call$2", "io__RawSecureSocket_connect$closure", 4, 19, 953, 0, 0, 0, 0, 0, 4, 4, 0, 0, 29, [], 326, [], 324, [], 76, [], 52, [], 50, [], 262, [], 97, [], 114, [], 134, [], 105, [], "connect"],
        _RawSecureSocket$: [function(address, requestedPort, is_server, context, _socket, _socketSubscription, _bufferedData, requestClientCertificate, requireClientCertificate, onBadCertificate, supportedProtocols) {
          var t1, t2, t3;
          t1 = P._RawSecureSocket;
          t2 = $.Zone__current;
          t3 = P.RawSecureSocket;
          t3 = new P._RawSecureSocket(_socket, new P._AsyncCompleter(new P._Future(0, t2, null, [t1]), [t1]), null, null, _socketSubscription, _bufferedData, 0, address, is_server, context, requestClientCertificate, requireClientCertificate, onBadCertificate, 201, true, true, 0, false, false, false, false, false, new P._AsyncCompleter(new P._Future(0, t2, null, [t3]), [t3]), new P._FilterStatus(false, true, true, false, false, false, false), true, false, false, P._SecureFilter__SecureFilter(), null);
          t3._RawSecureSocket$11(address, requestedPort, is_server, context, _socket, _socketSubscription, _bufferedData, requestClientCertificate, requireClientCertificate, onBadCertificate, supportedProtocols);
          return t3;
        }, null, null, 22, 0, 954, 81, [], 326, [], 324, [], 76, [], 148, [], 822, [], 823, [], 97, [], 114, [], 134, [], 105, [], "new _RawSecureSocket"],
        _RawSecureSocket__verifyFields: [function(host, requestedPort, is_server, requestClientCertificate, requireClientCertificate, onBadCertificate) {
          if (typeof host !== "string" && !(host instanceof P.InternetAddress))
            throw H.wrapException(P.ArgumentError$("host is not a String or an InternetAddress"));
          if (typeof requestedPort !== "number" || Math.floor(requestedPort) !== requestedPort)
            throw H.wrapException(P.ArgumentError$("requestedPort is not an int"));
          if (requestedPort < 0 || requestedPort > 65535)
            throw H.wrapException(P.ArgumentError$("requestedPort is not in the range 0..65535"));
          if (typeof requestClientCertificate !== "boolean")
            throw H.wrapException(P.ArgumentError$("requestClientCertificate is not a bool"));
          if (typeof requireClientCertificate !== "boolean")
            throw H.wrapException(P.ArgumentError$("requireClientCertificate is not a bool"));
          if (onBadCertificate != null && !J.getInterceptor(onBadCertificate).$isFunction)
            throw H.wrapException(P.ArgumentError$("onBadCertificate is not null or a Function"));
        }, "call$6", "io__RawSecureSocket__verifyFields$closure", 12, 0, 955, 29, [], 326, [], 324, [], 97, [], 114, [], 134, [], "_verifyFields"]
      }
    },
    "+_RawSecureSocket": [223, 1607],
    _RawSecureSocket_writeEventsEnabled_closure: {
      "^": "Closure:4;$this",
      call$0: [function() {
        return this.$this._sendWriteEvent$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _RawSecureSocket_writeEventsEnabled_closure": [2],
    _RawSecureSocket__secureHandshakeCompleteHandler_closure: {
      "^": "Closure:4;$this",
      call$0: [function() {
        var t1 = this.$this;
        return t1._handshakeComplete.complete$1(t1);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _RawSecureSocket__secureHandshakeCompleteHandler_closure": [2],
    _RawSecureSocket__tryFilter_closure: {
      "^": "Closure:3;$this",
      call$1: [function($status) {
        var t1 = this.$this;
        t1._filterStatus = $status;
        t1._filterActive = false;
        if (J.$eq$(t1._status, 203)) {
          t1._secureFilter.destroy$0();
          t1._secureFilter = null;
          return;
        }
        t1._socket.set$readEventsEnabled(true);
        if (t1._filterStatus.get$writeEmpty() === true && t1._closedWrite === true && t1._socketClosedWrite !== true) {
          t1.shutdown$1(C.SocketDirection_1);
          if (J.$eq$(t1._status, 203))
            return;
        }
        if (t1._filterStatus.get$readEmpty() === true && t1._socketClosedRead === true && t1._closedRead !== true) {
          if (J.$eq$(t1._status, 201)) {
            t1._secureFilter.handshake$0();
            if (J.$eq$(t1._status, 201))
              throw H.wrapException(P.HandshakeException$("Connection terminated during handshake", null));
          }
          t1._closeHandler$0();
        }
        if (J.$eq$(t1._status, 203))
          return;
        if (t1._filterStatus.get$progress() === true) {
          t1._filterPending = true;
          if (t1._filterStatus.get$writeEncryptedNoLongerEmpty() === true)
            t1._writeSocket$0();
          if (t1._filterStatus.get$writePlaintextNoLongerFull() === true)
            t1._sendWriteEvent$0();
          if (t1._filterStatus.get$readEncryptedNoLongerFull() === true)
            t1._readSocket$0();
          if (t1._filterStatus.get$readPlaintextNoLongerEmpty() === true)
            t1._scheduleReadEvent$0();
          if (J.$eq$(t1._status, 201))
            t1._secureHandshake$0();
        }
        t1._tryFilter$0();
      }, null, null, 2, 0, 3, 256, [], "call"]
    },
    "+ _RawSecureSocket__tryFilter_closure": [2],
    _RawSecureSocket__pushAllFilterStages_closure: {
      "^": "Closure:3;$this,wasInHandshake,bufs",
      call$1: [function(response) {
        var t1, t2, $status, t3, t4, buffer, new_start, new_end;
        response.get$length(response);
        t1 = new P._RawSecureSocket__pushAllFilterStages__start(response);
        t2 = new P._RawSecureSocket__pushAllFilterStages__end(response);
        $status = new P._FilterStatus(false, true, true, false, false, false, false);
        t3 = this.bufs;
        t4 = t3.$index(0, 1);
        $status.writeEmpty = t4.get$isEmpty(t4) && J.$eq$(t1.call$1(3), t2.call$1(3));
        if (this.wasInHandshake)
          $status.writeEmpty = false;
        t4 = t3.$index(0, 2);
        $status.readEmpty = t4.get$isEmpty(t4) && J.$eq$(t1.call$1(0), t2.call$1(0));
        buffer = t3.$index(0, 1);
        new_start = t1.call$1(1);
        if (!J.$eq$(new_start, buffer.get$start())) {
          $status.progress = true;
          buffer.get$free();
          buffer.set$start(new_start);
        }
        buffer = t3.$index(0, 2);
        new_start = t1.call$1(2);
        if (!J.$eq$(new_start, buffer.get$start())) {
          $status.progress = true;
          buffer.get$free();
          buffer.set$start(new_start);
        }
        buffer = t3.$index(0, 3);
        new_end = t2.call$1(3);
        if (!J.$eq$(new_end, buffer.get$end())) {
          $status.progress = true;
          buffer.get$length(buffer);
          buffer.set$end(new_end);
        }
        buffer = t3.$index(0, 0);
        new_end = t2.call$1(0);
        if (!J.$eq$(new_end, buffer.get$end())) {
          $status.progress = true;
          buffer.get$length(buffer);
          buffer.set$end(new_end);
        }
        return $status;
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _RawSecureSocket__pushAllFilterStages_closure": [2],
    _RawSecureSocket__pushAllFilterStages__start: {
      "^": "Closure:16;response",
      call$1: [function(index) {
        return this.response.$index(0, 2 * index);
      }, null, null, 2, 0, 16, 14, [], "call"]
    },
    "+ _RawSecureSocket__pushAllFilterStages__start": [2],
    _RawSecureSocket__pushAllFilterStages__end: {
      "^": "Closure:16;response",
      call$1: [function(index) {
        return this.response.$index(0, 2 * index + 1);
      }, null, null, 2, 0, 16, 14, [], "call"]
    },
    "+ _RawSecureSocket__pushAllFilterStages__end": [2],
    _ExternalBuffer: {
      "^": "Object;data@-14,start@-0,end@-0,size<-10",
      advanceStart$1: [function(bytes) {
        var t1, t2;
        t1 = J.$add$ns(this.start, bytes);
        this.start = t1;
        t2 = this.size;
        if (J.$ge$n(t1, t2))
          this.start = J.$sub$n(this.start, t2);
      }, "call$1", "get$advanceStart", 2, 0, 17, 30, [], "advanceStart"],
      advanceEnd$1: [function(bytes) {
        var t1, t2;
        t1 = J.$add$ns(this.end, bytes);
        this.end = t1;
        t2 = this.size;
        if (J.$ge$n(t1, t2))
          this.end = J.$sub$n(this.end, t2);
      }, "call$1", "get$advanceEnd", 2, 0, 17, 30, [], "advanceEnd"],
      get$isEmpty: [function(_) {
        return J.$eq$(this.end, this.start);
      }, null, null, 1, 0, 5, "isEmpty"],
      get$length: [function(_) {
        var t1, t2;
        t1 = J.$gt$n(this.start, this.end);
        t2 = this.end;
        return t1 ? J.$sub$n(J.$add$ns(this.size, t2), this.start) : J.$sub$n(t2, this.start);
      }, null, null, 1, 0, 11, "length"],
      get$linearLength: [function() {
        var t1, t2;
        t1 = J.$gt$n(this.start, this.end);
        t2 = this.start;
        return t1 ? J.$sub$n(this.size, t2) : J.$sub$n(this.end, t2);
      }, null, null, 1, 0, 11, "linearLength"],
      get$free: [function() {
        var t1, t2;
        t1 = J.$gt$n(this.start, this.end);
        t2 = this.start;
        return t1 ? J.$sub$n(J.$sub$n(t2, this.end), 1) : J.$sub$n(J.$sub$n(J.$add$ns(this.size, t2), this.end), 1);
      }, null, null, 1, 0, 11, "free"],
      get$linearFree: [function() {
        if (J.$gt$n(this.start, this.end))
          return J.$sub$n(J.$sub$n(this.start, this.end), 1);
        if (J.$eq$(this.start, 0))
          return J.$sub$n(J.$sub$n(this.size, this.end), 1);
        return J.$sub$n(this.size, this.end);
      }, null, null, 1, 0, 11, "linearFree"],
      read$1: [function(bytes) {
        var result, t1, t2, bytesRead, t3, t4, toRead, bytesRead0;
        bytes = bytes == null ? this.get$length(this) : P.min(bytes, this.get$length(this));
        if (J.$eq$(bytes, 0))
          return;
        result = new Uint8Array(H._checkLength(bytes));
        if (typeof bytes !== "number")
          return H.iae(bytes);
        t1 = this.size;
        t2 = J.getInterceptor$n(t1);
        bytesRead = 0;
        for (; bytesRead < bytes; bytesRead = bytesRead0) {
          t3 = J.$gt$n(this.start, this.end);
          t4 = this.start;
          t3 = t3 ? t2.$sub(t1, t4) : J.$sub$n(this.end, t4);
          toRead = P.min(bytes - bytesRead, t3);
          bytesRead0 = bytesRead + toRead;
          C.NativeUint8List_methods.setRange$4(result, bytesRead, bytesRead0, this.data, this.start);
          t3 = J.$add$ns(this.start, toRead);
          this.start = t3;
          if (J.$ge$n(t3, t1))
            this.start = J.$sub$n(this.start, t1);
        }
        return result;
      }, "call$1", "get$read", 2, 0, 105, 30, [], "read"],
      write$3: [function(inputData, offset, bytes) {
        var toWrite, t1, t2, written, t3, t4;
        if (J.$gt$n(bytes, this.get$free()))
          bytes = this.get$free();
        toWrite = P.min(bytes, this.get$linearFree());
        for (t1 = J.getInterceptor$n(bytes), t2 = this.size, written = 0; toWrite > 0;) {
          t3 = this.data;
          t4 = this.end;
          J.setRange$4$ax(t3, t4, J.$add$ns(t4, toWrite), inputData, offset);
          t4 = J.$add$ns(this.end, toWrite);
          this.end = t4;
          if (J.$ge$n(t4, t2))
            this.end = J.$sub$n(this.end, t2);
          offset = J.$add$ns(offset, toWrite);
          written += toWrite;
          toWrite = P.min(t1.$sub(bytes, written), this.get$linearFree());
        }
        return written;
      }, "call$3", "get$write", 6, 0, 1539, 915, [], 220, [], 30, [], "write"],
      writeFromSource$1: [function(getData) {
        var toWrite, t1, written, inputData, len, t2, t3;
        toWrite = this.get$linearFree();
        for (t1 = this.size, written = 0; J.$gt$n(toWrite, 0);) {
          inputData = getData.call$1(toWrite);
          if (inputData == null || J.$eq$(J.get$length$asx(inputData), 0))
            break;
          len = J.get$length$asx(inputData);
          t2 = this.data;
          t3 = this.end;
          J.setRange$3$ax(t2, t3, J.$add$ns(t3, len), inputData);
          t3 = J.$add$ns(this.end, len);
          this.end = t3;
          if (J.$ge$n(t3, t1))
            this.end = J.$sub$n(this.end, t1);
          if (typeof len !== "number")
            return H.iae(len);
          written += len;
          toWrite = this.get$linearFree();
        }
        return written;
      }, "call$1", "get$writeFromSource", 2, 0, 1543, 916, [], "writeFromSource"],
      readToSocket$1: [function(socket) {
        var t1, t2, t3, t4, toWrite, bytes;
        for (t1 = this.size, t2 = J.getInterceptor$n(t1); true;) {
          t3 = J.$gt$n(this.start, this.end);
          t4 = this.start;
          toWrite = t3 ? t2.$sub(t1, t4) : J.$sub$n(this.end, t4);
          if (J.$eq$(toWrite, 0))
            return false;
          bytes = socket.write$3(this.data, this.start, toWrite);
          t3 = J.$add$ns(this.start, bytes);
          this.start = t3;
          if (J.$ge$n(t3, t1))
            this.start = J.$sub$n(this.start, t1);
          if (typeof toWrite !== "number")
            return H.iae(toWrite);
          if (bytes < toWrite)
            return true;
        }
      }, "call$1", "get$readToSocket", 2, 0, 1548, 52, [], "readToSocket"],
      start$0: function() {
        return this.start.call$0();
      },
      start$2$arguments: function(arg0, arg1) {
        return this.start.call$2$arguments(arg0, arg1);
      },
      length$0: function($receiver) {
        return this.get$length(this).call$0();
      },
      static: {
        _ExternalBuffer$: [function(size) {
          var t1, t2;
          t1 = new P._ExternalBuffer(null, null, null, size);
          t2 = J.$tdiv$n(size, 2);
          t1.end = t2;
          t1.start = t2;
          return t1;
        }, null, null, 2, 0, 3, 284, [], "new _ExternalBuffer"]
      }
    },
    "+_ExternalBuffer": [1],
    _SecureFilter: {
      "^": "Object;",
      static: {
        _SecureFilter__SecureFilter: [function() {
          throw H.wrapException(new P.UnsupportedError("_SecureFilter._SecureFilter"));
        }, null, null, 0, 0, 956, "new _SecureFilter"]
      }
    },
    "+_SecureFilter": [1],
    TlsException: {
      "^": "Object;type<-9,message<-9,osError<-95",
      toString$0: [function(_) {
        var t1, t2;
        t1 = H.S(this.type);
        t2 = this.message;
        if (J.get$isEmpty$asx(t2) !== true) {
          t1 += ": " + H.S(t2);
          t2 = this.osError;
          if (t2 != null)
            t1 += " (" + H.S(t2) + ")";
        } else {
          t2 = this.osError;
          if (t2 != null)
            t1 += ": " + H.S(t2);
        }
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isException: 1,
      static: {
        TlsException$: [function(message, osError) {
          return new P.TlsException("TlsException", message, osError);
        }, null, null, 0, 4, 239, 32, 0, 17, [], 108, [], "new TlsException"],
        TlsException$_: [function(type, message, osError) {
          return new P.TlsException(type, message, osError);
        }, null, null, 6, 0, 958, 65, [], 17, [], 108, [], "new TlsException$_"]
      }
    },
    "+TlsException": [1, 74],
    HandshakeException: {
      "^": "TlsException;type-9,message-9,osError-95",
      static: {
        HandshakeException$: [function(message, osError) {
          return new P.HandshakeException("HandshakeException", message, osError);
        }, null, null, 0, 4, 239, 32, 0, 17, [], 108, [], "new HandshakeException"]
      }
    },
    "+HandshakeException": [519],
    CertificateException: {
      "^": "TlsException;type-9,message-9,osError-95",
      static: {
        CertificateException$: [function(message, osError) {
          return new P.CertificateException("CertificateException", message, osError);
        }, null, null, 0, 4, 239, 32, 0, 17, [], 108, [], "new CertificateException"]
      }
    },
    "+CertificateException": [519],
    SecurityContext: {
      "^": "Object;",
      static: {
        SecurityContext_SecurityContext: [function() {
          throw H.wrapException(new P.UnsupportedError("SecurityContext constructor"));
        }, null, null, 0, 0, 425, "new SecurityContext"],
        SecurityContext_defaultContext: [function() {
          throw H.wrapException(new P.UnsupportedError("default SecurityContext getter"));
        }, null, null, 1, 0, 425, "defaultContext"],
        SecurityContext_alpnSupported: [function() {
          throw H.wrapException(new P.UnsupportedError("SecurityContext alpnSupported getter"));
        }, null, null, 1, 0, 5, "alpnSupported"],
        SecurityContext__protocolsToLengthEncoding: [function(protocols) {
          var t1, protocolsLength, expectedLength, i, $length, t2, bytes, bytesOffset, proto, bytesOffset0, t3, t4, bits, j, char;
          if (protocols == null || J.$eq$(J.get$length$asx(protocols), 0))
            return new Uint8Array(H._checkLength(0));
          t1 = J.getInterceptor$asx(protocols);
          protocolsLength = t1.get$length(protocols);
          if (typeof protocolsLength !== "number")
            return H.iae(protocolsLength);
          expectedLength = protocolsLength;
          i = 0;
          for (; i < protocolsLength; ++i) {
            $length = J.get$length$asx(t1.$index(protocols, i));
            t2 = J.getInterceptor$n($length);
            if (t2.$gt($length, 0) && t2.$le($length, 255)) {
              if (typeof $length !== "number")
                return H.iae($length);
              expectedLength += $length;
            } else
              throw H.wrapException(P.ArgumentError$("Length of protocol must be between 1 and 255 (was: " + H.S($length) + ")."));
          }
          if (expectedLength >= 8192)
            throw H.wrapException(P.ArgumentError$("The maximum message length supported is 2^13-1."));
          t2 = H._checkLength(expectedLength);
          bytes = new Uint8Array(t2);
          for (bytesOffset = 0, i = 0; i < protocolsLength; ++i) {
            proto = t1.$index(protocols, i);
            bytesOffset0 = bytesOffset + 1;
            t3 = J.getInterceptor$asx(proto);
            t4 = t3.get$length(proto);
            if (bytesOffset < 0 || bytesOffset >= t2)
              return H.ioore(bytes, bytesOffset);
            bytes[bytesOffset] = t4;
            bytesOffset = bytesOffset0;
            bits = 0;
            j = 0;
            while (true) {
              t4 = t3.get$length(proto);
              if (typeof t4 !== "number")
                return H.iae(t4);
              if (!(j < t4))
                break;
              char = t3.codeUnitAt$1(proto, j);
              bits |= char;
              bytesOffset0 = bytesOffset + 1;
              if (bytesOffset < 0 || bytesOffset >= t2)
                return H.ioore(bytes, bytesOffset);
              bytes[bytesOffset] = char & 255;
              ++j;
              bytesOffset = bytesOffset0;
            }
            if (bits > 127)
              return P.SecurityContext__protocolsToLengthEncodingNonAsciiBailout(protocols);
          }
          return bytes;
        }, "call$1", "io_SecurityContext__protocolsToLengthEncoding$closure", 2, 0, 426, 228, [], "_protocolsToLengthEncoding"],
        SecurityContext__protocolsToLengthEncodingNonAsciiBailout: [function(protocols) {
          var t1, bytes, t2, i, t3;
          t1 = new P.SecurityContext__protocolsToLengthEncodingNonAsciiBailout_addProtocol();
          bytes = [];
          t2 = J.getInterceptor$asx(protocols);
          i = 0;
          while (true) {
            t3 = t2.get$length(protocols);
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (!(i < t3))
              break;
            t1.call$2(bytes, t2.$index(protocols, i));
            ++i;
          }
          if (bytes.length >= 8192)
            throw H.wrapException(P.ArgumentError$("The maximum message length supported is 2^13-1."));
          return new Uint8Array(H._ensureNativeList(bytes));
        }, "call$1", "io_SecurityContext__protocolsToLengthEncodingNonAsciiBailout$closure", 2, 0, 426, 228, [], "_protocolsToLengthEncodingNonAsciiBailout"]
      }
    },
    "+SecurityContext": [1],
    SecurityContext__protocolsToLengthEncodingNonAsciiBailout_addProtocol: {
      "^": "Closure:373;",
      call$2: [function(outBytes, protocol) {
        var protocolBytes, len;
        protocolBytes = C.Utf8Codec_false.get$encoder().convert$1(protocol);
        len = J.get$length$asx(protocolBytes);
        if (J.$gt$n(len, 255))
          throw H.wrapException(P.ArgumentError$("Length of protocol must be between 1 and 255 (was: " + H.S(len) + ")"));
        outBytes.push(len);
        C.JSArray_methods.addAll$1(outBytes, protocolBytes);
      }, null, null, 4, 0, 373, 917, [], 182, [], "call"]
    },
    "+ SecurityContext__protocolsToLengthEncodingNonAsciiBailout_addProtocol": [2],
    _ServiceObject: {
      "^": "Object;__serviceId:_ServiceObject___serviceId@-0",
      get$_serviceId: [function() {
        if (J.$eq$(this._ServiceObject___serviceId, 0)) {
          var t1 = $._nextServiceId;
          $._nextServiceId = J.$add$ns(t1, 1);
          this._ServiceObject___serviceId = t1;
        }
        return this._ServiceObject___serviceId;
      }, null, null, 1, 0, 11, "_serviceId"],
      get$_servicePath: [function() {
        return this.get$_serviceTypePath() + "/" + H.S(this.get$_serviceId());
      }, null, null, 1, 0, 7, "_servicePath"],
      _serviceType$1: [function(ref) {
        if (ref === true)
          return "@" + this.get$_serviceTypeName();
        return this.get$_serviceTypeName();
      }, "call$1", "get$_serviceType", 2, 0, 1557, 151, [], "_serviceType"],
      static: {
        _ServiceObject$: [function() {
          return new P._ServiceObject(0);
        }, null, null, 0, 0, 961, "new _ServiceObject"]
      }
    },
    "+_ServiceObject": [1],
    InternetAddressType: {
      "^": "Object;_io$_value<-0",
      get$name: [function() {
        switch (this._io$_value) {
          case -1:
            return "ANY";
          case 0:
            return "IP_V4";
          case 1:
            return "IP_V6";
          default:
            throw H.wrapException(P.ArgumentError$("Invalid InternetAddress"));
        }
      }, null, null, 1, 0, 7, "name"],
      toString$0: [function(_) {
        return "InternetAddressType: " + this.get$name();
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        "^": "InternetAddressType_IP_V4<-211,InternetAddressType_IP_V6<-211,InternetAddressType_ANY<-211",
        InternetAddressType$_: [function(_value) {
          return new P.InternetAddressType(_value);
        }, null, null, 2, 0, 22, 174, [], "new InternetAddressType$_"],
        InternetAddressType_InternetAddressType$_from: [function(value) {
          var t1 = J.getInterceptor(value);
          if (t1.$eq(value, 0))
            return C.InternetAddressType_0;
          if (t1.$eq(value, 1))
            return C.InternetAddressType_1;
          throw H.wrapException(P.ArgumentError$("Invalid type: " + H.S(value)));
        }, null, null, 2, 0, 962, 1, [], "new InternetAddressType$_from"]
      }
    },
    "+InternetAddressType": [1],
    InternetAddress: {
      "^": "Object;type@-211",
      static: {
        InternetAddress_LOOPBACK_IP_V4: [function() {
          throw H.wrapException(new P.UnsupportedError("InternetAddress.LOOPBACK_IP_V4"));
        }, null, null, 1, 0, 68, "LOOPBACK_IP_V4"],
        InternetAddress_LOOPBACK_IP_V6: [function() {
          throw H.wrapException(new P.UnsupportedError("InternetAddress.LOOPBACK_IP_V6"));
        }, null, null, 1, 0, 68, "LOOPBACK_IP_V6"],
        InternetAddress_ANY_IP_V4: [function() {
          throw H.wrapException(new P.UnsupportedError("InternetAddress.ANY_IP_V4"));
        }, null, null, 1, 0, 68, "ANY_IP_V4"],
        InternetAddress_ANY_IP_V6: [function() {
          throw H.wrapException(new P.UnsupportedError("InternetAddress.ANY_IP_V6"));
        }, null, null, 1, 0, 68, "ANY_IP_V6"],
        InternetAddress_InternetAddress: [function(address) {
          throw H.wrapException(new P.UnsupportedError("InternetAddress"));
        }, null, null, 2, 0, 963, 81, [], "new InternetAddress"],
        InternetAddress_lookup: [function(host, type) {
          throw H.wrapException(new P.UnsupportedError("InternetAddress.lookup"));
        }, function(host) {
          return P.InternetAddress_lookup(host, C.InternetAddressType_m1);
        }, "call$2$type", "call$1", "io_InternetAddress_lookup$closure", 2, 3, 964, 529, 29, [], 65, [], "lookup"],
        InternetAddress__cloneWithNewHost: [function(address, host) {
          throw H.wrapException(new P.UnsupportedError("InternetAddress._cloneWithNewHost"));
        }, "call$2", "io_InternetAddress__cloneWithNewHost$closure", 4, 0, 965, 81, [], 29, [], "_cloneWithNewHost"]
      }
    },
    "+InternetAddress": [1],
    NetworkInterface: {
      "^": "Object;",
      static: {
        NetworkInterface$: [function() {
          return new P.NetworkInterface();
        }, null, null, 0, 0, 966, "new NetworkInterface"],
        NetworkInterface_listSupported: [function() {
          throw H.wrapException(new P.UnsupportedError("NetworkInterface.listSupported"));
        }, null, null, 1, 0, 5, "listSupported"],
        NetworkInterface_list: [function(includeLinkLocal, includeLoopback, type) {
          throw H.wrapException(new P.UnsupportedError("NetworkInterface.list"));
        }, function() {
          return P.NetworkInterface_list(false, false, C.InternetAddressType_m1);
        }, "call$3$includeLinkLocal$includeLoopback$type", "call$0", "io_NetworkInterface_list$closure", 0, 7, 967, 4, 4, 529, 826, [], 827, [], 65, [], "list"]
      }
    },
    "+NetworkInterface": [1],
    RawServerSocket: {
      "^": "Object;",
      $isStream: 1,
      $asStream: function() {
        return [P.RawSocket];
      },
      static: {
        RawServerSocket$: [function() {
          return new P.RawServerSocket();
        }, null, null, 0, 0, 968, "new RawServerSocket"],
        RawServerSocket_bind: [function(address, port, backlog, shared, v6Only) {
          throw H.wrapException(new P.UnsupportedError("RawServerSocket.bind"));
        }, function(address, port) {
          return P.RawServerSocket_bind(address, port, 0, false, false);
        }, "call$5$backlog$shared$v6Only", "call$2", "io_RawServerSocket_bind$closure", 4, 7, 969, 7, 4, 4, 81, [], 26, [], 124, [], 121, [], 128, [], "bind"]
      }
    },
    "+RawServerSocket": [1, 1610],
    ServerSocket: {
      "^": "Object;",
      $isStream: 1,
      $asStream: function() {
        return [P.Socket];
      },
      static: {
        ServerSocket$: [function() {
          return new P.ServerSocket();
        }, null, null, 0, 0, 970, "new ServerSocket"],
        ServerSocket_bind: [function(address, port, backlog, shared, v6Only) {
          throw H.wrapException(new P.UnsupportedError("ServerSocket.bind"));
        }, function(address, port) {
          return P.ServerSocket_bind(address, port, 0, false, false);
        }, "call$5$backlog$shared$v6Only", "call$2", "io_ServerSocket_bind$closure", 4, 7, 971, 7, 4, 4, 81, [], 26, [], 124, [], 121, [], 128, [], "bind"]
      }
    },
    "+ServerSocket": [1, 1611],
    SocketDirection: {
      "^": "Object;_io$_value<-10",
      static: {
        "^": "SocketDirection_RECEIVE<-293,SocketDirection_SEND<-293,SocketDirection_BOTH<-293",
        SocketDirection$_: [function(_value) {
          return new P.SocketDirection(_value);
        }, null, null, 2, 0, 3, 174, [], "new SocketDirection$_"]
      }
    },
    "+SocketDirection": [1],
    SocketOption: {
      "^": "Object;_io$_value<-10",
      static: {
        "^": "SocketOption_TCP_NODELAY<-157,SocketOption__IP_MULTICAST_LOOP<-157,SocketOption__IP_MULTICAST_HOPS<-157,SocketOption__IP_MULTICAST_IF<-157,SocketOption__IP_BROADCAST<-157",
        SocketOption$_: [function(_value) {
          return new P.SocketOption(_value);
        }, null, null, 2, 0, 3, 174, [], "new SocketOption$_"]
      }
    },
    "+SocketOption": [1],
    RawSocketEvent: {
      "^": "Object;_io$_value<-0",
      toString$0: [function(_) {
        var t1 = this._io$_value;
        if (t1 >>> 0 !== t1 || t1 >= 4)
          return H.ioore(C.List_adS, t1);
        return C.List_adS[t1];
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        "^": "RawSocketEvent_READ<-219,RawSocketEvent_WRITE<-219,RawSocketEvent_READ_CLOSED<-219,RawSocketEvent_CLOSED<-219",
        RawSocketEvent$_: [function(_value) {
          return new P.RawSocketEvent(_value);
        }, null, null, 2, 0, 22, 174, [], "new RawSocketEvent$_"]
      }
    },
    "+RawSocketEvent": [1],
    RawSocket: {
      "^": "Object;readEventsEnabled@-8,writeEventsEnabled@-8",
      $isStream: 1,
      $asStream: function() {
        return [P.RawSocketEvent];
      },
      static: {
        RawSocket$: [function() {
          return new P.RawSocket(null, null);
        }, null, null, 0, 0, 972, "new RawSocket"],
        RawSocket_connect: [function(host, port, sourceAddress) {
          throw H.wrapException(new P.UnsupportedError("RawSocket constructor"));
        }, function(host, port) {
          return P.RawSocket_connect(host, port, null);
        }, "call$3$sourceAddress", "call$2", "io_RawSocket_connect$closure", 4, 3, 973, 0, 29, [], 26, [], 625, [], "connect"]
      }
    },
    "+RawSocket": [1, 223],
    Socket: {
      "^": "Object;",
      $isStream: 1,
      $asStream: function() {
        return [[P.List, P.int]];
      },
      $isEventSink: 1,
      $asEventSink: function() {
        return [[P.List, P.int]];
      },
      static: {
        Socket$: [function() {
          return new P.Socket();
        }, null, null, 0, 0, 974, "new Socket"],
        Socket_connect: [function(host, port, sourceAddress) {
          throw H.wrapException(new P.UnsupportedError("Socket constructor"));
        }, function(host, port) {
          return P.Socket_connect(host, port, null);
        }, "call$3$sourceAddress", "call$2", "io_Socket_connect$closure", 4, 3, 975, 0, 29, [], 26, [], 625, [], "connect"]
      }
    },
    "+Socket": [1, 78, 42],
    Datagram: {
      "^": "Object;data@-14,address@-186,port@-0",
      static: {
        Datagram$: [function(data, address, port) {
          return new P.Datagram(data, address, port);
        }, null, null, 6, 0, 976, 21, [], 81, [], 26, [], "new Datagram"]
      }
    },
    "+Datagram": [1],
    RawDatagramSocket: {
      "^": "Stream;readEventsEnabled@-8,writeEventsEnabled@-8,multicastLoopback@-8,multicastHops@-0,multicastInterface@-1615,broadcastEnabled@-8",
      $asStream: function() {
        return [P.RawSocketEvent];
      },
      "<>": [],
      static: {
        RawDatagramSocket$: [function() {
          return new P.RawDatagramSocket(null, null, null, null, null, null);
        }, null, null, 0, 0, 977, "new RawDatagramSocket"],
        RawDatagramSocket_bind: [function(host, port, reuseAddress) {
          throw H.wrapException(new P.UnsupportedError("RawDatagramSocket.bind"));
        }, function(host, port) {
          return P.RawDatagramSocket_bind(host, port, true);
        }, "call$3$reuseAddress", "call$2", "io_RawDatagramSocket_bind$closure", 4, 3, 978, 25, 29, [], 26, [], 829, [], "bind"]
      }
    },
    "+RawDatagramSocket": [223],
    SocketException: {
      "^": "Object;message<-9,osError<-95,address<-186,port<-0",
      toString$0: [function(_) {
        var t1, t2;
        t1 = this.message;
        if (J.get$isEmpty$asx(t1) !== true) {
          t1 = "SocketException" + (": " + H.S(t1));
          t2 = this.osError;
          if (t2 != null)
            t1 += " (" + H.S(t2) + ")";
        } else {
          t1 = this.osError;
          t1 = t1 != null ? "SocketException" + (": " + H.S(t1)) : "SocketException";
        }
        t2 = this.address;
        if (t2 != null)
          t1 += ", address = " + H.S(t2.get$host());
        t2 = this.port;
        if (t2 != null)
          t1 += ", port = " + H.S(t2);
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isException: 1,
      static: {
        SocketException$: [function(message, address, osError, port) {
          return new P.SocketException(message, osError, address, port);
        }, null, null, 2, 7, 979, 0, 0, 0, 17, [], 108, [], 81, [], 26, [], "new SocketException"],
        SocketException$closed: [function() {
          return new P.SocketException("Socket has been closed", null, null, null);
        }, null, null, 0, 0, 4, "new SocketException$closed"]
      }
    },
    "+SocketException": [1, 74],
    _StdStream: {
      "^": "Stream;_io$_stream<-42",
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        return this._io$_stream.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, onError);
      }, "listen$2$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, null);
      }, "listen$2$onDone", function(onData, cancelOnError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, null, null);
      }, "listen$2$cancelOnError", "call$4$cancelOnError$onDone$onError", "call$1", "call$2$onError", "call$3$onDone$onError", "call$3$onDone$onError", "call$2$onDone", "call$2$cancelOnError", "get$listen", 2, 7, 94, 0, 0, 0, 27, [], 20, [], 28, [], 24, [], "listen"],
      $asStream: function() {
        return [[P.List, P.int]];
      },
      "<>": [],
      static: {
        _StdStream$: [function(_stream) {
          return new P._StdStream(_stream);
        }, null, null, 2, 0, 427, 163, [], "new _StdStream"]
      }
    },
    "+_StdStream": [42],
    Stdin: {
      "^": "_StdStream;_io$_stream-42",
      readLineSync$2$encoding$retainNewlines: [function(encoding, retainNewlines) {
        var line, t1, crIsNewline;
        line = H.setRuntimeTypeInfo([], [P.int]);
        if ($.$get$Platform_isWindows()) {
          t1 = $._stdin;
          if (t1 == null) {
            t1 = P._StdIOUtils__getStdioInputStream();
            $._stdin = t1;
          }
          crIsNewline = P.stdioType(t1) === C.StdioType_terminal && !this.get$lineMode();
        } else
          crIsNewline = false;
        if (retainNewlines === true) {
          do
            this.readByteSync$0();
          while (true);
          if (line.length === 0)
            return;
        } else if (crIsNewline)
          for (; true;)
            this.readByteSync$0();
        else
          $outer$0:
            for (; true;)
              this.readByteSync$0();
        return encoding.decode$1(line);
      }, function() {
        return this.readLineSync$2$encoding$retainNewlines(C.C_SystemEncoding, false);
      }, "readLineSync$0", "call$2$encoding$retainNewlines", "call$0", "get$readLineSync", 0, 5, 1560, 201, 4, 48, [], 918, [], "readLineSync"],
      get$echoMode: [function() {
        throw H.wrapException(new P.UnsupportedError("Stdin.echoMode"));
      }, null, null, 1, 0, 5, "echoMode"],
      set$echoMode: [function(enabled) {
        throw H.wrapException(new P.UnsupportedError("Stdin.echoMode"));
      }, null, null, 3, 0, 35, 189, [], "echoMode"],
      get$lineMode: [function() {
        throw H.wrapException(new P.UnsupportedError("Stdin.lineMode"));
      }, null, null, 1, 0, 5, "lineMode"],
      set$lineMode: [function(enabled) {
        throw H.wrapException(new P.UnsupportedError("Stdin.lineMode"));
      }, null, null, 3, 0, 35, 189, [], "lineMode"],
      get$supportsAnsiEscapes: [function() {
        throw H.wrapException(new P.UnsupportedError("Stdin.supportsAnsiEscapes"));
      }, null, null, 1, 0, 5, "supportsAnsiEscapes"],
      readByteSync$0: [function() {
        throw H.wrapException(new P.UnsupportedError("Stdin.readByteSync"));
      }, "call$0", "get$readByteSync", 0, 0, 11, "readByteSync"],
      static: {
        Stdin$_: [function(stream) {
          return new P.Stdin(stream);
        }, null, null, 2, 0, 427, 37, [], "new Stdin$_"]
      }
    },
    "+Stdin": [1616, 42],
    Stdout: {
      "^": "_StdSink;_fd<-0,_nonBlocking@-78,_sink-78,_isTranslatable-8",
      get$hasTerminal: [function() {
        return this._hasTerminal$1(this._fd);
      }, null, null, 1, 0, 5, "hasTerminal"],
      get$terminalColumns: [function() {
        return this._terminalColumns$1(this._fd);
      }, null, null, 1, 0, 11, "terminalColumns"],
      get$terminalLines: [function() {
        return this._terminalLines$1(this._fd);
      }, null, null, 1, 0, 11, "terminalLines"],
      get$supportsAnsiEscapes: [function() {
        return P.Stdout__supportsAnsiEscapes(this._fd);
      }, null, null, 1, 0, 5, "supportsAnsiEscapes"],
      _hasTerminal$1: [function(fd) {
        throw H.wrapException(new P.UnsupportedError("Stdout.hasTerminal"));
      }, "call$1", "get$_hasTerminal", 2, 0, 32, 103, [], "_hasTerminal"],
      _terminalColumns$1: [function(fd) {
        throw H.wrapException(new P.UnsupportedError("Stdout.terminalColumns"));
      }, "call$1", "get$_terminalColumns", 2, 0, 16, 103, [], "_terminalColumns"],
      _terminalLines$1: [function(fd) {
        throw H.wrapException(new P.UnsupportedError("Stdout.terminalLines"));
      }, "call$1", "get$_terminalLines", 2, 0, 16, 103, [], "_terminalLines"],
      get$nonBlocking: [function() {
        var t1, t2, t3, t4;
        t1 = this._nonBlocking;
        if (t1 == null) {
          t1 = new P._FileStreamConsumer(null, null);
          t2 = P._File__openStdioSync(this._fd);
          t3 = [null];
          t4 = new P._Future(0, $.Zone__current, null, t3);
          t4._asyncComplete$1(t2);
          t1._openFuture = t4;
          t3 = new P._IOSinkImpl(C.Utf8Codec_false, true, t1, new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, t3), [null]), null, null, false, false, false);
          this._nonBlocking = t3;
          t1 = t3;
        }
        return t1;
      }, null, null, 1, 0, 1561, "nonBlocking"],
      static: {
        Stdout$_: [function(sink, _fd) {
          return new P.Stdout(_fd, null, sink, null);
        }, null, null, 4, 0, 981, 22, [], 830, [], "new Stdout$_"],
        Stdout__supportsAnsiEscapes: [function(fd) {
          throw H.wrapException(new P.UnsupportedError("Stdout.supportsAnsiEscapes"));
        }, "call$1", "io_Stdout__supportsAnsiEscapes$closure", 2, 0, 32, 103, [], "_supportsAnsiEscapes"]
      }
    },
    "+Stdout": [1617, 78],
    StdoutException: {
      "^": "Object;message<-9,osError<-95",
      toString$0: [function(_) {
        var t1, t2;
        t1 = "StdoutException: " + H.S(this.message);
        t2 = this.osError;
        return t1 + (t2 == null ? "" : ", " + H.S(t2));
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isException: 1,
      static: {
        StdoutException$: [function(message, osError) {
          return new P.StdoutException(message, osError);
        }, null, null, 2, 2, 428, 0, 17, [], 108, [], "new StdoutException"]
      }
    },
    "+StdoutException": [1, 74],
    StdinException: {
      "^": "Object;message<-9,osError<-95",
      toString$0: [function(_) {
        var t1, t2;
        t1 = "StdinException: " + H.S(this.message);
        t2 = this.osError;
        return t1 + (t2 == null ? "" : ", " + H.S(t2));
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isException: 1,
      static: {
        StdinException$: [function(message, osError) {
          return new P.StdinException(message, osError);
        }, null, null, 2, 2, 428, 0, 17, [], 108, [], "new StdinException"]
      }
    },
    "+StdinException": [1, 74],
    _StdConsumer: {
      "^": "Object;_file<-10",
      addStream$1: [function(stream) {
        var t1, t2, completer;
        t1 = {};
        t2 = new P._Future(0, $.Zone__current, null, [null]);
        completer = new P._AsyncCompleter(t2, [null]);
        t1.sub = null;
        t1.sub = stream.listen$4$cancelOnError$onDone$onError(new P._StdConsumer_addStream_closure(t1, this, completer), true, completer.get$complete(), completer.get$completeError());
        return t2;
      }, "call$1", "get$addStream", 2, 0, 212, 37, [], "addStream"],
      close$0: [function() {
        this._file.closeSync$0();
        var t1 = new P._Future(0, $.Zone__current, null, [null]);
        t1._asyncComplete$1(null);
        return t1;
      }, "call$0", "get$close", 0, 0, 18, "close"],
      static: {
        _StdConsumer$: [function(fd) {
          return new P._StdConsumer(P._File__openStdioSync(fd));
        }, null, null, 2, 0, 22, 103, [], "new _StdConsumer"]
      }
    },
    "+_StdConsumer": [1, 270],
    _StdConsumer_addStream_closure: {
      "^": "Closure:3;_box_0,$this,completer",
      call$1: [function(data) {
        var e, s, exception, t1;
        try {
          this.$this._file.writeFromSync$1(data);
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = H.getTraceFromException(exception);
          this._box_0.sub.cancel$0();
          this.completer.completeError$2(e, s);
        }
      }, null, null, 2, 0, 3, 21, [], "call"]
    },
    "+ _StdConsumer_addStream_closure": [2],
    _StdSink: {
      "^": "Object;_sink<-78,_isTranslatable<-8",
      get$encoding: [function() {
        return this._sink.get$encoding();
      }, null, null, 1, 0, 207, "encoding"],
      set$encoding: [function(encoding) {
        this._sink.set$encoding(encoding);
      }, null, null, 3, 0, 261, 48, [], "encoding"],
      write$1: [function(object) {
        this._sink.write$1(object);
      }, "call$1", "get$write", 2, 0, 27, 23, [], "write"],
      writeln$1: [function(object) {
        this._sink.writeln$1(object);
      }, function() {
        return this.writeln$1("");
      }, "writeln$0", "call$1", "call$0", "get$writeln", 0, 2, 294, 32, 23, [], "writeln"],
      writeAll$2: [function(objects, sep) {
        this._sink.writeAll$2(objects, sep);
      }, function(objects) {
        return this.writeAll$2(objects, "");
      }, "writeAll$1", "call$2", "call$1", "get$writeAll", 2, 2, 291, 32, 119, [], 919, [], "writeAll"],
      add$1: [function(_, data) {
        J.add$1$ax(this._sink, data);
      }, "call$1", "get$add", 2, 0, 26, 21, [], "add"],
      addError$2: [function(error, stackTrace) {
        this._sink.addError$2(error, stackTrace);
      }, function(error) {
        return this.addError$2(error, null);
      }, "addError$1", "call$2", "call$1", "get$addError", 2, 2, 81, 0, 8, [], 12, [], "addError"],
      writeCharCode$1: [function(charCode) {
        this._sink.writeCharCode$1(charCode);
      }, "call$1", "get$writeCharCode", 2, 0, 17, 84, [], "writeCharCode"],
      addStream$1: [function(stream) {
        return this._sink.addStream$1(stream);
      }, "call$1", "get$addStream", 2, 0, 212, 37, [], "addStream"],
      flush$0: [function() {
        return this._sink.flush$0();
      }, "call$0", "get$flush", 0, 0, 18, "flush"],
      close$0: [function() {
        return this._sink.close$0();
      }, "call$0", "get$close", 0, 0, 18, "close"],
      get$done: [function() {
        return this._sink.get$done();
      }, null, null, 1, 0, 18, "done"],
      static: {
        _StdSink$: [function(_sink) {
          return new P._StdSink(_sink, null);
        }, null, null, 2, 0, 983, 45, [], "new _StdSink"]
      }
    },
    "+_StdSink": [1, 78],
    StdioType: {
      "^": "Object;name<-9",
      toString$0: [function(_) {
        return "StdioType: " + H.S(this.name);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        "^": "StdioType_TERMINAL<-203,StdioType_PIPE<-203,StdioType_FILE<-203,StdioType_OTHER<-203",
        StdioType$_: [function($name) {
          return new P.StdioType($name);
        }, null, null, 2, 0, 13, 13, [], "new StdioType$_"]
      }
    },
    "+StdioType": [1],
    _StdIOUtils: {
      "^": "Object;",
      static: {
        _StdIOUtils$: [function() {
          return new P._StdIOUtils();
        }, null, null, 0, 0, 987, "new _StdIOUtils"],
        _StdIOUtils__getStdioOutputStream: [function(fd) {
          throw H.wrapException(new P.UnsupportedError("StdIOUtils._getStdioOutputStream"));
        }, "call$1", "io__StdIOUtils__getStdioOutputStream$closure", 2, 0, 22, 103, [], "_getStdioOutputStream"],
        _StdIOUtils__getStdioInputStream: [function() {
          throw H.wrapException(new P.UnsupportedError("StdIOUtils._getStdioInputStream"));
        }, "call$0", "io__StdIOUtils__getStdioInputStream$closure", 0, 0, 429, "_getStdioInputStream"],
        _StdIOUtils__socketType: [function(socket) {
          throw H.wrapException(new P.UnsupportedError("StdIOUtils._socketType"));
        }, "call$1", "io__StdIOUtils__socketType$closure", 2, 0, 988, 52, [], "_socketType"],
        _StdIOUtils__getStdioHandleType: [function(fd) {
          throw H.wrapException(new P.UnsupportedError("StdIOUtils._getStdioHandleType"));
        }, "call$1", "io__StdIOUtils__getStdioHandleType$closure", 2, 0, 22, 103, [], "_getStdioHandleType"]
      }
    },
    "+_StdIOUtils": [1],
    SystemEncoding: {
      "^": "Encoding;",
      get$name: [function() {
        return "system";
      }, null, null, 1, 0, 7, "name"],
      encode$1: [function(input) {
        return this.get$encoder().convert$1(input);
      }, "call$1", "get$encode", 2, 0, 141, 58, [], "encode"],
      decode$1: [function(encoded) {
        return this.get$decoder().convert$1(encoded);
      }, "call$1", "get$decode", 2, 0, 158, 532, [], "decode"],
      get$encoder: [function() {
        $.$get$Platform__operatingSystem();
        return C.C_Utf8Encoder;
      }, null, null, 1, 0, 1570, "encoder"],
      get$decoder: [function() {
        $.$get$Platform__operatingSystem();
        return C.Utf8Decoder_false;
      }, null, null, 1, 0, 1580, "decoder"],
      static: {
        SystemEncoding$: [function() {
          return new P.SystemEncoding();
        }, null, null, 0, 0, 4, "new SystemEncoding"]
      }
    },
    "+SystemEncoding": [79],
    _WindowsCodePageEncoder: {
      "^": "Converter;",
      convert$1: [function(input) {
        P._WindowsCodePageEncoder__encodeString(input);
      }, "call$1", "get$convert", 2, 0, 141, 58, [], "convert"],
      startChunkedConversion$1: [function(sink) {
        return new P._WindowsCodePageEncoderSink(sink);
      }, "call$1", "get$startChunkedConversion", 2, 0, 173, 22, [], "startChunkedConversion"],
      $asConverter: function() {
        return [P.String, [P.List, P.int]];
      },
      "<>": [],
      static: {
        _WindowsCodePageEncoder$: [function() {
          return new P._WindowsCodePageEncoder();
        }, null, null, 0, 0, 4, "new _WindowsCodePageEncoder"],
        _WindowsCodePageEncoder__encodeString: [function(string) {
          throw H.wrapException(new P.UnsupportedError("_WindowsCodePageEncoder._encodeString"));
        }, "call$1", "io__WindowsCodePageEncoder__encodeString$closure", 2, 0, 141, 39, [], "_encodeString"]
      }
    },
    "+_WindowsCodePageEncoder": [194, 192],
    _WindowsCodePageEncoderSink: {
      "^": "StringConversionSinkBase;_sink<-250",
      close$0: [function() {
        this._sink.close$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      add$1: [function(_, string) {
        P._WindowsCodePageEncoder__encodeString(string);
      }, "call$1", "get$add", 2, 0, 19, 39, [], "add"],
      addSlice$4: [function(source, start, end, isLast) {
        this.add$1(0, !J.$eq$(start, 0) || !J.$eq$(end, J.get$length$asx(source)) ? J.substring$2$s(source, start, end) : source);
        if (isLast === true)
          this._sink.close$0();
      }, "call$4", "get$addSlice", 8, 0, 87, 19, [], 3, [], 5, [], 46, [], "addSlice"],
      static: {
        _WindowsCodePageEncoderSink$: [function(_sink) {
          return new P._WindowsCodePageEncoderSink(_sink);
        }, null, null, 2, 0, 249, 45, [], "new _WindowsCodePageEncoderSink"]
      }
    },
    "+_WindowsCodePageEncoderSink": [100],
    _WindowsCodePageDecoder: {
      "^": "Converter;",
      convert$1: [function(input) {
        return P._WindowsCodePageDecoder__decodeBytes(input);
      }, "call$1", "get$convert", 2, 0, 158, 58, [], "convert"],
      startChunkedConversion$1: [function(sink) {
        return new P._WindowsCodePageDecoderSink(sink);
      }, "call$1", "get$startChunkedConversion", 2, 0, 159, 22, [], "startChunkedConversion"],
      $asConverter: function() {
        return [[P.List, P.int], P.String];
      },
      "<>": [],
      static: {
        _WindowsCodePageDecoder$: [function() {
          return new P._WindowsCodePageDecoder();
        }, null, null, 0, 0, 4, "new _WindowsCodePageDecoder"],
        _WindowsCodePageDecoder__decodeBytes: [function(bytes) {
          throw H.wrapException(new P.UnsupportedError("_WindowsCodePageDecoder._decodeBytes"));
        }, "call$1", "io__WindowsCodePageDecoder__decodeBytes$closure", 2, 0, 158, 30, [], "_decodeBytes"]
      }
    },
    "+_WindowsCodePageDecoder": [189, 232],
    _WindowsCodePageDecoderSink: {
      "^": "ByteConversionSinkBase;_sink<-248",
      close$0: [function() {
        this._sink.close$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      add$1: [function(_, bytes) {
        J.add$1$ax(this._sink, P._WindowsCodePageDecoder__decodeBytes(bytes));
      }, "call$1", "get$add", 2, 0, 26, 30, [], "add"],
      static: {
        _WindowsCodePageDecoderSink$: [function(_sink) {
          return new P._WindowsCodePageDecoderSink(_sink);
        }, null, null, 2, 0, 402, 45, [], "new _WindowsCodePageDecoderSink"]
      }
    },
    "+_WindowsCodePageDecoderSink": [99],
    WebSocketStatus: {
      "^": "Object;",
      static: {
        "^": "WebSocketStatus_NORMAL_CLOSURE<-0,WebSocketStatus_GOING_AWAY<-0,WebSocketStatus_PROTOCOL_ERROR<-0,WebSocketStatus_UNSUPPORTED_DATA<-0,WebSocketStatus_RESERVED_1004<-0,WebSocketStatus_NO_STATUS_RECEIVED<-0,WebSocketStatus_ABNORMAL_CLOSURE<-0,WebSocketStatus_INVALID_FRAME_PAYLOAD_DATA<-0,WebSocketStatus_POLICY_VIOLATION<-0,WebSocketStatus_MESSAGE_TOO_BIG<-0,WebSocketStatus_MISSING_MANDATORY_EXTENSION<-0,WebSocketStatus_INTERNAL_SERVER_ERROR<-0,WebSocketStatus_RESERVED_1015<-0",
        WebSocketStatus$: [function() {
          return new P.WebSocketStatus();
        }, null, null, 0, 0, 989, "new WebSocketStatus"]
      }
    },
    "+WebSocketStatus": [1],
    CompressionOptions: {
      "^": "Object;clientNoContextTakeover<-8,serverNoContextTakeover<-8,clientMaxWindowBits<-0,serverMaxWindowBits<-0,enabled<-8",
      _createServerResponseHeader$1: [function(requested) {
        var info, part, t1, mwb;
        info = new P._CompressionMaxWindowBits(null, null);
        part = (requested == null ? requested : requested.get$parameters()) != null ? J.$index$asx(requested.get$parameters(), "server_max_window_bits") : null;
        if (part != null) {
          t1 = J.getInterceptor$asx(part);
          if (J.$ge$n(t1.get$length(part), 2) && t1.startsWith$1(part, "0"))
            throw H.wrapException(P.ArgumentError$("Illegal 0 padding on value."));
          else {
            mwb = this.serverMaxWindowBits;
            if (mwb == null)
              mwb = H.Primitives_parseInt(part, null, new P.CompressionOptions__createServerResponseHeader_closure());
            info.headerValue = "; server_max_window_bits=" + H.S(mwb);
            info.maxWindowBits = mwb;
          }
        } else {
          info.headerValue = "";
          info.maxWindowBits = 15;
        }
        return info;
      }, "call$1", "get$_createServerResponseHeader", 2, 0, 1582, 407, [], "_createServerResponseHeader"],
      _createClientRequestHeader$2: [function(requested, size) {
        var info, t1;
        if (requested != null)
          info = "; client_max_window_bits=" + H.S(size);
        else {
          t1 = this.clientMaxWindowBits;
          info = t1 == null ? "; client_max_window_bits" : "; client_max_window_bits=" + H.S(t1);
          t1 = this.serverMaxWindowBits;
          if (t1 != null)
            info += "; server_max_window_bits=" + H.S(t1);
        }
        return info;
      }, "call$2", "get$_createClientRequestHeader", 4, 0, 1589, 407, [], 284, [], "_createClientRequestHeader"],
      _createHeader$1: [function(requested) {
        var info, t1, t2, headerList, info0;
        info = new P._CompressionMaxWindowBits("", 0);
        if (this.enabled !== true)
          return info;
        info.headerValue = "permessage-deflate";
        if (this.clientNoContextTakeover === true)
          if (requested != null)
            t1 = requested.get$parameters().containsKey$1("client_no_context_takeover");
          else
            t1 = true;
        else
          t1 = false;
        if (t1) {
          info.headerValue = "permessage-deflate; client_no_context_takeover";
          t1 = "permessage-deflate; client_no_context_takeover";
        } else
          t1 = "permessage-deflate";
        if (this.serverNoContextTakeover === true)
          if (requested != null)
            t2 = requested.get$parameters().containsKey$1("server_no_context_takeover");
          else
            t2 = true;
        else
          t2 = false;
        if (t2) {
          t1 += "; server_no_context_takeover";
          info.headerValue = t1;
        }
        headerList = this._createServerResponseHeader$1(requested);
        t1 = C.JSString_methods.$add(t1, headerList.headerValue);
        info.headerValue = t1;
        t2 = headerList.maxWindowBits;
        info.maxWindowBits = t2;
        if (requested != null)
          info0 = "; client_max_window_bits=" + H.S(t2);
        else {
          t2 = this.clientMaxWindowBits;
          info0 = t2 == null ? "; client_max_window_bits" : "; client_max_window_bits=" + H.S(t2);
          t2 = this.serverMaxWindowBits;
          if (t2 != null)
            info0 += "; server_max_window_bits=" + H.S(t2);
        }
        info.headerValue = t1 + info0;
        return info;
      }, function() {
        return this._createHeader$1(null);
      }, "_createHeader$0", "call$1", "call$0", "get$_createHeader", 0, 2, 1592, 0, 407, [], "_createHeader"],
      static: {
        "^": "CompressionOptions_DEFAULT<-297,CompressionOptions_OFF<-297",
        CompressionOptions$: [function(clientMaxWindowBits, clientNoContextTakeover, enabled, serverMaxWindowBits, serverNoContextTakeover) {
          return new P.CompressionOptions(clientNoContextTakeover, serverNoContextTakeover, clientMaxWindowBits, serverMaxWindowBits, enabled);
        }, null, null, 0, 11, 990, 4, 4, 0, 0, 25, 531, [], 538, [], 541, [], 544, [], 189, [], "new CompressionOptions"]
      }
    },
    "+CompressionOptions": [1],
    CompressionOptions__createServerResponseHeader_closure: {
      "^": "Closure:3;",
      call$1: [function(source) {
        return 15;
      }, null, null, 2, 0, 3, 19, [], "call"]
    },
    "+ CompressionOptions__createServerResponseHeader_closure": [2],
    WebSocketTransformer: {
      "^": "Object;",
      static: {
        WebSocketTransformer_WebSocketTransformer: [function(compression, protocolSelector) {
          return new P._WebSocketTransformerImpl(new P._SyncStreamController(null, 0, null, null, null, null, null, [P.WebSocket]), protocolSelector, compression);
        }, null, null, 0, 5, 991, 0, 178, 564, [], 113, [], "new WebSocketTransformer"],
        WebSocketTransformer_upgrade: [function(request, compression, protocolSelector) {
          return P._WebSocketTransformerImpl__upgrade(request, protocolSelector, compression);
        }, function(request) {
          return P.WebSocketTransformer_upgrade(request, C.CompressionOptions_qty, null);
        }, "call$3$compression$protocolSelector", "call$1", "io_WebSocketTransformer_upgrade$closure", 2, 5, 992, 0, 178, 54, [], 564, [], 113, [], "upgrade"],
        WebSocketTransformer_isUpgradeRequest: [function(request) {
          return P._WebSocketTransformerImpl__isUpgradeRequest(request);
        }, "call$1", "io_WebSocketTransformer_isUpgradeRequest$closure", 2, 0, 431, 54, [], "isUpgradeRequest"]
      }
    },
    "+WebSocketTransformer": [1, 1620],
    WebSocket: {
      "^": "Object;pingInterval@-65",
      $isStream: 1,
      $asStream: Isolate.functionThatReturnsNull,
      $isEventSink: 1,
      $asEventSink: Isolate.functionThatReturnsNull,
      static: {
        "^": "WebSocket_CONNECTING<-0,WebSocket_OPEN<-0,WebSocket_CLOSING<-0,WebSocket_CLOSED<-0",
        WebSocket_connect: [function(url, compression, headers, protocols) {
          return P._WebSocketImpl_connect(url, protocols, headers, compression);
        }, function(url) {
          return P.WebSocket_connect(url, C.CompressionOptions_qty, null, null);
        }, "call$4$compression$headers$protocols", "call$1", "io_WebSocket_connect$closure", 2, 7, 994, 0, 0, 178, 75, [], 228, [], 414, [], 113, [], "connect"],
        WebSocket$: [function() {
          return new P.WebSocket(null);
        }, null, null, 0, 0, 4, "new WebSocket", 839],
        WebSocket_WebSocket$fromUpgradedSocket: [function(socket, compression, protocol, serverSide) {
          if (serverSide == null)
            throw H.wrapException(P.ArgumentError$("The serverSide argument must be passed explicitly to WebSocket.fromUpgradedSocket."));
          return P._WebSocketImpl$_fromSocket(socket, protocol, compression, serverSide, null);
        }, null, null, 2, 7, 995, 0, 0, 178, 52, [], 182, [], 311, [], 113, [], "new WebSocket$fromUpgradedSocket"]
      }
    },
    "+WebSocket": [1, 523, 524],
    WebSocketException: {
      "^": "Object;message<-9",
      toString$0: [function(_) {
        return "WebSocketException: " + H.S(this.message);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isException: 1,
      static: {
        WebSocketException$: [function(message) {
          return new P.WebSocketException(message);
        }, null, null, 0, 2, 167, 32, 17, [], "new WebSocketException"]
      }
    },
    "+WebSocketException": [1, 74],
    _WebSocketMessageType: {
      "^": "Object;",
      static: {
        "^": "_WebSocketMessageType_NONE<-0,_WebSocketMessageType_TEXT<-0,_WebSocketMessageType_BINARY<-0",
        _WebSocketMessageType$: [function() {
          return new P._WebSocketMessageType();
        }, null, null, 0, 0, 996, "new _WebSocketMessageType"]
      }
    },
    "+_WebSocketMessageType": [1],
    _WebSocketOpcode: {
      "^": "Object;",
      static: {
        "^": "_WebSocketOpcode_CONTINUATION<-0,_WebSocketOpcode_TEXT<-0,_WebSocketOpcode_BINARY<-0,_WebSocketOpcode_RESERVED_3<-0,_WebSocketOpcode_RESERVED_4<-0,_WebSocketOpcode_RESERVED_5<-0,_WebSocketOpcode_RESERVED_6<-0,_WebSocketOpcode_RESERVED_7<-0,_WebSocketOpcode_CLOSE<-0,_WebSocketOpcode_PING<-0,_WebSocketOpcode_PONG<-0,_WebSocketOpcode_RESERVED_B<-0,_WebSocketOpcode_RESERVED_C<-0,_WebSocketOpcode_RESERVED_D<-0,_WebSocketOpcode_RESERVED_E<-0,_WebSocketOpcode_RESERVED_F<-0",
        _WebSocketOpcode$: [function() {
          return new P._WebSocketOpcode();
        }, null, null, 0, 0, 997, "new _WebSocketOpcode"]
      }
    },
    "+_WebSocketOpcode": [1],
    _EncodedString: {
      "^": "Object;bytes<-14",
      static: {
        _EncodedString$: [function(bytes) {
          return new P._EncodedString(bytes);
        }, null, null, 2, 0, 320, 30, [], "new _EncodedString"]
      }
    },
    "+_EncodedString": [1],
    _CompressionMaxWindowBits: {
      "^": "Object;headerValue@-9,maxWindowBits@-0",
      toString$0: [function(_) {
        return this.headerValue;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      static: {
        _CompressionMaxWindowBits$: [function(headerValue, maxWindowBits) {
          return new P._CompressionMaxWindowBits(headerValue, maxWindowBits);
        }, null, null, 0, 4, 418, 0, 0, 349, [], 842, [], "new _CompressionMaxWindowBits"]
      }
    },
    "+_CompressionMaxWindowBits": [1],
    _WebSocketProtocolTransformer: {
      "^": "Object;_io$_state@-0,_fin@-8,_compressed@-8,_opcode@-0,_len@-0,_masked@-8,_remainingLenBytes@-0,_remainingMaskingKeyBytes@-0,_remainingPayloadBytes@-0,_unmaskingIndex@-0,_currentMessageType@-0,closeCode@-0,closeReason@-9,_eventSink@-237,_serverSide<-8,_maskingBytes<-50,_payload<-226,_deflate@-298",
      bind$1: [function(stream) {
        return new P._BoundSinkStream(new P._WebSocketProtocolTransformer_bind_closure(this), stream, [null, null]);
      }, "call$1", "get$bind", 2, 0, 1599, 37, [], "bind"],
      addError$2: [function(error, stackTrace) {
        this._eventSink.addError$2(error, stackTrace);
      }, function(error) {
        return this.addError$2(error, null);
      }, "addError$1", "call$2", "call$1", "get$addError", 2, 2, 48, 0, 8, [], 12, [], "addError"],
      close$0: [function() {
        this._eventSink.close$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      add$1: [function(_, bytes) {
        var buffer, t1, lastIndex, t2, t3, t4, t5, index, byte, t6, payloadLength, payload, t7, t8;
        buffer = !!J.getInterceptor(bytes).$isUint8List ? bytes : new Uint8Array(H._ensureNativeList(bytes));
        t1 = J.getInterceptor$asx(buffer);
        lastIndex = t1.get$length(buffer);
        if (J.$eq$(this._io$_state, 5))
          throw H.wrapException(new P.WebSocketException("Data on closed connection"));
        if (J.$eq$(this._io$_state, 6))
          throw H.wrapException(new P.WebSocketException("Data on failed connection"));
        t2 = this._payload;
        t3 = J.getInterceptor$ax(t2);
        if (typeof lastIndex !== "number")
          return H.iae(lastIndex);
        t4 = this._maskingBytes;
        t5 = J.getInterceptor$ax(t4);
        index = 0;
        while (true) {
          if (!(index < lastIndex && !J.$eq$(this._io$_state, 5) && !J.$eq$(this._io$_state, 6)))
            break;
          byte = t1.$index(buffer, index);
          if (J.$le$n(this._io$_state, 2))
            if (J.$eq$(this._io$_state, 0)) {
              this._fin = (byte & 128) !== 0;
              if ((byte & 48) !== 0)
                throw H.wrapException(new P.WebSocketException("Protocol error"));
              t6 = byte & 15;
              this._opcode = t6;
              if (t6 !== 0)
                if ((byte & 64) !== 0)
                  this._compressed = true;
                else
                  this._compressed = false;
              if (J.$le$n(this._opcode, 2))
                if (J.$eq$(this._opcode, 0)) {
                  if (J.$eq$(this._currentMessageType, 0))
                    throw H.wrapException(new P.WebSocketException("Protocol error"));
                } else {
                  if (!J.$eq$(this._currentMessageType, 0))
                    throw H.wrapException(new P.WebSocketException("Protocol error"));
                  this._currentMessageType = this._opcode;
                }
              else if (J.$ge$n(this._opcode, 8) && J.$le$n(this._opcode, 10)) {
                if (this._fin !== true)
                  throw H.wrapException(new P.WebSocketException("Protocol error"));
              } else
                throw H.wrapException(new P.WebSocketException("Protocol error"));
              this._io$_state = 1;
            } else if (J.$eq$(this._io$_state, 1)) {
              this._masked = (byte & 128) !== 0;
              this._len = byte & 127;
              if ((J.$eq$(this._opcode, 8) || J.$eq$(this._opcode, 9) || J.$eq$(this._opcode, 10)) && J.$gt$n(this._len, 125))
                throw H.wrapException(new P.WebSocketException("Protocol error"));
              if (J.$eq$(this._len, 126)) {
                this._len = 0;
                this._remainingLenBytes = 2;
                this._io$_state = 2;
              } else if (J.$eq$(this._len, 127)) {
                this._len = 0;
                this._remainingLenBytes = 8;
                this._io$_state = 2;
              } else
                this._lengthDone$0();
            } else {
              this._len = (J.$shl$n(this._len, 8) | byte) >>> 0;
              t6 = J.$sub$n(this._remainingLenBytes, 1);
              this._remainingLenBytes = t6;
              if (J.$eq$(t6, 0))
                this._lengthDone$0();
            }
          else if (J.$eq$(this._io$_state, 3)) {
            t6 = this._remainingMaskingKeyBytes;
            this._remainingMaskingKeyBytes = J.$sub$n(t6, 1);
            if (typeof t6 !== "number")
              return H.iae(t6);
            t5.$indexSet(t4, 4 - t6, byte);
            if (J.$eq$(this._remainingMaskingKeyBytes, 0)) {
              this._remainingPayloadBytes = this._len;
              this._startPayload$0();
            }
          } else {
            payloadLength = P.min(lastIndex - index, this._remainingPayloadBytes);
            this._remainingPayloadBytes = J.$sub$n(this._remainingPayloadBytes, payloadLength);
            if (this._masked === true)
              this._unmask$3(index, payloadLength, buffer);
            t3.add$1(t2, J.asUint8List$2$x(t1.get$buffer(buffer), index, payloadLength));
            if (J.$eq$(this._opcode, 8) || J.$eq$(this._opcode, 9) || J.$eq$(this._opcode, 10)) {
              if (J.$eq$(this._remainingPayloadBytes, 0)) {
                switch (this._opcode) {
                  case 8:
                    this.closeCode = 1005;
                    payload = t2.takeBytes$0();
                    t6 = J.getInterceptor$asx(payload);
                    if (J.$gt$n(t6.get$length(payload), 0)) {
                      if (J.$eq$(t6.get$length(payload), 1))
                        H.throwExpression(new P.WebSocketException("Protocol error"));
                      t7 = J.$shl$n(t6.$index(payload, 0), 8);
                      t8 = t6.$index(payload, 1);
                      if (typeof t8 !== "number")
                        return H.iae(t8);
                      t8 = (t7 | t8) >>> 0;
                      this.closeCode = t8;
                      if (t8 === 1005)
                        H.throwExpression(new P.WebSocketException("Protocol error"));
                      if (J.$gt$n(t6.get$length(payload), 2)) {
                        t6 = t6.sublist$1(payload, 2);
                        this.closeReason = new P.Utf8Decoder(false).convert$1(t6);
                      }
                    }
                    this._io$_state = 5;
                    this._eventSink.close$0();
                    break;
                  case 9:
                    J.add$1$ax(this._eventSink, new P._WebSocketPing(t2.takeBytes$0()));
                    break;
                  case 10:
                    J.add$1$ax(this._eventSink, new P._WebSocketPong(t2.takeBytes$0()));
                    break;
                }
                this._prepareForNextFrame$0();
              }
            } else {
              if (!J.$eq$(this._currentMessageType, 1) && !J.$eq$(this._currentMessageType, 2))
                throw H.wrapException(new P.WebSocketException("Protocol error"));
              if (J.$eq$(this._remainingPayloadBytes, 0))
                this._messageFrameEnd$0();
            }
            index = index + payloadLength - 1;
          }
          ++index;
        }
      }, "call$1", "get$add", 2, 0, 26, 30, [], "add"],
      _unmask$3: [function(index, $length, buffer) {
        var t1, t2, t3, startOffset, end, t4, t5, i, t6, t7, t8, t9, blockCount, mask, blockMask, blockBuffer, bytes;
        t1 = J.getInterceptor$n($length);
        if (t1.$ge($length, 16)) {
          t2 = J.getInterceptor$n(index);
          t3 = t2.$and(index, 15);
          if (typeof t3 !== "number")
            return H.iae(t3);
          startOffset = 16 - t3;
          end = t2.$add(index, startOffset);
          for (t3 = J.getInterceptor$asx(buffer), t4 = this._maskingBytes, t5 = J.getInterceptor$asx(t4), i = index; t6 = J.getInterceptor$n(i), t6.$lt(i, end); i = t6.$add(i, 1)) {
            t7 = t3.$index(buffer, i);
            t8 = this._unmaskingIndex;
            t9 = J.getInterceptor$ns(t8);
            this._unmaskingIndex = t9.$add(t8, 1);
            t3.$indexSet(buffer, i, J.$xor$n(t7, t5.$index(t4, t9.$and(t8, 3))));
          }
          index = t2.$add(index, startOffset);
          $length = t1.$sub($length, startOffset);
          t1 = J.getInterceptor$n($length);
          blockCount = t1.$tdiv($length, 16);
          t2 = J.getInterceptor$n(blockCount);
          if (t2.$gt(blockCount, 0)) {
            for (mask = 0, i = 3; i >= 0; --i) {
              t6 = t5.$index(t4, J.$and$n(J.$add$ns(this._unmaskingIndex, i), 3));
              if (typeof t6 !== "number")
                return H.iae(t6);
              mask = (mask << 8 | t6) >>> 0;
            }
            blockMask = H.NativeInt32x4$(mask, mask, mask, mask);
            blockBuffer = J.asInt32x4List$2$x(t3.get$buffer(buffer), index, blockCount);
            for (t3 = blockBuffer._storage.length / 4 | 0, i = 0; i < t3; ++i)
              blockBuffer.$indexSet(0, i, blockBuffer.$index(0, i).$xor(0, blockMask));
            bytes = t2.$mul(blockCount, 16);
            index = J.$add$ns(index, bytes);
            $length = t1.$sub($length, bytes);
          }
        }
        end = J.$add$ns(index, $length);
        for (t1 = J.getInterceptor$asx(buffer), t2 = this._maskingBytes, t3 = J.getInterceptor$asx(t2), i = index; t4 = J.getInterceptor$n(i), t4.$lt(i, end); i = t4.$add(i, 1)) {
          t5 = t1.$index(buffer, i);
          t6 = this._unmaskingIndex;
          t7 = J.getInterceptor$ns(t6);
          this._unmaskingIndex = t7.$add(t6, 1);
          t1.$indexSet(buffer, i, J.$xor$n(t5, t3.$index(t2, t7.$and(t6, 3))));
        }
      }, "call$3", "get$_unmask", 6, 0, 1608, 14, [], 15, [], 41, [], "_unmask"],
      _lengthDone$0: [function() {
        if (this._masked === true) {
          if (this._serverSide !== true)
            throw H.wrapException(new P.WebSocketException("Received masked frame from server"));
          this._io$_state = 3;
        } else {
          if (this._serverSide === true)
            throw H.wrapException(new P.WebSocketException("Received unmasked frame from client"));
          this._remainingPayloadBytes = this._len;
          this._startPayload$0();
        }
      }, "call$0", "get$_lengthDone", 0, 0, 6, "_lengthDone"],
      _maskDone$0: [function() {
        this._remainingPayloadBytes = this._len;
        this._startPayload$0();
      }, "call$0", "get$_maskDone", 0, 0, 6, "_maskDone"],
      _startPayload$0: [function() {
        if (J.$eq$(this._remainingPayloadBytes, 0))
          if (this._isControlFrame$0()) {
            switch (this._opcode) {
              case 8:
                this._io$_state = 5;
                this._eventSink.close$0();
                break;
              case 9:
                J.add$1$ax(this._eventSink, new P._WebSocketPing(null));
                break;
              case 10:
                J.add$1$ax(this._eventSink, new P._WebSocketPong(null));
                break;
            }
            this._prepareForNextFrame$0();
          } else
            this._messageFrameEnd$0();
        else
          this._io$_state = 4;
      }, "call$0", "get$_startPayload", 0, 0, 6, "_startPayload"],
      _messageFrameEnd$0: [function() {
        var bytes, t1;
        if (this._fin === true) {
          bytes = this._payload.takeBytes$0();
          t1 = this._deflate;
          if (t1 != null && this._compressed === true)
            bytes = t1.processIncomingMessage$1(bytes);
          switch (this._currentMessageType) {
            case 1:
              t1 = this._eventSink;
              J.add$1$ax(t1, new P.Utf8Decoder(false).convert$1(bytes));
              break;
            case 2:
              J.add$1$ax(this._eventSink, bytes);
              break;
          }
          this._currentMessageType = 0;
        }
        this._prepareForNextFrame$0();
      }, "call$0", "get$_messageFrameEnd", 0, 0, 6, "_messageFrameEnd"],
      _controlFrameEnd$0: [function() {
        var payload, t1, t2, t3;
        switch (this._opcode) {
          case 8:
            this.closeCode = 1005;
            payload = this._payload.takeBytes$0();
            t1 = J.getInterceptor$asx(payload);
            if (J.$gt$n(t1.get$length(payload), 0)) {
              if (J.$eq$(t1.get$length(payload), 1))
                throw H.wrapException(new P.WebSocketException("Protocol error"));
              t2 = J.$shl$n(t1.$index(payload, 0), 8);
              t3 = t1.$index(payload, 1);
              if (typeof t3 !== "number")
                return H.iae(t3);
              t3 = (t2 | t3) >>> 0;
              this.closeCode = t3;
              if (t3 === 1005)
                throw H.wrapException(new P.WebSocketException("Protocol error"));
              if (J.$gt$n(t1.get$length(payload), 2)) {
                t1 = t1.sublist$1(payload, 2);
                this.closeReason = new P.Utf8Decoder(false).convert$1(t1);
              }
            }
            this._io$_state = 5;
            this._eventSink.close$0();
            break;
          case 9:
            J.add$1$ax(this._eventSink, new P._WebSocketPing(this._payload.takeBytes$0()));
            break;
          case 10:
            J.add$1$ax(this._eventSink, new P._WebSocketPong(this._payload.takeBytes$0()));
            break;
        }
        this._prepareForNextFrame$0();
      }, "call$0", "get$_controlFrameEnd", 0, 0, 6, "_controlFrameEnd"],
      _isControlFrame$0: [function() {
        return J.$eq$(this._opcode, 8) || J.$eq$(this._opcode, 9) || J.$eq$(this._opcode, 10);
      }, "call$0", "get$_isControlFrame", 0, 0, 5, "_isControlFrame"],
      _prepareForNextFrame$0: [function() {
        if (!J.$eq$(this._io$_state, 5) && !J.$eq$(this._io$_state, 6))
          this._io$_state = 0;
        this._fin = false;
        this._opcode = -1;
        this._len = -1;
        this._remainingLenBytes = -1;
        this._remainingMaskingKeyBytes = 4;
        this._remainingPayloadBytes = -1;
        this._unmaskingIndex = 0;
      }, "call$0", "get$_prepareForNextFrame", 0, 0, 6, "_prepareForNextFrame"],
      static: {
        "^": "_WebSocketProtocolTransformer_START<-0,_WebSocketProtocolTransformer_LEN_FIRST<-0,_WebSocketProtocolTransformer_LEN_REST<-0,_WebSocketProtocolTransformer_MASK<-0,_WebSocketProtocolTransformer_PAYLOAD<-0,_WebSocketProtocolTransformer_CLOSED<-0,_WebSocketProtocolTransformer_FAILURE<-0,_WebSocketProtocolTransformer_FIN<-0,_WebSocketProtocolTransformer_RSV1<-0,_WebSocketProtocolTransformer_RSV2<-0,_WebSocketProtocolTransformer_RSV3<-0,_WebSocketProtocolTransformer_OPCODE<-0",
        _WebSocketProtocolTransformer$: [function(_serverSide, _deflate) {
          var t1 = new Array(4);
          t1.fixed$length = Array;
          return new P._WebSocketProtocolTransformer(0, false, false, -1, -1, false, -1, 4, -1, 0, 0, 1005, "", null, _serverSide, t1, P.BytesBuilder_BytesBuilder(false), _deflate);
        }, null, null, 0, 4, 998, 4, 0, 578, [], 844, [], "new _WebSocketProtocolTransformer"]
      }
    },
    "+_WebSocketProtocolTransformer": [1, 1624, 525],
    _WebSocketProtocolTransformer_bind_closure: {
      "^": "Closure:145;$this",
      call$1: [function(eventSink) {
        var t1 = this.$this;
        if (t1._eventSink != null)
          throw H.wrapException(new P.StateError("WebSocket transformer already used."));
        t1._eventSink = eventSink;
        return t1;
      }, null, null, 2, 0, 145, 304, [], "call"]
    },
    "+ _WebSocketProtocolTransformer_bind_closure": [2],
    _WebSocketPing: {
      "^": "Object;payload<-14",
      static: {
        _WebSocketPing$: [function(payload) {
          return new P._WebSocketPing(payload);
        }, null, null, 0, 2, 432, 0, 585, [], "new _WebSocketPing"]
      }
    },
    "+_WebSocketPing": [1],
    _WebSocketPong: {
      "^": "Object;payload<-14",
      static: {
        _WebSocketPong$: [function(payload) {
          return new P._WebSocketPong(payload);
        }, null, null, 0, 2, 432, 0, 585, [], "new _WebSocketPong"]
      }
    },
    "+_WebSocketPong": [1],
    _WebSocketTransformerImpl: {
      "^": "Object;_io$_controller<-1626,_protocolSelector<-1627,_compression<-297",
      bind$1: [function(stream) {
        stream.listen$2$onDone(new P._WebSocketTransformerImpl_bind_closure(this), new P._WebSocketTransformerImpl_bind_closure0(this));
        return this._io$_controller.get$stream();
      }, "call$1", "get$bind", 2, 0, 1612, 37, [], "bind"],
      static: {
        _WebSocketTransformerImpl$: [function(_protocolSelector, _compression) {
          return new P._WebSocketTransformerImpl(new P._SyncStreamController(null, 0, null, null, null, null, null, [P.WebSocket]), _protocolSelector, _compression);
        }, null, null, 4, 0, 1000, 597, [], 847, [], "new _WebSocketTransformerImpl"],
        _WebSocketTransformerImpl__upgrade: [function(request, _protocolSelector, compression) {
          var t1, response, t2, protocols;
          t1 = {};
          response = request.get$response();
          if (!P._WebSocketTransformerImpl__isUpgradeRequest(request)) {
            response.set$statusCode(400);
            response.close$0();
            return P.Future_Future$error(new P.WebSocketException("Invalid WebSocket upgrade request"), null, null);
          }
          t2 = new P._WebSocketTransformerImpl__upgrade_upgrade(request, compression, response);
          protocols = J.$index$asx(request.get$headers(), "Sec-WebSocket-Protocol");
          t1.protocols = protocols;
          if (protocols != null && _protocolSelector != null) {
            t1.protocols = P._HttpParser__tokenizeFieldValue(J.join$1$ax(protocols, ", "));
            return P.Future_Future(new P._WebSocketTransformerImpl__upgrade_closure(t1, _protocolSelector), P.String).then$1(new P._WebSocketTransformerImpl__upgrade_closure0(t1)).catchError$1(new P._WebSocketTransformerImpl__upgrade_closure1(response)).then$1(t2);
          } else
            return t2.call$1(null);
        }, "call$3", "io__WebSocketTransformerImpl__upgrade$closure", 6, 0, 1001, 54, [], 597, [], 113, [], "_io$_upgrade"],
        _WebSocketTransformerImpl__negotiateCompression: [function(request, response, compression) {
          var extensionHeader, result, info, serverNoContextTakeover, clientNoContextTakeover, t1;
          extensionHeader = request.get$headers().value$1("Sec-WebSocket-Extensions");
          if (extensionHeader == null)
            extensionHeader = "";
          result = P._HeaderValue$("", null);
          result._parse$4(extensionHeader, ";", ",", false);
          if (compression.get$enabled() === true && J.$eq$(result._io$_value, "permessage-deflate")) {
            info = compression._createHeader$1(result);
            J.add$2$ax(response.get$headers(), "Sec-WebSocket-Extensions", info.headerValue);
            serverNoContextTakeover = result.get$parameters().containsKey$1("server_no_context_takeover") && compression.get$serverNoContextTakeover() === true;
            clientNoContextTakeover = result.get$parameters().containsKey$1("client_no_context_takeover") && compression.get$clientNoContextTakeover() === true;
            t1 = info.maxWindowBits;
            return new P._WebSocketPerMessageDeflate(serverNoContextTakeover, clientNoContextTakeover, t1, t1, true, null, null);
          }
          return;
        }, "call$3", "io__WebSocketTransformerImpl__negotiateCompression$closure", 6, 0, 1002, 54, [], 18, [], 113, [], "_negotiateCompression"],
        _WebSocketTransformerImpl__isUpgradeRequest: [function(request) {
          var t1, upgrade, version;
          t1 = {};
          if (!J.$eq$(request.get$method(), "GET"))
            return false;
          if (J.$index$asx(request.get$headers(), "connection") == null)
            return false;
          t1.isUpgrade = false;
          J.forEach$1$ax(J.$index$asx(request.get$headers(), "connection"), new P._WebSocketTransformerImpl__isUpgradeRequest_closure(t1));
          if (!t1.isUpgrade)
            return false;
          upgrade = request.get$headers().value$1("upgrade");
          if (upgrade == null || J.toLowerCase$0$s(upgrade) !== "websocket")
            return false;
          version = request.get$headers().value$1("Sec-WebSocket-Version");
          if (version == null || !J.$eq$(version, "13"))
            return false;
          if (request.get$headers().value$1("Sec-WebSocket-Key") == null)
            return false;
          return true;
        }, "call$1", "io__WebSocketTransformerImpl__isUpgradeRequest$closure", 2, 0, 431, 54, [], "_isUpgradeRequest"]
      }
    },
    "+_WebSocketTransformerImpl": [1, 1628],
    _WebSocketTransformerImpl_bind_closure: {
      "^": "Closure:3;$this",
      call$1: [function(request) {
        var t1 = this.$this;
        P._WebSocketTransformerImpl__upgrade(request, t1._protocolSelector, t1._compression).then$1(new P._WebSocketTransformerImpl_bind__closure(t1)).catchError$1(t1._io$_controller.get$addError());
      }, null, null, 2, 0, 3, 54, [], "call"]
    },
    "+ _WebSocketTransformerImpl_bind_closure": [2],
    _WebSocketTransformerImpl_bind__closure: {
      "^": "Closure:375;$this",
      call$1: [function(webSocket) {
        return J.add$1$ax(this.$this._io$_controller, webSocket);
      }, null, null, 2, 0, 375, 307, [], "call"]
    },
    "+ _WebSocketTransformerImpl_bind__closure": [2],
    _WebSocketTransformerImpl_bind_closure0: {
      "^": "Closure:4;$this",
      call$0: [function() {
        this.$this._io$_controller.close$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _WebSocketTransformerImpl_bind_closure": [2],
    _WebSocketTransformerImpl__upgrade_upgrade: {
      "^": "Closure:376;request,compression,response",
      call$1: [function(protocol) {
        var t1, t2, key, sha1, accept, t3, deflate;
        t1 = this.response;
        t1.set$statusCode(101);
        J.add$2$ax(t1.get$headers(), "connection", "Upgrade");
        J.add$2$ax(t1.get$headers(), "upgrade", "websocket");
        t2 = this.request;
        key = t2.get$headers().value$1("Sec-WebSocket-Key");
        sha1 = P._SHA1$();
        sha1.add$1(0, new H.CodeUnits(H.S(key) + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"));
        accept = P._CryptoUtils_bytesToBase64(sha1.close$0(), false, false);
        J.add$2$ax(t1.get$headers(), "Sec-WebSocket-Accept", accept);
        if (protocol != null)
          J.add$2$ax(t1.get$headers(), "Sec-WebSocket-Protocol", protocol);
        t3 = this.compression;
        deflate = P._WebSocketTransformerImpl__negotiateCompression(t2, t1, t3);
        t1.get$headers().set$contentLength(0);
        return t1.detachSocket$0().then$1(new P._WebSocketTransformerImpl__upgrade_upgrade_closure(t3, protocol, deflate));
      }, null, null, 2, 0, 376, 182, [], "call"]
    },
    "+ _WebSocketTransformerImpl__upgrade_upgrade": [2],
    _WebSocketTransformerImpl__upgrade_upgrade_closure: {
      "^": "Closure:3;compression,protocol,deflate",
      call$1: [function(socket) {
        return P._WebSocketImpl$_fromSocket(socket, this.protocol, this.compression, true, this.deflate);
      }, null, null, 2, 0, 3, 52, [], "call"]
    },
    "+ _WebSocketTransformerImpl__upgrade_upgrade_closure": [2],
    _WebSocketTransformerImpl__upgrade_closure: {
      "^": "Closure:4;_box_0,_protocolSelector",
      call$0: [function() {
        return this._protocolSelector.call$1(this._box_0.protocols);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _WebSocketTransformerImpl__upgrade_closure": [2],
    _WebSocketTransformerImpl__upgrade_closure0: {
      "^": "Closure:3;_box_0",
      call$1: [function(protocol) {
        if (J.$lt$n(J.indexOf$1$asx(this._box_0.protocols, protocol), 0))
          throw H.wrapException(new P.WebSocketException("Selected protocol is not in the list of available protocols"));
        return protocol;
      }, null, null, 2, 0, 3, 182, [], "call"]
    },
    "+ _WebSocketTransformerImpl__upgrade_closure": [2],
    _WebSocketTransformerImpl__upgrade_closure1: {
      "^": "Closure:3;response",
      call$1: [function(error) {
        var t1 = this.response;
        t1.set$statusCode(500);
        t1.close$0();
        throw H.wrapException(error);
      }, null, null, 2, 0, 3, 8, [], "call"]
    },
    "+ _WebSocketTransformerImpl__upgrade_closure": [2],
    _WebSocketTransformerImpl__isUpgradeRequest_closure: {
      "^": "Closure:13;_box_0",
      call$1: [function(value) {
        if (J.toLowerCase$0$s(value) === "upgrade")
          this._box_0.isUpgrade = true;
      }, null, null, 2, 0, 13, 1, [], "call"]
    },
    "+ _WebSocketTransformerImpl__isUpgradeRequest_closure": [2],
    _WebSocketPerMessageDeflate: {
      "^": "Object;serverNoContextTakeover@-8,clientNoContextTakeover@-8,clientMaxWindowBits@-0,serverMaxWindowBits@-0,serverSide@-8,decoder@-133,encoder@-133",
      _ensureDecoder$0: [function() {
        if (this.decoder == null)
          this.decoder = P._Filter__newZLibInflateFilter(this.serverSide === true ? this.clientMaxWindowBits : this.serverMaxWindowBits, null, true);
      }, "call$0", "get$_ensureDecoder", 0, 0, 6, "_ensureDecoder"],
      _ensureEncoder$0: [function() {
        if (this.encoder == null)
          this.encoder = P._Filter__newZLibDeflateFilter(false, 6, this.serverSide === true ? this.serverMaxWindowBits : this.clientMaxWindowBits, 8, 0, null, true);
      }, "call$0", "get$_ensureEncoder", 0, 0, 6, "_ensureEncoder"],
      processIncomingMessage$1: [function(msg) {
        var t1, data, result, out;
        if (this.decoder == null)
          this.decoder = P._Filter__newZLibInflateFilter(this.serverSide === true ? this.clientMaxWindowBits : this.serverMaxWindowBits, null, true);
        t1 = [P.int];
        data = H.setRuntimeTypeInfo([], t1);
        C.JSArray_methods.addAll$1(data, msg);
        C.JSArray_methods.addAll$1(data, C.List_0_0_255_255);
        this.decoder.process$3(data, 0, data.length);
        result = H.setRuntimeTypeInfo([], t1);
        for (; out = this.decoder.processed$0(), true;)
          C.JSArray_methods.addAll$1(result, out);
        t1 = this.serverSide === true;
        if (!(t1 && this.clientNoContextTakeover === true))
          t1 = !t1 && this.serverNoContextTakeover === true;
        else
          t1 = true;
        if (t1)
          this.decoder = null;
        return new Uint8Array(H._ensureNativeList(result));
      }, "call$1", "get$processIncomingMessage", 2, 0, 377, 92, [], "processIncomingMessage"],
      processOutgoingMessage$1: [function(msg) {
        var result, t1, i, t2, buffer, out;
        if (this.encoder == null)
          this.encoder = P._Filter__newZLibDeflateFilter(false, 6, this.serverSide === true ? this.serverMaxWindowBits : this.clientMaxWindowBits, 8, 0, null, true);
        result = H.setRuntimeTypeInfo([], [P.int]);
        t1 = J.getInterceptor(msg);
        if (!t1.$isUint8List) {
          i = 0;
          while (true) {
            t2 = t1.get$length(msg);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            if (!J.$lt$n(t1.$index(msg, i), 0)) {
              t2 = t1.$index(msg, i);
              if (typeof t2 !== "number")
                return H.iae(t2);
              t2 = 255 < t2;
            } else
              t2 = true;
            if (t2)
              throw H.wrapException(P.ArgumentError$("List element is not a byte value (value " + H.S(t1.$index(msg, i)) + " at index " + i + ")"));
            ++i;
          }
          buffer = new Uint8Array(H._ensureNativeList(msg));
        } else
          buffer = msg;
        this.encoder.process$3(buffer, 0, J.get$length$asx(buffer));
        for (; out = this.encoder.processed$0(), true;)
          C.JSArray_methods.addAll$1(result, out);
        t1 = this.serverSide === true;
        if (!(!t1 && this.clientNoContextTakeover === true))
          t1 = t1 && this.serverNoContextTakeover === true;
        else
          t1 = true;
        if (t1)
          this.encoder = null;
        t1 = result.length;
        return t1 > 4 ? C.JSArray_methods.sublist$2(result, 0, t1 - 4) : result;
      }, "call$1", "get$processOutgoingMessage", 2, 0, 269, 92, [], "processOutgoingMessage"],
      static: {
        _WebSocketPerMessageDeflate$: [function(clientMaxWindowBits, clientNoContextTakeover, serverMaxWindowBits, serverNoContextTakeover, serverSide) {
          return new P._WebSocketPerMessageDeflate(serverNoContextTakeover, clientNoContextTakeover, clientMaxWindowBits, serverMaxWindowBits, serverSide, null, null);
        }, null, null, 0, 11, 1003, 140, 140, 4, 4, 4, 541, [], 544, [], 538, [], 531, [], 311, [], "new _WebSocketPerMessageDeflate"]
      }
    },
    "+_WebSocketPerMessageDeflate": [1],
    _WebSocketOutgoingTransformer: {
      "^": "Object;webSocket<-526,_eventSink@-525,_deflateHelper@-298",
      bind$1: [function(stream) {
        return new P._BoundSinkStream(new P._WebSocketOutgoingTransformer_bind_closure(this), stream, [null, null]);
      }, "call$1", "get$bind", 2, 0, 1622, 37, [], "bind"],
      add$1: [function(_, message) {
        var t1, data, opcode;
        t1 = J.getInterceptor(message);
        if (!!t1.$is_WebSocketPong) {
          this.addFrame$2(10, message.payload);
          return;
        }
        if (!!t1.$is_WebSocketPing) {
          this.addFrame$2(9, message.payload);
          return;
        }
        if (message != null) {
          if (typeof message === "string") {
            data = C.Utf8Codec_false.get$encoder().convert$1(message);
            opcode = 1;
          } else if (H.checkSubtype(message, "$isList", [P.int], "$asList")) {
            data = message;
            opcode = 2;
          } else {
            if (!!t1.$is_EncodedString)
              data = message.bytes;
            else
              throw H.wrapException(P.ArgumentError$(message));
            opcode = 1;
          }
          t1 = this._deflateHelper;
          if (t1 != null)
            data = t1.processOutgoingMessage$1(data);
        } else {
          data = null;
          opcode = 1;
        }
        this.addFrame$2(opcode, data);
      }, "call$1", "get$add", 2, 0, 27, 17, [], "add"],
      addError$2: [function(error, stackTrace) {
        this._eventSink.addError$2(error, stackTrace);
      }, function(error) {
        return this.addError$2(error, null);
      }, "addError$1", "call$2", "call$1", "get$addError", 2, 2, 48, 0, 8, [], 12, [], "addError"],
      close$0: [function() {
        var t1, code, reason, data;
        t1 = this.webSocket;
        code = t1.get$_outCloseCode();
        reason = t1.get$_outCloseReason();
        if (code != null) {
          data = H.setRuntimeTypeInfo([], [P.int]);
          t1 = J.getInterceptor$n(code);
          data.push(t1.$shr(code, 8) & 255);
          data.push(t1.$and(code, 255));
          if (reason != null)
            C.JSArray_methods.addAll$1(data, C.Utf8Codec_false.get$encoder().convert$1(reason));
        } else
          data = null;
        this.addFrame$2(8, data);
        this._eventSink.close$0();
      }, "call$0", "get$close", 0, 0, 6, "close"],
      addFrame$2: [function(opcode, data) {
        var t1, t2;
        t1 = this.webSocket.get$_serverSide();
        if (this._deflateHelper != null) {
          t2 = J.getInterceptor(opcode);
          t2 = t2.$eq(opcode, 1) || t2.$eq(opcode, 2);
        } else
          t2 = false;
        C.JSArray_methods.forEach$1(P._WebSocketOutgoingTransformer_createFrame(opcode, data, t1, t2), new P._WebSocketOutgoingTransformer_addFrame_closure(this));
      }, "call$2", "get$addFrame", 4, 0, 1625, 598, [], 21, [], "addFrame"],
      static: {
        _WebSocketOutgoingTransformer$: [function(webSocket) {
          var t1 = new P._WebSocketOutgoingTransformer(webSocket, null, null);
          t1._deflateHelper = webSocket.get$_deflate();
          return t1;
        }, null, null, 2, 0, 1004, 307, [], "new _WebSocketOutgoingTransformer"],
        _WebSocketOutgoingTransformer_createFrame: [function(opcode, data, serverSide, compressed) {
          var mask, t1, dataLength, headerSize, t2, t3, header, t4, t5, index, lengthBytes, i, index0;
          mask = serverSide !== true;
          t1 = data == null;
          dataLength = t1 ? 0 : J.get$length$asx(data);
          headerSize = mask ? 6 : 2;
          t2 = J.getInterceptor$n(dataLength);
          if (t2.$gt(dataLength, 65535))
            headerSize += 8;
          else if (t2.$gt(dataLength, 125))
            headerSize += 2;
          t3 = H._checkLength(headerSize);
          header = new Uint8Array(t3);
          t4 = compressed === true ? 64 : 0;
          t5 = J.$and$n(opcode, 15);
          if (typeof t5 !== "number")
            return H.iae(t5);
          if (0 >= t3)
            return H.ioore(header, 0);
          header[0] = (128 | t4 | t5) >>> 0;
          if (t2.$gt(dataLength, 65535)) {
            if (1 >= t3)
              return H.ioore(header, 1);
            header[1] = 127;
            index = 2;
            lengthBytes = 8;
          } else if (t2.$gt(dataLength, 125)) {
            if (1 >= t3)
              return H.ioore(header, 1);
            header[1] = 126;
            index = 2;
            lengthBytes = 2;
          } else {
            index = 1;
            lengthBytes = 1;
          }
          for (t4 = lengthBytes - 1, i = 0; i < lengthBytes; ++i, index = index0) {
            index0 = index + 1;
            t5 = t2.$shr(dataLength, (t4 - i) * 8);
            if (index >= t3)
              return H.ioore(header, index);
            header[index] = t5 & 255;
          }
          if (mask) {
            if (1 >= t3)
              return H.ioore(header, 1);
            header[1] = header[1] | 128;
            P._IOCrypto_getRandomBytes(4);
          }
          if (t1)
            return [header];
          else
            return [header, data];
        }, "call$4", "io__WebSocketOutgoingTransformer_createFrame$closure", 8, 0, 1005, 598, [], 21, [], 311, [], 850, [], "createFrame"]
      }
    },
    "+_WebSocketOutgoingTransformer": [1, 237, 1630],
    _WebSocketOutgoingTransformer_bind_closure: {
      "^": "Closure:378;$this",
      call$1: [function(eventSink) {
        var t1 = this.$this;
        if (t1._eventSink != null)
          throw H.wrapException(new P.StateError("WebSocket transformer already used"));
        t1._eventSink = eventSink;
        return t1;
      }, null, null, 2, 0, 378, 304, [], "call"]
    },
    "+ _WebSocketOutgoingTransformer_bind_closure": [2],
    _WebSocketOutgoingTransformer_addFrame_closure: {
      "^": "Closure:3;$this",
      call$1: [function(e) {
        J.add$1$ax(this.$this._eventSink, e);
      }, null, null, 2, 0, 3, 47, [], "call"]
    },
    "+ _WebSocketOutgoingTransformer_addFrame_closure": [2],
    _WebSocketConsumer: {
      "^": "Object;webSocket<-526,socket<-127,_io$_controller@-236,_io$_subscription@-103,_issuedPause@-8,_closed@-8,_closeCompleter@-41,_completer@-41",
      _onListen$0: [function() {
        var t1 = this._io$_subscription;
        if (t1 != null)
          t1.cancel$0();
      }, "call$0", "get$_onListen", 0, 0, 6, "_onListen"],
      _io$_onPause$0: [function() {
        var t1 = this._io$_subscription;
        if (t1 != null)
          t1.pause$0();
        else
          this._issuedPause = true;
      }, "call$0", "get$_io$_onPause", 0, 0, 6, "_io$_onPause"],
      _io$_onResume$0: [function() {
        var t1 = this._io$_subscription;
        if (t1 != null)
          t1.resume$0();
        else
          this._issuedPause = false;
      }, "call$0", "get$_io$_onResume", 0, 0, 6, "_io$_onResume"],
      _io$_cancel$0: [function() {
        var t1 = this._io$_subscription;
        if (t1 != null) {
          this._io$_subscription = null;
          t1.cancel$0();
        }
      }, "call$0", "get$_io$_cancel", 0, 0, 6, "_io$_cancel"],
      _ensureController$0: [function() {
        var t1, t2, t3;
        if (this._io$_controller != null)
          return;
        t1 = new P._SyncStreamController(null, 0, null, null, this.get$_io$_onPause(), this.get$_io$_onResume(), this.get$_onListen(), [null]);
        this._io$_controller = t1;
        t1 = t1.get$stream();
        t2 = this.webSocket;
        t3 = new P._WebSocketOutgoingTransformer(t2, null, null);
        t3._deflateHelper = t2.get$_deflate();
        this.socket.addStream$1(t3.bind$1(t1)).then$2$onError(new P._WebSocketConsumer__ensureController_closure(this), new P._WebSocketConsumer__ensureController_closure0(this));
      }, "call$0", "get$_ensureController", 0, 0, 4, "_ensureController"],
      _done$2: [function(error, stackTrace) {
        var t1 = this._completer;
        if (t1 == null)
          return false;
        if (error != null)
          t1.completeError$2(error, stackTrace);
        else
          t1.complete$1(this.webSocket);
        this._completer = null;
        return true;
      }, function(error) {
        return this._done$2(error, null);
      }, "_done$1", function() {
        return this._done$2(null, null);
      }, "_done$0", "call$2", "call$1", "call$0", "get$_done", 0, 4, 1637, 0, 0, 8, [], 12, [], "_done"],
      addStream$1: [function(stream) {
        var t1;
        if (this._closed === true) {
          stream.listen$1(null).cancel$0();
          t1 = new P._Future(0, $.Zone__current, null, [null]);
          t1._asyncComplete$1(this.webSocket);
          return t1;
        }
        this._ensureController$0();
        this._completer = new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]);
        t1 = this.get$_done();
        t1 = stream.listen$4$cancelOnError$onDone$onError(new P._WebSocketConsumer_addStream_closure(this), true, t1, t1);
        this._io$_subscription = t1;
        if (this._issuedPause === true) {
          t1.pause$0();
          this._issuedPause = false;
        }
        return this._completer.get$future();
      }, "call$1", "get$addStream", 2, 0, 1642, 37, [], "addStream"],
      close$0: [function() {
        this._ensureController$0();
        this._io$_controller.close$0();
        return this._closeCompleter.get$future().then$1(new P._WebSocketConsumer_close_closure(new P._WebSocketConsumer_close_closeSocket(this)));
      }, "call$0", "get$close", 0, 0, 18, "close"],
      add$1: [function(_, data) {
        if (this._closed === true)
          return;
        this._ensureController$0();
        J.add$1$ax(this._io$_controller, data);
      }, "call$1", "get$add", 2, 0, 27, 21, [], "add"],
      closeSocket$0: [function() {
        this._closed = true;
        this._io$_cancel$0();
        this.close$0();
      }, "call$0", "get$closeSocket", 0, 0, 6, "closeSocket"],
      static: {
        _WebSocketConsumer$: [function(webSocket, socket) {
          return new P._WebSocketConsumer(webSocket, socket, null, null, false, false, new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]), null);
        }, null, null, 4, 0, 1006, 307, [], 52, [], "new _WebSocketConsumer"]
      }
    },
    "+_WebSocketConsumer": [1, 1631],
    _WebSocketConsumer__ensureController_closure: {
      "^": "Closure:3;$this",
      call$1: [function(_) {
        var t1 = this.$this;
        t1._done$0();
        t1._closeCompleter.complete$1(t1.webSocket);
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _WebSocketConsumer__ensureController_closure": [2],
    _WebSocketConsumer__ensureController_closure0: {
      "^": "Closure:80;$this",
      call$2: [function(error, stackTrace) {
        var t1 = this.$this;
        t1._closed = true;
        t1._io$_cancel$0();
        if (error instanceof P.ArgumentError) {
          if (!t1._done$2(error, stackTrace))
            t1._closeCompleter.completeError$2(error, stackTrace);
        } else {
          t1._done$0();
          t1._closeCompleter.complete$1(t1.webSocket);
        }
      }, null, null, 4, 0, 80, 8, [], 12, [], "call"]
    },
    "+ _WebSocketConsumer__ensureController_closure": [2],
    _WebSocketConsumer_addStream_closure: {
      "^": "Closure:3;$this",
      call$1: [function(data) {
        J.add$1$ax(this.$this._io$_controller, data);
      }, null, null, 2, 0, 3, 21, [], "call"]
    },
    "+ _WebSocketConsumer_addStream_closure": [2],
    _WebSocketConsumer_close_closeSocket: {
      "^": "Closure:18;$this",
      call$0: [function() {
        var t1 = this.$this;
        return t1.socket.close$0().catchError$1(new P._WebSocketConsumer_close_closeSocket_closure()).then$1(new P._WebSocketConsumer_close_closeSocket_closure0(t1));
      }, null, null, 0, 0, 18, "call"]
    },
    "+ _WebSocketConsumer_close_closeSocket": [2],
    _WebSocketConsumer_close_closeSocket_closure: {
      "^": "Closure:3;",
      call$1: [function(_) {
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _WebSocketConsumer_close_closeSocket_closure": [2],
    _WebSocketConsumer_close_closeSocket_closure0: {
      "^": "Closure:3;$this",
      call$1: [function(_) {
        return this.$this.webSocket;
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _WebSocketConsumer_close_closeSocket_closure": [2],
    _WebSocketConsumer_close_closure: {
      "^": "Closure:3;closeSocket",
      call$1: [function(_) {
        return this.closeSocket.call$0();
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _WebSocketConsumer_close_closure": [2],
    _WebSocketImpl: {
      "^": "Stream__ServiceObject0;protocol<-9,_io$_controller@-236,_io$_subscription@-103,_sink@-523,_socket<-10,_serverSide<-8,_readyState@-0,_writeClosed@-8,_closeCode@-0,_closeReason@-9,_pingInterval@-65,_pingTimer@-128,_consumer@-1632,_outCloseCode@-0,_outCloseReason@-9,_closeTimer@-128,_deflate@-298,_ServiceObject___serviceId-0",
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        return this._io$_controller.get$stream().listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, onError);
      }, "listen$2$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", function(onData, onDone) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, null);
      }, "listen$2$onDone", function(onData, cancelOnError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, null, null);
      }, "listen$2$cancelOnError", "call$4$cancelOnError$onDone$onError", "call$1", "call$2$onError", "call$3$onDone$onError", "call$3$onDone$onError", "call$2$onDone", "call$2$cancelOnError", "get$listen", 2, 7, 502, 0, 0, 0, 27, [], 20, [], 28, [], 24, [], "listen"],
      get$pingInterval: [function() {
        return this._pingInterval;
      }, null, null, 1, 0, 83, "pingInterval"],
      set$pingInterval: [function(interval) {
        var t1;
        if (this._writeClosed === true)
          return;
        t1 = this._pingTimer;
        if (t1 != null)
          t1.cancel$0();
        this._pingInterval = interval;
        if (interval == null)
          return;
        this._pingTimer = P.Timer_Timer(interval, new P._WebSocketImpl_pingInterval_closure(this));
      }, null, null, 3, 0, 162, 921, [], "pingInterval"],
      get$readyState: [function() {
        return this._readyState;
      }, null, null, 1, 0, 11, "readyState"],
      get$extensions: [function() {
        return;
      }, null, null, 1, 0, 7, "extensions"],
      get$closeCode: [function() {
        return this._closeCode;
      }, null, null, 1, 0, 11, "closeCode"],
      get$closeReason: [function() {
        return this._closeReason;
      }, null, null, 1, 0, 7, "closeReason"],
      add$1: [function(_, data) {
        J.add$1$ax(this._sink, data);
      }, "call$1", "get$add", 2, 0, 27, 21, [], "add"],
      addUtf8Text$1: [function(bytes) {
        if (!H.checkSubtype(bytes, "$isList", [P.int], "$asList"))
          throw H.wrapException(P.ArgumentError$value(bytes, "bytes", "Is not a list of bytes"));
        J.add$1$ax(this._sink, new P._EncodedString(bytes));
      }, "call$1", "get$addUtf8Text", 2, 0, 26, 30, [], "addUtf8Text"],
      addError$2: [function(error, stackTrace) {
        this._sink.addError$2(error, stackTrace);
      }, function(error) {
        return this.addError$2(error, null);
      }, "addError$1", "call$2", "call$1", "get$addError", 2, 2, 81, 0, 8, [], 12, [], "addError"],
      addStream$1: [function(stream) {
        return this._sink.addStream$1(stream);
      }, "call$1", "get$addStream", 2, 0, 1643, 37, [], "addStream"],
      get$done: [function() {
        return this._sink.get$done();
      }, null, null, 1, 0, 18, "done"],
      close$2: [function(code, reason) {
        if (P._WebSocketImpl__isReservedStatusCode(code))
          throw H.wrapException(new P.WebSocketException("Reserved status code " + H.S(code)));
        if (this._outCloseCode == null) {
          this._outCloseCode = code;
          this._outCloseReason = reason;
        }
        if (!this._io$_controller.get$isClosed()) {
          if (!this._io$_controller.get$hasListener() && this._io$_subscription != null)
            this._io$_controller.get$stream().listen$2$cancelOnError(null, true).asFuture$1(null).catchError$1(new P._WebSocketImpl_close_closure());
          if (this._closeTimer == null)
            this._closeTimer = P.Timer_Timer(C.Duration_5000000, new P._WebSocketImpl_close_closure0(this));
        }
        return this._sink.close$0();
      }, function(code) {
        return this.close$2(code, null);
      }, "close$1", function() {
        return this.close$2(null, null);
      }, "close$0", "call$2", "call$1", "call$0", "get$close", 0, 4, 1648, 0, 0, 145, [], 452, [], "close"],
      _io$_close$2: [function(code, reason) {
        if (this._writeClosed === true)
          return;
        if (this._outCloseCode == null) {
          this._outCloseCode = code;
          this._outCloseReason = reason;
        }
        this._writeClosed = true;
        this._consumer.closeSocket$0();
        J.remove$1$ax($.$get$_WebSocketImpl__webSockets(), this.get$_serviceId());
      }, function(code) {
        return this._io$_close$2(code, null);
      }, "_io$_close$1", function() {
        return this._io$_close$2(null, null);
      }, "_io$_close$0", "call$2", "call$1", "call$0", "get$_io$_close", 0, 4, 1652, 0, 0, 145, [], 452, [], "_io$_close"],
      get$_serviceTypePath: [function() {
        return "io/websockets";
      }, null, null, 1, 0, 7, "_serviceTypePath"],
      get$_serviceTypeName: [function() {
        return "WebSocket";
      }, null, null, 1, 0, 7, "_serviceTypeName"],
      _io$_toJSON$1: [function(ref) {
        var r, t1, $name, exception;
        t1 = this._socket;
        $name = H.S(t1.get$address().get$host()) + ":" + H.S(t1.get$port());
        r = P.LinkedHashMap_LinkedHashMap$_literal(["id", this.get$_serviceTypePath() + "/" + H.S(this.get$_serviceId()), "type", this._serviceType$1(ref), "name", $name, "user_name", $name], P.String, null);
        if (ref === true)
          return r;
        try {
          J.$indexSet$ax(r, "socket", t1._io$_toJSON$1(true));
        } catch (exception) {
          H.unwrapException(exception);
          J.$indexSet$ax(r, "socket", P.LinkedHashMap__makeLiteral(["id", this.get$_serviceTypePath() + "/" + H.S(this.get$_serviceId()), "type", "@Socket", "name", "UserSocket", "user_name", "UserSocket"]));
        }
        return r;
      }, "call$1", "get$_io$_toJSON", 2, 0, 361, 151, [], "_io$_toJSON"],
      _WebSocketImpl$_fromSocket$5: function(_socket, protocol, compression, _serverSide, deflate) {
        var t1, t2, t3, t4, t5, transformer, exception;
        t1 = this._socket;
        t2 = $.Zone__current;
        t3 = [null];
        t4 = [null];
        t5 = new P._WebSocketConsumer(this, t1, null, null, false, false, new P._AsyncCompleter(new P._Future(0, t2, null, t3), t4), null);
        this._consumer = t5;
        this._sink = new P._StreamSinkImpl(t5, new P._AsyncCompleter(new P._Future(0, t2, null, t3), t4), null, null, false, false, false, [null]);
        this._readyState = 1;
        this._deflate = deflate;
        t4 = new Array(4);
        t4.fixed$length = Array;
        transformer = new P._WebSocketProtocolTransformer(0, false, false, -1, -1, false, -1, 4, -1, 0, 0, 1005, "", null, this._serverSide, t4, P.BytesBuilder_BytesBuilder(false), deflate);
        t4 = t1.transform$1(transformer).listen$4$cancelOnError$onDone$onError(new P._WebSocketImpl$_fromSocket_closure(this), true, new P._WebSocketImpl$_fromSocket_closure0(this, transformer), new P._WebSocketImpl$_fromSocket_closure1(this));
        this._io$_subscription = t4;
        t4.pause$0();
        t4 = this._io$_subscription.get$resume();
        t3 = this._io$_subscription.get$pause();
        t2 = this._io$_subscription.get$resume();
        this._io$_controller = new P._SyncStreamController(null, 0, null, t4, t3, t2, new P._WebSocketImpl$_fromSocket_closure2(this), [null]);
        J.$indexSet$ax($.$get$_WebSocketImpl__webSockets(), this.get$_serviceId(), this);
        try {
          t1.set$_io$_owner(this);
        } catch (exception) {
          H.unwrapException(exception);
        }
      },
      $isWebSocket: 1,
      $asStream: Isolate.functionThatReturnsNull,
      $isEventSink: 1,
      $asEventSink: Isolate.functionThatReturnsNull,
      static: {
        "^": "_WebSocketImpl__webSockets@-1633,_WebSocketImpl_DEFAULT_WINDOW_BITS<-0,_WebSocketImpl_PER_MESSAGE_DEFLATE<-9,_WebSocketImpl__httpClient<-509",
        _WebSocketImpl_connect: [function(url, protocols, headers, compression) {
          var t1, uri, t2, nonceData, i, t3, nonce, t4, t5, t6, t7;
          t1 = {};
          uri = P.Uri_parse(url, 0, null);
          t1.uri = uri;
          if (!J.$eq$(uri.get$scheme(), "ws") && !J.$eq$(uri.get$scheme(), "wss"))
            throw H.wrapException(new P.WebSocketException("Unsupported URL scheme '" + H.S(uri.get$scheme()) + "'"));
          t2 = H._checkLength(16);
          nonceData = new Uint8Array(t2);
          for (i = 0; i < 16; ++i) {
            t3 = C.C__JSRandom.nextInt$1(256);
            if (i >= t2)
              return H.ioore(nonceData, i);
            nonceData[i] = t3;
          }
          nonce = P._CryptoUtils_bytesToBase64(nonceData, false, false);
          t2 = J.$eq$(t1.uri.get$scheme(), "wss") ? "https" : "http";
          t3 = t1.uri.get$userInfo();
          t4 = t1.uri.get$host();
          t5 = t1.uri.get$port();
          t6 = t1.uri.get$path();
          t7 = t1.uri.get$query();
          uri = P._Uri__Uri(t1.uri.get$fragment(), t4, t6, null, t5, t7, null, t2, t3);
          t1.uri = uri;
          return $.$get$_WebSocketImpl__httpClient()._openUrl$2("GET", uri).then$1(new P._WebSocketImpl_connect_closure(t1, protocols, headers, compression, nonce)).then$1(new P._WebSocketImpl_connect_closure0(t1, compression, nonce));
        }, function(url, protocols, headers) {
          return P._WebSocketImpl_connect(url, protocols, headers, C.CompressionOptions_qty);
        }, "call$4$compression", "call$3", "io__WebSocketImpl_connect$closure", 6, 3, 1007, 178, 75, [], 228, [], 414, [], 113, [], "connect"],
        _WebSocketImpl_negotiateClientCompression: [function(response, compression) {
          var extensionHeader, result, t1;
          extensionHeader = response.get$headers().value$1("Sec-WebSocket-Extensions");
          if (extensionHeader == null)
            extensionHeader = "";
          result = P._HeaderValue$("", null);
          result._parse$4(extensionHeader, ";", ",", false);
          if (compression.get$enabled() === true && J.$eq$(result._io$_value, "permessage-deflate")) {
            t1 = new P._WebSocketImpl_negotiateClientCompression_getWindowBits(result);
            return new P._WebSocketPerMessageDeflate(result.get$parameters().containsKey$1("server_no_context_takeover"), result.get$parameters().containsKey$1("client_no_context_takeover"), t1.call$1("client_max_window_bits"), t1.call$1("server_max_window_bits"), false, null, null);
          }
          return;
        }, "call$2", "io__WebSocketImpl_negotiateClientCompression$closure", 4, 0, 1008, 18, [], 113, [], "negotiateClientCompression"],
        _WebSocketImpl$_fromSocket: [function(_socket, protocol, compression, _serverSide, deflate) {
          var t1 = new P._WebSocketImpl(protocol, null, null, null, _socket, _serverSide, 0, false, null, null, null, null, null, null, null, null, null, 0);
          t1._WebSocketImpl$_fromSocket$5(_socket, protocol, compression, _serverSide, deflate);
          return t1;
        }, null, null, 6, 4, 1009, 4, 0, 148, [], 182, [], 113, [], 578, [], 851, [], "new _WebSocketImpl$_fromSocket"],
        _WebSocketImpl__isReservedStatusCode: [function(code) {
          var t1;
          if (code != null) {
            t1 = J.getInterceptor$n(code);
            if (!t1.$lt(code, 1000))
              if (!t1.$eq(code, 1004))
                if (!t1.$eq(code, 1005))
                  if (!t1.$eq(code, 1006))
                    if (!(t1.$gt(code, 1011) && t1.$lt(code, 1015)))
                      t1 = t1.$ge(code, 1015) && t1.$lt(code, 3000);
                    else
                      t1 = true;
                  else
                    t1 = true;
                else
                  t1 = true;
              else
                t1 = true;
            else
              t1 = true;
          } else
            t1 = false;
          return t1;
        }, "call$1", "io__WebSocketImpl__isReservedStatusCode$closure", 2, 0, 32, 145, [], "_isReservedStatusCode"]
      }
    },
    "+_WebSocketImpl": [1634, 1635],
    Stream__ServiceObject0: {
      "^": "Stream+_ServiceObject;__serviceId:_ServiceObject___serviceId@-0",
      $asStream: Isolate.functionThatReturnsNull,
      "<>": [],
      static: {
        "Stream+_ServiceObject$0": [function() {
          return new P.Stream__ServiceObject0(0);
        }, null, null, 0, 0, 4, "new Stream+_ServiceObject"]
      }
    },
    _WebSocketImpl_connect_closure: {
      "^": "Closure:3;_box_0,protocols,headers,compression,nonce",
      call$1: [function(request) {
        var t1, auth;
        t1 = this._box_0;
        if (t1.uri.get$userInfo() != null && J.get$isEmpty$asx(t1.uri.get$userInfo()) !== true) {
          t1 = t1.uri.get$userInfo();
          auth = P._CryptoUtils_bytesToBase64(C.Utf8Codec_false.get$encoder().convert$1(t1), false, false);
          request.get$headers().$set$2("authorization", "Basic " + auth);
        }
        t1 = this.headers;
        if (t1 != null)
          J.forEach$1$ax(t1, new P._WebSocketImpl_connect__closure1(request));
        t1 = request.get$headers();
        t1.$set$2("connection", "Upgrade");
        t1.$set$2("upgrade", "websocket");
        t1.$set$2("Sec-WebSocket-Key", this.nonce);
        t1.$set$2("Cache-Control", "no-cache");
        t1.$set$2("Sec-WebSocket-Version", "13");
        t1 = this.protocols;
        if (t1 != null)
          J.add$2$ax(request.get$headers(), "Sec-WebSocket-Protocol", J.toList$0$ax(t1));
        t1 = this.compression;
        if (t1.get$enabled() === true)
          J.add$2$ax(request.get$headers(), "Sec-WebSocket-Extensions", t1._createHeader$0());
        return request.close$0();
      }, null, null, 2, 0, 3, 54, [], "call"]
    },
    "+ _WebSocketImpl_connect_closure": [2],
    _WebSocketImpl_connect__closure1: {
      "^": "Closure:12;request",
      call$2: [function(field, value) {
        return J.add$2$ax(this.request.get$headers(), field, value);
      }, null, null, 4, 0, 12, 460, [], 1, [], "call"]
    },
    "+ _WebSocketImpl_connect__closure": [2],
    _WebSocketImpl_connect_closure0: {
      "^": "Closure:3;_box_0,compression,nonce",
      call$1: [function(response) {
        var t1, accept, sha1, expectedAccept, receivedAccept, t2, i, t3, protocol, deflate;
        t1 = new P._WebSocketImpl_connect__error(response);
        if (!J.$eq$(response.get$statusCode(), 101) || J.$index$asx(response.get$headers(), "connection") == null || J.any$1$ax(J.$index$asx(response.get$headers(), "connection"), new P._WebSocketImpl_connect__closure()) !== true || J.toLowerCase$0$s(response.get$headers().value$1("upgrade")) !== "websocket")
          t1.call$1("Connection to '" + H.S(this._box_0.uri) + "' was not upgraded to websocket");
        accept = response.get$headers().value$1("Sec-WebSocket-Accept");
        if (accept == null)
          t1.call$1("Response did not contain a 'Sec-WebSocket-Accept' header");
        sha1 = P._SHA1$();
        sha1.add$1(0, new H.CodeUnits(this.nonce + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"));
        expectedAccept = sha1.close$0();
        receivedAccept = P._CryptoUtils_base64StringToBytes(accept, true);
        t2 = receivedAccept.length;
        if (expectedAccept.length !== t2)
          t1.call$1("Reasponse header 'Sec-WebSocket-Accept' is the wrong length");
        for (i = 0; i < expectedAccept.length; ++i) {
          t3 = expectedAccept[i];
          if (i >= t2)
            return H.ioore(receivedAccept, i);
          if (!J.$eq$(t3, receivedAccept[i]))
            t1.call$1("Bad response 'Sec-WebSocket-Accept' header");
        }
        protocol = response.get$headers().value$1("Sec-WebSocket-Protocol");
        t1 = this.compression;
        deflate = P._WebSocketImpl_negotiateClientCompression(response, t1);
        return response.detachSocket$0().then$1(new P._WebSocketImpl_connect__closure0(t1, protocol, deflate));
      }, null, null, 2, 0, 3, 18, [], "call"]
    },
    "+ _WebSocketImpl_connect_closure": [2],
    _WebSocketImpl_connect__error: {
      "^": "Closure:19;response",
      call$1: [function(message) {
        this.response.detachSocket$0().then$1(new P._WebSocketImpl_connect__error_closure());
        throw H.wrapException(new P.WebSocketException(message));
      }, null, null, 2, 0, 19, 17, [], "call"]
    },
    "+ _WebSocketImpl_connect__error": [2],
    _WebSocketImpl_connect__error_closure: {
      "^": "Closure:3;",
      call$1: [function(socket) {
        socket.destroy$0();
      }, null, null, 2, 0, 3, 52, [], "call"]
    },
    "+ _WebSocketImpl_connect__error_closure": [2],
    _WebSocketImpl_connect__closure: {
      "^": "Closure:3;",
      call$1: [function(value) {
        return J.toLowerCase$0$s(value) === "upgrade";
      }, null, null, 2, 0, 3, 1, [], "call"]
    },
    "+ _WebSocketImpl_connect__closure": [2],
    _WebSocketImpl_connect__closure0: {
      "^": "Closure:3;compression,protocol,deflate",
      call$1: [function(socket) {
        return P._WebSocketImpl$_fromSocket(socket, this.protocol, this.compression, false, this.deflate);
      }, null, null, 2, 0, 3, 52, [], "call"]
    },
    "+ _WebSocketImpl_connect__closure": [2],
    _WebSocketImpl_negotiateClientCompression_getWindowBits: {
      "^": "Closure:31;hv",
      call$1: [function(type) {
        var o = J.$index$asx(this.hv.get$parameters(), type);
        if (o == null)
          return 15;
        return H.Primitives_parseInt(o, null, new P._WebSocketImpl_negotiateClientCompression_getWindowBits_closure());
      }, null, null, 2, 0, 31, 65, [], "call"]
    },
    "+ _WebSocketImpl_negotiateClientCompression_getWindowBits": [2],
    _WebSocketImpl_negotiateClientCompression_getWindowBits_closure: {
      "^": "Closure:3;",
      call$1: [function(s) {
        return 15;
      }, null, null, 2, 0, 3, 49, [], "call"]
    },
    "+ _WebSocketImpl_negotiateClientCompression_getWindowBits_closure": [2],
    _WebSocketImpl$_fromSocket_closure: {
      "^": "Closure:3;$this",
      call$1: [function(data) {
        var t1, t2;
        t1 = J.getInterceptor(data);
        if (!!t1.$is_WebSocketPing) {
          t1 = this.$this;
          if (t1._writeClosed !== true)
            J.add$1$ax(t1._consumer, new P._WebSocketPong(data.payload));
        } else {
          t2 = this.$this;
          if (!!t1.$is_WebSocketPong)
            t2.set$pingInterval(t2._pingInterval);
          else
            J.add$1$ax(t2._io$_controller, data);
        }
      }, null, null, 2, 0, 3, 21, [], "call"]
    },
    "+ _WebSocketImpl$_fromSocket_closure": [2],
    _WebSocketImpl$_fromSocket_closure1: {
      "^": "Closure:12;$this",
      call$2: [function(error, stackTrace) {
        var t1, t2;
        t1 = this.$this;
        t2 = t1._closeTimer;
        if (t2 != null)
          t2.cancel$0();
        if (error instanceof P.FormatException)
          t1._io$_close$1(1007);
        else
          t1._io$_close$1(1002);
        t1._closeCode = t1._outCloseCode;
        t1._closeReason = t1._outCloseReason;
        t1._io$_controller.close$0();
      }, null, null, 4, 0, 12, 8, [], 12, [], "call"]
    },
    "+ _WebSocketImpl$_fromSocket_closure": [2],
    _WebSocketImpl$_fromSocket_closure0: {
      "^": "Closure:4;$this,transformer",
      call$0: [function() {
        var t1, t2;
        t1 = this.$this;
        t2 = t1._closeTimer;
        if (t2 != null)
          t2.cancel$0();
        if (J.$eq$(t1._readyState, 1)) {
          t1._readyState = 2;
          t2 = this.transformer;
          if (!P._WebSocketImpl__isReservedStatusCode(t2.closeCode))
            t1._io$_close$2(t2.closeCode, t2.closeReason);
          else
            t1._io$_close$0();
          t1._readyState = 3;
        }
        t2 = this.transformer;
        t1._closeCode = t2.closeCode;
        t1._closeReason = t2.closeReason;
        t1._io$_controller.close$0();
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _WebSocketImpl$_fromSocket_closure": [2],
    _WebSocketImpl$_fromSocket_closure2: {
      "^": "Closure:4;$this",
      call$0: [function() {
        var t1 = this.$this;
        t1._io$_subscription.cancel$0();
        t1._io$_subscription = null;
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _WebSocketImpl$_fromSocket_closure": [2],
    _WebSocketImpl_pingInterval_closure: {
      "^": "Closure:4;$this",
      call$0: [function() {
        var t1 = this.$this;
        if (t1._writeClosed === true)
          return;
        J.add$1$ax(t1._consumer, new P._WebSocketPing(null));
        t1._pingTimer = P.Timer_Timer(t1._pingInterval, new P._WebSocketImpl_pingInterval__closure(t1));
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _WebSocketImpl_pingInterval_closure": [2],
    _WebSocketImpl_pingInterval__closure: {
      "^": "Closure:4;$this",
      call$0: [function() {
        this.$this._io$_close$1(1001);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _WebSocketImpl_pingInterval__closure": [2],
    _WebSocketImpl_close_closure: {
      "^": "Closure:3;",
      call$1: [function(_) {
        return P.LinkedHashMap__makeEmpty();
      }, null, null, 2, 0, 3, 16, [], "call"]
    },
    "+ _WebSocketImpl_close_closure": [2],
    _WebSocketImpl_close_closure0: {
      "^": "Closure:4;$this",
      call$0: [function() {
        var t1, t2;
        t1 = this.$this;
        t1._closeCode = t1._outCloseCode;
        t1._closeReason = t1._outCloseReason;
        t2 = t1._io$_subscription;
        if (t2 != null)
          t2.cancel$0();
        t1._io$_controller.close$0();
        J.remove$1$ax($.$get$_WebSocketImpl__webSockets(), t1.get$_serviceId());
      }, null, null, 0, 0, 4, "call"]
    },
    "+ _WebSocketImpl_close_closure": [2],
    _BytesConsumer: {
      "^": "",
      $typedefType: 26,
      $$isTypedef: true
    },
    "+_BytesConsumer": "",
    BadCertificateCallback: {
      "^": "",
      $typedefType: 1136,
      $$isTypedef: true
    },
    "+BadCertificateCallback": "",
    _ProtocolSelector: {
      "^": "",
      $typedefType: 436,
      $$isTypedef: true
    },
    "+_ProtocolSelector": ""
  }], ["dart.isolate", "dart:isolate",, P, {
    "^": "",
    Isolate_spawn_closure: {
      "^": "Closure:3;paused,errorsAreFatal,onExit,onError,forcePause",
      call$1: [function(msg) {
        var isolate, t1;
        t1 = J.getInterceptor$asx(msg);
        isolate = new P.Isolate(t1.$index(msg, 1), t1.$index(msg, 2), t1.$index(msg, 3));
        if (this.forcePause) {
          t1 = this.errorsAreFatal;
          if (t1 != null)
            isolate.setErrorsFatal$1(t1);
          t1 = this.onExit;
          if (t1 != null)
            isolate.addOnExitListener$1(t1);
          t1 = this.onError;
          if (t1 != null)
            isolate.addErrorListener$1(t1);
          if (this.paused !== true)
            isolate.resume$1(isolate.get$pauseCapability());
        }
        return isolate;
      }, null, null, 2, 0, 3, 92, [], "call"]
    },
    "+ Isolate_spawn_closure": [2],
    Isolate_spawnUri_closure: {
      "^": "Closure:3;paused,onExit,onError,errorsAreFatal,forcePause",
      call$1: [function(msg) {
        var isolate, t1;
        t1 = J.getInterceptor$asx(msg);
        isolate = new P.Isolate(t1.$index(msg, 1), t1.$index(msg, 2), t1.$index(msg, 3));
        if (this.forcePause) {
          t1 = this.errorsAreFatal;
          if (t1 != null)
            isolate.setErrorsFatal$1(t1);
          t1 = this.onExit;
          if (t1 != null)
            isolate.addOnExitListener$1(t1);
          t1 = this.onError;
          if (t1 != null)
            isolate.addErrorListener$1(t1);
          if (this.paused !== true)
            isolate.resume$1(isolate.get$pauseCapability());
        }
        return isolate;
      }, null, null, 2, 0, 3, 92, [], "call"]
    },
    "+ Isolate_spawnUri_closure": [2],
    Capability: {
      "^": "Object;",
      static: {
        Capability_Capability: [function() {
          return new H.CapabilityImpl(H.random64());
        }, null, null, 0, 0, 1010, "new Capability"]
      }
    },
    "+Capability": [1],
    IsolateSpawnException: {
      "^": "Object;message<-9",
      toString$0: [function(_) {
        return "IsolateSpawnException: " + H.S(this.message);
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isException: 1,
      static: {
        IsolateSpawnException$: [function(message) {
          return new P.IsolateSpawnException(message);
        }, null, null, 2, 0, 13, 17, [], "new IsolateSpawnException"]
      }
    },
    "+IsolateSpawnException": [1, 102],
    Isolate: {
      "^": "Object;controlPort<-491,pauseCapability<-299,terminateCapability<-299",
      pause$1: [function(resumeCapability) {
        var message;
        if (resumeCapability == null)
          resumeCapability = new H.CapabilityImpl(H.random64());
        message = new Array(3);
        message.fixed$length = Array;
        message[0] = "pause";
        message[1] = this.pauseCapability;
        message[2] = resumeCapability;
        this.controlPort.send$1(message);
        return resumeCapability;
      }, function() {
        return this.pause$1(null);
      }, "pause$0", "call$1", "call$0", "get$pause", 0, 2, 1657, 0, 377, [], "pause"],
      _pause$1: [function(resumeCapability) {
        var message = new Array(3);
        message.fixed$length = Array;
        message[0] = "pause";
        message[1] = this.pauseCapability;
        message[2] = resumeCapability;
        this.controlPort.send$1(message);
      }, "call$1", "get$_pause", 2, 0, 379, 377, [], "_pause"],
      resume$1: [function(resumeCapability) {
        var message = new Array(2);
        message.fixed$length = Array;
        message[0] = "resume";
        message[1] = resumeCapability;
        this.controlPort.send$1(message);
      }, "call$1", "get$resume", 2, 0, 379, 377, [], "resume"],
      addOnExitListener$2$response: [function(responsePort, response) {
        var message = new Array(3);
        message.fixed$length = Array;
        message[0] = "add-ondone";
        message[1] = responsePort;
        message[2] = response;
        this.controlPort.send$1(message);
      }, function(responsePort) {
        return this.addOnExitListener$2$response(responsePort, null);
      }, "addOnExitListener$1", "call$2$response", "call$1", "get$addOnExitListener", 2, 3, 1662, 0, 354, [], 18, [], "addOnExitListener"],
      removeOnExitListener$1: [function(responsePort) {
        var message = new Array(2);
        message.fixed$length = Array;
        message[0] = "remove-ondone";
        message[1] = responsePort;
        this.controlPort.send$1(message);
      }, "call$1", "get$removeOnExitListener", 2, 0, 174, 354, [], "removeOnExitListener"],
      setErrorsFatal$1: [function(errorsAreFatal) {
        var message = new Array(3);
        message.fixed$length = Array;
        message[0] = "set-errors-fatal";
        message[1] = this.terminateCapability;
        message[2] = errorsAreFatal;
        this.controlPort.send$1(message);
      }, "call$1", "get$setErrorsFatal", 2, 0, 35, 313, [], "setErrorsFatal"],
      kill$1$priority: [function(priority) {
        this.controlPort.send$1(["kill", this.terminateCapability, priority]);
      }, function() {
        return this.kill$1$priority(1);
      }, "kill$0", "call$1$priority", "call$0", "get$kill", 0, 3, 1665, 195, 536, [], "kill"],
      ping$3$priority$response: [function(responsePort, priority, response) {
        var message = new Array(4);
        message.fixed$length = Array;
        message[0] = "ping";
        message[1] = responsePort;
        message[2] = priority;
        message[3] = response;
        this.controlPort.send$1(message);
      }, function(responsePort) {
        return this.ping$3$priority$response(responsePort, 0, null);
      }, "ping$1", "call$3$priority$response", "call$1", "get$ping", 2, 5, 1666, 0, 7, 354, [], 18, [], 536, [], "ping"],
      addErrorListener$1: [function(port) {
        var message = new Array(2);
        message.fixed$length = Array;
        message[0] = "getErrors";
        message[1] = port;
        this.controlPort.send$1(message);
      }, "call$1", "get$addErrorListener", 2, 0, 174, 26, [], "addErrorListener"],
      removeErrorListener$1: [function(port) {
        var message = new Array(2);
        message.fixed$length = Array;
        message[0] = "stopErrors";
        message[1] = port;
        this.controlPort.send$1(message);
      }, "call$1", "get$removeErrorListener", 2, 0, 174, 26, [], "removeErrorListener"],
      get$errors: [function() {
        var t1, controller;
        t1 = {};
        t1.controller = null;
        t1.port = null;
        controller = new P._SyncBroadcastStreamController(new P.Isolate_errors_closure(t1, this, new P.Isolate_errors_handleError(t1)), new P.Isolate_errors_closure0(t1, this), 0, null, null, null, null, [null]);
        t1.controller = controller;
        return new P._BroadcastStream(controller, [H.getTypeArgumentByIndex(controller, 0)]);
      }, null, null, 1, 0, 538, "errors"],
      static: {
        "^": "Isolate_IMMEDIATE<-0,Isolate_BEFORE_NEXT_EVENT<-0,Isolate__currentIsolateCache<-10,Isolate__packageBase@-36",
        Isolate$: [function(controlPort, pauseCapability, terminateCapability) {
          return new P.Isolate(controlPort, pauseCapability, terminateCapability);
        }, null, null, 2, 5, 1011, 0, 0, 923, [], 924, [], 925, [], "new Isolate"],
        Isolate_current: [function() {
          return $.$get$Isolate__currentIsolateCache();
        }, null, null, 1, 0, 1012, "current"],
        Isolate_packageRoot: [function() {
          throw H.wrapException(new P.UnsupportedError("Isolate.packageRoot"));
        }, null, null, 1, 0, 433, "packageRoot"],
        Isolate_packageConfig: [function() {
          throw H.wrapException(new P.UnsupportedError("Isolate.packageConfig"));
        }, null, null, 1, 0, 433, "packageConfig"],
        Isolate_resolvePackageUri: [function(packageUri) {
          if (!J.$eq$(packageUri.get$scheme(), "package"))
            return packageUri;
          return $.$get$Isolate__packageBase().resolveUri$1(packageUri.replace$1$scheme(""));
        }, "call$1", "isolate_Isolate_resolvePackageUri$closure", 2, 0, 1014, 926, [], "resolvePackageUri"],
        Isolate_spawn: [function(entryPoint, message, errorsAreFatal, onError, onExit, paused) {
          var forcePause, e, st, t1, $name, exception;
          forcePause = errorsAreFatal != null || onExit != null || onError != null;
          try {
            if (!H.functionTypeTest(entryPoint, {func: 1, args: [,]})) {
              t1 = P.ArgumentError$(entryPoint);
              throw H.wrapException(t1);
            }
            t1 = paused === true || forcePause === true;
            $.IsolateNatives_enableSpawnWorker = true;
            $name = entryPoint instanceof H.Closure ? entryPoint.$static_name : null;
            if ($name == null)
              H.throwExpression(new P.UnsupportedError("only top-level functions can be spawned."));
            t1 = H.IsolateNatives_spawn($name, null, null, message, false, false, t1).then$1(new P.Isolate_spawn_closure(paused, errorsAreFatal, onExit, onError, forcePause));
            return t1;
          } catch (exception) {
            t1 = H.unwrapException(exception);
            e = t1;
            st = H.getTraceFromException(exception);
            return P.Future_Future$error(e, st, P.Isolate);
          }
        }, function(entryPoint, message) {
          return P.Isolate_spawn(entryPoint, message, null, null, null, false);
        }, "call$6$errorsAreFatal$onError$onExit$paused", "call$2", "isolate_Isolate_spawn$closure", 4, 9, 1015, 4, 0, 0, 0, 927, [], 17, [], 501, [], 313, [], 586, [], 20, [], "spawn"],
        Isolate_spawnUri: [function(uri, args, message, automaticPackageResolution, checked, environment, errorsAreFatal, onError, onExit, packageConfig, packageRoot, paused) {
          var forcePause, i, e, st, t1, t2, exception;
          if (environment != null)
            throw H.wrapException(new P.UnimplementedError("environment"));
          if (packageRoot != null)
            throw H.wrapException(new P.UnimplementedError("packageRoot"));
          if (packageConfig != null)
            throw H.wrapException(new P.UnimplementedError("packageConfig"));
          forcePause = errorsAreFatal != null || onExit != null || onError != null;
          try {
            if (H.checkSubtype(args, "$isList", [P.String], "$asList"))
              for (i = 0, t1 = J.getInterceptor$asx(args); J.$lt$n(i, t1.get$length(args)); i = J.$add$ns(i, 1)) {
                t2 = t1.$index(args, i);
                if (typeof t2 !== "string") {
                  t1 = P.ArgumentError$("Args must be a list of Strings " + H.S(args));
                  throw H.wrapException(t1);
                }
              }
            else if (args != null) {
              t1 = P.ArgumentError$("Args must be a list of Strings " + H.S(args));
              throw H.wrapException(t1);
            }
            t1 = paused === true || forcePause === true;
            $.IsolateNatives_enableSpawnWorker = true;
            t1 = H.IsolateNatives_spawn(null, J.toString$0$(uri), args, message, false, true, t1).then$1(new P.Isolate_spawnUri_closure(paused, onExit, onError, errorsAreFatal, forcePause));
            return t1;
          } catch (exception) {
            t1 = H.unwrapException(exception);
            e = t1;
            st = H.getTraceFromException(exception);
            return P.Future_Future$error(e, st, P.Isolate);
          }
        }, function(uri, args, message) {
          return P.Isolate_spawnUri(uri, args, message, false, null, null, null, null, null, null, null, false);
        }, "call$12$automaticPackageResolution$checked$environment$errorsAreFatal$onError$onExit$packageConfig$packageRoot$paused", "call$3", "isolate_Isolate_spawnUri$closure", 6, 19, 1016, 4, 0, 0, 0, 0, 0, 0, 0, 4, 40, [], 360, [], 17, [], 501, [], 586, [], 20, [], 313, [], 932, [], 155, [], 933, [], 934, [], 935, [], "spawnUri"]
      }
    },
    "+Isolate": [1],
    Isolate_errors_handleError: {
      "^": "Closure:27;_box_0",
      call$1: [function(message) {
        var t1, errorDescription;
        t1 = J.getInterceptor$asx(message);
        errorDescription = t1.$index(message, 0);
        t1 = new P._StringStackTrace(t1.$index(message, 1));
        this._box_0.controller.addError$2(new P.RemoteError(errorDescription, t1), t1);
      }, null, null, 2, 0, 27, 17, [], "call"]
    },
    "+ Isolate_errors_handleError": [2],
    Isolate_errors_closure: {
      "^": "Closure:4;_box_0,$this,handleError",
      call$0: [function() {
        var t1, port, t2;
        t1 = $.RawReceivePortImpl__nextFreeId;
        $.RawReceivePortImpl__nextFreeId = t1 + 1;
        port = new H.RawReceivePortImpl(t1, this.handleError, false);
        t2 = init.globalState.currentContext;
        t2._addRegistration$2(t1, port);
        t2._updateGlobalState$0();
        this._box_0.port = port;
        this.$this.addErrorListener$1(new H._NativeJsSendPort(port, init.globalState.currentContext.id));
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Isolate_errors_closure": [2],
    Isolate_errors_closure0: {
      "^": "Closure:4;_box_0,$this",
      call$0: [function() {
        var t1, t2, t3, message;
        t1 = this._box_0;
        t2 = t1.port;
        t2.toString;
        t3 = init.globalState.currentContext.id;
        message = new Array(2);
        message.fixed$length = Array;
        message[0] = "stopErrors";
        message[1] = new H._NativeJsSendPort(t2, t3);
        this.$this.controlPort.send$1(message);
        t1.port.close$0();
        t1.port = null;
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Isolate_errors_closure": [2],
    SendPort: {
      "^": "Object;",
      static: {
        SendPort$: [function() {
          return new P.SendPort();
        }, null, null, 0, 0, 302, "new SendPort"]
      }
    },
    "+SendPort": [1, 299],
    ReceivePort: {
      "^": "Object;",
      static: {
        ReceivePort_ReceivePort: [function() {
          var t1, t2, t3;
          t1 = $.RawReceivePortImpl__nextFreeId;
          $.RawReceivePortImpl__nextFreeId = t1 + 1;
          t2 = new H.RawReceivePortImpl(t1, null, false);
          t3 = init.globalState.currentContext;
          t3._addRegistration$2(t1, t2);
          t3._updateGlobalState$0();
          t3 = new H.ReceivePortImpl(t2, null);
          t3.ReceivePortImpl$fromRawReceivePort$1(t2);
          return t3;
        }, null, null, 0, 0, 1017, "new ReceivePort"],
        ReceivePort_ReceivePort$fromRawReceivePort: [function(rawPort) {
          return H.ReceivePortImpl$fromRawReceivePort(rawPort);
        }, null, null, 2, 0, 1018, 936, [], "new ReceivePort$fromRawReceivePort"]
      }
    },
    "+ReceivePort": [1, 524],
    RawReceivePort: {
      "^": "Object;",
      static: {
        RawReceivePort_RawReceivePort: [function(handler) {
          var t1, t2, t3;
          t1 = $.RawReceivePortImpl__nextFreeId;
          $.RawReceivePortImpl__nextFreeId = t1 + 1;
          t2 = new H.RawReceivePortImpl(t1, handler, false);
          t3 = init.globalState.currentContext;
          t3._addRegistration$2(t1, t2);
          t3._updateGlobalState$0();
          return t2;
        }, null, null, 0, 2, 1019, 0, 358, [], "new RawReceivePort"]
      }
    },
    "+RawReceivePort": [1],
    RemoteError: {
      "^": "Object;_description<-9,stackTrace<-221",
      toString$0: [function(_) {
        return this._description;
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isError: 1,
      static: {
        RemoteError$: [function(description, stackDescription) {
          return new P.RemoteError(description, new P._StringStackTrace(stackDescription));
        }, null, null, 4, 0, 40, 298, [], 937, [], "new RemoteError"]
      }
    },
    "+RemoteError": [1, 34],
    _UnaryFunction: {
      "^": "",
      $typedefType: 3,
      $$isTypedef: true
    },
    "+_UnaryFunction": ""
  }], ["dart.math", "dart:math",, P, {
    "^": "SQRT2<-23,SQRT1_2<-23,PI<-23,LOG10E<-23,LOG2E<-23,LN2<-23,LN10<-23,E<-23",
    min: [function(a, b) {
      if (typeof a !== "number")
        throw H.wrapException(P.ArgumentError$(a));
      if (typeof b !== "number")
        throw H.wrapException(P.ArgumentError$(b));
      if (a > b)
        return b;
      if (a < b)
        return a;
      if (typeof b === "number") {
        if (typeof a === "number")
          if (a === 0)
            return (a + b) * a * b;
        if (a === 0 && C.JSDouble_methods.get$isNegative(b) || C.JSDouble_methods.get$isNaN(b))
          return b;
        return a;
      }
      return a;
    }, "call$2", "math__min$closure", 4, 0, function() {
      return {func: 1, args: [,,]};
    }, 87, [], 78, [], "min"],
    max: [function(a, b) {
      if (typeof a !== "number")
        throw H.wrapException(P.ArgumentError$(a));
      if (typeof b !== "number")
        throw H.wrapException(P.ArgumentError$(b));
      if (a > b)
        return a;
      if (a < b)
        return b;
      if (typeof b === "number") {
        if (typeof a === "number")
          if (a === 0)
            return a + b;
        if (C.JSDouble_methods.get$isNaN(b))
          return b;
        return a;
      }
      if (b === 0 && C.JSNumber_methods.get$isNegative(a))
        return b;
      return a;
    }, "call$2", "math__max$closure", 4, 0, function() {
      return {func: 1, args: [,,]};
    }, 87, [], 78, [], "max"],
    atan2: [function(a, b) {
      return Math.atan2(H.checkNum(a), H.checkNum(b));
    }, "call$2", "math__atan2$closure", 4, 0, 1022, 87, [], 78, [], "atan2"],
    pow: [function(x, exponent) {
      H.checkNum(x);
      H.checkNum(exponent);
      return Math.pow(x, exponent);
    }, "call$2", "math__pow$closure", 4, 0, 1023, 38, [], 942, [], "pow"],
    sin: [function(x) {
      return Math.sin(H.checkNum(x));
    }, "call$1", "math__sin$closure", 2, 0, 72, 38, [], "sin"],
    cos: [function(x) {
      return Math.cos(H.checkNum(x));
    }, "call$1", "math__cos$closure", 2, 0, 72, 38, [], "cos"],
    tan: [function(x) {
      return Math.tan(H.checkNum(x));
    }, "call$1", "math__tan$closure", 2, 0, 72, 38, [], "tan"],
    acos: [function(x) {
      return Math.acos(H.checkNum(x));
    }, "call$1", "math__acos$closure", 2, 0, 72, 38, [], "acos"],
    asin: [function(x) {
      return Math.asin(H.checkNum(x));
    }, "call$1", "math__asin$closure", 2, 0, 72, 38, [], "asin"],
    atan: [function(x) {
      return Math.atan(H.checkNum(x));
    }, "call$1", "math__atan$closure", 2, 0, 72, 38, [], "atan"],
    sqrt: [function(x) {
      return Math.sqrt(H.checkNum(x));
    }, "call$1", "math__sqrt$closure", 2, 0, 72, 38, [], "sqrt"],
    exp: [function(x) {
      return Math.exp(H.checkNum(x));
    }, "call$1", "math__exp$closure", 2, 0, 72, 38, [], "exp"],
    log0: [function(x) {
      return Math.log(H.checkNum(x));
    }, "call$1", "math__log$closure", 2, 0, 72, 38, [], "log"],
    _clampToZero: [function(value) {
      return J.$mul$ns(J.$negate$n(value), 0);
    }, "call$1", "math___clampToZero$closure", 2, 0, function() {
      return {func: 1, args: [,]};
    }, 1, [], "_clampToZero"],
    _JSRandom: {
      "^": "Object;",
      nextInt$1: [function(max) {
        var t1 = J.getInterceptor$n(max);
        if (t1.$le(max, 0) || t1.$gt(max, 4294967296))
          throw H.wrapException(P.RangeError$("max must be in range 0 < max \u2264 2^32, was " + H.S(max)));
        return Math.random() * max >>> 0;
      }, "call$1", "get$nextInt", 2, 0, 16, 297, [], "nextInt"],
      nextDouble$0: [function() {
        return Math.random();
      }, "call$0", "get$nextDouble", 0, 0, 52, "nextDouble"],
      nextBool$0: [function() {
        return Math.random() < 0.5;
      }, "call$0", "get$nextBool", 0, 0, 5, "nextBool"]
    },
    "+_JSRandom": 0,
    _Random: {
      "^": "Object;_lo,_hi",
      _nextState$0: function() {
        var t1, tmpHi, tmpHiLo, tmpLo, tmpLoLo, newLo;
        t1 = this._lo;
        tmpHi = 4294901760 * t1;
        tmpHiLo = (tmpHi & 4294967295) >>> 0;
        tmpLo = 55905 * t1;
        tmpLoLo = (tmpLo & 4294967295) >>> 0;
        newLo = tmpLoLo + tmpHiLo + this._hi;
        t1 = (newLo & 4294967295) >>> 0;
        this._lo = t1;
        this._hi = (C.JSInt_methods._tdivFast$1(tmpLo - tmpLoLo + (tmpHi - tmpHiLo) + (newLo - t1), 4294967296) & 4294967295) >>> 0;
      },
      nextInt$1: [function(max) {
        var t1, t2, rnd32, result;
        t1 = J.getInterceptor$n(max);
        if (t1.$le(max, 0) || t1.$gt(max, 4294967296))
          throw H.wrapException(P.RangeError$("max must be in range 0 < max \u2264 2^32, was " + H.S(max)));
        if (t1.$and(max, t1.$sub(max, 1)) === 0) {
          this._nextState$0();
          t2 = this._lo;
          t1 = t1.$sub(max, 1);
          if (typeof t1 !== "number")
            return H.iae(t1);
          return (t2 & t1) >>> 0;
        }
        t1 = typeof max !== "number";
        do {
          this._nextState$0();
          rnd32 = this._lo;
          if (t1)
            H.throwExpression(H.argumentErrorValue(max));
          result = rnd32 % max;
          if (typeof max !== "number")
            return H.iae(max);
        } while (rnd32 - result + max >= 4294967296);
        return result;
      }, "call$1", "get$nextInt", 2, 0, 16, 297, [], "nextInt"],
      nextDouble$0: [function() {
        this._nextState$0();
        var t1 = this._lo;
        this._nextState$0();
        return ((t1 & 67108863) * 134217728 + (this._lo & 134217727)) / 9007199254740992;
      }, "call$0", "get$nextDouble", 0, 0, 52, "nextDouble"],
      nextBool$0: [function() {
        this._nextState$0();
        return (this._lo & 1) === 0;
      }, "call$0", "get$nextBool", 0, 0, 5, "nextBool"],
      _Random$1: function(seed) {
        var empty_seed, t1, low, high, tmplow, t2, low0, t3;
        empty_seed = J.$lt$n(seed, 0) ? -1 : 0;
        do {
          t1 = J.getInterceptor$n(seed);
          low = t1.$and(seed, 4294967295);
          seed = J.$tdiv$n(t1.$sub(seed, low), 4294967296);
          t1 = J.getInterceptor$n(seed);
          high = t1.$and(seed, 4294967295);
          seed = J.$tdiv$n(t1.$sub(seed, high), 4294967296);
          t1 = J.getInterceptor$in(low);
          tmplow = t1.$shl(low, 21);
          t2 = t1.$shr(low, 11);
          tmplow = ((t1.$not(low) & 4294967295) >>> 0) + tmplow;
          low = (tmplow & 4294967295) >>> 0;
          high = (~high >>> 0) + ((high << 21 | t2) >>> 0) + C.JSInt_methods._tdivFast$1(tmplow - low, 4294967296) & 4294967295;
          tmplow = ((low ^ (low >>> 24 | high << 8)) >>> 0) * 265;
          low = (tmplow & 4294967295) >>> 0;
          high = ((high ^ high >>> 24) >>> 0) * 265 + C.JSInt_methods._tdivFast$1(tmplow - low, 4294967296) & 4294967295;
          tmplow = ((low ^ (low >>> 14 | high << 18)) >>> 0) * 21;
          low = (tmplow & 4294967295) >>> 0;
          high = ((high ^ high >>> 14) >>> 0) * 21 + C.JSInt_methods._tdivFast$1(tmplow - low, 4294967296) & 4294967295;
          low = (low ^ (low >>> 28 | high << 4)) >>> 0;
          high = (high ^ high >>> 28) >>> 0;
          tmplow = (low << 31 >>> 0) + low;
          low0 = (tmplow & 4294967295) >>> 0;
          t2 = C.JSInt_methods._tdivFast$1(tmplow - low0, 4294967296);
          tmplow = this._lo * 1037;
          t1 = (tmplow & 4294967295) >>> 0;
          this._lo = t1;
          t3 = (this._hi * 1037 + C.JSInt_methods._tdivFast$1(tmplow - t1, 4294967296) & 4294967295) >>> 0;
          this._hi = t3;
          this._lo = (t1 ^ low0) >>> 0;
          this._hi = (t3 ^ high + ((high << 31 | low >>> 1) >>> 0) + t2 & 4294967295) >>> 0;
        } while (!J.$eq$(seed, empty_seed));
        if (this._hi === 0 && this._lo === 0)
          this._lo = 23063;
        this._nextState$0();
        this._nextState$0();
        this._nextState$0();
        this._nextState$0();
      },
      static: {
        _Random$: function(seed) {
          var t1 = new P._Random(0, 0);
          t1._Random$1(seed);
          return t1;
        }
      }
    },
    "+_Random": 0,
    _JSSecureRandom: {
      "^": "Object;_math$_buffer",
      nextBool$0: [function() {
        var t1, t2;
        t1 = this._math$_buffer;
        t2 = t1.buffer;
        crypto.getRandomValues((t2 && C.NativeByteBuffer_methods).asUint8List$2(t2, 0, 1));
        t1 = t1.getUint8(0);
        t1.toString;
        if (typeof t1 !== "number")
          return t1.$and();
        return (t1 & 1) === 1;
      }, "call$0", "get$nextBool", 0, 0, 5, "nextBool"],
      nextDouble$0: [function() {
        var t1, t2, highByte, result;
        t1 = this._math$_buffer;
        t2 = t1.buffer;
        crypto.getRandomValues((t2 && C.NativeByteBuffer_methods).asUint8List$2(t2, 1, 7));
        t1.setUint8(0, 63);
        highByte = t1.getUint8(1);
        if (typeof highByte !== "number")
          return highByte.$or();
        t1.setUint8(1, (highByte | 240) >>> 0);
        result = t1.getFloat64(0, false) - 1;
        return (highByte & 16) !== 0 ? result + 11102230246251565e-32 : result;
      }, "call$0", "get$nextDouble", 0, 0, 52, "nextDouble"],
      nextInt$1: [function(max) {
        var t1, byteCount, t2, start, randomLimit, t3, t4, random, result;
        t1 = J.getInterceptor$n(max);
        if (t1.$le(max, 0) || t1.$gt(max, 4294967296))
          throw H.wrapException(P.RangeError$("max must be in range 0 < max \u2264 2^32, was " + H.S(max)));
        if (t1.$gt(max, 255))
          if (t1.$gt(max, 65535))
            byteCount = t1.$gt(max, 16777215) ? 4 : 3;
          else
            byteCount = 2;
        else
          byteCount = 1;
        t2 = this._math$_buffer;
        t2.setUint32(0, 0, false);
        start = 4 - byteCount;
        randomLimit = Math.pow(256, byteCount);
        for (t3 = typeof max !== "number"; true;) {
          t4 = t2.buffer;
          crypto.getRandomValues((t4 && C.NativeByteBuffer_methods).asUint8List$2(t4, start, byteCount));
          random = t2.getUint32(0, false);
          if (t1.$and(max, t1.$sub(max, 1)) === 0) {
            t2 = t1.$sub(max, 1);
            if (typeof t2 !== "number")
              return H.iae(t2);
            return (random & t2) >>> 0;
          }
          if (t3)
            H.throwExpression(H.argumentErrorValue(max));
          result = random % max;
          if (typeof max !== "number")
            return H.iae(max);
          if (random - result + max < randomLimit)
            return result;
        }
      }, "call$1", "get$nextInt", 2, 0, 16, 297, [], "nextInt"],
      _JSSecureRandom$0: function() {
        var $crypto = self.crypto;
        if ($crypto != null)
          if ($crypto.getRandomValues != null)
            return;
        throw H.wrapException(new P.UnsupportedError("No source of cryptographically secure random numbers available."));
      },
      static: {
        _JSSecureRandom$: function() {
          var t1 = new P._JSSecureRandom(new DataView(new ArrayBuffer(H._checkLength(8))));
          t1._JSSecureRandom$0();
          return t1;
        }
      }
    },
    "+_JSSecureRandom": 0,
    _JenkinsSmiHash: {
      "^": "Object;",
      static: {
        _JenkinsSmiHash$: [function() {
          return new P._JenkinsSmiHash();
        }, null, null, 0, 0, 1020, "new _JenkinsSmiHash"],
        _JenkinsSmiHash_combine: [function(hash, value) {
          var t1 = J.$add$ns(hash, value);
          if (typeof t1 !== "number")
            return H.iae(t1);
          hash = 536870911 & t1;
          hash = 536870911 & hash + ((524287 & hash) << 10);
          return hash ^ hash >>> 6;
        }, "call$2", "math__JenkinsSmiHash_combine$closure", 4, 0, 70, 524, [], 1, [], "combine"],
        _JenkinsSmiHash_finish: [function(hash) {
          if (typeof hash !== "number")
            return H.iae(hash);
          hash = 536870911 & hash + ((67108863 & hash) << 3);
          hash ^= hash >>> 11;
          return 536870911 & hash + ((16383 & hash) << 15);
        }, "call$1", "math__JenkinsSmiHash_finish$closure", 2, 0, 16, 524, [], "finish"],
        _JenkinsSmiHash_hash2: [function(a, b) {
          return P._JenkinsSmiHash_finish(P._JenkinsSmiHash_combine(P._JenkinsSmiHash_combine(0, a), b));
        }, "call$2", "math__JenkinsSmiHash_hash2$closure", 4, 0, 393, 87, [], 78, [], "hash2"],
        _JenkinsSmiHash_hash4: [function(a, b, c, d) {
          return P._JenkinsSmiHash_finish(P._JenkinsSmiHash_combine(P._JenkinsSmiHash_combine(P._JenkinsSmiHash_combine(P._JenkinsSmiHash_combine(0, a), b), c), d));
        }, "call$4", "math__JenkinsSmiHash_hash4$closure", 8, 0, 1021, 87, [], 78, [], 301, [], 306, [], "hash4"]
      }
    },
    "+_JenkinsSmiHash": [1],
    Point: {
      "^": "Object;x<-528,y<-528,$ti",
      toString$0: [function(_) {
        return "Point(" + H.S(this.x) + ", " + H.S(this.y) + ")";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        if (!(other instanceof P.Point))
          return false;
        return J.$eq$(this.x, other.x) && J.$eq$(this.y, other.y);
      }, null, "get$==", 2, 0, 24, 2, [], "=="],
      get$hashCode: [function(_) {
        var t1, t2;
        t1 = J.get$hashCode$(this.x);
        t2 = J.get$hashCode$(this.y);
        return P._JenkinsSmiHash_finish(P._JenkinsSmiHash_combine(P._JenkinsSmiHash_combine(0, t1), t2));
      }, null, null, 1, 0, 11, "hashCode"],
      $add: [function(_, other) {
        return new P.Point(J.$add$ns(this.x, other.get$x()), J.$add$ns(this.y, other.get$y()), this.$ti);
      }, null, "get$+", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Point, T], args: [[P.Point, T]]};
        }, this.$receiver, "Point");
      }, 2, [], "+"],
      $sub: [function(_, other) {
        return new P.Point(J.$sub$n(this.x, other.get$x()), J.$sub$n(this.y, other.get$y()), this.$ti);
      }, null, "get$-", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Point, T], args: [[P.Point, T]]};
        }, this.$receiver, "Point");
      }, 2, [], "-"],
      $mul: [function(_, factor) {
        return new P.Point(J.$mul$ns(this.x, factor), J.$mul$ns(this.y, factor), this.$ti);
      }, null, "get$*", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Point, T], args: [P.num]};
        }, this.$receiver, "Point");
      }, 616, [], "*"],
      get$magnitude: [function() {
        var t1, t2;
        t1 = this.x;
        t2 = this.y;
        return Math.sqrt(H.checkNum(J.$add$ns(J.$mul$ns(t1, t1), J.$mul$ns(t2, t2))));
      }, null, null, 1, 0, 52, "magnitude"],
      distanceTo$1: [function(other) {
        var dx, dy;
        dx = J.$sub$n(this.x, other.get$x());
        dy = J.$sub$n(this.y, other.get$y());
        return Math.sqrt(H.checkNum(J.$add$ns(J.$mul$ns(dx, dx), J.$mul$ns(dy, dy))));
      }, "call$1", "get$distanceTo", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: P.double, args: [[P.Point, T]]};
        }, this.$receiver, "Point");
      }, 2, [], "distanceTo"],
      squaredDistanceTo$1: [function(other) {
        var dx, dy;
        dx = J.$sub$n(this.x, other.get$x());
        dy = J.$sub$n(this.y, other.get$y());
        return J.$add$ns(J.$mul$ns(dx, dx), J.$mul$ns(dy, dy));
      }, "call$1", "get$squaredDistanceTo", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: T, args: [[P.Point, T]]};
        }, this.$receiver, "Point");
      }, 2, [], "squaredDistanceTo"],
      "<>": [491],
      static: {
        Point$: [function(x, y, $T) {
          return new P.Point(x, y, [$T]);
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [T, T]};
          }, this.$receiver, "Point");
        }, 38, [], 132, [], "new Point"]
      }
    },
    "+Point": [1],
    Random: {
      "^": "Object;",
      static: {
        "^": "Random__secureRandom<-10",
        Random_Random: [function(seed) {
          return seed == null ? C.C__JSRandom : P._Random$(seed);
        }, null, null, 0, 2, 1025, 0, 943, [], "new Random"],
        Random_Random$secure: [function() {
          return $.$get$Random__secureRandom();
        }, null, null, 0, 0, 1026, "new Random$secure"]
      }
    },
    "+Random": [1],
    _RectangleBase: {
      "^": "Object;$ti",
      get$right: [function() {
        return J.$add$ns(this.get$left(), this.get$width());
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: T};
        }, this.$receiver, "_RectangleBase");
      }, "right"],
      get$bottom: [function() {
        return J.$add$ns(this.get$top(), this.get$height());
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: T};
        }, this.$receiver, "_RectangleBase");
      }, "bottom"],
      toString$0: [function(_) {
        return "Rectangle (" + H.S(this.get$left()) + ", " + H.S(this.get$top()) + ") " + H.S(this.get$width()) + " x " + H.S(this.get$height());
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        if (!J.getInterceptor(other).$isRectangle)
          return false;
        return J.$eq$(this.get$left(), other.get$left()) && J.$eq$(this.get$top(), other.get$top()) && J.$eq$(J.$add$ns(this.get$left(), this.get$width()), J.$add$ns(other.get$left(), other.get$width())) && J.$eq$(J.$add$ns(this.get$top(), this.get$height()), J.$add$ns(other.get$top(), other.get$height()));
      }, null, "get$==", 2, 0, 24, 2, [], "=="],
      get$hashCode: [function(_) {
        var t1, t2, t3, t4;
        t1 = J.get$hashCode$(this.get$left());
        t2 = J.get$hashCode$(this.get$top());
        t3 = J.get$hashCode$(J.$add$ns(this.get$left(), this.get$width()));
        t4 = J.get$hashCode$(J.$add$ns(this.get$top(), this.get$height()));
        return P._JenkinsSmiHash_finish(P._JenkinsSmiHash_combine(P._JenkinsSmiHash_combine(P._JenkinsSmiHash_combine(P._JenkinsSmiHash_combine(0, t1), t2), t3), t4));
      }, null, null, 1, 0, 11, "hashCode"],
      intersection$1: [function(other) {
        var x0, x1, y0, y1;
        x0 = P.max(this.get$left(), other.get$left());
        x1 = P.min(J.$add$ns(this.get$left(), this.get$width()), J.$add$ns(other.get$left(), other.get$width()));
        if (x0 <= x1) {
          y0 = P.max(this.get$top(), other.get$top());
          y1 = P.min(J.$add$ns(this.get$top(), this.get$height()), J.$add$ns(other.get$top(), other.get$height()));
          if (y0 <= y1)
            return P.Rectangle$(x0, y0, x1 - x0, y1 - y0, H.getTypeArgumentByIndex(this, 0));
        }
        return;
      }, "call$1", "get$intersection", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Rectangle, T], args: [[P.Rectangle, T]]};
        }, this.$receiver, "_RectangleBase");
      }, 2, [], "intersection"],
      intersects$1: [function(other) {
        return J.$le$n(this.get$left(), J.$add$ns(other.get$left(), other.get$width())) && J.$le$n(other.get$left(), J.$add$ns(this.get$left(), this.get$width())) && J.$le$n(this.get$top(), J.$add$ns(other.get$top(), other.get$height())) && J.$le$n(other.get$top(), J.$add$ns(this.get$top(), this.get$height()));
      }, "call$1", "get$intersects", 2, 0, 380, 2, [], "intersects"],
      boundingBox$1: [function(other) {
        var right, bottom, left, $top;
        right = P.max(J.$add$ns(this.get$left(), this.get$width()), J.$add$ns(other.get$left(), other.get$width()));
        bottom = P.max(J.$add$ns(this.get$top(), this.get$height()), J.$add$ns(other.get$top(), other.get$height()));
        left = P.min(this.get$left(), other.get$left());
        $top = P.min(this.get$top(), other.get$top());
        return P.Rectangle$(left, $top, right - left, bottom - $top, H.getTypeArgumentByIndex(this, 0));
      }, "call$1", "get$boundingBox", 2, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Rectangle, T], args: [[P.Rectangle, T]]};
        }, this.$receiver, "_RectangleBase");
      }, 2, [], "boundingBox"],
      containsRectangle$1: [function(another) {
        return J.$le$n(this.get$left(), another.get$left()) && J.$ge$n(J.$add$ns(this.get$left(), this.get$width()), J.$add$ns(another.get$left(), another.get$width())) && J.$le$n(this.get$top(), another.get$top()) && J.$ge$n(J.$add$ns(this.get$top(), this.get$height()), J.$add$ns(another.get$top(), another.get$height()));
      }, "call$1", "get$containsRectangle", 2, 0, 380, 443, [], "containsRectangle"],
      containsPoint$1: [function(another) {
        return J.$ge$n(another.get$x(), this.get$left()) && J.$le$n(another.get$x(), J.$add$ns(this.get$left(), this.get$width())) && J.$ge$n(another.get$y(), this.get$top()) && J.$le$n(another.get$y(), J.$add$ns(this.get$top(), this.get$height()));
      }, "call$1", "get$containsPoint", 2, 0, 540, 443, [], "containsPoint"],
      get$topLeft: [function() {
        return new P.Point(this.get$left(), this.get$top(), this.$ti);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Point, T]};
        }, this.$receiver, "_RectangleBase");
      }, "topLeft"],
      get$topRight: [function() {
        return new P.Point(J.$add$ns(this.get$left(), this.get$width()), this.get$top(), this.$ti);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Point, T]};
        }, this.$receiver, "_RectangleBase");
      }, "topRight"],
      get$bottomRight: [function() {
        return new P.Point(J.$add$ns(this.get$left(), this.get$width()), J.$add$ns(this.get$top(), this.get$height()), this.$ti);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Point, T]};
        }, this.$receiver, "_RectangleBase");
      }, "bottomRight"],
      get$bottomLeft: [function() {
        return new P.Point(this.get$left(), J.$add$ns(this.get$top(), this.get$height()), this.$ti);
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: [P.Point, T]};
        }, this.$receiver, "_RectangleBase");
      }, "bottomLeft"],
      "<>": [928],
      static: {
        _RectangleBase$: [function($T) {
          return new P._RectangleBase([$T]);
        }, null, null, 0, 0, 4, "new _RectangleBase"]
      }
    },
    "+_RectangleBase": [1],
    Rectangle: {
      "^": "_RectangleBase;left<-208,top<-208,width<-208,height<-208,$ti",
      "<>": [342],
      static: {
        Rectangle$: [function(left, $top, width, height, $T) {
          var t1, t2;
          t1 = J.getInterceptor$n(width);
          t1 = t1.$lt(width, 0) ? J.$mul$ns(t1.$negate(width), 0) : width;
          t2 = J.getInterceptor$n(height);
          t2 = t2.$lt(height, 0) ? J.$mul$ns(t2.$negate(height), 0) : height;
          return new P.Rectangle(left, $top, t1, t2, [$T]);
        }, null, null, 8, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [T, T, T, T]};
          }, this.$receiver, "Rectangle");
        }, 457, [], 424, [], 139, [], 351, [], "new Rectangle"],
        Rectangle_Rectangle$fromPoints: [function(a, b, $T) {
          var left, t1, $top;
          left = P.min(a.get$x(), b.get$x());
          t1 = P.max(a.get$x(), b.get$x());
          $top = P.min(a.get$y(), b.get$y());
          return P.Rectangle$(left, $top, t1 - left, P.max(a.get$y(), b.get$y()) - $top, $T);
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P.Rectangle, T], args: [[P.Point, T], [P.Point, T]]};
          }, this.$receiver, "Rectangle");
        }, 87, [], 78, [], "new Rectangle$fromPoints"]
      }
    },
    "+Rectangle": [1644],
    MutableRectangle: {
      "^": "_RectangleBase;left@-195,top@-195,_width@-195,_height@-195,$ti",
      get$width: [function() {
        return this._width;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: T};
        }, this.$receiver, "MutableRectangle");
      }, "width"],
      set$width: [function(width) {
        var t1 = J.getInterceptor$n(width);
        this._width = t1.$lt(width, 0) ? J.$mul$ns(t1.$negate(width), 0) : width;
      }, null, null, 3, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "MutableRectangle");
      }, 139, [], "width"],
      get$height: [function() {
        return this._height;
      }, null, null, 1, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, ret: T};
        }, this.$receiver, "MutableRectangle");
      }, "height"],
      set$height: [function(height) {
        var t1 = J.getInterceptor$n(height);
        this._height = t1.$lt(height, 0) ? J.$mul$ns(t1.$negate(height), 0) : height;
      }, null, null, 3, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "MutableRectangle");
      }, 351, [], "height"],
      $isRectangle: 1,
      "<>": [254],
      static: {
        MutableRectangle$: [function(left, $top, width, height, $T) {
          var t1, t2;
          t1 = J.getInterceptor$n(width);
          t1 = t1.$lt(width, 0) ? J.$mul$ns(t1.$negate(width), 0) : width;
          t2 = J.getInterceptor$n(height);
          t2 = t2.$lt(height, 0) ? J.$mul$ns(t2.$negate(height), 0) : height;
          return new P.MutableRectangle(left, $top, t1, t2, [$T]);
        }, null, null, 8, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, args: [T, T, T, T]};
          }, this.$receiver, "MutableRectangle");
        }, 457, [], 424, [], 139, [], 351, [], "new MutableRectangle"],
        MutableRectangle_MutableRectangle$fromPoints: [function(a, b, $T) {
          var left, width, $top, height, t1, t2;
          left = P.min(a.get$x(), b.get$x());
          width = P.max(a.get$x(), b.get$x()) - left;
          $top = P.min(a.get$y(), b.get$y());
          height = P.max(a.get$y(), b.get$y()) - $top;
          t1 = width < 0 ? -width * 0 : width;
          t2 = height < 0 ? -height * 0 : height;
          return new P.MutableRectangle(left, $top, t1, t2, [$T]);
        }, null, null, 4, 0, function() {
          return H.computeSignature(function(T) {
            return {func: 1, ret: [P.MutableRectangle, T], args: [[P.Point, T], [P.Point, T]]};
          }, this.$receiver, "MutableRectangle");
        }, 87, [], 78, [], "new MutableRectangle$fromPoints"]
      }
    },
    "+MutableRectangle": [1646, 1647]
  }], ["dart.mirrors", "dart:mirrors",, P, {
    "^": "",
    currentMirrorSystem: [function() {
      return $.$get$currentJsMirrorSystem();
    }, "call$0", "mirrors__currentMirrorSystem$closure", 0, 0, 434, "currentMirrorSystem"],
    reflect0: [function(reflectee) {
      return H.reflect(reflectee);
    }, "call$1", "mirrors__reflect$closure", 2, 0, 382, 496, [], "reflect"],
    reflectClass: [function(key) {
      var t1, tm;
      t1 = J.getInterceptor(key);
      if (!t1.$isType || t1.$eq(key, C.Type_dynamic_0Rz))
        throw H.wrapException(P.ArgumentError$(H.S(key) + " does not denote a class"));
      tm = P.reflectType0(key, null);
      if (!J.getInterceptor(tm).$isClassMirror)
        throw H.wrapException(P.ArgumentError$(H.S(key) + " does not denote a class"));
      return tm.get$originalDeclaration();
    }, "call$1", "mirrors__reflectClass$closure", 2, 0, 1030, 6, [], "reflectClass"],
    reflectType0: [function(key, typeArguments) {
      if (J.$eq$(key, C.Type_dynamic_0Rz)) {
        $.$get$currentJsMirrorSystem().toString;
        return $.$get$JsMirrorSystem__dynamicType();
      }
      return H.reflectType(key, typeArguments);
    }, function(key) {
      return P.reflectType0(key, null);
    }, "call$2", "call$1", "mirrors__reflectType$closure", 2, 2, 1031, 0, 6, [], 948, [], "reflectType"],
    MirrorSystem_findLibrary_closure: {
      "^": "Closure:3;libraryName",
      call$1: [function(library) {
        library.get$simpleName();
        return false;
      }, null, null, 2, 0, 3, 372, [], "call"]
    },
    "+ MirrorSystem_findLibrary_closure": [2],
    MirrorSystem: {
      "^": "Object;",
      findLibrary$1: [function(libraryName) {
        return this.get$libraries().get$values().singleWhere$1(0, new P.MirrorSystem_findLibrary_closure(libraryName));
      }, "call$1", "get$findLibrary", 2, 0, 339, 388, [], "findLibrary"],
      static: {
        MirrorSystem$: [function() {
          return new P.MirrorSystem();
        }, null, null, 0, 0, 434, "new MirrorSystem"],
        MirrorSystem_getName: [function(symbol) {
          return symbol.get$__internal$_name();
        }, "call$1", "mirrors_MirrorSystem_getName$closure", 2, 0, 1028, 419, [], "getName"],
        MirrorSystem_getSymbol: [function($name, library) {
          return H.getSymbol($name, library);
        }, function($name) {
          return P.MirrorSystem_getSymbol($name, null);
        }, "call$2", "call$1", "mirrors_MirrorSystem_getSymbol$closure", 2, 2, 1029, 0, 13, [], 372, [], "getSymbol"]
      }
    },
    "+MirrorSystem": [1],
    Mirror: {
      "^": "Object;",
      static: {
        Mirror$: [function() {
          return new P.Mirror();
        }, null, null, 0, 0, 1032, "new Mirror"]
      }
    },
    "+Mirror": [1],
    IsolateMirror: {
      "^": "Object;",
      $isMirror: 1,
      static: {
        IsolateMirror$: [function() {
          return new P.IsolateMirror();
        }, null, null, 0, 0, 1033, "new IsolateMirror"]
      }
    },
    "+IsolateMirror": [1, 143],
    DeclarationMirror: {
      "^": "Object;",
      $isMirror: 1,
      static: {
        DeclarationMirror$: [function() {
          return new P.DeclarationMirror();
        }, null, null, 0, 0, 125, "new DeclarationMirror"]
      }
    },
    "+DeclarationMirror": [1, 143],
    ObjectMirror: {
      "^": "Object;",
      $isMirror: 1,
      static: {
        ObjectMirror$: [function() {
          return new P.ObjectMirror();
        }, null, null, 0, 0, 1034, "new ObjectMirror"]
      }
    },
    "+ObjectMirror": [1, 143],
    InstanceMirror: {
      "^": "Object;",
      $isMirror: 1,
      static: {
        InstanceMirror$: [function() {
          return new P.InstanceMirror();
        }, null, null, 0, 0, 446, "new InstanceMirror"]
      }
    },
    "+InstanceMirror": [1, 303],
    ClosureMirror: {
      "^": "Object;",
      $isInstanceMirror: 1,
      $isMirror: 1,
      static: {
        ClosureMirror$: [function() {
          return new P.ClosureMirror();
        }, null, null, 0, 0, 1035, "new ClosureMirror"]
      }
    },
    "+ClosureMirror": [1, 1650],
    LibraryMirror: {
      "^": "Object;",
      $isMirror: 1,
      $isDeclarationMirror: 1,
      static: {
        LibraryMirror$: [function() {
          return new P.LibraryMirror();
        }, null, null, 0, 0, 343, "new LibraryMirror"]
      }
    },
    "+LibraryMirror": [1, 303, 200],
    LibraryDependencyMirror: {
      "^": "Object;",
      $isMirror: 1,
      static: {
        LibraryDependencyMirror$: [function() {
          return new P.LibraryDependencyMirror();
        }, null, null, 0, 0, 1036, "new LibraryDependencyMirror"]
      }
    },
    "+LibraryDependencyMirror": [1, 143],
    CombinatorMirror: {
      "^": "Object;",
      $isMirror: 1,
      static: {
        CombinatorMirror$: [function() {
          return new P.CombinatorMirror();
        }, null, null, 0, 0, 1037, "new CombinatorMirror"]
      }
    },
    "+CombinatorMirror": [1, 143],
    TypeMirror: {
      "^": "Object;",
      $isMirror: 1,
      $isDeclarationMirror: 1,
      static: {
        TypeMirror$: [function() {
          return new P.TypeMirror();
        }, null, null, 0, 0, 53, "new TypeMirror"]
      }
    },
    "+TypeMirror": [1, 200],
    ClassMirror: {
      "^": "Object;",
      $isTypeMirror: 1,
      $isMirror: 1,
      $isDeclarationMirror: 1,
      static: {
        ClassMirror$: [function() {
          return new P.ClassMirror();
        }, null, null, 0, 0, 56, "new ClassMirror"]
      }
    },
    "+ClassMirror": [1, 303, 305],
    FunctionTypeMirror: {
      "^": "Object;",
      $isClassMirror: 1,
      $isMirror: 1,
      $isTypeMirror: 1,
      $isDeclarationMirror: 1,
      static: {
        FunctionTypeMirror$: [function() {
          return new P.FunctionTypeMirror();
        }, null, null, 0, 0, 1038, "new FunctionTypeMirror"]
      }
    },
    "+FunctionTypeMirror": [1, 1653],
    TypeVariableMirror: {
      "^": "TypeMirror;",
      $isMirror: 1,
      static: {
        TypeVariableMirror$: [function() {
          return new P.TypeVariableMirror();
        }, null, null, 0, 0, 1039, "new TypeVariableMirror"]
      }
    },
    "+TypeVariableMirror": [305],
    TypedefMirror: {
      "^": "Object;",
      $isTypeMirror: 1,
      $isDeclarationMirror: 1,
      $isMirror: 1,
      static: {
        TypedefMirror$: [function() {
          return new P.TypedefMirror();
        }, null, null, 0, 0, 1040, "new TypedefMirror"]
      }
    },
    "+TypedefMirror": [1, 305],
    MethodMirror: {
      "^": "Object;",
      $isMirror: 1,
      $isDeclarationMirror: 1,
      static: {
        MethodMirror$: [function() {
          return new P.MethodMirror();
        }, null, null, 0, 0, 295, "new MethodMirror"]
      }
    },
    "+MethodMirror": [1, 200],
    VariableMirror: {
      "^": "Object;",
      $isMirror: 1,
      $isDeclarationMirror: 1,
      static: {
        VariableMirror$: [function() {
          return new P.VariableMirror();
        }, null, null, 0, 0, 1041, "new VariableMirror"]
      }
    },
    "+VariableMirror": [1, 200],
    ParameterMirror: {
      "^": "Object;",
      $isMirror: 1,
      $isVariableMirror: 1,
      $isDeclarationMirror: 1,
      static: {
        ParameterMirror$: [function() {
          return new P.ParameterMirror();
        }, null, null, 0, 0, 1042, "new ParameterMirror"]
      }
    },
    "+ParameterMirror": [1, 1654],
    SourceLocation: {
      "^": "Object;",
      static: {
        SourceLocation$: [function() {
          return new P.SourceLocation();
        }, null, null, 0, 0, 123, "new SourceLocation"]
      }
    },
    "+SourceLocation": [1],
    Comment: {
      "^": "Object;text<-9,trimmedText<-9,isDocComment<-8",
      static: {
        Comment$: [function(text, trimmedText, isDocComment) {
          return new P.Comment(text, trimmedText, isDocComment);
        }, null, null, 6, 0, 1043, 106, [], 949, [], 950, [], "new Comment"]
      }
    },
    "+Comment": [1],
    MirrorsUsed: {
      "^": "Object;symbols<-10,targets<-10,metaTargets<-10,override<-10",
      static: {
        MirrorsUsed$: [function(metaTargets, override, symbols, targets) {
          return new P.MirrorsUsed(symbols, targets, metaTargets, override);
        }, null, null, 0, 9, 1044, 0, 0, 0, 0, 951, [], 952, [], 953, [], 954, [], "new MirrorsUsed"]
      }
    },
    "+MirrorsUsed": [1]
  }], ["nativewrappers", "dart:nativewrappers",, P, {
    "^": "",
    NativeFieldWrapperClass1: {
      "^": "Object;",
      static: {
        NativeFieldWrapperClass1$: [function() {
          return new P.NativeFieldWrapperClass1();
        }, null, null, 0, 0, 1045, "new NativeFieldWrapperClass1"]
      }
    },
    "+NativeFieldWrapperClass1": [1],
    NativeFieldWrapperClass2: {
      "^": "Object;",
      static: {
        NativeFieldWrapperClass2$: [function() {
          return new P.NativeFieldWrapperClass2();
        }, null, null, 0, 0, 1046, "new NativeFieldWrapperClass2"]
      }
    },
    "+NativeFieldWrapperClass2": [1],
    NativeFieldWrapperClass3: {
      "^": "Object;",
      static: {
        NativeFieldWrapperClass3$: [function() {
          return new P.NativeFieldWrapperClass3();
        }, null, null, 0, 0, 1047, "new NativeFieldWrapperClass3"]
      }
    },
    "+NativeFieldWrapperClass3": [1],
    NativeFieldWrapperClass4: {
      "^": "Object;",
      static: {
        NativeFieldWrapperClass4$: [function() {
          return new P.NativeFieldWrapperClass4();
        }, null, null, 0, 0, 1048, "new NativeFieldWrapperClass4"]
      }
    },
    "+NativeFieldWrapperClass4": [1]
  }], ["dart.typed_data", "dart:typed_data",, P, {
    "^": "",
    ByteBuffer: {
      "^": "Object;",
      static: {
        ByteBuffer$: [function() {
          return new P.ByteBuffer();
        }, null, null, 0, 0, 169, "new ByteBuffer"]
      }
    },
    "+ByteBuffer": [1],
    TypedData: {
      "^": "Object;",
      static: {
        TypedData$: [function() {
          return new P.TypedData();
        }, null, null, 0, 0, 1049, "new TypedData"]
      }
    },
    "+TypedData": [1],
    Endianness: {
      "^": "Object;_littleEndian<-8",
      static: {
        "^": "Endianness_BIG_ENDIAN<-306,Endianness_LITTLE_ENDIAN<-306,Endianness_HOST_ENDIAN<-306",
        Endianness$_: [function(_littleEndian) {
          return new P.Endianness(_littleEndian);
        }, null, null, 2, 0, 33, 955, [], "new Endianness$_"]
      }
    },
    "+Endianness": [1],
    ByteData: {
      "^": "Object;",
      static: {
        ByteData_ByteData: [function($length) {
          return new DataView(new ArrayBuffer(H._checkLength($length)));
        }, null, null, 2, 0, 1050, 15, [], "new ByteData"],
        ByteData_ByteData$view: [function(buffer, offsetInBytes, $length) {
          return J.asByteData$2$x(buffer, offsetInBytes, $length);
        }, null, null, 2, 4, 1051, 7, 0, 41, [], 36, [], 15, [], "new ByteData$view"]
      }
    },
    "+ByteData": [1, 38],
    Int8List: {
      "^": "Object;",
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      static: {
        "^": "Int8List_BYTES_PER_ELEMENT<-0",
        Int8List_Int8List: [function($length) {
          return new Int8Array(H._checkLength($length));
        }, null, null, 2, 0, 1052, 15, [], "new Int8List"],
        Int8List_Int8List$fromList: [function(elements) {
          return new Int8Array(H._ensureNativeList(elements));
        }, null, null, 2, 0, 1053, 35, [], "new Int8List$fromList"],
        Int8List_Int8List$view: [function(buffer, offsetInBytes, $length) {
          return J.asInt8List$2$x(buffer, offsetInBytes, $length);
        }, null, null, 2, 4, 1054, 7, 0, 41, [], 36, [], 15, [], "new Int8List$view"]
      }
    },
    "+Int8List": [1, 38, 14],
    Uint8List: {
      "^": "Object;",
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      static: {
        "^": "Uint8List_BYTES_PER_ELEMENT<-0",
        Uint8List_Uint8List: [function($length) {
          return new Uint8Array(H._checkLength($length));
        }, null, null, 2, 0, 229, 15, [], "new Uint8List"],
        Uint8List_Uint8List$fromList: [function(elements) {
          return new Uint8Array(H._ensureNativeList(elements));
        }, null, null, 2, 0, 377, 35, [], "new Uint8List$fromList"],
        Uint8List_Uint8List$view: [function(buffer, offsetInBytes, $length) {
          return J.asUint8List$2$x(buffer, offsetInBytes, $length);
        }, null, null, 2, 4, 1055, 7, 0, 41, [], 36, [], 15, [], "new Uint8List$view"]
      }
    },
    "+Uint8List": [1, 38, 14],
    Uint8ClampedList: {
      "^": "Object;",
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      static: {
        "^": "Uint8ClampedList_BYTES_PER_ELEMENT<-0",
        Uint8ClampedList_Uint8ClampedList: [function($length) {
          return new Uint8ClampedArray(H._checkLength($length));
        }, null, null, 2, 0, 1056, 15, [], "new Uint8ClampedList"],
        Uint8ClampedList_Uint8ClampedList$fromList: [function(elements) {
          return new Uint8ClampedArray(H._ensureNativeList(elements));
        }, null, null, 2, 0, 1057, 35, [], "new Uint8ClampedList$fromList"],
        Uint8ClampedList_Uint8ClampedList$view: [function(buffer, offsetInBytes, $length) {
          return J.asUint8ClampedList$2$x(buffer, offsetInBytes, $length);
        }, null, null, 2, 4, 1058, 7, 0, 41, [], 36, [], 15, [], "new Uint8ClampedList$view"]
      }
    },
    "+Uint8ClampedList": [1, 38, 14],
    Int16List: {
      "^": "Object;",
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      static: {
        "^": "Int16List_BYTES_PER_ELEMENT<-0",
        Int16List_Int16List: [function($length) {
          return new Int16Array(H._checkLength($length));
        }, null, null, 2, 0, 1059, 15, [], "new Int16List"],
        Int16List_Int16List$fromList: [function(elements) {
          return new Int16Array(H._ensureNativeList(elements));
        }, null, null, 2, 0, 1060, 35, [], "new Int16List$fromList"],
        Int16List_Int16List$view: [function(buffer, offsetInBytes, $length) {
          return J.asInt16List$2$x(buffer, offsetInBytes, $length);
        }, null, null, 2, 4, 1061, 7, 0, 41, [], 36, [], 15, [], "new Int16List$view"]
      }
    },
    "+Int16List": [1, 38, 14],
    Uint16List: {
      "^": "Object;",
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      static: {
        "^": "Uint16List_BYTES_PER_ELEMENT<-0",
        Uint16List_Uint16List: [function($length) {
          return new Uint16Array(H._checkLength($length));
        }, null, null, 2, 0, 1062, 15, [], "new Uint16List"],
        Uint16List_Uint16List$fromList: [function(elements) {
          return new Uint16Array(H._ensureNativeList(elements));
        }, null, null, 2, 0, 1063, 35, [], "new Uint16List$fromList"],
        Uint16List_Uint16List$view: [function(buffer, offsetInBytes, $length) {
          return J.asUint16List$2$x(buffer, offsetInBytes, $length);
        }, null, null, 2, 4, 1064, 7, 0, 41, [], 36, [], 15, [], "new Uint16List$view"]
      }
    },
    "+Uint16List": [1, 38, 14],
    Int32List: {
      "^": "Object;",
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      static: {
        "^": "Int32List_BYTES_PER_ELEMENT<-0",
        Int32List_Int32List: [function($length) {
          return new Int32Array(H._checkLength($length));
        }, null, null, 2, 0, 1065, 15, [], "new Int32List"],
        Int32List_Int32List$fromList: [function(elements) {
          return new Int32Array(H._ensureNativeList(elements));
        }, null, null, 2, 0, 1066, 35, [], "new Int32List$fromList"],
        Int32List_Int32List$view: [function(buffer, offsetInBytes, $length) {
          return J.asInt32List$2$x(buffer, offsetInBytes, $length);
        }, null, null, 2, 4, 1067, 7, 0, 41, [], 36, [], 15, [], "new Int32List$view"]
      }
    },
    "+Int32List": [1, 38, 14],
    Uint32List: {
      "^": "Object;",
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      static: {
        "^": "Uint32List_BYTES_PER_ELEMENT<-0",
        Uint32List_Uint32List: [function($length) {
          return new Uint32Array(H._checkLength($length));
        }, null, null, 2, 0, 1068, 15, [], "new Uint32List"],
        Uint32List_Uint32List$fromList: [function(elements) {
          return new Uint32Array(H._ensureNativeList(elements));
        }, null, null, 2, 0, 1069, 35, [], "new Uint32List$fromList"],
        Uint32List_Uint32List$view: [function(buffer, offsetInBytes, $length) {
          return J.asUint32List$2$x(buffer, offsetInBytes, $length);
        }, null, null, 2, 4, 1070, 7, 0, 41, [], 36, [], 15, [], "new Uint32List$view"]
      }
    },
    "+Uint32List": [1, 38, 14],
    Int64List: {
      "^": "Object;",
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      static: {
        "^": "Int64List_BYTES_PER_ELEMENT<-0",
        Int64List_Int64List: [function($length) {
          throw H.wrapException(new P.UnsupportedError("Int64List not supported by dart2js."));
        }, null, null, 2, 0, 1071, 15, [], "new Int64List"],
        Int64List_Int64List$fromList: [function(elements) {
          throw H.wrapException(new P.UnsupportedError("Int64List not supported by dart2js."));
        }, null, null, 2, 0, 1072, 35, [], "new Int64List$fromList"],
        Int64List_Int64List$view: [function(buffer, offsetInBytes, $length) {
          return J.asInt64List$2$x(buffer, offsetInBytes, $length);
        }, null, null, 2, 4, 1073, 7, 0, 41, [], 36, [], 15, [], "new Int64List$view"]
      }
    },
    "+Int64List": [1, 38, 14],
    Uint64List: {
      "^": "Object;",
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      static: {
        "^": "Uint64List_BYTES_PER_ELEMENT<-0",
        Uint64List_Uint64List: [function($length) {
          throw H.wrapException(new P.UnsupportedError("Uint64List not supported by dart2js."));
        }, null, null, 2, 0, 1074, 15, [], "new Uint64List"],
        Uint64List_Uint64List$fromList: [function(elements) {
          throw H.wrapException(new P.UnsupportedError("Uint64List not supported by dart2js."));
        }, null, null, 2, 0, 1075, 35, [], "new Uint64List$fromList"],
        Uint64List_Uint64List$view: [function(buffer, offsetInBytes, $length) {
          return J.asUint64List$2$x(buffer, offsetInBytes, $length);
        }, null, null, 2, 4, 1076, 7, 0, 41, [], 36, [], 15, [], "new Uint64List$view"]
      }
    },
    "+Uint64List": [1, 38, 14],
    Float32List: {
      "^": "Object;",
      $isList: 1,
      $asList: function() {
        return [P.double];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.double];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.double];
      },
      static: {
        "^": "Float32List_BYTES_PER_ELEMENT<-0",
        Float32List_Float32List: [function($length) {
          return new Float32Array(H._checkLength($length));
        }, null, null, 2, 0, 1077, 15, [], "new Float32List"],
        Float32List_Float32List$fromList: [function(elements) {
          return new Float32Array(H._ensureNativeList(elements));
        }, null, null, 2, 0, 1078, 35, [], "new Float32List$fromList"],
        Float32List_Float32List$view: [function(buffer, offsetInBytes, $length) {
          return J.asFloat32List$2$x(buffer, offsetInBytes, $length);
        }, null, null, 2, 4, 1079, 7, 0, 41, [], 36, [], 15, [], "new Float32List$view"]
      }
    },
    "+Float32List": [1, 38, 532],
    Float64List: {
      "^": "Object;",
      $isList: 1,
      $asList: function() {
        return [P.double];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.double];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.double];
      },
      static: {
        "^": "Float64List_BYTES_PER_ELEMENT<-0",
        Float64List_Float64List: [function($length) {
          return new Float64Array(H._checkLength($length));
        }, null, null, 2, 0, 1080, 15, [], "new Float64List"],
        Float64List_Float64List$fromList: [function(elements) {
          return new Float64Array(H._ensureNativeList(elements));
        }, null, null, 2, 0, 1081, 35, [], "new Float64List$fromList"],
        Float64List_Float64List$view: [function(buffer, offsetInBytes, $length) {
          return J.asFloat64List$2$x(buffer, offsetInBytes, $length);
        }, null, null, 2, 4, 1082, 7, 0, 41, [], 36, [], 15, [], "new Float64List$view"]
      }
    },
    "+Float64List": [1, 38, 532],
    Float32x4List: {
      "^": "Object;",
      $isList: 1,
      $asList: function() {
        return [P.Float32x4];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Float32x4];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Float32x4];
      },
      static: {
        "^": "Float32x4List_BYTES_PER_ELEMENT<-0",
        Float32x4List_Float32x4List: [function($length) {
          return new H.NativeFloat32x4List(new Float32Array(H._checkLength(J.$mul$ns($length, 4))));
        }, null, null, 2, 0, 1083, 15, [], "new Float32x4List"],
        Float32x4List_Float32x4List$fromList: [function(elements) {
          return H.NativeFloat32x4List_NativeFloat32x4List$fromList(elements);
        }, null, null, 2, 0, 1084, 35, [], "new Float32x4List$fromList"],
        Float32x4List_Float32x4List$view: [function(buffer, offsetInBytes, $length) {
          return J.asFloat32x4List$2$x(buffer, offsetInBytes, $length);
        }, null, null, 2, 4, 1085, 7, 0, 41, [], 36, [], 15, [], "new Float32x4List$view"]
      }
    },
    "+Float32x4List": [1, 38, 1658],
    Int32x4List: {
      "^": "Object;",
      $isList: 1,
      $asList: function() {
        return [P.Int32x4];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Int32x4];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Int32x4];
      },
      static: {
        "^": "Int32x4List_BYTES_PER_ELEMENT<-0",
        Int32x4List_Int32x4List: [function($length) {
          return new H.NativeInt32x4List(new Int32Array(H._checkLength(J.$mul$ns($length, 4))));
        }, null, null, 2, 0, 1086, 15, [], "new Int32x4List"],
        Int32x4List_Int32x4List$fromList: [function(elements) {
          return H.NativeInt32x4List_NativeInt32x4List$fromList(elements);
        }, null, null, 2, 0, 1087, 35, [], "new Int32x4List$fromList"],
        Int32x4List_Int32x4List$view: [function(buffer, offsetInBytes, $length) {
          return J.asInt32x4List$2$x(buffer, offsetInBytes, $length);
        }, null, null, 2, 4, 1088, 7, 0, 41, [], 36, [], 15, [], "new Int32x4List$view"]
      }
    },
    "+Int32x4List": [1, 38, 1659],
    Float64x2List: {
      "^": "Object;",
      $isList: 1,
      $asList: function() {
        return [P.Float64x2];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Float64x2];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Float64x2];
      },
      static: {
        "^": "Float64x2List_BYTES_PER_ELEMENT<-0",
        Float64x2List_Float64x2List: [function($length) {
          return new H.NativeFloat64x2List(new Float64Array(H._checkLength(J.$mul$ns($length, 2))));
        }, null, null, 2, 0, 1089, 15, [], "new Float64x2List"],
        Float64x2List_Float64x2List$fromList: [function(elements) {
          return H.NativeFloat64x2List_NativeFloat64x2List$fromList(elements);
        }, null, null, 2, 0, 1090, 35, [], "new Float64x2List$fromList"],
        Float64x2List_Float64x2List$view: [function(buffer, offsetInBytes, $length) {
          return J.asFloat64x2List$2$x(buffer, offsetInBytes, $length);
        }, null, null, 2, 4, 1091, 7, 0, 41, [], 36, [], 15, [], "new Float64x2List$view"]
      }
    },
    "+Float64x2List": [1, 38, 1660],
    Float32x4: {
      "^": "Object;",
      static: {
        "^": "Float32x4_XXXX<-0,Float32x4_XXXY<-0,Float32x4_XXXZ<-0,Float32x4_XXXW<-0,Float32x4_XXYX<-0,Float32x4_XXYY<-0,Float32x4_XXYZ<-0,Float32x4_XXYW<-0,Float32x4_XXZX<-0,Float32x4_XXZY<-0,Float32x4_XXZZ<-0,Float32x4_XXZW<-0,Float32x4_XXWX<-0,Float32x4_XXWY<-0,Float32x4_XXWZ<-0,Float32x4_XXWW<-0,Float32x4_XYXX<-0,Float32x4_XYXY<-0,Float32x4_XYXZ<-0,Float32x4_XYXW<-0,Float32x4_XYYX<-0,Float32x4_XYYY<-0,Float32x4_XYYZ<-0,Float32x4_XYYW<-0,Float32x4_XYZX<-0,Float32x4_XYZY<-0,Float32x4_XYZZ<-0,Float32x4_XYZW<-0,Float32x4_XYWX<-0,Float32x4_XYWY<-0,Float32x4_XYWZ<-0,Float32x4_XYWW<-0,Float32x4_XZXX<-0,Float32x4_XZXY<-0,Float32x4_XZXZ<-0,Float32x4_XZXW<-0,Float32x4_XZYX<-0,Float32x4_XZYY<-0,Float32x4_XZYZ<-0,Float32x4_XZYW<-0,Float32x4_XZZX<-0,Float32x4_XZZY<-0,Float32x4_XZZZ<-0,Float32x4_XZZW<-0,Float32x4_XZWX<-0,Float32x4_XZWY<-0,Float32x4_XZWZ<-0,Float32x4_XZWW<-0,Float32x4_XWXX<-0,Float32x4_XWXY<-0,Float32x4_XWXZ<-0,Float32x4_XWXW<-0,Float32x4_XWYX<-0,Float32x4_XWYY<-0,Float32x4_XWYZ<-0,Float32x4_XWYW<-0,Float32x4_XWZX<-0,Float32x4_XWZY<-0,Float32x4_XWZZ<-0,Float32x4_XWZW<-0,Float32x4_XWWX<-0,Float32x4_XWWY<-0,Float32x4_XWWZ<-0,Float32x4_XWWW<-0,Float32x4_YXXX<-0,Float32x4_YXXY<-0,Float32x4_YXXZ<-0,Float32x4_YXXW<-0,Float32x4_YXYX<-0,Float32x4_YXYY<-0,Float32x4_YXYZ<-0,Float32x4_YXYW<-0,Float32x4_YXZX<-0,Float32x4_YXZY<-0,Float32x4_YXZZ<-0,Float32x4_YXZW<-0,Float32x4_YXWX<-0,Float32x4_YXWY<-0,Float32x4_YXWZ<-0,Float32x4_YXWW<-0,Float32x4_YYXX<-0,Float32x4_YYXY<-0,Float32x4_YYXZ<-0,Float32x4_YYXW<-0,Float32x4_YYYX<-0,Float32x4_YYYY<-0,Float32x4_YYYZ<-0,Float32x4_YYYW<-0,Float32x4_YYZX<-0,Float32x4_YYZY<-0,Float32x4_YYZZ<-0,Float32x4_YYZW<-0,Float32x4_YYWX<-0,Float32x4_YYWY<-0,Float32x4_YYWZ<-0,Float32x4_YYWW<-0,Float32x4_YZXX<-0,Float32x4_YZXY<-0,Float32x4_YZXZ<-0,Float32x4_YZXW<-0,Float32x4_YZYX<-0,Float32x4_YZYY<-0,Float32x4_YZYZ<-0,Float32x4_YZYW<-0,Float32x4_YZZX<-0,Float32x4_YZZY<-0,Float32x4_YZZZ<-0,Float32x4_YZZW<-0,Float32x4_YZWX<-0,Float32x4_YZWY<-0,Float32x4_YZWZ<-0,Float32x4_YZWW<-0,Float32x4_YWXX<-0,Float32x4_YWXY<-0,Float32x4_YWXZ<-0,Float32x4_YWXW<-0,Float32x4_YWYX<-0,Float32x4_YWYY<-0,Float32x4_YWYZ<-0,Float32x4_YWYW<-0,Float32x4_YWZX<-0,Float32x4_YWZY<-0,Float32x4_YWZZ<-0,Float32x4_YWZW<-0,Float32x4_YWWX<-0,Float32x4_YWWY<-0,Float32x4_YWWZ<-0,Float32x4_YWWW<-0,Float32x4_ZXXX<-0,Float32x4_ZXXY<-0,Float32x4_ZXXZ<-0,Float32x4_ZXXW<-0,Float32x4_ZXYX<-0,Float32x4_ZXYY<-0,Float32x4_ZXYZ<-0,Float32x4_ZXYW<-0,Float32x4_ZXZX<-0,Float32x4_ZXZY<-0,Float32x4_ZXZZ<-0,Float32x4_ZXZW<-0,Float32x4_ZXWX<-0,Float32x4_ZXWY<-0,Float32x4_ZXWZ<-0,Float32x4_ZXWW<-0,Float32x4_ZYXX<-0,Float32x4_ZYXY<-0,Float32x4_ZYXZ<-0,Float32x4_ZYXW<-0,Float32x4_ZYYX<-0,Float32x4_ZYYY<-0,Float32x4_ZYYZ<-0,Float32x4_ZYYW<-0,Float32x4_ZYZX<-0,Float32x4_ZYZY<-0,Float32x4_ZYZZ<-0,Float32x4_ZYZW<-0,Float32x4_ZYWX<-0,Float32x4_ZYWY<-0,Float32x4_ZYWZ<-0,Float32x4_ZYWW<-0,Float32x4_ZZXX<-0,Float32x4_ZZXY<-0,Float32x4_ZZXZ<-0,Float32x4_ZZXW<-0,Float32x4_ZZYX<-0,Float32x4_ZZYY<-0,Float32x4_ZZYZ<-0,Float32x4_ZZYW<-0,Float32x4_ZZZX<-0,Float32x4_ZZZY<-0,Float32x4_ZZZZ<-0,Float32x4_ZZZW<-0,Float32x4_ZZWX<-0,Float32x4_ZZWY<-0,Float32x4_ZZWZ<-0,Float32x4_ZZWW<-0,Float32x4_ZWXX<-0,Float32x4_ZWXY<-0,Float32x4_ZWXZ<-0,Float32x4_ZWXW<-0,Float32x4_ZWYX<-0,Float32x4_ZWYY<-0,Float32x4_ZWYZ<-0,Float32x4_ZWYW<-0,Float32x4_ZWZX<-0,Float32x4_ZWZY<-0,Float32x4_ZWZZ<-0,Float32x4_ZWZW<-0,Float32x4_ZWWX<-0,Float32x4_ZWWY<-0,Float32x4_ZWWZ<-0,Float32x4_ZWWW<-0,Float32x4_WXXX<-0,Float32x4_WXXY<-0,Float32x4_WXXZ<-0,Float32x4_WXXW<-0,Float32x4_WXYX<-0,Float32x4_WXYY<-0,Float32x4_WXYZ<-0,Float32x4_WXYW<-0,Float32x4_WXZX<-0,Float32x4_WXZY<-0,Float32x4_WXZZ<-0,Float32x4_WXZW<-0,Float32x4_WXWX<-0,Float32x4_WXWY<-0,Float32x4_WXWZ<-0,Float32x4_WXWW<-0,Float32x4_WYXX<-0,Float32x4_WYXY<-0,Float32x4_WYXZ<-0,Float32x4_WYXW<-0,Float32x4_WYYX<-0,Float32x4_WYYY<-0,Float32x4_WYYZ<-0,Float32x4_WYYW<-0,Float32x4_WYZX<-0,Float32x4_WYZY<-0,Float32x4_WYZZ<-0,Float32x4_WYZW<-0,Float32x4_WYWX<-0,Float32x4_WYWY<-0,Float32x4_WYWZ<-0,Float32x4_WYWW<-0,Float32x4_WZXX<-0,Float32x4_WZXY<-0,Float32x4_WZXZ<-0,Float32x4_WZXW<-0,Float32x4_WZYX<-0,Float32x4_WZYY<-0,Float32x4_WZYZ<-0,Float32x4_WZYW<-0,Float32x4_WZZX<-0,Float32x4_WZZY<-0,Float32x4_WZZZ<-0,Float32x4_WZZW<-0,Float32x4_WZWX<-0,Float32x4_WZWY<-0,Float32x4_WZWZ<-0,Float32x4_WZWW<-0,Float32x4_WWXX<-0,Float32x4_WWXY<-0,Float32x4_WWXZ<-0,Float32x4_WWXW<-0,Float32x4_WWYX<-0,Float32x4_WWYY<-0,Float32x4_WWYZ<-0,Float32x4_WWYW<-0,Float32x4_WWZX<-0,Float32x4_WWZY<-0,Float32x4_WWZZ<-0,Float32x4_WWZW<-0,Float32x4_WWWX<-0,Float32x4_WWWY<-0,Float32x4_WWWZ<-0,Float32x4_WWWW<-0",
        Float32x4_Float32x4: [function(x, y, z, w) {
          return H.NativeFloat32x4$(x, y, z, w);
        }, null, null, 8, 0, 1092, 38, [], 132, [], 244, [], 245, [], "new Float32x4"],
        Float32x4_Float32x4$splat: [function(v) {
          var t1, t2, t3, t4;
          t1 = $.$get$NativeFloat32x4__list();
          t1[0] = v;
          t2 = t1[0];
          t1[0] = v;
          t3 = t1[0];
          t1[0] = v;
          t4 = t1[0];
          t1[0] = v;
          t1 = new H.NativeFloat32x4(t2, t3, t4, t1[0]);
          t1.NativeFloat32x4$4(v, v, v, v);
          return t1;
        }, null, null, 2, 0, 119, 56, [], "new Float32x4$splat"],
        Float32x4_Float32x4$zero: [function() {
          return new H.NativeFloat32x4(0, 0, 0, 0);
        }, null, null, 0, 0, 118, "new Float32x4$zero"],
        Float32x4_Float32x4$fromInt32x4Bits: [function(x) {
          var t1, t2, t3;
          t1 = $.$get$NativeFloat32x4__uint32view();
          t2 = x.get$x();
          t3 = t1.length;
          if (0 >= t3)
            return H.ioore(t1, 0);
          t1[0] = t2;
          t2 = x.get$y();
          if (1 >= t3)
            return H.ioore(t1, 1);
          t1[1] = t2;
          t2 = x.get$z();
          if (2 >= t3)
            return H.ioore(t1, 2);
          t1[2] = t2;
          t2 = x.get$w();
          if (3 >= t3)
            return H.ioore(t1, 3);
          t1[3] = t2;
          t2 = $.$get$NativeFloat32x4__list();
          return new H.NativeFloat32x4(t2[0], t2[1], t2[2], t2[3]);
        }, null, null, 2, 0, 1093, 38, [], "new Float32x4$fromInt32x4Bits"],
        Float32x4_Float32x4$fromFloat64x2: [function(v) {
          var t1, t2;
          t1 = v.get$x();
          t2 = $.$get$NativeFloat32x4__list();
          t2[0] = t1;
          t1 = t2[0];
          t2[0] = v.get$y();
          return new H.NativeFloat32x4(t1, t2[0], 0, 0);
        }, null, null, 2, 0, 1094, 56, [], "new Float32x4$fromFloat64x2"]
      }
    },
    "+Float32x4": [1],
    Int32x4: {
      "^": "Object;",
      static: {
        "^": "Int32x4_XXXX<-0,Int32x4_XXXY<-0,Int32x4_XXXZ<-0,Int32x4_XXXW<-0,Int32x4_XXYX<-0,Int32x4_XXYY<-0,Int32x4_XXYZ<-0,Int32x4_XXYW<-0,Int32x4_XXZX<-0,Int32x4_XXZY<-0,Int32x4_XXZZ<-0,Int32x4_XXZW<-0,Int32x4_XXWX<-0,Int32x4_XXWY<-0,Int32x4_XXWZ<-0,Int32x4_XXWW<-0,Int32x4_XYXX<-0,Int32x4_XYXY<-0,Int32x4_XYXZ<-0,Int32x4_XYXW<-0,Int32x4_XYYX<-0,Int32x4_XYYY<-0,Int32x4_XYYZ<-0,Int32x4_XYYW<-0,Int32x4_XYZX<-0,Int32x4_XYZY<-0,Int32x4_XYZZ<-0,Int32x4_XYZW<-0,Int32x4_XYWX<-0,Int32x4_XYWY<-0,Int32x4_XYWZ<-0,Int32x4_XYWW<-0,Int32x4_XZXX<-0,Int32x4_XZXY<-0,Int32x4_XZXZ<-0,Int32x4_XZXW<-0,Int32x4_XZYX<-0,Int32x4_XZYY<-0,Int32x4_XZYZ<-0,Int32x4_XZYW<-0,Int32x4_XZZX<-0,Int32x4_XZZY<-0,Int32x4_XZZZ<-0,Int32x4_XZZW<-0,Int32x4_XZWX<-0,Int32x4_XZWY<-0,Int32x4_XZWZ<-0,Int32x4_XZWW<-0,Int32x4_XWXX<-0,Int32x4_XWXY<-0,Int32x4_XWXZ<-0,Int32x4_XWXW<-0,Int32x4_XWYX<-0,Int32x4_XWYY<-0,Int32x4_XWYZ<-0,Int32x4_XWYW<-0,Int32x4_XWZX<-0,Int32x4_XWZY<-0,Int32x4_XWZZ<-0,Int32x4_XWZW<-0,Int32x4_XWWX<-0,Int32x4_XWWY<-0,Int32x4_XWWZ<-0,Int32x4_XWWW<-0,Int32x4_YXXX<-0,Int32x4_YXXY<-0,Int32x4_YXXZ<-0,Int32x4_YXXW<-0,Int32x4_YXYX<-0,Int32x4_YXYY<-0,Int32x4_YXYZ<-0,Int32x4_YXYW<-0,Int32x4_YXZX<-0,Int32x4_YXZY<-0,Int32x4_YXZZ<-0,Int32x4_YXZW<-0,Int32x4_YXWX<-0,Int32x4_YXWY<-0,Int32x4_YXWZ<-0,Int32x4_YXWW<-0,Int32x4_YYXX<-0,Int32x4_YYXY<-0,Int32x4_YYXZ<-0,Int32x4_YYXW<-0,Int32x4_YYYX<-0,Int32x4_YYYY<-0,Int32x4_YYYZ<-0,Int32x4_YYYW<-0,Int32x4_YYZX<-0,Int32x4_YYZY<-0,Int32x4_YYZZ<-0,Int32x4_YYZW<-0,Int32x4_YYWX<-0,Int32x4_YYWY<-0,Int32x4_YYWZ<-0,Int32x4_YYWW<-0,Int32x4_YZXX<-0,Int32x4_YZXY<-0,Int32x4_YZXZ<-0,Int32x4_YZXW<-0,Int32x4_YZYX<-0,Int32x4_YZYY<-0,Int32x4_YZYZ<-0,Int32x4_YZYW<-0,Int32x4_YZZX<-0,Int32x4_YZZY<-0,Int32x4_YZZZ<-0,Int32x4_YZZW<-0,Int32x4_YZWX<-0,Int32x4_YZWY<-0,Int32x4_YZWZ<-0,Int32x4_YZWW<-0,Int32x4_YWXX<-0,Int32x4_YWXY<-0,Int32x4_YWXZ<-0,Int32x4_YWXW<-0,Int32x4_YWYX<-0,Int32x4_YWYY<-0,Int32x4_YWYZ<-0,Int32x4_YWYW<-0,Int32x4_YWZX<-0,Int32x4_YWZY<-0,Int32x4_YWZZ<-0,Int32x4_YWZW<-0,Int32x4_YWWX<-0,Int32x4_YWWY<-0,Int32x4_YWWZ<-0,Int32x4_YWWW<-0,Int32x4_ZXXX<-0,Int32x4_ZXXY<-0,Int32x4_ZXXZ<-0,Int32x4_ZXXW<-0,Int32x4_ZXYX<-0,Int32x4_ZXYY<-0,Int32x4_ZXYZ<-0,Int32x4_ZXYW<-0,Int32x4_ZXZX<-0,Int32x4_ZXZY<-0,Int32x4_ZXZZ<-0,Int32x4_ZXZW<-0,Int32x4_ZXWX<-0,Int32x4_ZXWY<-0,Int32x4_ZXWZ<-0,Int32x4_ZXWW<-0,Int32x4_ZYXX<-0,Int32x4_ZYXY<-0,Int32x4_ZYXZ<-0,Int32x4_ZYXW<-0,Int32x4_ZYYX<-0,Int32x4_ZYYY<-0,Int32x4_ZYYZ<-0,Int32x4_ZYYW<-0,Int32x4_ZYZX<-0,Int32x4_ZYZY<-0,Int32x4_ZYZZ<-0,Int32x4_ZYZW<-0,Int32x4_ZYWX<-0,Int32x4_ZYWY<-0,Int32x4_ZYWZ<-0,Int32x4_ZYWW<-0,Int32x4_ZZXX<-0,Int32x4_ZZXY<-0,Int32x4_ZZXZ<-0,Int32x4_ZZXW<-0,Int32x4_ZZYX<-0,Int32x4_ZZYY<-0,Int32x4_ZZYZ<-0,Int32x4_ZZYW<-0,Int32x4_ZZZX<-0,Int32x4_ZZZY<-0,Int32x4_ZZZZ<-0,Int32x4_ZZZW<-0,Int32x4_ZZWX<-0,Int32x4_ZZWY<-0,Int32x4_ZZWZ<-0,Int32x4_ZZWW<-0,Int32x4_ZWXX<-0,Int32x4_ZWXY<-0,Int32x4_ZWXZ<-0,Int32x4_ZWXW<-0,Int32x4_ZWYX<-0,Int32x4_ZWYY<-0,Int32x4_ZWYZ<-0,Int32x4_ZWYW<-0,Int32x4_ZWZX<-0,Int32x4_ZWZY<-0,Int32x4_ZWZZ<-0,Int32x4_ZWZW<-0,Int32x4_ZWWX<-0,Int32x4_ZWWY<-0,Int32x4_ZWWZ<-0,Int32x4_ZWWW<-0,Int32x4_WXXX<-0,Int32x4_WXXY<-0,Int32x4_WXXZ<-0,Int32x4_WXXW<-0,Int32x4_WXYX<-0,Int32x4_WXYY<-0,Int32x4_WXYZ<-0,Int32x4_WXYW<-0,Int32x4_WXZX<-0,Int32x4_WXZY<-0,Int32x4_WXZZ<-0,Int32x4_WXZW<-0,Int32x4_WXWX<-0,Int32x4_WXWY<-0,Int32x4_WXWZ<-0,Int32x4_WXWW<-0,Int32x4_WYXX<-0,Int32x4_WYXY<-0,Int32x4_WYXZ<-0,Int32x4_WYXW<-0,Int32x4_WYYX<-0,Int32x4_WYYY<-0,Int32x4_WYYZ<-0,Int32x4_WYYW<-0,Int32x4_WYZX<-0,Int32x4_WYZY<-0,Int32x4_WYZZ<-0,Int32x4_WYZW<-0,Int32x4_WYWX<-0,Int32x4_WYWY<-0,Int32x4_WYWZ<-0,Int32x4_WYWW<-0,Int32x4_WZXX<-0,Int32x4_WZXY<-0,Int32x4_WZXZ<-0,Int32x4_WZXW<-0,Int32x4_WZYX<-0,Int32x4_WZYY<-0,Int32x4_WZYZ<-0,Int32x4_WZYW<-0,Int32x4_WZZX<-0,Int32x4_WZZY<-0,Int32x4_WZZZ<-0,Int32x4_WZZW<-0,Int32x4_WZWX<-0,Int32x4_WZWY<-0,Int32x4_WZWZ<-0,Int32x4_WZWW<-0,Int32x4_WWXX<-0,Int32x4_WWXY<-0,Int32x4_WWXZ<-0,Int32x4_WWXW<-0,Int32x4_WWYX<-0,Int32x4_WWYY<-0,Int32x4_WWYZ<-0,Int32x4_WWYW<-0,Int32x4_WWZX<-0,Int32x4_WWZY<-0,Int32x4_WWZZ<-0,Int32x4_WWZW<-0,Int32x4_WWWX<-0,Int32x4_WWWY<-0,Int32x4_WWWZ<-0,Int32x4_WWWW<-0",
        Int32x4_Int32x4: [function(x, y, z, w) {
          return H.NativeInt32x4$(x, y, z, w);
        }, null, null, 8, 0, 1095, 38, [], 132, [], 244, [], 245, [], "new Int32x4"],
        Int32x4_Int32x4$bool: [function(x, y, z, w) {
          var t1, t2, t3;
          t1 = x === true ? -1 : 0;
          t2 = y === true ? -1 : 0;
          t3 = z === true ? -1 : 0;
          return new H.NativeInt32x4(t1, t2, t3, w === true ? -1 : 0);
        }, null, null, 8, 0, 1096, 38, [], 132, [], 244, [], 245, [], "new Int32x4$bool"],
        Int32x4_Int32x4$fromFloat32x4Bits: [function(x) {
          var floatList, t1, view, t2, t3, t4;
          floatList = $.$get$NativeFloat32x4__list();
          floatList[0] = x.get$x();
          floatList[1] = x.get$y();
          floatList[2] = x.get$z();
          floatList[3] = x.get$w();
          t1 = floatList.buffer;
          view = (t1 && C.NativeByteBuffer_methods).asInt32List$0(t1);
          t1 = view.length;
          if (0 >= t1)
            return H.ioore(view, 0);
          t2 = view[0];
          if (1 >= t1)
            return H.ioore(view, 1);
          t3 = view[1];
          if (2 >= t1)
            return H.ioore(view, 2);
          t4 = view[2];
          if (3 >= t1)
            return H.ioore(view, 3);
          return new H.NativeInt32x4(t2, t3, t4, view[3]);
        }, null, null, 2, 0, 98, 38, [], "new Int32x4$fromFloat32x4Bits"]
      }
    },
    "+Int32x4": [1],
    Float64x2: {
      "^": "Object;",
      static: {
        Float64x2_Float64x2: [function(x, y) {
          return H.NativeFloat64x2$(x, y);
        }, null, null, 4, 0, 1097, 38, [], 132, [], "new Float64x2"],
        Float64x2_Float64x2$splat: [function(v) {
          var t1 = new H.NativeFloat64x2(v, v);
          t1.NativeFloat64x2$2(v, v);
          return t1;
        }, null, null, 2, 0, 182, 56, [], "new Float64x2$splat"],
        Float64x2_Float64x2$zero: [function() {
          var t1 = new H.NativeFloat64x2(0, 0);
          t1.NativeFloat64x2$2(0, 0);
          return t1;
        }, null, null, 0, 0, 180, "new Float64x2$zero"],
        Float64x2_Float64x2$fromFloat32x4: [function(v) {
          var t1, t2, t3;
          t1 = v.get$x();
          t2 = v.get$y();
          t3 = new H.NativeFloat64x2(t1, t2);
          t3.NativeFloat64x2$2(t1, t2);
          return t3;
        }, null, null, 2, 0, 1098, 56, [], "new Float64x2$fromFloat32x4"]
      }
    },
    "+Float64x2": [1]
  }], ["", "package:args/src/arg_parser.dart",, N, {
    "^": "",
    ArgParser: {
      "^": "Object;_options<-533,_commands<-534,options<-533,commands<-534,_optionsAndSeparators<-10,allowTrailingOptions<-8",
      addCommand$2: [function($name, parser) {
        var t1 = this._commands;
        if (t1.containsKey$1($name))
          throw H.wrapException(P.ArgumentError$('Duplicate command "' + H.S($name) + '".'));
        if (parser == null)
          parser = N.ArgParser_ArgParser(false);
        J.$indexSet$ax(t1, $name, parser);
        return parser;
      }, function($name) {
        return this.addCommand$2($name, null);
      }, "addCommand$1", "call$2", "call$1", "get$addCommand", 2, 2, 541, 0, 13, [], 612, [], "addCommand"],
      addFlag$7$abbr$callback$defaultsTo$help$hide$negatable: [function($name, abbr, callback, defaultsTo, help, hide, negatable) {
        this._addOption$11$hide$negatable($name, abbr, help, null, null, null, defaultsTo, callback, C.OptionType_woc, hide, negatable);
      }, function($name) {
        return this.addFlag$7$abbr$callback$defaultsTo$help$hide$negatable($name, null, null, false, null, false, true);
      }, "addFlag$1", function($name, abbr) {
        return this.addFlag$7$abbr$callback$defaultsTo$help$hide$negatable($name, abbr, null, false, null, false, true);
      }, "addFlag$2$abbr", "call$7$abbr$callback$defaultsTo$help$hide$negatable", "call$1", "call$2$abbr", "get$addFlag", 2, 13, 542, 0, 0, 4, 25, 0, 4, 13, [], 300, [], 223, [], 405, [], 299, [], 33, [], 224, [], "addFlag"],
      addOption$11$abbr$allowMultiple$allowed$allowedHelp$callback$defaultsTo$help$hide$splitCommas$valueHelp: [function($name, abbr, allowMultiple, allowed, allowedHelp, callback, defaultsTo, help, hide, splitCommas, valueHelp) {
        var t1 = allowMultiple === true;
        if (!t1 && splitCommas != null)
          throw H.wrapException(P.ArgumentError$("splitCommas may not be set if allowMultiple is false."));
        this._addOption$11$hide$splitCommas($name, abbr, help, valueHelp, allowed, allowedHelp, defaultsTo, callback, t1 ? C.OptionType_Icb : C.OptionType_F9d, hide, splitCommas);
      }, function($name) {
        return this.addOption$11$abbr$allowMultiple$allowed$allowedHelp$callback$defaultsTo$help$hide$splitCommas$valueHelp($name, null, false, null, null, null, null, null, false, null, null);
      }, "addOption$1", function($name, abbr) {
        return this.addOption$11$abbr$allowMultiple$allowed$allowedHelp$callback$defaultsTo$help$hide$splitCommas$valueHelp($name, abbr, false, null, null, null, null, null, false, null, null);
      }, "addOption$2$abbr", "call$11$abbr$allowMultiple$allowed$allowedHelp$callback$defaultsTo$help$hide$splitCommas$valueHelp", "call$1", "call$2$abbr", "get$addOption", 2, 21, 543, 0, 0, 0, 0, 0, 0, 0, 4, 0, 4, 13, [], 300, [], 223, [], 295, [], 225, [], 287, [], 405, [], 33, [], 968, [], 286, [], 224, [], "addOption"],
      _addOption$12$hide$negatable$splitCommas: [function($name, abbr, help, valueHelp, allowed, allowedHelp, defaultsTo, callback, type, hide, negatable, splitCommas) {
        var t1, t2, existing, t3, t4, option;
        t1 = this._options;
        if (t1.containsKey$1($name))
          throw H.wrapException(P.ArgumentError$('Duplicate option "' + H.S($name) + '".'));
        t2 = abbr != null;
        if (t2) {
          existing = this.findByAbbreviation$1(abbr);
          if (existing != null)
            throw H.wrapException(P.ArgumentError$('Abbreviation "' + H.S(abbr) + '" is already used by "' + H.S(existing.get$name()) + '".'));
        }
        t3 = allowed == null ? null : new P.UnmodifiableListView(allowed, [null]);
        t4 = allowedHelp == null ? null : new P.UnmodifiableMapView(allowedHelp, [null, null]);
        option = new G.Option($name, abbr, t3, defaultsTo, callback, help, valueHelp, t4, type, negatable, splitCommas == null ? J.$eq$(type, C.OptionType_Icb) : splitCommas, hide);
        t3 = J.getInterceptor$asx($name);
        if (t3.get$isEmpty($name) === true)
          H.throwExpression(P.ArgumentError$("Name cannot be empty."));
        else if (t3.startsWith$1($name, "-"))
          H.throwExpression(P.ArgumentError$("Name " + H.S($name) + ' cannot start with "-".'));
        t3 = $.$get$Option__invalidChars()._nativeRegExp;
        if (t3.test(H.checkString($name)))
          H.throwExpression(P.ArgumentError$('Name "' + H.S($name) + '" contains invalid characters.'));
        if (t2) {
          t2 = J.getInterceptor$asx(abbr);
          if (!J.$eq$(t2.get$length(abbr), 1))
            H.throwExpression(P.ArgumentError$("Abbreviation must be null or have length 1."));
          else if (t2.$eq(abbr, "-"))
            H.throwExpression(P.ArgumentError$('Abbreviation cannot be "-".'));
          if (t3.test(H.checkString(abbr)))
            H.throwExpression(P.ArgumentError$("Abbreviation is an invalid character."));
        }
        J.$indexSet$ax(t1, $name, option);
        J.add$1$ax(this._optionsAndSeparators, option);
      }, function($name, abbr, help, valueHelp, allowed, allowedHelp, defaultsTo, callback, type, hide, splitCommas) {
        return this._addOption$12$hide$negatable$splitCommas($name, abbr, help, valueHelp, allowed, allowedHelp, defaultsTo, callback, type, hide, false, splitCommas);
      }, "_addOption$11$hide$splitCommas", function($name, abbr, help, valueHelp, allowed, allowedHelp, defaultsTo, callback, type, hide, negatable) {
        return this._addOption$12$hide$negatable$splitCommas($name, abbr, help, valueHelp, allowed, allowedHelp, defaultsTo, callback, type, hide, negatable, null);
      }, "_addOption$11$hide$negatable", "call$12$hide$negatable$splitCommas", "call$11$hide$splitCommas", "call$11$hide$negatable", "get$_addOption", 18, 7, 544, 4, 0, 4, 13, [], 300, [], 223, [], 295, [], 225, [], 287, [], 405, [], 33, [], 65, [], 299, [], 286, [], 224, [], "_addOption"],
      addSeparator$1: [function(text) {
        J.add$1$ax(this._optionsAndSeparators, text);
      }, "call$1", "get$addSeparator", 2, 0, 19, 106, [], "addSeparator"],
      parse$1: [function(args) {
        var t1, t2, t3;
        t1 = J.toList$0$ax(args);
        t2 = P.String;
        t3 = H.setRuntimeTypeInfo([], [t2]);
        return new G.Parser(null, null, this, t1, t3, P.LinkedHashMap_LinkedHashMap$_empty(t2, null)).parse$0();
      }, "call$1", "get$parse", 2, 0, 545, 360, [], "parse"],
      getUsage$0: [function() {
        return new G.Usage(this._optionsAndSeparators, null, 0, null, 0, 0).generate$0();
      }, "call$0", "get$getUsage", 0, 0, 7, "getUsage", 970],
      get$usage: [function() {
        return new G.Usage(this._optionsAndSeparators, null, 0, null, 0, 0).generate$0();
      }, null, null, 1, 0, 7, "usage"],
      getDefault$1: [function(option) {
        var t1 = this.options;
        if (!t1.containsKey$1(option))
          throw H.wrapException(P.ArgumentError$("No option named " + H.S(option)));
        return J.$index$asx(t1, option).get$defaultValue();
      }, "call$1", "get$getDefault", 2, 0, 13, 66, [], "getDefault"],
      findByAbbreviation$1: [function(abbr) {
        return this.options.get$values().firstWhere$2$orElse(0, new N.ArgParser_findByAbbreviation_closure(abbr), new N.ArgParser_findByAbbreviation_closure0());
      }, "call$1", "get$findByAbbreviation", 2, 0, 546, 300, [], "findByAbbreviation"],
      static: {
        ArgParser_ArgParser: [function(allowTrailingOptions) {
          var t1, t2, t3, t4;
          t1 = P.String;
          t2 = P.LinkedHashMap_LinkedHashMap$_empty(t1, G.Option);
          t1 = P.LinkedHashMap_LinkedHashMap$_empty(t1, N.ArgParser);
          t3 = [null, null];
          t4 = allowTrailingOptions != null && allowTrailingOptions;
          return new N.ArgParser(t2, t1, new P.UnmodifiableMapView(t2, t3), new P.UnmodifiableMapView(t1, t3), [], t4);
        }, null, null, 0, 3, 1099, 4, 600, [], "new ArgParser"],
        ArgParser$_: [function(options, commands, allowTrailingOptions) {
          var t1, t2;
          t1 = [null, null];
          t2 = allowTrailingOptions != null && allowTrailingOptions;
          return new N.ArgParser(options, commands, new P.UnmodifiableMapView(options, t1), new P.UnmodifiableMapView(commands, t1), [], t2);
        }, null, null, 4, 3, 1100, 4, 957, [], 427, [], 600, [], "new ArgParser$_"]
      }
    },
    "+ArgParser": [1],
    ArgParser_findByAbbreviation_closure: {
      "^": "Closure:3;abbr",
      call$1: [function(option) {
        return J.$eq$(option.get$abbreviation(), this.abbr);
      }, null, null, 2, 0, 3, 66, [], "call"]
    },
    "+ ArgParser_findByAbbreviation_closure": [2],
    ArgParser_findByAbbreviation_closure0: {
      "^": "Closure:4;",
      call$0: [function() {
        return;
      }, null, null, 0, 0, 4, "call"]
    },
    "+ ArgParser_findByAbbreviation_closure": [2]
  }], ["", "package:args/src/arg_parser_exception.dart",, Z, {
    "^": "",
    ArgParserException: {
      "^": "FormatException;commands<-61,message-9,source-10,offset-0",
      static: {
        ArgParserException$: [function(message, commands) {
          return new Z.ArgParserException(commands == null ? C.List_empty : P.List_List$unmodifiable(commands, null), message, null, null);
        }, null, null, 2, 2, 1101, 0, 17, [], 427, [], "new ArgParserException"]
      }
    },
    "+ArgParserException": [1663]
  }], ["", "package:args/src/arg_results.dart",, V, {
    "^": "",
    newArgResults: [function(parser, parsed, $name, command, rest, $arguments) {
      var t1 = [null];
      return new V.ArgResults(parser, parsed, $name, command, new P.UnmodifiableListView(rest, t1), new P.UnmodifiableListView($arguments, t1));
    }, "call$6", "arg_results__newArgResults$closure", 12, 0, 1102, 612, [], 971, [], 13, [], 534, [], 322, [], 69, [], "newArgResults"],
    ArgResults: {
      "^": "Object;_parser<-535,_parsed<-460,name<-9,command<-384,rest<-61,$arguments<-61",
      $index: [function(_, $name) {
        var t1 = this._parser;
        if (!t1.get$options().containsKey$1($name))
          throw H.wrapException(P.ArgumentError$('Could not find an option named "' + H.S($name) + '".'));
        return J.$index$asx(t1.get$options(), $name).getOrDefault$1(J.$index$asx(this._parsed, $name));
      }, null, "get$[]", 2, 0, 13, 13, [], "[]"],
      get$options: [function() {
        var result = P.LinkedHashSet_LinkedHashSet$from(this._parsed.get$keys(), P.String);
        J.forEach$1$ax(this._parser.get$options(), new V.ArgResults_options_closure(result));
        return result;
      }, null, null, 1, 0, 371, "options"],
      wasParsed$1: [function($name) {
        if (J.$index$asx(this._parser.get$options(), $name) == null)
          throw H.wrapException(P.ArgumentError$('Could not find an option named "' + H.S($name) + '".'));
        return this._parsed.containsKey$1($name);
      }, "call$1", "get$wasParsed", 2, 0, 30, 13, [], "wasParsed"],
      static: {
        ArgResults$_: [function(_parser, _parsed, $name, command, rest, $arguments) {
          var t1 = [null];
          return new V.ArgResults(_parser, _parsed, $name, command, new P.UnmodifiableListView(rest, t1), new P.UnmodifiableListView($arguments, t1));
        }, null, null, 12, 0, 1103, 974, [], 975, [], 13, [], 534, [], 322, [], 69, [], "new ArgResults$_"]
      }
    },
    "+ArgResults": [1],
    ArgResults_options_closure: {
      "^": "Closure:12;result",
      call$2: [function($name, option) {
        if (option.get$defaultValue() != null)
          this.result.add$1(0, $name);
      }, null, null, 4, 0, 12, 13, [], 66, [], "call"]
    },
    "+ ArgResults_options_closure": [2]
  }], ["", "package:args/src/option.dart",, G, {
    "^": "",
    newOption: [function($name, abbreviation, help, valueHelp, allowed, allowedHelp, defaultValue, callback, type, hide, negatable, splitCommas) {
      var t1, t2, t3, t4, t5;
      t1 = allowed == null ? null : new P.UnmodifiableListView(allowed, [null]);
      t2 = allowedHelp == null ? null : new P.UnmodifiableMapView(allowedHelp, [null, null]);
      t3 = splitCommas == null ? J.$eq$(type, C.OptionType_Icb) : splitCommas;
      t4 = J.getInterceptor$asx($name);
      if (t4.get$isEmpty($name) === true)
        H.throwExpression(P.ArgumentError$("Name cannot be empty."));
      else if (t4.startsWith$1($name, "-"))
        H.throwExpression(P.ArgumentError$("Name " + H.S($name) + ' cannot start with "-".'));
      t4 = $.$get$Option__invalidChars()._nativeRegExp;
      if (t4.test(H.checkString($name)))
        H.throwExpression(P.ArgumentError$('Name "' + H.S($name) + '" contains invalid characters.'));
      if (abbreviation != null) {
        t5 = J.getInterceptor$asx(abbreviation);
        if (!J.$eq$(t5.get$length(abbreviation), 1))
          H.throwExpression(P.ArgumentError$("Abbreviation must be null or have length 1."));
        else if (t5.$eq(abbreviation, "-"))
          H.throwExpression(P.ArgumentError$('Abbreviation cannot be "-".'));
        if (t4.test(H.checkString(abbreviation)))
          H.throwExpression(P.ArgumentError$("Abbreviation is an invalid character."));
      }
      return new G.Option($name, abbreviation, t1, defaultValue, callback, help, valueHelp, t2, type, negatable, t3, hide);
    }, function($name, abbreviation, help, valueHelp, allowed, allowedHelp, defaultValue, callback, type, hide, splitCommas) {
      return G.newOption($name, abbreviation, help, valueHelp, allowed, allowedHelp, defaultValue, callback, type, hide, null, splitCommas);
    }, function($name, abbreviation, help, valueHelp, allowed, allowedHelp, defaultValue, callback, type, hide, negatable) {
      return G.newOption($name, abbreviation, help, valueHelp, allowed, allowedHelp, defaultValue, callback, type, hide, negatable, null);
    }, "call$12$hide$negatable$splitCommas", "call$11$hide$splitCommas", "call$11$hide$negatable", "option__newOption$closure", 18, 7, 1104, 0, 0, 4, 13, [], 431, [], 223, [], 295, [], 225, [], 287, [], 135, [], 33, [], 65, [], 299, [], 286, [], 224, [], "newOption"],
    Option: {
      "^": "Object;name<-9,abbreviation<-9,allowed<-61,defaultValue<-10,callback<-29,help<-9,valueHelp<-9,allowedHelp<-82,type<-1667,negatable<-8,splitCommas<-8,hide<-8",
      get$isFlag: [function() {
        return J.$eq$(this.type, C.OptionType_woc);
      }, null, null, 1, 0, 5, "isFlag"],
      get$isSingle: [function() {
        return J.$eq$(this.type, C.OptionType_F9d);
      }, null, null, 1, 0, 5, "isSingle"],
      get$isMultiple: [function() {
        return J.$eq$(this.type, C.OptionType_Icb);
      }, null, null, 1, 0, 5, "isMultiple"],
      getOrDefault$1: [function(value) {
        var t1;
        if (value != null)
          return value;
        if (!J.$eq$(this.type, C.OptionType_Icb))
          return this.defaultValue;
        t1 = this.defaultValue;
        if (t1 != null)
          return [t1];
        return [];
      }, "call$1", "get$getOrDefault", 2, 0, 3, 1, [], "getOrDefault"],
      callback$1: function(arg0) {
        return this.callback.call$1(arg0);
      },
      static: {
        "^": "Option__invalidChars<-10",
        Option$_: [function($name, abbreviation, help, valueHelp, allowed, allowedHelp, defaultValue, callback, type, hide, negatable, splitCommas) {
          var t1, t2, t3, t4, t5;
          t1 = allowed == null ? null : new P.UnmodifiableListView(allowed, [null]);
          t2 = allowedHelp == null ? null : new P.UnmodifiableMapView(allowedHelp, [null, null]);
          t3 = splitCommas == null ? J.$eq$(type, C.OptionType_Icb) : splitCommas;
          t4 = J.getInterceptor$asx($name);
          if (t4.get$isEmpty($name) === true)
            H.throwExpression(P.ArgumentError$("Name cannot be empty."));
          else if (t4.startsWith$1($name, "-"))
            H.throwExpression(P.ArgumentError$("Name " + H.S($name) + ' cannot start with "-".'));
          t4 = $.$get$Option__invalidChars()._nativeRegExp;
          if (t4.test(H.checkString($name)))
            H.throwExpression(P.ArgumentError$('Name "' + H.S($name) + '" contains invalid characters.'));
          if (abbreviation != null) {
            t5 = J.getInterceptor$asx(abbreviation);
            if (!J.$eq$(t5.get$length(abbreviation), 1))
              H.throwExpression(P.ArgumentError$("Abbreviation must be null or have length 1."));
            else if (t5.$eq(abbreviation, "-"))
              H.throwExpression(P.ArgumentError$('Abbreviation cannot be "-".'));
            if (t4.test(H.checkString(abbreviation)))
              H.throwExpression(P.ArgumentError$("Abbreviation is an invalid character."));
          }
          return new G.Option($name, abbreviation, t1, defaultValue, callback, help, valueHelp, t2, type, negatable, t3, hide);
        }, null, null, 18, 7, 1105, 0, 0, 4, 13, [], 431, [], 223, [], 295, [], 225, [], 287, [], 135, [], 33, [], 65, [], 299, [], 286, [], 224, [], "new Option$_"]
      }
    },
    "+Option": [1],
    OptionType: {
      "^": "Object;name<-9",
      static: {
        "^": "OptionType_FLAG<-10,OptionType_SINGLE<-10,OptionType_MULTIPLE<-10",
        OptionType$_: [function($name) {
          return new G.OptionType($name);
        }, null, null, 2, 0, 13, 13, [], "new OptionType$_"]
      }
    },
    "+OptionType": [1]
  }], ["", "package:args/src/parser.dart",, G, {
    "^": "_LONG_OPT<-10,_ABBR_OPT<-10,_SOLO_OPT<-10",
    Parser: {
      "^": "Object;commandName<-9,parent<-1668,grammar<-535,args<-61,rest<-10,results<-460",
      get$current: [function() {
        return J.$index$asx(this.args, 0);
      }, null, null, 1, 0, 7, "current"],
      parse$0: [function() {
        var commandResults, commandName, commandParser, error, t1, t2, $arguments, t3, t4, t5, command, t6, t7, exception;
        t1 = this.args;
        t2 = J.getInterceptor$ax(t1);
        $arguments = t2.toList$0(t1);
        commandResults = null;
        for (t3 = this.rest, t4 = J.getInterceptor$asx(t3), t5 = this.grammar; J.$gt$n(t2.get$length(t1), 0);) {
          if (J.$eq$(t2.$index(t1, 0), "--")) {
            t2.removeAt$1(t1, 0);
            break;
          }
          command = J.$index$asx(t5.get$commands(), t2.$index(t1, 0));
          if (command != null) {
            if (t4.get$isEmpty(t3) !== true)
              H.throwExpression(Z.ArgParserException$("Cannot specify arguments before a command.", null));
            commandName = t2.removeAt$1(t1, 0);
            t6 = P.String;
            t7 = H.setRuntimeTypeInfo([], [t6]);
            if (t3 != null)
              C.JSArray_methods.addAll$1(t7, t3);
            commandParser = new G.Parser(commandName, this, command, t1, t7, P.LinkedHashMap_LinkedHashMap$_empty(t6, null));
            try {
              commandResults = commandParser.parse$0();
            } catch (exception) {
              t1 = H.unwrapException(exception);
              if (t1 instanceof Z.ArgParserException) {
                error = t1;
                if (commandName == null)
                  throw exception;
                t1 = error.get$message();
                t2 = [commandName];
                C.JSArray_methods.addAll$1(t2, error.get$commands());
                throw H.wrapException(Z.ArgParserException$(t1, t2));
              } else
                throw exception;
            }
            t4.clear$0(t3);
            break;
          }
          if (this.parseSoloOption$0())
            continue;
          if (this.parseAbbreviation$1(this))
            continue;
          if (this.parseLongOption$0())
            continue;
          if (t5.get$allowTrailingOptions() !== true)
            break;
          t4.add$1(t3, t2.removeAt$1(t1, 0));
        }
        J.forEach$1$ax(t5.get$options(), new G.Parser_parse_closure(this));
        t4.addAll$1(t3, t1);
        t2.clear$0(t1);
        t1 = [null];
        return new V.ArgResults(t5, this.results, this.commandName, commandResults, new P.UnmodifiableListView(t3, t1), new P.UnmodifiableListView($arguments, t1));
      }, "call$0", "get$parse", 0, 0, 547, "parse"],
      readNextArgAsValue$1: [function(option) {
        var t1, t2, t3, t4;
        t1 = this.args;
        t2 = J.getInterceptor$asx(t1);
        t3 = J.$gt$n(t2.get$length(t1), 0);
        t4 = 'Missing argument for "' + H.S(option.get$name()) + '".';
        if (!t3)
          H.throwExpression(Z.ArgParserException$(t4, null));
        this.setOption$3(this.results, option, t2.$index(t1, 0));
        t2.removeAt$1(t1, 0);
      }, "call$1", "get$readNextArgAsValue", 2, 0, 548, 66, [], "readNextArgAsValue"],
      parseSoloOption$0: [function() {
        var t1, t2, soloOpt, t3, option, t4;
        t1 = this.args;
        t2 = J.getInterceptor$asx(t1);
        soloOpt = $.$get$_SOLO_OPT().firstMatch$1(t2.$index(t1, 0));
        if (soloOpt == null)
          return false;
        t3 = soloOpt._match;
        if (1 >= t3.length)
          return H.ioore(t3, 1);
        option = this.grammar.findByAbbreviation$1(t3[1]);
        if (option == null) {
          t1 = this.parent;
          if (1 >= t3.length)
            return H.ioore(t3, 1);
          t3 = 'Could not find an option or flag "-' + H.S(t3[1]) + '".';
          if (t1 == null)
            H.throwExpression(Z.ArgParserException$(t3, null));
          return t1.parseSoloOption$0();
        }
        t2.removeAt$1(t1, 0);
        if (option.get$isFlag())
          J.$indexSet$ax(this.results, option.get$name(), true);
        else {
          t3 = J.$gt$n(t2.get$length(t1), 0);
          t4 = 'Missing argument for "' + H.S(option.get$name()) + '".';
          if (!t3)
            H.throwExpression(Z.ArgParserException$(t4, null));
          this.setOption$3(this.results, option, t2.$index(t1, 0));
          t2.removeAt$1(t1, 0);
        }
        return true;
      }, "call$0", "get$parseSoloOption", 0, 0, 5, "parseSoloOption"],
      parseAbbreviation$1: [function(innermostCommand) {
        var t1, t2, abbrOpt, t3, c, first, t4, t5, i, i0;
        t1 = this.args;
        t2 = J.getInterceptor$asx(t1);
        abbrOpt = $.$get$_ABBR_OPT().firstMatch$1(t2.$index(t1, 0));
        if (abbrOpt == null)
          return false;
        t3 = abbrOpt._match;
        if (1 >= t3.length)
          return H.ioore(t3, 1);
        c = J.substring$2$s(t3[1], 0, 1);
        first = this.grammar.findByAbbreviation$1(c);
        if (first == null) {
          t1 = this.parent;
          t2 = 'Could not find an option with short name "-' + c + '".';
          if (t1 == null)
            H.throwExpression(Z.ArgParserException$(t2, null));
          return t1.parseAbbreviation$1(innermostCommand);
        } else if (!first.get$isFlag()) {
          if (1 >= t3.length)
            return H.ioore(t3, 1);
          t4 = J.substring$1$s(t3[1], 1);
          if (2 >= t3.length)
            return H.ioore(t3, 2);
          this.setOption$3(this.results, first, t4 + H.S(t3[2]));
        } else {
          if (2 >= t3.length)
            return H.ioore(t3, 2);
          t4 = J.$eq$(t3[2], "");
          t5 = 'Option "-' + c + '" is a flag and cannot handle value "';
          if (1 >= t3.length)
            return H.ioore(t3, 1);
          t5 += J.substring$1$s(t3[1], 1);
          if (2 >= t3.length)
            return H.ioore(t3, 2);
          t5 = t5 + H.S(t3[2]) + '".';
          if (!t4)
            H.throwExpression(Z.ArgParserException$(t5, null));
          i = 0;
          while (true) {
            if (1 >= t3.length)
              return H.ioore(t3, 1);
            t4 = J.get$length$asx(t3[1]);
            if (typeof t4 !== "number")
              return H.iae(t4);
            if (!(i < t4))
              break;
            if (1 >= t3.length)
              return H.ioore(t3, 1);
            i0 = i + 1;
            innermostCommand.parseShortFlag$1(J.substring$2$s(t3[1], i, i0));
            i = i0;
          }
        }
        t2.removeAt$1(t1, 0);
        return true;
      }, "call$1", "get$parseAbbreviation", 2, 0, 549, 979, [], "parseAbbreviation"],
      parseShortFlag$1: [function(c) {
        var option, t1, t2;
        option = this.grammar.findByAbbreviation$1(c);
        if (option == null) {
          t1 = this.parent;
          t2 = 'Could not find an option with short name "-' + H.S(c) + '".';
          if (t1 == null)
            H.throwExpression(Z.ArgParserException$(t2, null));
          t1.parseShortFlag$1(c);
          return;
        }
        t1 = option.get$isFlag();
        t2 = 'Option "-' + H.S(c) + '" must be a flag to be in a collapsed "-".';
        if (!t1)
          H.throwExpression(Z.ArgParserException$(t2, null));
        J.$indexSet$ax(this.results, option.get$name(), true);
      }, "call$1", "get$parseShortFlag", 2, 0, 19, 301, [], "parseShortFlag"],
      parseLongOption$0: [function() {
        var t1, t2, longOpt, t3, $name, t4, option;
        t1 = this.args;
        t2 = J.getInterceptor$asx(t1);
        longOpt = $.$get$_LONG_OPT().firstMatch$1(t2.$index(t1, 0));
        if (longOpt == null)
          return false;
        t3 = longOpt._match;
        if (1 >= t3.length)
          return H.ioore(t3, 1);
        $name = t3[1];
        t4 = this.grammar;
        option = J.$index$asx(t4.get$options(), $name);
        if (option != null) {
          t2.removeAt$1(t1, 0);
          if (option.get$isFlag()) {
            if (3 >= t3.length)
              return H.ioore(t3, 3);
            t1 = t3[3];
            t2 = 'Flag option "' + H.S($name) + '" should not be given a value.';
            if (t1 != null)
              H.throwExpression(Z.ArgParserException$(t2, null));
            J.$indexSet$ax(this.results, option.get$name(), true);
          } else {
            if (3 >= t3.length)
              return H.ioore(t3, 3);
            t3 = t3[3];
            if (t3 != null)
              this.setOption$3(this.results, option, t3);
            else {
              t3 = J.$gt$n(t2.get$length(t1), 0);
              t4 = 'Missing argument for "' + H.S(option.get$name()) + '".';
              if (!t3)
                H.throwExpression(Z.ArgParserException$(t4, null));
              this.setOption$3(this.results, option, t2.$index(t1, 0));
              t2.removeAt$1(t1, 0);
            }
          }
        } else {
          t3 = J.getInterceptor$s($name);
          if (t3.startsWith$1($name, "no-")) {
            $name = t3.substring$1($name, 3);
            option = J.$index$asx(t4.get$options(), $name);
            if (option == null) {
              t1 = this.parent;
              t2 = 'Could not find an option named "' + $name + '".';
              if (t1 == null)
                H.throwExpression(Z.ArgParserException$(t2, null));
              return t1.parseLongOption$0();
            }
            t2.removeAt$1(t1, 0);
            t1 = option.get$isFlag();
            t2 = 'Cannot negate non-flag option "' + $name + '".';
            if (!t1)
              H.throwExpression(Z.ArgParserException$(t2, null));
            t1 = option.get$negatable();
            t2 = 'Cannot negate option "' + $name + '".';
            if (t1 !== true)
              H.throwExpression(Z.ArgParserException$(t2, null));
            J.$indexSet$ax(this.results, option.get$name(), false);
          } else {
            t1 = this.parent;
            t2 = 'Could not find an option named "' + H.S($name) + '".';
            if (t1 == null)
              H.throwExpression(Z.ArgParserException$(t2, null));
            return t1.parseLongOption$0();
          }
        }
        return true;
      }, "call$0", "get$parseLongOption", 0, 0, 5, "parseLongOption"],
      validate$2: [function(condition, message) {
        if (condition !== true)
          throw H.wrapException(Z.ArgParserException$(message, null));
      }, "call$2", "get$validate", 4, 0, 550, 980, [], 17, [], "validate"],
      setOption$3: [function(results, option, value) {
        var list, t1, t2, t3, _i, element;
        if (!option.get$isMultiple()) {
          this._validateAllowed$2(option, value);
          J.$indexSet$ax(results, option.get$name(), value);
          return;
        }
        list = results.putIfAbsent$2(option.get$name(), new G.Parser_setOption_closure());
        if (option.get$splitCommas() === true)
          for (t1 = J.split$1$s(value, ","), t2 = t1.length, t3 = J.getInterceptor$ax(list), _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
            element = t1[_i];
            this._validateAllowed$2(option, element);
            t3.add$1(list, element);
          }
        else {
          this._validateAllowed$2(option, value);
          J.add$1$ax(list, value);
        }
      }, "call$3", "get$setOption", 6, 0, 551, 430, [], 66, [], 1, [], "setOption"],
      setFlag$3: [function(results, option, value) {
        J.$indexSet$ax(results, option.get$name(), value);
      }, "call$3", "get$setFlag", 6, 0, 552, 430, [], 66, [], 1, [], "setFlag"],
      _validateAllowed$2: [function(option, value) {
        var t1, t2;
        if (option.get$allowed() == null)
          return;
        t1 = J.contains$1$asx(option.get$allowed(), value);
        t2 = '"' + H.S(value) + '" is not an allowed value for option "' + H.S(option.get$name()) + '".';
        if (t1 !== true)
          H.throwExpression(Z.ArgParserException$(t2, null));
      }, "call$2", "get$_validateAllowed", 4, 0, 553, 66, [], 1, [], "_validateAllowed"],
      static: {
        Parser$: [function(commandName, grammar, args, $parent, rest) {
          var t1, t2;
          t1 = P.String;
          t2 = H.setRuntimeTypeInfo([], [t1]);
          if (rest != null)
            C.JSArray_methods.addAll$1(t2, rest);
          return new G.Parser(commandName, $parent, grammar, args, t2, P.LinkedHashMap_LinkedHashMap$_empty(t1, null));
        }, null, null, 6, 4, 1106, 0, 0, 977, [], 978, [], 360, [], 62, [], 322, [], "new Parser"]
      }
    },
    "+Parser": [1],
    Parser_parse_closure: {
      "^": "Closure:12;$this",
      call$2: [function($name, option) {
        if (option.get$callback() == null)
          return;
        option.callback$1(option.getOrDefault$1(J.$index$asx(this.$this.results, $name)));
      }, null, null, 4, 0, 12, 13, [], 66, [], "call"]
    },
    "+ Parser_parse_closure": [2],
    Parser_setOption_closure: {
      "^": "Closure:4;",
      call$0: [function() {
        return H.setRuntimeTypeInfo([], [P.String]);
      }, null, null, 0, 0, 4, "call"]
    },
    "+ Parser_setOption_closure": [2]
  }], ["", "package:args/src/usage.dart",, G, {
    "^": "",
    padRight: [function(source, $length) {
      var t1 = H.S(source);
      while (true) {
        if (typeof $length !== "number")
          return H.iae($length);
        if (!(t1.length < $length))
          break;
        t1 += " ";
      }
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }, "call$2", "usage__padRight$closure", 4, 0, 1108, 19, [], 15, [], "padRight"],
    Usage: {
      "^": "Object;optionsAndSeparators<-50,buffer*-256,currentColumn@-0,columnWidths@-14,numHelpLines@-0,newlinesNeeded@-0",
      generate$0: [function() {
        var t1, optionOrSeparator, t2, allowedNames, t3, _i, $name, t4;
        this.buffer = new P.StringBuffer("");
        this.calculateColumnWidths$0();
        for (t1 = J.get$iterator$ax(this.optionsAndSeparators); t1.moveNext$0();) {
          optionOrSeparator = t1.get$current();
          if (typeof optionOrSeparator === "string") {
            if (J.get$isNotEmpty$asx(this.buffer))
              this.buffer.write$1("\n\n");
            this.buffer.write$1(optionOrSeparator);
            this.newlinesNeeded = 1;
            continue;
          }
          H.interceptedTypeCast(optionOrSeparator, "$isOption");
          if (optionOrSeparator.hide === true)
            continue;
          this.write$2(0, this.getAbbreviation$1(optionOrSeparator));
          this.write$2(1, this.getLongOption$1(optionOrSeparator));
          t2 = optionOrSeparator.help;
          if (t2 != null)
            this.write$2(2, t2);
          t2 = optionOrSeparator.allowedHelp;
          if (t2 != null) {
            allowedNames = t2.get$keys().toList$1$growable(0, false);
            t3 = allowedNames.length - 1;
            if (t3 - 0 <= 32)
              H.Sort__insertionSort(allowedNames, 0, t3, P.core_Comparable_compare$closure());
            else
              H.Sort__dualPivotQuicksort(allowedNames, 0, t3, P.core_Comparable_compare$closure());
            this.newlinesNeeded = J.$add$ns(this.newlinesNeeded, 1);
            this.currentColumn = 0;
            this.numHelpLines = 0;
            for (t3 = allowedNames.length, _i = 0; _i < allowedNames.length; allowedNames.length === t3 || (0, H.throwConcurrentModificationError)(allowedNames), ++_i) {
              $name = allowedNames[_i];
              this.write$2(1, "      [" + H.S($name) + "]");
              this.write$2(2, J.$index$asx(t2, $name));
            }
            this.newlinesNeeded = J.$add$ns(this.newlinesNeeded, 1);
            this.currentColumn = 0;
            this.numHelpLines = 0;
          } else if (optionOrSeparator.allowed != null)
            this.write$2(2, this.buildAllowedList$1(optionOrSeparator));
          else {
            t2 = optionOrSeparator.defaultValue;
            if (t2 != null) {
              t3 = optionOrSeparator.type;
              t4 = J.getInterceptor(t3);
              if (t4.$eq(t3, C.OptionType_woc) && J.$eq$(t2, true))
                this.write$2(2, "(defaults to on)");
              else if (!t4.$eq(t3, C.OptionType_woc))
                this.write$2(2, '(defaults to "' + H.S(t2) + '")');
            }
          }
          if (J.$gt$n(this.numHelpLines, 1)) {
            this.newlinesNeeded = J.$add$ns(this.newlinesNeeded, 1);
            this.currentColumn = 0;
            this.numHelpLines = 0;
          }
        }
        return J.toString$0$(this.buffer);
      }, "call$0", "get$generate", 0, 0, 7, "generate"],
      getAbbreviation$1: [function(option) {
        if (option.get$abbreviation() != null)
          return "-" + H.S(option.get$abbreviation()) + ", ";
        else
          return "";
      }, "call$1", "get$getAbbreviation", 2, 0, 253, 66, [], "getAbbreviation"],
      getLongOption$1: [function(option) {
        var result = option.get$negatable() === true ? "--[no-]" + H.S(option.get$name()) : "--" + H.S(option.get$name());
        return option.get$valueHelp() != null ? result + ("=<" + H.S(option.get$valueHelp()) + ">") : result;
      }, "call$1", "get$getLongOption", 2, 0, 253, 66, [], "getLongOption"],
      getAllowedTitle$1: [function(allowed) {
        return "      [" + H.S(allowed) + "]";
      }, "call$1", "get$getAllowedTitle", 2, 0, 28, 225, [], "getAllowedTitle"],
      calculateColumnWidths$0: [function() {
        var t1, abbr, title, option, t2;
        for (t1 = J.get$iterator$ax(this.optionsAndSeparators), abbr = 0, title = 0; t1.moveNext$0();) {
          option = t1.get$current();
          if (!(option instanceof G.Option))
            continue;
          if (option.hide === true)
            continue;
          abbr = P.max(abbr, this.getAbbreviation$1(option).length);
          title = P.max(title, this.getLongOption$1(option).length);
          t2 = option.allowedHelp;
          if (t2 != null)
            for (t2 = t2.get$keys(), t2 = t2.get$iterator(t2); t2.moveNext$0();)
              title = P.max(title, ("      [" + H.S(t2.get$current()) + "]").length);
        }
        this.columnWidths = [abbr, title + 4];
      }, "call$0", "get$calculateColumnWidths", 0, 0, 6, "calculateColumnWidths"],
      newline$0: [function() {
        this.newlinesNeeded = J.$add$ns(this.newlinesNeeded, 1);
        this.currentColumn = 0;
        this.numHelpLines = 0;
      }, "call$0", "get$newline", 0, 0, 6, "newline"],
      write$2: [function(column, text) {
        var lines, t1, _i;
        lines = J.split$1$s(text, "\n");
        while (true) {
          if (!(lines.length > 0 && J.trim$0$s(lines[0]) === ""))
            break;
          P.RangeError_checkValidRange(0, 1, lines.length, null, null, null);
          lines.splice(0, 1);
        }
        while (true) {
          t1 = lines.length;
          if (!(t1 > 0 && J.trim$0$s(lines[t1 - 1]) === ""))
            break;
          if (0 >= lines.length)
            return H.ioore(lines, -1);
          lines.pop();
        }
        for (t1 = lines.length, _i = 0; _i < lines.length; lines.length === t1 || (0, H.throwConcurrentModificationError)(lines), ++_i)
          this.writeLine$2(column, lines[_i]);
      }, "call$2", "get$write", 4, 0, 381, 590, [], 106, [], "write"],
      writeLine$2: [function(column, text) {
        var t1, t2, t3;
        for (; J.$gt$n(this.newlinesNeeded, 0);) {
          this.buffer.write$1("\n");
          this.newlinesNeeded = J.$sub$n(this.newlinesNeeded, 1);
        }
        for (; !J.$eq$(this.currentColumn, column);) {
          t1 = J.$lt$n(this.currentColumn, 2);
          t2 = this.buffer;
          if (t1)
            t2.write$1(G.padRight("", J.$index$asx(this.columnWidths, this.currentColumn)));
          else
            t2.write$1("\n");
          this.currentColumn = J.$mod$n(J.$add$ns(this.currentColumn, 1), 3);
        }
        t1 = J.getInterceptor$n(column);
        t2 = t1.$lt(column, J.get$length$asx(this.columnWidths));
        t3 = this.buffer;
        if (t2)
          t3.write$1(G.padRight(text, J.$index$asx(this.columnWidths, column)));
        else
          t3.write$1(text);
        this.currentColumn = J.$mod$n(J.$add$ns(this.currentColumn, 1), 3);
        if (t1.$eq(column, 2))
          this.newlinesNeeded = J.$add$ns(this.newlinesNeeded, 1);
        if (t1.$eq(column, 2))
          this.numHelpLines = J.$add$ns(this.numHelpLines, 1);
        else
          this.numHelpLines = 0;
      }, "call$2", "get$writeLine", 4, 0, 381, 590, [], 106, [], "writeLine"],
      buildAllowedList$1: [function(option) {
        var t1, first, t2, allowed;
        for (t1 = J.get$iterator$ax(option.get$allowed()), first = true, t2 = "["; t1.moveNext$0(); first = false) {
          allowed = t1.get$current();
          if (!first)
            t2 += ", ";
          t2 += H.S(allowed);
          if (J.$eq$(allowed, option.get$defaultValue()))
            t2 += " (default)";
        }
        t1 = t2 + "]";
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, "call$1", "get$buildAllowedList", 2, 0, 253, 66, [], "buildAllowedList"],
      static: {
        "^": "Usage_NUM_COLUMNS<-10",
        Usage$: [function(optionsAndSeparators) {
          return new G.Usage(optionsAndSeparators, null, 0, null, 0, 0);
        }, null, null, 2, 0, 1107, 982, [], "new Usage"]
      }
    },
    "+Usage": [1]
  }], ["", "package:dart_shapes/line-parser.dart",, R, {
    "^": "",
    LineParser: {
      "^": "Object;",
      static: {
        LineParser$: [function() {
          return new R.LineParser();
        }, null, null, 0, 0, 1109, "new LineParser"]
      }
    },
    "+LineParser": [1]
  }], ["", "package:dart_shapes/shapes-mirror.dart",, R, {
    "^": "",
    ShapesMirror: {
      "^": "Object;_classMirrors@-10,_symbolCache@-10,_emptySymbol<-10,shapes@-10",
      buildMirrors$0: [function() {
        var t1, t2, shapeInterface, t3, key, classMirror;
        $.$get$currentJsMirrorSystem().toString;
        t1 = J.get$single$ax(H.JsMirrorSystem_librariesByName().$index(0, "shapes")).get$declarations()._collection$_map;
        t2 = J.getInterceptor$asx(t1);
        shapeInterface = t2.$index(t1, C.Symbol_Shape);
        for (t3 = t1.get$keys(), t3 = t3.get$iterator(t3); t3.moveNext$0();) {
          key = t3.get$current();
          classMirror = t2.$index(t1, key);
          classMirror.get$isAbstract();
          if (J.contains$1$asx(classMirror.get$superinterfaces(), shapeInterface))
            J.$indexSet$ax(this._classMirrors, key, classMirror);
        }
      }, "call$0", "get$buildMirrors", 0, 0, 4, "buildMirrors"],
      reflect$1: [function(shapeDefinition) {
        var $arguments, className, t1, numericArgs;
        $arguments = J.split$1$s(shapeDefinition, " ");
        className = C.JSArray_methods.removeAt$1($arguments, 0);
        t1 = J.getInterceptor$s(className);
        className = t1.substring$2(className, 0, 1).toUpperCase() + t1.substring$1(className, 1).toLowerCase();
        numericArgs = new H.MappedListIterable($arguments, new R.ShapesMirror_reflect_closure(), [null, null]).toList$0(0);
        if (!this._symbolCache.containsKey$1(className))
          J.$indexSet$ax(this._symbolCache, className, new H.Symbol0(H.Symbol_validatePublicSymbol(className)));
        return J.$index$asx(this._classMirrors, J.$index$asx(this._symbolCache, className)).newInstance$2(this._emptySymbol, numericArgs).reflectee;
      }, "call$1", "get$reflect", 2, 0, 556, 984, [], "reflect"],
      parse$1: [function(line) {
        J.add$1$ax(this.shapes, this.reflect$1(line));
      }, "call$1", "get$parse", 2, 0, 13, 161, [], "parse"],
      static: {
        ShapesMirror$: [function() {
          var t1, t2;
          t1 = P.Symbol;
          t2 = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [t1, P.ClassMirror]);
          t1 = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [P.String, t1]);
          return new R.ShapesMirror(t2, t1, new H.Symbol0(H.Symbol_validatePublicSymbol("")), H.setRuntimeTypeInfo([], [M.Shape]));
        }, null, null, 0, 0, 1110, "new ShapesMirror"]
      }
    },
    "+ShapesMirror": [1, 1669],
    ShapesMirror_reflect_closure: {
      "^": "Closure:3;",
      call$1: [function(argument) {
        return P.num_parse(argument, null);
      }, null, null, 2, 0, 3, 447, [], "call"]
    },
    "+ ShapesMirror_reflect_closure": [2]
  }], ["shapes", "package:dart_shapes/shapes.dart",, M, {
    "^": "",
    Circle: {
      "^": "Object;_r<-46",
      area$0: [function() {
        var t1 = this._r;
        return J.$mul$ns(J.$mul$ns(t1, t1), 3.141592653589793);
      }, "call$0", "get$area", 0, 0, 4, "area"],
      circumference$0: [function() {
        var t1 = this._r;
        if (typeof t1 !== "number")
          return H.iae(t1);
        return 2 * t1 * 3.141592653589793;
      }, "call$0", "get$circumference", 0, 0, 4, "circumference"],
      toString$0: [function(_) {
        return "Circle(" + H.S(this._r) + ")";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isShape: 1,
      static: {
        Circle$: [function(_r) {
          return new M.Circle(_r);
        }, null, null, 2, 0, 435, 985, [], "new Circle"]
      }
    },
    "+Circle": [1, 286],
    Rectangle0: {
      "^": "Object;_x<-46,_y<-46",
      area$0: [function() {
        return J.$mul$ns(this._x, this._y);
      }, "call$0", "get$area", 0, 0, 4, "area"],
      circumference$0: [function() {
        var t1, t2;
        t1 = this._x;
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2 = this._y;
        if (typeof t2 !== "number")
          return H.iae(t2);
        return 2 * t1 * t2;
      }, "call$0", "get$circumference", 0, 0, 4, "circumference"],
      toString$0: [function(_) {
        return "Rectangle(" + H.S(this._x) + ", " + H.S(this._y) + ")";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isShape: 1,
      static: {
        Rectangle$0: [function(_x, _y) {
          return new M.Rectangle0(_x, _y);
        }, null, null, 4, 0, 1112, 573, [], 987, [], "new Rectangle"]
      }
    },
    "+Rectangle": [1, 286],
    Shape: {
      "^": "Object;",
      static: {
        Shape$: [function() {
          return new M.Shape();
        }, null, null, 0, 0, 1113, "new Shape"]
      }
    },
    "+Shape": [1],
    Square: {
      "^": "Object;_x<-46",
      area$0: [function() {
        var t1 = this._x;
        return J.$mul$ns(t1, t1);
      }, "call$0", "get$area", 0, 0, 4, "area"],
      circumference$0: [function() {
        var t1 = this._x;
        if (typeof t1 !== "number")
          return H.iae(t1);
        return 4 * t1;
      }, "call$0", "get$circumference", 0, 0, 4, "circumference"],
      toString$0: [function(_) {
        return "Square(" + H.S(this._x) + ")";
      }, "call$0", "get$toString", 0, 0, 7, "toString"],
      $isShape: 1,
      static: {
        Square$: [function(_x) {
          return new M.Square(_x);
        }, null, null, 2, 0, 435, 573, [], "new Square"]
      }
    },
    "+Square": [1, 286]
  }], ["", "lib/file-parser.dart",, T, {
    "^": "",
    FileParser: {
      "^": "Object;_filename@-9,_lineParser@-1671",
      parse$0: [function() {
        var $async$goto = 0, $async$completer = new P.Completer_Completer$sync(), $async$handler = 1, $async$currentError, $async$next = [], $async$self = this, lines, line, t1;
        var $async$parse$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = new P._FileStream(null, P._File$($async$self._filename).path, null, null, null, new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]), false, true, false, false);
                t1._io$_position = 0;
                lines = C.C_LineSplitter.bind$1(new P.Utf8Decoder(false).bind$1(t1));
                t1 = new P._StreamIterator(null, lines, false, [null]);
                $async$handler = 2;
              case 5:
                // for condition
                $async$goto = 7;
                return P._asyncHelper(t1.moveNext$0(), $async$parse$0, $async$completer);
              case 7:
                // returning from await.
                if (!($async$result === true)) {
                  // goto after for
                  $async$goto = 6;
                  break;
                }
                line = t1.get$current();
                $async$self._lineParser.parse$1(line);
                // goto for condition
                $async$goto = 5;
                break;
              case 6:
                // after for
                $async$next.push(4);
                // goto finally
                $async$goto = 3;
                break;
              case 2:
                // uncaught
                $async$next = [1];
              case 3:
                // finally
                $async$handler = 1;
                $async$goto = 8;
                return P._asyncHelper(t1.cancel$0(), $async$parse$0, $async$completer);
              case 8:
                // returning from await.
                // goto the next finally handler
                $async$goto = $async$next.pop();
                break;
              case 4:
                // after finally
                // implicit return
                return P._asyncHelper(null, 0, $async$completer);
              case 1:
                // rethrow
                return P._asyncHelper($async$currentError, 1, $async$completer);
            }
        });
        return P._asyncHelper(null, $async$parse$0, $async$completer);
      }, "call$0", "get$parse", 0, 0, 4, "parse"],
      static: {
        FileParser$: [function(_filename, _lineParser) {
          return new T.FileParser(_filename, _lineParser);
        }, null, null, 4, 0, 1114, 988, [], 659, [], "new FileParser"]
      }
    },
    "+FileParser": [1]
  }], ["", "lib/line-parser.dart",, R, {
    "^": "",
    LineParser0: {
      "^": "Object;",
      static: {
        LineParser$0: [function() {
          return new R.LineParser0();
        }, null, null, 0, 0, 1115, "new LineParser"]
      }
    },
    "+LineParser": [1]
  }], ["", "bin/main.dart",, F, {
    "^": "shapeDef@-61,argResults@-384",
    main: [function($arguments) {
      var mirror, definition, shape, parser, t1, t2, t3, line, exception;
      parser = N.ArgParser_ArgParser(false);
      parser.addOption$2$abbr("input", "i");
      parser.addOption$2$abbr("predicates", "p");
      t1 = J.toList$0$ax($arguments);
      t2 = P.String;
      t3 = H.setRuntimeTypeInfo([], [t2]);
      $.argResults = new G.Parser(null, null, parser, t1, t3, P.LinkedHashMap_LinkedHashMap$_empty(t2, null)).parse$0();
      t1 = P.Symbol;
      t3 = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [t1, P.ClassMirror]);
      t1 = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [t2, t1]);
      mirror = new R.ShapesMirror(t3, t1, new H.Symbol0(H.Symbol_validatePublicSymbol("")), H.setRuntimeTypeInfo([], [M.Shape]));
      mirror.buildMirrors$0();
      if (!(J.$index$asx($.argResults, "input") == null))
        J.$index$asx($.argResults, "input");
      for (t1 = J.get$iterator$ax($.$get$shapeDef()); t1.moveNext$0();) {
        definition = t1.get$current();
        try {
          shape = mirror.reflect$1(definition);
          line = H.S(J.toString$0$(shape));
          t2 = $.printToZone;
          if (t2 == null)
            H.printString(line);
          else
            t2.call$1(line);
        } catch (exception) {
          t2 = J.getInterceptor(H.unwrapException(exception));
          if (!!t2.$isNoSuchMethodError) {
            line = "***Error: don't know how to create \"" + H.S(definition) + '"';
            t2 = $.printToZone;
            if (t2 == null)
              H.printString(line);
            else
              t2.call$1(line);
          } else if (!!t2.$isFormatException) {
            line = "***Error: couldn't parse numeric arguments for \"" + H.S(definition) + '"';
            t2 = $.printToZone;
            if (t2 == null)
              H.printString(line);
            else
              t2.call$1(line);
          } else
            throw exception;
        }
      }
    }, "call$1", "main__main$closure", 2, 0, 436, 69, [], "main"]
  }, 1]];
  setupProgram(dart, 0);
  // getInterceptor methods
  J.getInterceptor = function(receiver) {
    if (typeof receiver == "number") {
      if (Math.floor(receiver) == receiver)
        return J.JSInt.prototype;
      return J.JSDouble.prototype;
    }
    if (typeof receiver == "string")
      return J.JSString.prototype;
    if (receiver == null)
      return J.JSNull.prototype;
    if (typeof receiver == "boolean")
      return J.JSBool.prototype;
    if (receiver.constructor == Array)
      return J.JSArray.prototype;
    if (typeof receiver != "object") {
      if (typeof receiver == "function")
        return J.JavaScriptFunction.prototype;
      return receiver;
    }
    if (receiver instanceof P.Object)
      return receiver;
    return J.getNativeInterceptor(receiver);
  };
  J.getInterceptor$a = function(receiver) {
    if (receiver == null)
      return receiver;
    if (receiver.constructor == Array)
      return J.JSArray.prototype;
    if (!(receiver instanceof P.Object))
      return J.UnknownJavaScriptObject.prototype;
    return receiver;
  };
  J.getInterceptor$asx = function(receiver) {
    if (typeof receiver == "string")
      return J.JSString.prototype;
    if (receiver == null)
      return receiver;
    if (receiver.constructor == Array)
      return J.JSArray.prototype;
    if (typeof receiver != "object") {
      if (typeof receiver == "function")
        return J.JavaScriptFunction.prototype;
      return receiver;
    }
    if (receiver instanceof P.Object)
      return receiver;
    return J.getNativeInterceptor(receiver);
  };
  J.getInterceptor$ax = function(receiver) {
    if (receiver == null)
      return receiver;
    if (receiver.constructor == Array)
      return J.JSArray.prototype;
    if (typeof receiver != "object") {
      if (typeof receiver == "function")
        return J.JavaScriptFunction.prototype;
      return receiver;
    }
    if (receiver instanceof P.Object)
      return receiver;
    return J.getNativeInterceptor(receiver);
  };
  J.getInterceptor$i = function(receiver) {
    if (typeof receiver == "number") {
      if (Math.floor(receiver) == receiver)
        return J.JSInt.prototype;
      return J.JSNumber.prototype;
    }
    if (receiver == null)
      return receiver;
    if (!(receiver instanceof P.Object))
      return J.UnknownJavaScriptObject.prototype;
    return receiver;
  };
  J.getInterceptor$in = function(receiver) {
    if (typeof receiver == "number") {
      if (Math.floor(receiver) == receiver)
        return J.JSInt.prototype;
      return J.JSNumber.prototype;
    }
    if (receiver == null)
      return receiver;
    if (!(receiver instanceof P.Object))
      return J.UnknownJavaScriptObject.prototype;
    return receiver;
  };
  J.getInterceptor$n = function(receiver) {
    if (typeof receiver == "number")
      return J.JSNumber.prototype;
    if (receiver == null)
      return receiver;
    if (!(receiver instanceof P.Object))
      return J.UnknownJavaScriptObject.prototype;
    return receiver;
  };
  J.getInterceptor$ns = function(receiver) {
    if (typeof receiver == "number")
      return J.JSNumber.prototype;
    if (typeof receiver == "string")
      return J.JSString.prototype;
    if (receiver == null)
      return receiver;
    if (!(receiver instanceof P.Object))
      return J.UnknownJavaScriptObject.prototype;
    return receiver;
  };
  J.getInterceptor$s = function(receiver) {
    if (typeof receiver == "string")
      return J.JSString.prototype;
    if (receiver == null)
      return receiver;
    if (!(receiver instanceof P.Object))
      return J.UnknownJavaScriptObject.prototype;
    return receiver;
  };
  J.getInterceptor$x = function(receiver) {
    if (receiver == null)
      return receiver;
    if (typeof receiver != "object") {
      if (typeof receiver == "function")
        return J.JavaScriptFunction.prototype;
      return receiver;
    }
    if (receiver instanceof P.Object)
      return receiver;
    return J.getNativeInterceptor(receiver);
  };
  J.get$add$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).get$add(receiver);
  };
  J.get$buffer$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$buffer(receiver);
  };
  J.get$codeUnits$s = function(receiver) {
    return J.getInterceptor$s(receiver).get$codeUnits(receiver);
  };
  J.get$first$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).get$first(receiver);
  };
  J.get$isEmpty$asx = function(receiver) {
    return J.getInterceptor$asx(receiver).get$isEmpty(receiver);
  };
  J.get$isNotEmpty$asx = function(receiver) {
    return J.getInterceptor$asx(receiver).get$isNotEmpty(receiver);
  };
  J.get$isOdd$i = function(receiver) {
    return J.getInterceptor$i(receiver).get$isOdd(receiver);
  };
  J.get$iterator$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).get$iterator(receiver);
  };
  J.get$last$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).get$last(receiver);
  };
  J.get$length$asx = function(receiver) {
    return J.getInterceptor$asx(receiver).get$length(receiver);
  };
  J.get$list$a = function(receiver) {
    return J.getInterceptor$a(receiver).get$list(receiver);
  };
  J.get$offsetInBytes$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$offsetInBytes(receiver);
  };
  J.get$single$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).get$single(receiver);
  };
  J.$add$ns = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver + a0;
    return J.getInterceptor$ns(receiver).$add(receiver, a0);
  };
  J.$and$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return (receiver & a0) >>> 0;
    return J.getInterceptor$n(receiver).$and(receiver, a0);
  };
  J.$div$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver / a0;
    return J.getInterceptor$n(receiver).$div(receiver, a0);
  };
  J.$ge$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver >= a0;
    return J.getInterceptor$n(receiver).$ge(receiver, a0);
  };
  J.$gt$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver > a0;
    return J.getInterceptor$n(receiver).$gt(receiver, a0);
  };
  J.$index$asx = function(receiver, a0) {
    if (typeof a0 === "number")
      if (receiver.constructor == Array || typeof receiver == "string" || H.isJsIndexable(receiver, receiver[init.dispatchPropertyName]))
        if (a0 >>> 0 === a0 && a0 < receiver.length)
          return receiver[a0];
    return J.getInterceptor$asx(receiver).$index(receiver, a0);
  };
  J.$indexSet$ax = function(receiver, a0, a1) {
    if (typeof a0 === "number")
      if ((receiver.constructor == Array || H.isJsIndexable(receiver, receiver[init.dispatchPropertyName])) && !receiver.immutable$list && a0 >>> 0 === a0 && a0 < receiver.length)
        return receiver[a0] = a1;
    return J.getInterceptor$ax(receiver).$indexSet(receiver, a0, a1);
  };
  J.$le$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver <= a0;
    return J.getInterceptor$n(receiver).$le(receiver, a0);
  };
  J.$lt$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver < a0;
    return J.getInterceptor$n(receiver).$lt(receiver, a0);
  };
  J.$mod$n = function(receiver, a0) {
    return J.getInterceptor$n(receiver).$mod(receiver, a0);
  };
  J.$mul$ns = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver * a0;
    return J.getInterceptor$ns(receiver).$mul(receiver, a0);
  };
  J.$negate$n = function(receiver) {
    if (typeof receiver == "number")
      return -receiver;
    return J.getInterceptor$n(receiver).$negate(receiver);
  };
  J.$not$i = function(receiver) {
    if (typeof receiver == "number" && Math.floor(receiver) == receiver)
      return ~receiver >>> 0;
    return J.getInterceptor$i(receiver).$not(receiver);
  };
  J.$or$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return (receiver | a0) >>> 0;
    return J.getInterceptor$n(receiver).$or(receiver, a0);
  };
  J.$shl$n = function(receiver, a0) {
    return J.getInterceptor$n(receiver).$shl(receiver, a0);
  };
  J.$shr$n = function(receiver, a0) {
    return J.getInterceptor$n(receiver).$shr(receiver, a0);
  };
  J.$sub$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver - a0;
    return J.getInterceptor$n(receiver).$sub(receiver, a0);
  };
  J.$tdiv$n = function(receiver, a0) {
    return J.getInterceptor$n(receiver).$tdiv(receiver, a0);
  };
  J.$xor$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return (receiver ^ a0) >>> 0;
    return J.getInterceptor$n(receiver).$xor(receiver, a0);
  };
  J.abs$0$n = function(receiver) {
    return J.getInterceptor$n(receiver).abs$0(receiver);
  };
  J.add$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).add$1(receiver, a0);
  };
  J.add$2$ax = function(receiver, a0, a1) {
    return J.getInterceptor$ax(receiver).add$2(receiver, a0, a1);
  };
  J.addAll$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).addAll$1(receiver, a0);
  };
  J.allMatches$1$s = function(receiver, a0) {
    return J.getInterceptor$s(receiver).allMatches$1(receiver, a0);
  };
  J.allMatches$2$s = function(receiver, a0, a1) {
    return J.getInterceptor$s(receiver).allMatches$2(receiver, a0, a1);
  };
  J.any$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).any$1(receiver, a0);
  };
  J.asByteData$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).asByteData$2(receiver, a0, a1);
  };
  J.asFloat32List$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).asFloat32List$2(receiver, a0, a1);
  };
  J.asFloat32x4List$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).asFloat32x4List$2(receiver, a0, a1);
  };
  J.asFloat64List$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).asFloat64List$2(receiver, a0, a1);
  };
  J.asFloat64x2List$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).asFloat64x2List$2(receiver, a0, a1);
  };
  J.asInt16List$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).asInt16List$2(receiver, a0, a1);
  };
  J.asInt32List$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).asInt32List$2(receiver, a0, a1);
  };
  J.asInt32x4List$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).asInt32x4List$2(receiver, a0, a1);
  };
  J.asInt64List$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).asInt64List$2(receiver, a0, a1);
  };
  J.asInt8List$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).asInt8List$2(receiver, a0, a1);
  };
  J.asUint16List$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).asUint16List$2(receiver, a0, a1);
  };
  J.asUint32List$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).asUint32List$2(receiver, a0, a1);
  };
  J.asUint64List$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).asUint64List$2(receiver, a0, a1);
  };
  J.asUint8ClampedList$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).asUint8ClampedList$2(receiver, a0, a1);
  };
  J.asUint8List$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).asUint8List$2(receiver, a0, a1);
  };
  J.clear$0$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).clear$0(receiver);
  };
  J.codeUnitAt$1$s = function(receiver, a0) {
    return J.getInterceptor$s(receiver).codeUnitAt$1(receiver, a0);
  };
  J.compareTo$1$ns = function(receiver, a0) {
    return J.getInterceptor$ns(receiver).compareTo$1(receiver, a0);
  };
  J.contains$1$asx = function(receiver, a0) {
    return J.getInterceptor$asx(receiver).contains$1(receiver, a0);
  };
  J.elementAt$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).elementAt$1(receiver, a0);
  };
  J.endsWith$1$s = function(receiver, a0) {
    return J.getInterceptor$s(receiver).endsWith$1(receiver, a0);
  };
  J.expand$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).expand$1(receiver, a0);
  };
  J.fillRange$3$ax = function(receiver, a0, a1, a2) {
    return J.getInterceptor$ax(receiver).fillRange$3(receiver, a0, a1, a2);
  };
  J.fold$2$ax = function(receiver, a0, a1) {
    return J.getInterceptor$ax(receiver).fold$2(receiver, a0, a1);
  };
  J.forEach$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).forEach$1(receiver, a0);
  };
  J.indexOf$1$asx = function(receiver, a0) {
    return J.getInterceptor$asx(receiver).indexOf$1(receiver, a0);
  };
  J.indexOf$2$asx = function(receiver, a0, a1) {
    return J.getInterceptor$asx(receiver).indexOf$2(receiver, a0, a1);
  };
  J.join$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).join$1(receiver, a0);
  };
  J.lastIndexOf$1$asx = function(receiver, a0) {
    return J.getInterceptor$asx(receiver).lastIndexOf$1(receiver, a0);
  };
  J.length$0$asx = function(receiver) {
    return J.getInterceptor$asx(receiver).length$0(receiver);
  };
  J.map$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).map$1(receiver, a0);
  };
  J.matchAsPrefix$2$s = function(receiver, a0, a1) {
    return J.getInterceptor$s(receiver).matchAsPrefix$2(receiver, a0, a1);
  };
  J.remainder$1$n = function(receiver, a0) {
    return J.getInterceptor$n(receiver).remainder$1(receiver, a0);
  };
  J.remove$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).remove$1(receiver, a0);
  };
  J.removeLast$0$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).removeLast$0(receiver);
  };
  J.round$0$n = function(receiver) {
    return J.getInterceptor$n(receiver).round$0(receiver);
  };
  J.setRange$3$ax = function(receiver, a0, a1, a2) {
    return J.getInterceptor$ax(receiver).setRange$3(receiver, a0, a1, a2);
  };
  J.setRange$4$ax = function(receiver, a0, a1, a2, a3) {
    return J.getInterceptor$ax(receiver).setRange$4(receiver, a0, a1, a2, a3);
  };
  J.skip$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).skip$1(receiver, a0);
  };
  J.split$1$s = function(receiver, a0) {
    return J.getInterceptor$s(receiver).split$1(receiver, a0);
  };
  J.startsWith$1$s = function(receiver, a0) {
    return J.getInterceptor$s(receiver).startsWith$1(receiver, a0);
  };
  J.startsWith$2$s = function(receiver, a0, a1) {
    return J.getInterceptor$s(receiver).startsWith$2(receiver, a0, a1);
  };
  J.sublist$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).sublist$1(receiver, a0);
  };
  J.sublist$2$ax = function(receiver, a0, a1) {
    return J.getInterceptor$ax(receiver).sublist$2(receiver, a0, a1);
  };
  J.substring$1$s = function(receiver, a0) {
    return J.getInterceptor$s(receiver).substring$1(receiver, a0);
  };
  J.substring$2$s = function(receiver, a0, a1) {
    return J.getInterceptor$s(receiver).substring$2(receiver, a0, a1);
  };
  J.toList$0$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).toList$0(receiver);
  };
  J.toLowerCase$0$s = function(receiver) {
    return J.getInterceptor$s(receiver).toLowerCase$0(receiver);
  };
  J.toRadixString$1$n = function(receiver, a0) {
    return J.getInterceptor$n(receiver).toRadixString$1(receiver, a0);
  };
  J.toUpperCase$0$s = function(receiver) {
    return J.getInterceptor$s(receiver).toUpperCase$0(receiver);
  };
  J.trim$0$s = function(receiver) {
    return J.getInterceptor$s(receiver).trim$0(receiver);
  };
  J.truncate$1$n = function(receiver, a0) {
    return J.getInterceptor$n(receiver).truncate$1(receiver, a0);
  };
  J.where$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).where$1(receiver, a0);
  };
  J.get$hashCode$ = function(receiver) {
    return J.getInterceptor(receiver).get$hashCode(receiver);
  };
  J.$eq$ = function(receiver, a0) {
    if (receiver == null)
      return a0 == null;
    if (typeof receiver != "object")
      return a0 != null && receiver === a0;
    return J.getInterceptor(receiver).$eq(receiver, a0);
  };
  J.noSuchMethod$1$ = function(receiver, a0) {
    return J.getInterceptor(receiver).noSuchMethod$1(receiver, a0);
  };
  J.toString$0$ = function(receiver) {
    return J.getInterceptor(receiver).toString$0(receiver);
  };
  Isolate.makeConstantList = function(list) {
    list.immutable$list = Array;
    list.fixed$length = Array;
    return list;
  };
  var $ = Isolate.$isolateProperties;
  C.Interceptor_methods = J.Interceptor.prototype;
  C.JSArray_methods = J.JSArray.prototype;
  C.JSDouble_methods = J.JSDouble.prototype;
  C.JSInt_methods = J.JSInt.prototype;
  C.JSNull_methods = J.JSNull.prototype;
  C.JSNumber_methods = J.JSNumber.prototype;
  C.JSString_methods = J.JSString.prototype;
  C.JavaScriptFunction_methods = J.JavaScriptFunction.prototype;
  C.NativeByteBuffer_methods = H.NativeByteBuffer.prototype;
  C.NativeFloat32List_methods = H.NativeFloat32List.prototype;
  C.NativeFloat64List_methods = H.NativeFloat64List.prototype;
  C.NativeInt32List_methods = H.NativeInt32List.prototype;
  C.NativeUint8List_methods = H.NativeUint8List.prototype;
  C.PlainJavaScriptObject_methods = J.PlainJavaScriptObject.prototype;
  C.UnknownJavaScriptObject_methods = J.UnknownJavaScriptObject.prototype;
  C.AsciiCodec_false = new P.AsciiCodec(false);
  C.AsciiDecoder_false_127 = new P.AsciiDecoder(false, 127);
  C.AsciiDecoder_true_127 = new P.AsciiDecoder(true, 127);
  C.AsciiEncoder_127 = new P.AsciiEncoder(127);
  C.Base64Encoder_false = new P.Base64Encoder(false);
  C.Base64Codec_Base64Encoder_false = new P.Base64Codec(C.Base64Encoder_false);
  C.Base64Encoder_true = new P.Base64Encoder(true);
  C.Base64Codec_Base64Encoder_true = new P.Base64Codec(C.Base64Encoder_true);
  C.C_Base64Decoder = new P.Base64Decoder();
  C.C_EmptyIterable = new H.EmptyIterable([null]);
  C.C_EmptyIterator = new H.EmptyIterator([null]);
  C.C_LineSplitter = new P.LineSplitter();
  C.C_NoInline = new H.NoInline();
  C.C_OutOfMemoryError = new P.OutOfMemoryError();
  C.C_SystemEncoding = new P.SystemEncoding();
  C.C_Utf8Encoder = new P.Utf8Encoder();
  C.C__DelayedDone = new P._DelayedDone();
  C.C__Growable = new J._Growable();
  C.C__JSRandom = new P._JSRandom();
  C.C__Override = new P._Override();
  C.C__Proxy = new P._Proxy0();
  C.C__RootZone = new P._RootZone();
  C.CompressionOptions_qty0 = new P.CompressionOptions(false, false, null, null, false);
  C.CompressionOptions_qty = new P.CompressionOptions(false, false, null, null, true);
  C.Creates_NativeByteBuffer = new H.Creates("NativeByteBuffer");
  C.Deprecated_R41 = new P.Deprecated("This constructor will be removed in Dart 2.0. Use `implements` instead of `extends` if implementing this abstract class.");
  C.Deprecated_adS = new P.Deprecated("Dart sdk v. 1.8");
  C.Deprecated_kXN = new P.Deprecated("Replaced with get usage. getUsage() will be removed in args 1.0");
  C.Deprecated_o8I = new P.Deprecated("next release");
  C.Duration_0 = new P.Duration(0);
  C.Duration_120000000 = new P.Duration(120000000);
  C.Duration_15000000 = new P.Duration(15000000);
  C.Duration_5000000 = new P.Duration(5000000);
  C.Endianness_false = new P.Endianness(false);
  C.Endianness_true = new P.Endianness(true);
  C.FileLock_0 = new P.FileLock(0, "FileLock.SHARED");
  C.FileLock_1 = new P.FileLock(1, "FileLock.EXCLUSIVE");
  C.FileLock_2 = new P.FileLock(2, "FileLock.BLOCKING_SHARED");
  C.FileLock_3 = new P.FileLock(3, "FileLock.BLOCKING_EXCLUSIVE");
  C.FileMode_0 = new P.FileMode(0);
  C.FileMode_1 = new P.FileMode(1);
  C.FileMode_2 = new P.FileMode(2);
  C.FileMode_3 = new P.FileMode(3);
  C.FileMode_4 = new P.FileMode(4);
  C.FileSystemEntityType_3 = new P.FileSystemEntityType(3);
  C.FileStat_8qt = new P.FileStat(null, null, null, C.FileSystemEntityType_3, 0, -1);
  C.FileSystemEntityType_0 = new P.FileSystemEntityType(0);
  C.FileSystemEntityType_1 = new P.FileSystemEntityType(1);
  C.FileSystemEntityType_2 = new P.FileSystemEntityType(2);
  C.GZipCodec_yXb = new P.GZipCodec(true, 6, 8, 0, 15, null, false);
  C.HtmlEscapeMode_0 = new P.HtmlEscapeMode("attribute", true, true, false, false);
  C.HtmlEscapeMode_00 = new P.HtmlEscapeMode("attribute", true, false, true, false);
  C.HtmlEscapeMode_2oY = new P.HtmlEscapeMode("element", true, false, false, false);
  C.HtmlEscapeMode_p2v = new P.HtmlEscapeMode("unknown", true, true, true, true);
  C.HtmlEscape_gsm = new P.HtmlEscape(C.HtmlEscapeMode_p2v);
  C.InternetAddressType_0 = new P.InternetAddressType(0);
  C.InternetAddressType_1 = new P.InternetAddressType(1);
  C.InternetAddressType_m1 = new P.InternetAddressType(-1);
  C.JSName_BYTES_PER_ELEMENT = new H.JSName("BYTES_PER_ELEMENT");
  C.JSName_byteLength = new H.JSName("byteLength");
  C.JSName_byteOffset = new H.JSName("byteOffset");
  C.JS_CONST_4IJ = function() {  var toStringFunction = Object.prototype.toString;  function getTag(o) {    var s = toStringFunction.call(o);    return s.substring(8, s.length - 1);  }  function getUnknownTag(object, tag) {    if (/^HTML[A-Z].*Element$/.test(tag)) {      var name = toStringFunction.call(object);      if (name == "[object Object]") return null;      return "HTMLElement";    }  }  function getUnknownTagGenericBrowser(object, tag) {    if (self.HTMLElement && object instanceof HTMLElement) return "HTMLElement";    return getUnknownTag(object, tag);  }  function prototypeForTag(tag) {    if (typeof window == "undefined") return null;    if (typeof window[tag] == "undefined") return null;    var constructor = window[tag];    if (typeof constructor != "function") return null;    return constructor.prototype;  }  function discriminator(tag) { return null; }  var isBrowser = typeof navigator == "object";  return {    getTag: getTag,    getUnknownTag: isBrowser ? getUnknownTagGenericBrowser : getUnknownTag,    prototypeForTag: prototypeForTag,    discriminator: discriminator };};
  C.JS_CONST_AgZ = function(hooks) { return hooks; };
  C.JS_CONST_EKH = function(hooks) {  if (typeof dartExperimentalFixupGetTag != "function") return hooks;  hooks.getTag = dartExperimentalFixupGetTag(hooks.getTag);};
  C.JS_CONST_EyN = function(hooks) {  var getTag = hooks.getTag;  var prototypeForTag = hooks.prototypeForTag;  function getTagFixed(o) {    var tag = getTag(o);    if (tag == "Document") {      // "Document", so we check for the xmlVersion property, which is the empty      if (!!o.xmlVersion) return "!Document";      return "!HTMLDocument";    }    return tag;  }  function prototypeForTagFixed(tag) {    if (tag == "Document") return null;    return prototypeForTag(tag);  }  hooks.getTag = getTagFixed;  hooks.prototypeForTag = prototypeForTagFixed;};
  C.JS_CONST_LlX = function(hooks) {  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";  if (userAgent.indexOf("Firefox") == -1) return hooks;  var getTag = hooks.getTag;  var quickMap = {    "BeforeUnloadEvent": "Event",    "DataTransfer": "Clipboard",    "GeoGeolocation": "Geolocation",    "Location": "!Location",    "WorkerMessageEvent": "MessageEvent",    "XMLDocument": "!Document"};  function getTagFirefox(o) {    var tag = getTag(o);    return quickMap[tag] || tag;  }  hooks.getTag = getTagFirefox;};
  C.JS_CONST_TSE = function getTagFallback(o) {  var s = Object.prototype.toString.call(o);  return s.substring(8, s.length - 1);};
  C.JS_CONST_c0o = function(hooks) {  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";  if (userAgent.indexOf("Trident/") == -1) return hooks;  var getTag = hooks.getTag;  var quickMap = {    "BeforeUnloadEvent": "Event",    "DataTransfer": "Clipboard",    "HTMLDDElement": "HTMLElement",    "HTMLDTElement": "HTMLElement",    "HTMLPhraseElement": "HTMLElement",    "Position": "Geoposition"  };  function getTagIE(o) {    var tag = getTag(o);    var newTag = quickMap[tag];    if (newTag) return newTag;    if (tag == "Object") {      if (window.DataView && (o instanceof window.DataView)) return "DataView";    }    return tag;  }  function prototypeForTagIE(tag) {    var constructor = window[tag];    if (constructor == null) return null;    return constructor.prototype;  }  hooks.getTag = getTagIE;  hooks.prototypeForTag = prototypeForTagIE;};
  C.JS_CONST_nuk = function(getTagFallback) {  return function(hooks) {    if (typeof navigator != "object") return hooks;    var ua = navigator.userAgent;    if (ua.indexOf("DumpRenderTree") >= 0) return hooks;    if (ua.indexOf("Chrome") >= 0) {      function confirm(p) {        return typeof window == "object" && window[p] && window[p].name == p;      }      if (confirm("Window") && confirm("HTMLElement")) return hooks;    }    hooks.getTag = getTagFallback;  };};
  C.JsonCodec_null_null = new P.JsonCodec(null, null);
  C.JsonDecoder_null = new P.JsonDecoder(null);
  C.JsonEncoder_null_null = new P.JsonEncoder(null, null);
  C.Latin1Codec_false = new P.Latin1Codec(false);
  C.Latin1Decoder_false_255 = new P.Latin1Decoder(false, 255);
  C.Latin1Decoder_true_255 = new P.Latin1Decoder(true, 255);
  C.Latin1Encoder_255 = new P.Latin1Encoder(255);
  C.List_0_0_255_255 = Isolate.makeConstantList([0, 0, 255, 255]);
  C.List_127_2047_65535_1114111 = H.setRuntimeTypeInfo(Isolate.makeConstantList([127, 2047, 65535, 1114111]), [P.int]);
  C.List_239_191_189 = H.setRuntimeTypeInfo(Isolate.makeConstantList([239, 191, 189]), [P.int]);
  C.List_2Vk = Isolate.makeConstantList([0, 0, 32776, 33792, 1, 10240, 0, 0]);
  C.List_2Vk1 = Isolate.makeConstantList([72, 84, 84, 80, 47, 49, 46, 48]);
  C.List_2Vk0 = Isolate.makeConstantList([72, 84, 84, 80, 47, 49, 46, 49]);
  C.List_65533 = Isolate.makeConstantList([65533]);
  C.List_6Pr = Isolate.makeConstantList([0, 0, 26624, 1023, 0, 0, 65534, 2047]);
  C.List_72_84_84_80 = Isolate.makeConstantList([72, 84, 84, 80]);
  C.List_A8J = Isolate.makeConstantList(["(", ")", "<", ">", "@", ",", ";", ":", "\\", '"', "/", "[", "]", "?", "=", "{", "}"]);
  C.List_ALf = Isolate.makeConstantList(["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]);
  C.List_CVk = Isolate.makeConstantList([0, 0, 65490, 45055, 65535, 34815, 65534, 18431]);
  C.List_CpJ = Isolate.makeConstantList([C.FileSystemEntityType_0, C.FileSystemEntityType_1, C.FileSystemEntityType_2, C.FileSystemEntityType_3]);
  C.List_E7y = Isolate.makeConstantList([13, 10, 48, 13, 10, 13, 10]);
  C.List_E7y0 = Isolate.makeConstantList([72, 84, 84, 80, 47, 49, 46]);
  C.List_ECn = Isolate.makeConstantList(["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]);
  C.List_FILE_DIRECTORY_LINK_NOT_FOUND = Isolate.makeConstantList(["FILE", "DIRECTORY", "LINK", "NOT_FOUND"]);
  C.List_JYB = Isolate.makeConstantList([0, 0, 26624, 1023, 65534, 2047, 65534, 2047]);
  C.List_JYB0 = Isolate.makeConstantList([0, 0, 34816, 1023, 65534, 2047, 65534, 2047]);
  C.List_KIf = Isolate.makeConstantList([0, 0, 26498, 1023, 65534, 34815, 65534, 18431]);
  C.List_MYA = Isolate.makeConstantList(["allow", "content-encoding", "content-language", "content-length", "content-location", "content-md5", "content-range", "content-type", "expires", "last-modified"]);
  C.List_NAl = Isolate.makeConstantList(["---", "--x", "-w-", "-wx", "r--", "r-x", "rw-", "rwx"]);
  C.List_NUU = Isolate.makeConstantList([false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, true, false, false, false, false, false, true, true, false, false, true, false, false, true, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false]);
  C.List_Rop = Isolate.makeConstantList(["accept", "accept-charset", "accept-encoding", "accept-language", "authorization", "expect", "from", "host", "if-match", "if-modified-since", "if-none-match", "if-range", "if-unmodified-since", "max-forwards", "proxy-authorization", "range", "referer", "te", "user-agent"]);
  C.List_UI5 = Isolate.makeConstantList(["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"]);
  C.List_adS = Isolate.makeConstantList(["RawSocketEvent:READ", "RawSocketEvent:WRITE", "RawSocketEvent:READ_CLOSED", "RawSocketEvent:CLOSED"]);
  C.List_axv = Isolate.makeConstantList([0, 0, 32722, 11263, 65534, 34815, 65534, 18431]);
  C.List_cGl = Isolate.makeConstantList([48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70]);
  C.List_eFd = Isolate.makeConstantList([1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19, 1e20, 1e21, 1e22]);
  C.List_empty0 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [P.ClassMirror]);
  C.List_empty4 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [P.String]);
  C.List_empty1 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [P.TypeMirror]);
  C.List_empty2 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [P.TypeVariableMirror]);
  C.List_empty3 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [P.int]);
  C.List_empty = Isolate.makeConstantList([]);
  C.List_fld = Isolate.makeConstantList(["cache-control", "connection", "date", "pragma", "trailer", "transfer-encoding", "upgrade", "via", "warning"]);
  C.List_gRj = Isolate.makeConstantList([0, 0, 32722, 12287, 65534, 34815, 65534, 18431]);
  C.List_gnE = Isolate.makeConstantList([0, 0, 65498, 45055, 65535, 34815, 65534, 18431]);
  C.List_h8w = Isolate.makeConstantList(["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]);
  C._Proxy_cg9 = new P._Proxy(null, null, null, null, true);
  C.List_jqP = Isolate.makeConstantList([C._Proxy_cg9]);
  C.List_kcl = Isolate.makeConstantList([7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]);
  C.List_nfu = Isolate.makeConstantList(["accept-ranges", "age", "etag", "location", "proxy-authenticate", "retry-after", "server", "vary", "www-authenticate"]);
  C.List_nxB = Isolate.makeConstantList([0, 0, 24576, 1023, 65534, 34815, 65534, 18431]);
  C.List_q3m = Isolate.makeConstantList([-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -1, -2, -2, -1, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, 62, -2, 62, -2, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -2, -2, -2, 0, -2, -2, -2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -2, -2, -2, -2, 63, -2, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2]);
  C.List_qFt = Isolate.makeConstantList([0, 0, 27858, 1023, 65534, 51199, 65535, 32767]);
  C.List_qNA = Isolate.makeConstantList([0, 0, 32754, 11263, 65534, 34815, 65534, 18431]);
  C.List_qg40 = Isolate.makeConstantList([0, 0, 32722, 12287, 65535, 34815, 65534, 18431]);
  C.List_qg4 = Isolate.makeConstantList([0, 0, 65490, 12287, 65535, 34815, 65534, 18431]);
  C.List_uQj = Isolate.makeConstantList([C.FileLock_0, C.FileLock_1, C.FileLock_2, C.FileLock_3]);
  C.ProcessStartMode_0 = new P.ProcessStartMode(0, "ProcessStartMode.NORMAL");
  C.ProcessStartMode_1 = new P.ProcessStartMode(1, "ProcessStartMode.DETACHED");
  C.ProcessStartMode_2 = new P.ProcessStartMode(2, "ProcessStartMode.DETACHED_WITH_STDIO");
  C.List_w61 = Isolate.makeConstantList([C.ProcessStartMode_0, C.ProcessStartMode_1, C.ProcessStartMode_2]);
  C.List_yTu0 = H.setRuntimeTypeInfo(Isolate.makeConstantList([1, 2, 3, 4, 0]), [P.int]);
  C.List_yTu = Isolate.makeConstantList([48, 13, 10, 13, 10]);
  C.List_yzJ = Isolate.makeConstantList([3614090360, 3905402710, 606105819, 3250441966, 4118548399, 1200080426, 2821735955, 4249261313, 1770035416, 2336552879, 4294925233, 2304563134, 1804603682, 4254626195, 2792965006, 1236535329, 4129170786, 3225465664, 643717713, 3921069994, 3593408605, 38016083, 3634488961, 3889429448, 568446438, 3275163606, 4107603335, 1163531501, 2850285829, 4243563512, 1735328473, 2368359562, 4294588738, 2272392833, 1839030562, 4259657740, 2763975236, 1272893353, 4139469664, 3200236656, 681279174, 3936430074, 3572445317, 76029189, 3654602809, 3873151461, 530742520, 3299628645, 4096336452, 1126891415, 2878612391, 4237533241, 1700485571, 2399980690, 4293915773, 2240044497, 1873313359, 4264355552, 2734768916, 1309151649, 4149444226, 3174756917, 718787259, 3951481745]);
  C.Map_empty = new H.ConstantStringMap(0, {}, C.List_empty4, [P.String, [P.List, P.String]]);
  C.Map_empty0 = new H.ConstantStringMap(0, {}, C.List_empty4, [P.String, P.String]);
  C.List_empty5 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [P.Symbol]);
  C.Map_empty1 = new H.ConstantStringMap(0, {}, C.List_empty5, [P.Symbol, null]);
  C.Map_empty2 = new H.ConstantStringMap(0, {}, C.List_empty, [null, null]);
  C.Native_4si = new H.Native("Uint8ClampedArray,CanvasPixelArray");
  C.Native_ArrayBuffer = new H.Native("ArrayBuffer");
  C.Native_ArrayBufferView = new H.Native("ArrayBufferView");
  C.Native_DataView = new H.Native("DataView");
  C.Native_Float32Array = new H.Native("Float32Array");
  C.Native_Float64Array = new H.Native("Float64Array");
  C.Native_Int16Array = new H.Native("Int16Array");
  C.Native_Int32Array = new H.Native("Int32Array");
  C.Native_Int8Array = new H.Native("Int8Array");
  C.Native_Uint16Array = new H.Native("Uint16Array");
  C.Native_Uint32Array = new H.Native("Uint32Array");
  C.Native_eZS = new H.Native("Uint8Array,!nonleaf");
  C.OptionType_F9d = new G.OptionType("OptionType.SINGLE");
  C.OptionType_Icb = new G.OptionType("OptionType.MULTIPLE");
  C.OptionType_woc = new G.OptionType("OptionType.FLAG");
  C.ProcessSignal_10_SIGUSR1 = new P.ProcessSignal(10, "SIGUSR1");
  C.ProcessSignal_11_SIGSEGV = new P.ProcessSignal(11, "SIGSEGV");
  C.ProcessSignal_12_SIGUSR2 = new P.ProcessSignal(12, "SIGUSR2");
  C.ProcessSignal_13_SIGPIPE = new P.ProcessSignal(13, "SIGPIPE");
  C.ProcessSignal_14_SIGALRM = new P.ProcessSignal(14, "SIGALRM");
  C.ProcessSignal_15_SIGTERM = new P.ProcessSignal(15, "SIGTERM");
  C.ProcessSignal_17_SIGCHLD = new P.ProcessSignal(17, "SIGCHLD");
  C.ProcessSignal_18_SIGCONT = new P.ProcessSignal(18, "SIGCONT");
  C.ProcessSignal_19_SIGSTOP = new P.ProcessSignal(19, "SIGSTOP");
  C.ProcessSignal_1_SIGHUP = new P.ProcessSignal(1, "SIGHUP");
  C.ProcessSignal_20_SIGTSTP = new P.ProcessSignal(20, "SIGTSTP");
  C.ProcessSignal_21_SIGTTIN = new P.ProcessSignal(21, "SIGTTIN");
  C.ProcessSignal_22_SIGTTOU = new P.ProcessSignal(22, "SIGTTOU");
  C.ProcessSignal_23_SIGURG = new P.ProcessSignal(23, "SIGURG");
  C.ProcessSignal_24_SIGXCPU = new P.ProcessSignal(24, "SIGXCPU");
  C.ProcessSignal_25_SIGXFSZ = new P.ProcessSignal(25, "SIGXFSZ");
  C.ProcessSignal_26_SIGVTALRM = new P.ProcessSignal(26, "SIGVTALRM");
  C.ProcessSignal_27_SIGPROF = new P.ProcessSignal(27, "SIGPROF");
  C.ProcessSignal_28_SIGWINCH = new P.ProcessSignal(28, "SIGWINCH");
  C.ProcessSignal_29_SIGPOLL = new P.ProcessSignal(29, "SIGPOLL");
  C.ProcessSignal_2_SIGINT = new P.ProcessSignal(2, "SIGINT");
  C.ProcessSignal_31_SIGSYS = new P.ProcessSignal(31, "SIGSYS");
  C.ProcessSignal_3_SIGQUIT = new P.ProcessSignal(3, "SIGQUIT");
  C.ProcessSignal_4_SIGILL = new P.ProcessSignal(4, "SIGILL");
  C.ProcessSignal_5_SIGTRAP = new P.ProcessSignal(5, "SIGTRAP");
  C.ProcessSignal_6_SIGABRT = new P.ProcessSignal(6, "SIGABRT");
  C.ProcessSignal_7_SIGBUS = new P.ProcessSignal(7, "SIGBUS");
  C.ProcessSignal_8_SIGFPE = new P.ProcessSignal(8, "SIGFPE");
  C.ProcessSignal_9_SIGKILL = new P.ProcessSignal(9, "SIGKILL");
  C.RawSocketEvent_0 = new P.RawSocketEvent(0);
  C.RawSocketEvent_1 = new P.RawSocketEvent(1);
  C.RawSocketEvent_2 = new P.RawSocketEvent(2);
  C.RawSocketEvent_3 = new P.RawSocketEvent(3);
  C.Returns_EKW = new H.Returns("NativeByteBuffer|Null");
  C.SocketDirection_0 = new P.SocketDirection(0);
  C.SocketDirection_1 = new P.SocketDirection(1);
  C.SocketDirection_2 = new P.SocketDirection(2);
  C.SocketOption_0 = new P.SocketOption(0);
  C.SocketOption_1 = new P.SocketOption(1);
  C.SocketOption_2 = new P.SocketOption(2);
  C.SocketOption_3 = new P.SocketOption(3);
  C.SocketOption_4 = new P.SocketOption(4);
  C.StdioType_file = new P.StdioType("file");
  C.StdioType_other = new P.StdioType("other");
  C.StdioType_pipe = new P.StdioType("pipe");
  C.StdioType_terminal = new P.StdioType("terminal");
  C.Symbol_0c4 = new H.Symbol0("");
  C.Symbol_Shape = new H.Symbol0("Shape");
  C.Symbol_call = new H.Symbol0("call");
  C.Symbol_dynamic = new H.Symbol0("dynamic");
  C.Symbol_void = new H.Symbol0("void");
  C.Type__DoubleLinkedQueueIterator_2Vk = H.createRuntimeType("_DoubleLinkedQueueIterator");
  C.TypeVariable_0 = new H.TypeVariable(C.Type__DoubleLinkedQueueIterator_2Vk, "E", 1);
  C.Type_xwz = H.createRuntimeType("_SyncBroadcastStreamController");
  C.TypeVariable_00 = new H.TypeVariable(C.Type_xwz, "T", 1);
  C.Type_4ys = H.createRuntimeType("_SplayTree_IterableMixin_SetMixin");
  C.TypeVariable_2No = new H.TypeVariable(C.Type_4ys, "E", 1);
  C.Type__AsBroadcastStreamController_uew = H.createRuntimeType("_AsBroadcastStreamController");
  C.TypeVariable_2Y5 = new H.TypeVariable(C.Type__AsBroadcastStreamController_uew, "T", 1);
  C.Type__DoubleLinkedQueueSentinel_ga3 = H.createRuntimeType("_DoubleLinkedQueueSentinel");
  C.TypeVariable_3AX = new H.TypeVariable(C.Type__DoubleLinkedQueueSentinel_ga3, "E", 1);
  C.Type__ConverterStreamEventSink_mzi = H.createRuntimeType("_ConverterStreamEventSink");
  C.TypeVariable_4CA = new H.TypeVariable(C.Type__ConverterStreamEventSink_mzi, "S", 1);
  C.Type_0TC = H.createRuntimeType("_SinkTransformerStreamSubscription");
  C.TypeVariable_6mv = new H.TypeVariable(C.Type_0TC, "T", 1);
  C.Type__StreamSubscriptionTransformer_0 = H.createRuntimeType("_StreamSubscriptionTransformer");
  C.TypeVariable_7BT = new H.TypeVariable(C.Type__StreamSubscriptionTransformer_0, "T", 1);
  C.Type_zzp = H.createRuntimeType("_AsyncStreamControllerDispatch");
  C.TypeVariable_86y = new H.TypeVariable(C.Type_zzp, "T", 1);
  C.Type__DoubleLinkedQueueElement_arz = H.createRuntimeType("_DoubleLinkedQueueElement");
  C.TypeVariable_AlA = new H.TypeVariable(C.Type__DoubleLinkedQueueElement_arz, "E", 1);
  C.Type__BroadcastStreamController_3De = H.createRuntimeType("_BroadcastStreamController");
  C.TypeVariable_C43 = new H.TypeVariable(C.Type__BroadcastStreamController_3De, "T", 1);
  C.TypeVariable_C5p = new H.TypeVariable(C.Type__ConverterStreamEventSink_mzi, "T", 1);
  C.TypeVariable_CF9 = new H.TypeVariable(C.Type__StreamSubscriptionTransformer_0, "S", 1);
  C.Type_gg9 = H.createRuntimeType("_SplayTree_IterableMixin");
  C.TypeVariable_Ck9 = new H.TypeVariable(C.Type_gg9, "E", 1);
  C.Type__CaseInsensitiveStringMap_y1F = H.createRuntimeType("_CaseInsensitiveStringMap");
  C.TypeVariable_Dnt = new H.TypeVariable(C.Type__CaseInsensitiveStringMap_y1F, "V", 1);
  C.Type__StateStreamSubscription_Mld = H.createRuntimeType("_StateStreamSubscription");
  C.TypeVariable_Ecu = new H.TypeVariable(C.Type__StateStreamSubscription_Mld, "T", 1);
  C.Type_rz1 = H.createRuntimeType("_BroadcastSubscriptionWrapper");
  C.TypeVariable_LdF = new H.TypeVariable(C.Type_rz1, "T", 1);
  C.Type_y7h = H.createRuntimeType("_AsyncBroadcastStreamController");
  C.TypeVariable_MJa = new H.TypeVariable(C.Type_y7h, "T", 1);
  C.Type_EkO = H.createRuntimeType("_StreamControllerAddStreamState");
  C.TypeVariable_OnH = new H.TypeVariable(C.Type_EkO, "T", 1);
  C.TypeVariable_PTP = new H.TypeVariable(C.Type_0TC, "S", 1);
  C.Type_SynchronousStreamController_MY2 = H.createRuntimeType("SynchronousStreamController");
  C.TypeVariable_TOW = new H.TypeVariable(C.Type_SynchronousStreamController_MY2, "T", 1);
  C.Type_yXb = H.createRuntimeType("Object_ListMixin");
  C.TypeVariable_TTS = new H.TypeVariable(C.Type_yXb, "E", 1);
  C.Type_BidirectionalIterator_46c = H.createRuntimeType("BidirectionalIterator");
  C.TypeVariable_Type_BidirectionalIterator_46c_E = new H.TypeVariable(C.Type_BidirectionalIterator_46c, "E", 1);
  C.Type_ChunkedConversionSink_NCr = H.createRuntimeType("ChunkedConversionSink");
  C.TypeVariable_Type_ChunkedConversionSink_NCr_T = new H.TypeVariable(C.Type_ChunkedConversionSink_NCr, "T", 1);
  C.Type_ChunkedConverter_yzN = H.createRuntimeType("ChunkedConverter");
  C.TypeVariable_Type_ChunkedConverter_yzN_S = new H.TypeVariable(C.Type_ChunkedConverter_yzN, "S", 1);
  C.TypeVariable_Type_ChunkedConverter_yzN_S2 = new H.TypeVariable(C.Type_ChunkedConverter_yzN, "S2", 1);
  C.TypeVariable_Type_ChunkedConverter_yzN_T = new H.TypeVariable(C.Type_ChunkedConverter_yzN, "T", 1);
  C.TypeVariable_Type_ChunkedConverter_yzN_T2 = new H.TypeVariable(C.Type_ChunkedConverter_yzN, "T2", 1);
  C.Type_Codec_1xO = H.createRuntimeType("Codec");
  C.TypeVariable_Type_Codec_1xO_S = new H.TypeVariable(C.Type_Codec_1xO, "S", 1);
  C.TypeVariable_Type_Codec_1xO_T = new H.TypeVariable(C.Type_Codec_1xO, "T", 1);
  C.Type_Comparable_Q43 = H.createRuntimeType("Comparable");
  C.TypeVariable_Type_Comparable_Q43_T = new H.TypeVariable(C.Type_Comparable_Q43, "T", 1);
  C.Type_Completer_CNi = H.createRuntimeType("Completer");
  C.TypeVariable_Type_Completer_CNi_T = new H.TypeVariable(C.Type_Completer_CNi, "T", 1);
  C.Type_Converter_JmU = H.createRuntimeType("Converter");
  C.TypeVariable_Type_Converter_JmU_S = new H.TypeVariable(C.Type_Converter_JmU, "S", 1);
  C.TypeVariable_Type_Converter_JmU_T = new H.TypeVariable(C.Type_Converter_JmU, "T", 1);
  C.Type_DoubleLinkedQueueEntry_FGJ = H.createRuntimeType("DoubleLinkedQueueEntry");
  C.TypeVariable_Type_DoubleLinkedQueueEntry_FGJ_E = new H.TypeVariable(C.Type_DoubleLinkedQueueEntry_FGJ, "E", 1);
  C.Type_DoubleLinkedQueue_6La = H.createRuntimeType("DoubleLinkedQueue");
  C.TypeVariable_Type_DoubleLinkedQueue_6La_E = new H.TypeVariable(C.Type_DoubleLinkedQueue_6La, "E", 1);
  C.Type_EventSink_ar2 = H.createRuntimeType("EventSink");
  C.TypeVariable_Type_EventSink_ar2_T = new H.TypeVariable(C.Type_EventSink_ar2, "T", 1);
  C.Type_Expando_lCi = H.createRuntimeType("Expando");
  C.TypeVariable_Type_Expando_lCi_T = new H.TypeVariable(C.Type_Expando_lCi, "T", 1);
  C.Type_FutureOr_Ozn = H.createRuntimeType("FutureOr");
  C.TypeVariable_Type_FutureOr_Ozn_T = new H.TypeVariable(C.Type_FutureOr_Ozn, "T", 1);
  C.Type_Future_JO4 = H.createRuntimeType("Future");
  C.TypeVariable_Type_Future_JO4_T = new H.TypeVariable(C.Type_Future_JO4, "T", 1);
  C.Type_HasNextIterator_wEV = H.createRuntimeType("HasNextIterator");
  C.TypeVariable_Type_HasNextIterator_wEV_E = new H.TypeVariable(C.Type_HasNextIterator_wEV, "E", 1);
  C.Type_HashMap_RoN = H.createRuntimeType("HashMap");
  C.TypeVariable_Type_HashMap_RoN_K = new H.TypeVariable(C.Type_HashMap_RoN, "K", 1);
  C.TypeVariable_Type_HashMap_RoN_V = new H.TypeVariable(C.Type_HashMap_RoN, "V", 1);
  C.Type_HashSet_cdS = H.createRuntimeType("HashSet");
  C.TypeVariable_Type_HashSet_cdS_E = new H.TypeVariable(C.Type_HashSet_cdS, "E", 1);
  C.Type_IterableBase_if4 = H.createRuntimeType("IterableBase");
  C.TypeVariable_Type_IterableBase_if4_E = new H.TypeVariable(C.Type_IterableBase_if4, "E", 1);
  C.Type_IterableMixin_cJC = H.createRuntimeType("IterableMixin");
  C.TypeVariable_Type_IterableMixin_cJC_E = new H.TypeVariable(C.Type_IterableMixin_cJC, "E", 1);
  C.Type_Iterable_K9t = H.createRuntimeType("Iterable");
  C.TypeVariable_Type_Iterable_K9t_E = new H.TypeVariable(C.Type_Iterable_K9t, "E", 1);
  C.Type_Iterator_T5k = H.createRuntimeType("Iterator");
  C.TypeVariable_Type_Iterator_T5k_E = new H.TypeVariable(C.Type_Iterator_T5k, "E", 1);
  C.Type_JSArray_zDM = H.createRuntimeType("JSArray");
  C.TypeVariable_Type_JSArray_zDM_E = new H.TypeVariable(C.Type_JSArray_zDM, "E", 1);
  C.Type_LinkedHashMap_mTw = H.createRuntimeType("LinkedHashMap");
  C.TypeVariable_Type_LinkedHashMap_mTw_K = new H.TypeVariable(C.Type_LinkedHashMap_mTw, "K", 1);
  C.TypeVariable_Type_LinkedHashMap_mTw_V = new H.TypeVariable(C.Type_LinkedHashMap_mTw, "V", 1);
  C.Type_LinkedHashSet_j93 = H.createRuntimeType("LinkedHashSet");
  C.TypeVariable_Type_LinkedHashSet_j93_E = new H.TypeVariable(C.Type_LinkedHashSet_j93, "E", 1);
  C.Type_LinkedListEntry_Odg = H.createRuntimeType("LinkedListEntry");
  C.TypeVariable_Type_LinkedListEntry_Odg_E = new H.TypeVariable(C.Type_LinkedListEntry_Odg, "E", 1618);
  C.Type_LinkedList_Mys = H.createRuntimeType("LinkedList");
  C.TypeVariable_Type_LinkedList_Mys_E = new H.TypeVariable(C.Type_LinkedList_Mys, "E", 694);
  C.Type_ListBase_3Qc = H.createRuntimeType("ListBase");
  C.TypeVariable_Type_ListBase_3Qc_E = new H.TypeVariable(C.Type_ListBase_3Qc, "E", 1);
  C.Type_ListMixin_Ism = H.createRuntimeType("ListMixin");
  C.TypeVariable_Type_ListMixin_Ism_E = new H.TypeVariable(C.Type_ListMixin_Ism, "E", 1);
  C.Type_ListQueue_c4R = H.createRuntimeType("ListQueue");
  C.TypeVariable_Type_ListQueue_c4R_E = new H.TypeVariable(C.Type_ListQueue_c4R, "E", 1);
  C.Type_List_naM = H.createRuntimeType("List");
  C.TypeVariable_Type_List_naM_E = new H.TypeVariable(C.Type_List_naM, "E", 1);
  C.Type_MapBase_Olj = H.createRuntimeType("MapBase");
  C.TypeVariable_Type_MapBase_Olj_K = new H.TypeVariable(C.Type_MapBase_Olj, "K", 1);
  C.TypeVariable_Type_MapBase_Olj_V = new H.TypeVariable(C.Type_MapBase_Olj, "V", 1);
  C.Type_MapMixin_UNR = H.createRuntimeType("MapMixin");
  C.TypeVariable_Type_MapMixin_UNR_K = new H.TypeVariable(C.Type_MapMixin_UNR, "K", 1);
  C.TypeVariable_Type_MapMixin_UNR_V = new H.TypeVariable(C.Type_MapMixin_UNR, "V", 1);
  C.Type_MapView_6Vn = H.createRuntimeType("MapView");
  C.TypeVariable_Type_MapView_6Vn_K = new H.TypeVariable(C.Type_MapView_6Vn, "K", 1);
  C.TypeVariable_Type_MapView_6Vn_V = new H.TypeVariable(C.Type_MapView_6Vn, "V", 1);
  C.Type_Map_2Zi = H.createRuntimeType("Map");
  C.TypeVariable_Type_Map_2Zi_K = new H.TypeVariable(C.Type_Map_2Zi, "K", 1);
  C.TypeVariable_Type_Map_2Zi_V = new H.TypeVariable(C.Type_Map_2Zi, "V", 1);
  C.Type_MutableRectangle_G79 = H.createRuntimeType("MutableRectangle");
  C.TypeVariable_Type_MutableRectangle_G79_T = new H.TypeVariable(C.Type_MutableRectangle_G79, "T", 46);
  C.Type_Point_Yua = H.createRuntimeType("Point");
  C.TypeVariable_Type_Point_Yua_T = new H.TypeVariable(C.Type_Point_Yua, "T", 46);
  C.Type_Queue_jXq = H.createRuntimeType("Queue");
  C.TypeVariable_Type_Queue_jXq_E = new H.TypeVariable(C.Type_Queue_jXq, "E", 1);
  C.Type_Rectangle_o6V = H.createRuntimeType("Rectangle");
  C.TypeVariable_Type_Rectangle_o6V_T = new H.TypeVariable(C.Type_Rectangle_o6V, "T", 46);
  C.Type_SetBase_2bH = H.createRuntimeType("SetBase");
  C.TypeVariable_Type_SetBase_2bH_E = new H.TypeVariable(C.Type_SetBase_2bH, "E", 1);
  C.Type_SetMixin_WMS = H.createRuntimeType("SetMixin");
  C.TypeVariable_Type_SetMixin_WMS_E = new H.TypeVariable(C.Type_SetMixin_WMS, "E", 1);
  C.Type_Set_mC8 = H.createRuntimeType("Set");
  C.TypeVariable_Type_Set_mC8_E = new H.TypeVariable(C.Type_Set_mC8, "E", 1);
  C.Type_Sink_wrR = H.createRuntimeType("Sink");
  C.TypeVariable_Type_Sink_wrR_T = new H.TypeVariable(C.Type_Sink_wrR, "T", 1);
  C.Type_SplayTreeMap_4AN = H.createRuntimeType("SplayTreeMap");
  C.TypeVariable_Type_SplayTreeMap_4AN_K = new H.TypeVariable(C.Type_SplayTreeMap_4AN, "K", 1);
  C.TypeVariable_Type_SplayTreeMap_4AN_V = new H.TypeVariable(C.Type_SplayTreeMap_4AN, "V", 1);
  C.Type_SplayTreeSet_fjq = H.createRuntimeType("SplayTreeSet");
  C.TypeVariable_Type_SplayTreeSet_fjq_E = new H.TypeVariable(C.Type_SplayTreeSet_fjq, "E", 1);
  C.Type_StreamConsumer_epf = H.createRuntimeType("StreamConsumer");
  C.TypeVariable_Type_StreamConsumer_epf_S = new H.TypeVariable(C.Type_StreamConsumer_epf, "S", 1);
  C.Type_StreamController_QWq = H.createRuntimeType("StreamController");
  C.TypeVariable_Type_StreamController_QWq_T = new H.TypeVariable(C.Type_StreamController_QWq, "T", 1);
  C.Type_StreamIterator_sgl = H.createRuntimeType("StreamIterator");
  C.TypeVariable_Type_StreamIterator_sgl_T = new H.TypeVariable(C.Type_StreamIterator_sgl, "T", 1);
  C.Type_StreamSink_Y6h = H.createRuntimeType("StreamSink");
  C.TypeVariable_Type_StreamSink_Y6h_S = new H.TypeVariable(C.Type_StreamSink_Y6h, "S", 1);
  C.Type_StreamSubscription_GVy = H.createRuntimeType("StreamSubscription");
  C.TypeVariable_Type_StreamSubscription_GVy_T = new H.TypeVariable(C.Type_StreamSubscription_GVy, "T", 1);
  C.Type_StreamTransformer_alc = H.createRuntimeType("StreamTransformer");
  C.TypeVariable_Type_StreamTransformer_alc_S = new H.TypeVariable(C.Type_StreamTransformer_alc, "S", 1);
  C.TypeVariable_Type_StreamTransformer_alc_T = new H.TypeVariable(C.Type_StreamTransformer_alc, "T", 1);
  C.Type_StreamView_yTL = H.createRuntimeType("StreamView");
  C.TypeVariable_Type_StreamView_yTL_T = new H.TypeVariable(C.Type_StreamView_yTL, "T", 1);
  C.Type_Stream_qXA = H.createRuntimeType("Stream");
  C.TypeVariable_Type_Stream_qXA_T = new H.TypeVariable(C.Type_Stream_qXA, "T", 1);
  C.Type_UnmodifiableListView_Gx6 = H.createRuntimeType("UnmodifiableListView");
  C.TypeVariable_Type_UnmodifiableListView_Gx6_E = new H.TypeVariable(C.Type_UnmodifiableListView_Gx6, "E", 1);
  C.Type_UnmodifiableMapBase_KU4 = H.createRuntimeType("UnmodifiableMapBase");
  C.TypeVariable_Type_UnmodifiableMapBase_KU4_K = new H.TypeVariable(C.Type_UnmodifiableMapBase_KU4, "K", 1);
  C.TypeVariable_Type_UnmodifiableMapBase_KU4_V = new H.TypeVariable(C.Type_UnmodifiableMapBase_KU4, "V", 1);
  C.Type_UnmodifiableMapView_C2I = H.createRuntimeType("UnmodifiableMapView");
  C.TypeVariable_Type_UnmodifiableMapView_C2I_K = new H.TypeVariable(C.Type_UnmodifiableMapView_C2I, "K", 1);
  C.TypeVariable_Type_UnmodifiableMapView_C2I_V = new H.TypeVariable(C.Type_UnmodifiableMapView_C2I, "V", 1);
  C.Type__AddStreamState_ifH = H.createRuntimeType("_AddStreamState");
  C.TypeVariable_Type__AddStreamState_ifH_T = new H.TypeVariable(C.Type__AddStreamState_ifH, "T", 1);
  C.Type__AsBroadcastStream_pV3 = H.createRuntimeType("_AsBroadcastStream");
  C.TypeVariable_Type__AsBroadcastStream_pV3_T = new H.TypeVariable(C.Type__AsBroadcastStream_pV3, "T", 1);
  C.Type__AsyncCompleter_Irt = H.createRuntimeType("_AsyncCompleter");
  C.TypeVariable_Type__AsyncCompleter_Irt_T = new H.TypeVariable(C.Type__AsyncCompleter_Irt, "T", 1);
  C.Type__AsyncStreamController_Ux9 = H.createRuntimeType("_AsyncStreamController");
  C.TypeVariable_Type__AsyncStreamController_Ux9_T = new H.TypeVariable(C.Type__AsyncStreamController_Ux9, "T", 1);
  C.Type__BoundSinkStream_rmX = H.createRuntimeType("_BoundSinkStream");
  C.TypeVariable_Type__BoundSinkStream_rmX_S = new H.TypeVariable(C.Type__BoundSinkStream_rmX, "S", 1);
  C.TypeVariable_Type__BoundSinkStream_rmX_T = new H.TypeVariable(C.Type__BoundSinkStream_rmX, "T", 1);
  C.Type__BroadcastStream_e2q = H.createRuntimeType("_BroadcastStream");
  C.TypeVariable_Type__BroadcastStream_e2q_T = new H.TypeVariable(C.Type__BroadcastStream_e2q, "T", 1);
  C.Type__BroadcastSubscription_bl8 = H.createRuntimeType("_BroadcastSubscription");
  C.TypeVariable_Type__BroadcastSubscription_bl8_T = new H.TypeVariable(C.Type__BroadcastSubscription_bl8, "T", 1);
  C.Type__Completer_T1l = H.createRuntimeType("_Completer");
  C.TypeVariable_Type__Completer_T1l_T = new H.TypeVariable(C.Type__Completer_T1l, "T", 1);
  C.Type__ControllerStream_iHe = H.createRuntimeType("_ControllerStream");
  C.TypeVariable_Type__ControllerStream_iHe_T = new H.TypeVariable(C.Type__ControllerStream_iHe, "T", 1);
  C.Type__ControllerSubscription_S4n = H.createRuntimeType("_ControllerSubscription");
  C.TypeVariable_Type__ControllerSubscription_S4n_T = new H.TypeVariable(C.Type__ControllerSubscription_S4n, "T", 1);
  C.Type__DelayedData_0mC = H.createRuntimeType("_DelayedData");
  C.TypeVariable_Type__DelayedData_0mC_T = new H.TypeVariable(C.Type__DelayedData_0mC, "T", 1);
  C.Type__DelayedEvent_kaS = H.createRuntimeType("_DelayedEvent");
  C.TypeVariable_Type__DelayedEvent_kaS_T = new H.TypeVariable(C.Type__DelayedEvent_kaS, "T", 1);
  C.Type__DistinctStream_iDA = H.createRuntimeType("_DistinctStream");
  C.TypeVariable_Type__DistinctStream_iDA_T = new H.TypeVariable(C.Type__DistinctStream_iDA, "T", 1);
  C.Type__DoneStreamSubscription_kvD = H.createRuntimeType("_DoneStreamSubscription");
  C.TypeVariable_Type__DoneStreamSubscription_kvD_T = new H.TypeVariable(C.Type__DoneStreamSubscription_kvD, "T", 1);
  C.Type__DoubleLink_7Yv = H.createRuntimeType("_DoubleLink");
  C.TypeVariable_Type__DoubleLink_7Yv_Link = new H.TypeVariable(C.Type__DoubleLink_7Yv, "Link", 1133);
  C.Type__DoubleLinkedQueueEntry_2Vu = H.createRuntimeType("_DoubleLinkedQueueEntry");
  C.TypeVariable_Type__DoubleLinkedQueueEntry_2Vu_E = new H.TypeVariable(C.Type__DoubleLinkedQueueEntry_2Vu, "E", 1);
  C.Type__EmptyStream_4QF = H.createRuntimeType("_EmptyStream");
  C.TypeVariable_Type__EmptyStream_4QF_T = new H.TypeVariable(C.Type__EmptyStream_4QF, "T", 1);
  C.Type__EventDispatch_yvL = H.createRuntimeType("_EventDispatch");
  C.TypeVariable_Type__EventDispatch_yvL_T = new H.TypeVariable(C.Type__EventDispatch_yvL, "T", 1);
  C.Type__EventSinkWrapper_iL9 = H.createRuntimeType("_EventSinkWrapper");
  C.TypeVariable_Type__EventSinkWrapper_iL9_T = new H.TypeVariable(C.Type__EventSinkWrapper_iL9, "T", 1);
  C.Type__EventSink_ciW = H.createRuntimeType("_EventSink");
  C.TypeVariable_Type__EventSink_ciW_T = new H.TypeVariable(C.Type__EventSink_ciW, "T", 1);
  C.Type__ExpandStream_m9l = H.createRuntimeType("_ExpandStream");
  C.TypeVariable_Type__ExpandStream_m9l_S = new H.TypeVariable(C.Type__ExpandStream_m9l, "S", 1);
  C.TypeVariable_Type__ExpandStream_m9l_T = new H.TypeVariable(C.Type__ExpandStream_m9l, "T", 1);
  C.Type__ForwardingStream_EK0 = H.createRuntimeType("_ForwardingStream");
  C.TypeVariable_Type__ForwardingStream_EK0_S = new H.TypeVariable(C.Type__ForwardingStream_EK0, "S", 1);
  C.TypeVariable_Type__ForwardingStream_EK0_T = new H.TypeVariable(C.Type__ForwardingStream_EK0, "T", 1);
  C.Type__FusedCodec_4kv = H.createRuntimeType("_FusedCodec");
  C.TypeVariable_Type__FusedCodec_4kv_M = new H.TypeVariable(C.Type__FusedCodec_4kv, "M", 1);
  C.TypeVariable_Type__FusedCodec_4kv_S = new H.TypeVariable(C.Type__FusedCodec_4kv, "S", 1);
  C.TypeVariable_Type__FusedCodec_4kv_T = new H.TypeVariable(C.Type__FusedCodec_4kv, "T", 1);
  C.Type__FusedConverter_33h = H.createRuntimeType("_FusedConverter");
  C.TypeVariable_Type__FusedConverter_33h_M = new H.TypeVariable(C.Type__FusedConverter_33h, "M", 1);
  C.TypeVariable_Type__FusedConverter_33h_S = new H.TypeVariable(C.Type__FusedConverter_33h, "S", 1);
  C.TypeVariable_Type__FusedConverter_33h_T = new H.TypeVariable(C.Type__FusedConverter_33h, "T", 1);
  C.Type__FutureListener_XVS = H.createRuntimeType("_FutureListener");
  C.TypeVariable_Type__FutureListener_XVS_S = new H.TypeVariable(C.Type__FutureListener_XVS, "S", 1);
  C.TypeVariable_Type__FutureListener_XVS_T = new H.TypeVariable(C.Type__FutureListener_XVS, "T", 1);
  C.Type__Future_ifn = H.createRuntimeType("_Future");
  C.TypeVariable_Type__Future_ifn_T = new H.TypeVariable(C.Type__Future_ifn, "T", 1);
  C.Type__GeneratedStreamImpl_jrB = H.createRuntimeType("_GeneratedStreamImpl");
  C.TypeVariable_Type__GeneratedStreamImpl_jrB_T = new H.TypeVariable(C.Type__GeneratedStreamImpl_jrB, "T", 1);
  C.Type__GeneratorIterable_H1k = H.createRuntimeType("_GeneratorIterable");
  C.TypeVariable_Type__GeneratorIterable_H1k_E = new H.TypeVariable(C.Type__GeneratorIterable_H1k, "E", 1);
  C.Type__HandleErrorStream_OpF = H.createRuntimeType("_HandleErrorStream");
  C.TypeVariable_Type__HandleErrorStream_OpF_T = new H.TypeVariable(C.Type__HandleErrorStream_OpF, "T", 1);
  C.Type__HandlerEventSink_u5Q = H.createRuntimeType("_HandlerEventSink");
  C.TypeVariable_Type__HandlerEventSink_u5Q_S = new H.TypeVariable(C.Type__HandlerEventSink_u5Q, "S", 1);
  C.TypeVariable_Type__HandlerEventSink_u5Q_T = new H.TypeVariable(C.Type__HandlerEventSink_u5Q, "T", 1);
  C.Type__HashSetBase_V0W = H.createRuntimeType("_HashSetBase");
  C.TypeVariable_Type__HashSetBase_V0W_E = new H.TypeVariable(C.Type__HashSetBase_V0W, "E", 1);
  C.Type__HttpOutboundMessage_Q0A = H.createRuntimeType("_HttpOutboundMessage");
  C.TypeVariable_Type__HttpOutboundMessage_Q0A_T = new H.TypeVariable(C.Type__HttpOutboundMessage_Q0A, "T", 1);
  C.Type__InvertedCodec_SAd = H.createRuntimeType("_InvertedCodec");
  C.TypeVariable_Type__InvertedCodec_SAd_S = new H.TypeVariable(C.Type__InvertedCodec_SAd, "S", 1);
  C.TypeVariable_Type__InvertedCodec_SAd_T = new H.TypeVariable(C.Type__InvertedCodec_SAd, "T", 1);
  C.Type__IterablePendingEvents_2jR = H.createRuntimeType("_IterablePendingEvents");
  C.TypeVariable_Type__IterablePendingEvents_2jR_T = new H.TypeVariable(C.Type__IterablePendingEvents_2jR, "T", 1);
  C.Type__LinkedListIterator_j0s = H.createRuntimeType("_LinkedListIterator");
  C.TypeVariable_Type__LinkedListIterator_j0s_E = new H.TypeVariable(C.Type__LinkedListIterator_j0s, "E", 397);
  C.Type__ListQueueIterator_Ofa = H.createRuntimeType("_ListQueueIterator");
  C.TypeVariable_Type__ListQueueIterator_Ofa_E = new H.TypeVariable(C.Type__ListQueueIterator_Ofa, "E", 1);
  C.Type__MapBaseValueIterable_4VA = H.createRuntimeType("_MapBaseValueIterable");
  C.TypeVariable_Type__MapBaseValueIterable_4VA_K = new H.TypeVariable(C.Type__MapBaseValueIterable_4VA, "K", 1);
  C.TypeVariable_Type__MapBaseValueIterable_4VA_V = new H.TypeVariable(C.Type__MapBaseValueIterable_4VA, "V", 1);
  C.Type__MapBaseValueIterator_mtc = H.createRuntimeType("_MapBaseValueIterator");
  C.TypeVariable_Type__MapBaseValueIterator_mtc_K = new H.TypeVariable(C.Type__MapBaseValueIterator_mtc, "K", 1);
  C.TypeVariable_Type__MapBaseValueIterator_mtc_V = new H.TypeVariable(C.Type__MapBaseValueIterator_mtc, "V", 1);
  C.Type__MapStream_ynF = H.createRuntimeType("_MapStream");
  C.TypeVariable_Type__MapStream_ynF_S = new H.TypeVariable(C.Type__MapStream_ynF, "S", 1);
  C.TypeVariable_Type__MapStream_ynF_T = new H.TypeVariable(C.Type__MapStream_ynF, "T", 1);
  C.Type__PendingEvents_v74 = H.createRuntimeType("_PendingEvents");
  C.TypeVariable_Type__PendingEvents_v74_T = new H.TypeVariable(C.Type__PendingEvents_v74, "T", 1);
  C.Type__RectangleBase_O5w = H.createRuntimeType("_RectangleBase");
  C.TypeVariable_Type__RectangleBase_O5w_T = new H.TypeVariable(C.Type__RectangleBase_O5w, "T", 46);
  C.Type__SimpleCallbackSink_qZk = H.createRuntimeType("_SimpleCallbackSink");
  C.TypeVariable_Type__SimpleCallbackSink_qZk_T = new H.TypeVariable(C.Type__SimpleCallbackSink_qZk, "T", 1);
  C.Type__SkipStream_6eq = H.createRuntimeType("_SkipStream");
  C.TypeVariable_Type__SkipStream_6eq_T = new H.TypeVariable(C.Type__SkipStream_6eq, "T", 1);
  C.Type__SkipWhileStream_lyG = H.createRuntimeType("_SkipWhileStream");
  C.TypeVariable_Type__SkipWhileStream_lyG_T = new H.TypeVariable(C.Type__SkipWhileStream_lyG, "T", 1);
  C.Type__SplayTreeIterator_gg4 = H.createRuntimeType("_SplayTreeIterator");
  C.TypeVariable_Type__SplayTreeIterator_gg4_K = new H.TypeVariable(C.Type__SplayTreeIterator_gg4, "K", 1);
  C.TypeVariable_Type__SplayTreeIterator_gg4_T = new H.TypeVariable(C.Type__SplayTreeIterator_gg4, "T", 1);
  C.Type__SplayTreeKeyIterable_mtF = H.createRuntimeType("_SplayTreeKeyIterable");
  C.TypeVariable_Type__SplayTreeKeyIterable_mtF_K = new H.TypeVariable(C.Type__SplayTreeKeyIterable_mtF, "K", 1);
  C.Type__SplayTreeKeyIterator_6i1 = H.createRuntimeType("_SplayTreeKeyIterator");
  C.TypeVariable_Type__SplayTreeKeyIterator_6i1_K = new H.TypeVariable(C.Type__SplayTreeKeyIterator_6i1, "K", 1);
  C.Type__SplayTreeMapNode_jWj = H.createRuntimeType("_SplayTreeMapNode");
  C.TypeVariable_Type__SplayTreeMapNode_jWj_K = new H.TypeVariable(C.Type__SplayTreeMapNode_jWj, "K", 1);
  C.TypeVariable_Type__SplayTreeMapNode_jWj_V = new H.TypeVariable(C.Type__SplayTreeMapNode_jWj, "V", 1);
  C.Type__SplayTreeNodeIterator_0 = H.createRuntimeType("_SplayTreeNodeIterator");
  C.TypeVariable_Type__SplayTreeNodeIterator_0_K = new H.TypeVariable(C.Type__SplayTreeNodeIterator_0, "K", 1);
  C.Type__SplayTreeNode_mCJ = H.createRuntimeType("_SplayTreeNode");
  C.TypeVariable_Type__SplayTreeNode_mCJ_K = new H.TypeVariable(C.Type__SplayTreeNode_mCJ, "K", 1);
  C.Type__SplayTreeValueIterable_F4j = H.createRuntimeType("_SplayTreeValueIterable");
  C.TypeVariable_Type__SplayTreeValueIterable_F4j_K = new H.TypeVariable(C.Type__SplayTreeValueIterable_F4j, "K", 1);
  C.TypeVariable_Type__SplayTreeValueIterable_F4j_V = new H.TypeVariable(C.Type__SplayTreeValueIterable_F4j, "V", 1);
  C.Type__SplayTreeValueIterator_F4j = H.createRuntimeType("_SplayTreeValueIterator");
  C.TypeVariable_Type__SplayTreeValueIterator_F4j_K = new H.TypeVariable(C.Type__SplayTreeValueIterator_F4j, "K", 1);
  C.TypeVariable_Type__SplayTreeValueIterator_F4j_V = new H.TypeVariable(C.Type__SplayTreeValueIterator_F4j, "V", 1);
  C.Type__SplayTree_STv = H.createRuntimeType("_SplayTree");
  C.TypeVariable_Type__SplayTree_STv_K = new H.TypeVariable(C.Type__SplayTree_STv, "K", 1);
  C.TypeVariable_Type__SplayTree_STv_Node = new H.TypeVariable(C.Type__SplayTree_STv, "Node", 1124);
  C.Type__StreamController_wxj = H.createRuntimeType("_StreamController");
  C.TypeVariable_Type__StreamController_wxj_T = new H.TypeVariable(C.Type__StreamController_wxj, "T", 1);
  C.Type__StreamImplEvents_Q06 = H.createRuntimeType("_StreamImplEvents");
  C.TypeVariable_Type__StreamImplEvents_Q06_T = new H.TypeVariable(C.Type__StreamImplEvents_Q06, "T", 1);
  C.Type__StreamImpl_7xV = H.createRuntimeType("_StreamImpl");
  C.TypeVariable_Type__StreamImpl_7xV_T = new H.TypeVariable(C.Type__StreamImpl_7xV, "T", 1);
  C.Type__StreamIterator_AH7 = H.createRuntimeType("_StreamIterator");
  C.TypeVariable_Type__StreamIterator_AH7_T = new H.TypeVariable(C.Type__StreamIterator_AH7, "T", 1);
  C.Type__StreamSinkImpl_UrA = H.createRuntimeType("_StreamSinkImpl");
  C.TypeVariable_Type__StreamSinkImpl_UrA_T = new H.TypeVariable(C.Type__StreamSinkImpl_UrA, "T", 1);
  C.Type__StreamSinkTransformer_gUt = H.createRuntimeType("_StreamSinkTransformer");
  C.TypeVariable_Type__StreamSinkTransformer_gUt_S = new H.TypeVariable(C.Type__StreamSinkTransformer_gUt, "S", 1);
  C.TypeVariable_Type__StreamSinkTransformer_gUt_T = new H.TypeVariable(C.Type__StreamSinkTransformer_gUt, "T", 1);
  C.Type__StreamSinkWrapper_UQE = H.createRuntimeType("_StreamSinkWrapper");
  C.TypeVariable_Type__StreamSinkWrapper_UQE_T = new H.TypeVariable(C.Type__StreamSinkWrapper_UQE, "T", 1);
  C.Type__SyncCompleter_7QI = H.createRuntimeType("_SyncCompleter");
  C.TypeVariable_Type__SyncCompleter_7QI_T = new H.TypeVariable(C.Type__SyncCompleter_7QI, "T", 1);
  C.Type__SyncStreamController_kiv = H.createRuntimeType("_SyncStreamController");
  C.TypeVariable_Type__SyncStreamController_kiv_T = new H.TypeVariable(C.Type__SyncStreamController_kiv, "T", 1);
  C.Type__TakeStream_Yma = H.createRuntimeType("_TakeStream");
  C.TypeVariable_Type__TakeStream_Yma_T = new H.TypeVariable(C.Type__TakeStream_Yma, "T", 1);
  C.Type__TakeWhileStream_CWV = H.createRuntimeType("_TakeWhileStream");
  C.TypeVariable_Type__TakeWhileStream_CWV_T = new H.TypeVariable(C.Type__TakeWhileStream_CWV, "T", 1);
  C.Type__TypeTest_7QV = H.createRuntimeType("_TypeTest");
  C.TypeVariable_Type__TypeTest_7QV_T = new H.TypeVariable(C.Type__TypeTest_7QV, "T", 1);
  C.Type__UnmodifiableMapMixin_FuX = H.createRuntimeType("_UnmodifiableMapMixin");
  C.TypeVariable_Type__UnmodifiableMapMixin_FuX_K = new H.TypeVariable(C.Type__UnmodifiableMapMixin_FuX, "K", 1);
  C.TypeVariable_Type__UnmodifiableMapMixin_FuX_V = new H.TypeVariable(C.Type__UnmodifiableMapMixin_FuX, "V", 1);
  C.Type__WhereStream_1p9 = H.createRuntimeType("_WhereStream");
  C.TypeVariable_Type__WhereStream_1p9_T = new H.TypeVariable(C.Type__WhereStream_1p9, "T", 1);
  C.Type__ZoneFunction_xw8 = H.createRuntimeType("_ZoneFunction");
  C.TypeVariable_Type__ZoneFunction_xw8_T = new H.TypeVariable(C.Type__ZoneFunction_xw8, "T", 29);
  C.Type_MMm = H.createRuntimeType("_ForwardingStreamSubscription");
  C.TypeVariable_ahM = new H.TypeVariable(C.Type_MMm, "S", 1);
  C.Type__BoundSubscriptionStream_03r = H.createRuntimeType("_BoundSubscriptionStream");
  C.TypeVariable_etK = new H.TypeVariable(C.Type__BoundSubscriptionStream_03r, "S", 1);
  C.Type__StreamHandlerTransformer_LlB = H.createRuntimeType("_StreamHandlerTransformer");
  C.TypeVariable_hD9 = new H.TypeVariable(C.Type__StreamHandlerTransformer_LlB, "S", 1);
  C.Type__BufferingStreamSubscription_M5k = H.createRuntimeType("_BufferingStreamSubscription");
  C.TypeVariable_iiT = new H.TypeVariable(C.Type__BufferingStreamSubscription_M5k, "T", 1);
  C.Type_8aB = H.createRuntimeType("_SyncStreamControllerDispatch");
  C.TypeVariable_izR = new H.TypeVariable(C.Type_8aB, "T", 1);
  C.Type__ControllerEventSinkWrapper_GTp = H.createRuntimeType("_ControllerEventSinkWrapper");
  C.TypeVariable_mpT = new H.TypeVariable(C.Type__ControllerEventSinkWrapper_GTp, "T", 1);
  C.TypeVariable_oVw = new H.TypeVariable(C.Type_MMm, "T", 1);
  C.Type__StreamControllerLifecycle_exN = H.createRuntimeType("_StreamControllerLifecycle");
  C.TypeVariable_wsa = new H.TypeVariable(C.Type__StreamControllerLifecycle_exN, "T", 1);
  C.TypeVariable_xw8 = new H.TypeVariable(C.Type__BoundSubscriptionStream_03r, "T", 1);
  C.TypeVariable_zgG = new H.TypeVariable(C.Type__StreamHandlerTransformer_LlB, "T", 1);
  C.Type_ByteBuffer_RkP = H.createRuntimeType("ByteBuffer");
  C.Type_ByteData_zNC = H.createRuntimeType("ByteData");
  C.Type_Float32List_LB7 = H.createRuntimeType("Float32List");
  C.Type_Float32x4List_0ez = H.createRuntimeType("Float32x4List");
  C.Type_Float64List_LB7 = H.createRuntimeType("Float64List");
  C.Type_Float64x2List_0ez = H.createRuntimeType("Float64x2List");
  C.Type_Int16List_uXf = H.createRuntimeType("Int16List");
  C.Type_Int32List_O50 = H.createRuntimeType("Int32List");
  C.Type_Int32x4List_pCi = H.createRuntimeType("Int32x4List");
  C.Type_Int8List_ekJ = H.createRuntimeType("Int8List");
  C.Type_JSObject_8k0 = H.createRuntimeType("JSObject");
  C.Type_JsTypeVariableMirror_gT2 = H.createRuntimeType("JsTypeVariableMirror");
  C.Type_Null_Yyn = H.createRuntimeType("Null");
  C.Type_String_k8F = H.createRuntimeType("String");
  C.Type_Uint16List_2bx = H.createRuntimeType("Uint16List");
  C.Type_Uint32List_2bx = H.createRuntimeType("Uint32List");
  C.Type_Uint8ClampedList_Jik = H.createRuntimeType("Uint8ClampedList");
  C.Type_Uint8List_WLA = H.createRuntimeType("Uint8List");
  C.Type_bool_lhE = H.createRuntimeType("bool");
  C.Type_double_K1J = H.createRuntimeType("double");
  C.Type_dynamic_0Rz = H.createRuntimeType("dynamic");
  C.Type_int_tHn = H.createRuntimeType("int");
  C.Type_num_cv7 = H.createRuntimeType("num");
  C.Utf8Codec_false = new P.Utf8Codec(false);
  C.Utf8Decoder_false = new P.Utf8Decoder(false);
  C.ZLibCodec_kqe = new P.ZLibCodec(false, 6, 8, 0, 15, false, null);
  C._AuthenticationScheme_0 = new P._AuthenticationScheme(0);
  C._AuthenticationScheme_1 = new P._AuthenticationScheme(1);
  C._AuthenticationScheme_m1 = new P._AuthenticationScheme(-1);
  C._IterationMarker_null_2 = new P._IterationMarker(null, 2);
  C._Patch_full = new H._Patch("full");
  C._Patch_lazy = new H._Patch("lazy");
  C._Patch_null = new H._Patch(null);
  C._Patch_startup = new H._Patch("startup");
  C._ProxyConfiguration_8Zd = new P._ProxyConfiguration(C.List_jqP);
  C._ZoneFunction_3bB = new P._ZoneFunction(C.C__RootZone, P.async___rootCreatePeriodicTimer$closure(), [{func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, v: true, args: [P.Timer]}]}]);
  C._ZoneFunction_7G2 = new P._ZoneFunction(C.C__RootZone, P.async___rootRegisterBinaryCallback$closure(), [{func: 1, ret: {func: 1, args: [,,]}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,,]}]}]);
  C._ZoneFunction_Eeh = new P._ZoneFunction(C.C__RootZone, P.async___rootRegisterUnaryCallback$closure(), [{func: 1, ret: {func: 1, args: [,]}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,]}]}]);
  C._ZoneFunction_NMc = new P._ZoneFunction(C.C__RootZone, P.async___rootHandleUncaughtError$closure(), [{func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone,, P.StackTrace]}]);
  C._ZoneFunction__RootZone__rootCreateTimer = new P._ZoneFunction(C.C__RootZone, P.async___rootCreateTimer$closure(), [{func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, v: true}]}]);
  C._ZoneFunction__RootZone__rootErrorCallback = new P._ZoneFunction(C.C__RootZone, P.async___rootErrorCallback$closure(), [{func: 1, ret: P.AsyncError, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Object, P.StackTrace]}]);
  C._ZoneFunction__RootZone__rootFork = new P._ZoneFunction(C.C__RootZone, P.async___rootFork$closure(), [{func: 1, ret: P.Zone, args: [P.Zone, P.ZoneDelegate, P.Zone, P.ZoneSpecification, P.Map]}]);
  C._ZoneFunction__RootZone__rootPrint = new P._ZoneFunction(C.C__RootZone, P.async___rootPrint$closure(), [{func: 1, v: true, args: [P.Zone, P.ZoneDelegate, P.Zone, P.String]}]);
  C._ZoneFunction__RootZone__rootRegisterCallback = new P._ZoneFunction(C.C__RootZone, P.async___rootRegisterCallback$closure(), [{func: 1, ret: {func: 1}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1}]}]);
  C._ZoneFunction__RootZone__rootRun = new P._ZoneFunction(C.C__RootZone, P.async___rootRun$closure(), [{func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1}]}]);
  C._ZoneFunction__RootZone__rootRunBinary = new P._ZoneFunction(C.C__RootZone, P.async___rootRunBinary$closure(), [{func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,,]},,,]}]);
  C._ZoneFunction__RootZone__rootRunUnary = new P._ZoneFunction(C.C__RootZone, P.async___rootRunUnary$closure(), [{func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,]},,]}]);
  C._ZoneFunction__RootZone__rootScheduleMicrotask = new P._ZoneFunction(C.C__RootZone, P.async___rootScheduleMicrotask$closure(), [{func: 1, v: true, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, v: true}]}]);
  C._ZoneSpecification_ALf = new P._ZoneSpecification(null, null, null, null, null, null, null, null, null, null, null, null, null);
  $.printToZone = null;
  $.IsolateNatives_enableSpawnWorker = null;
  $.RawReceivePortImpl__nextFreeId = 1;
  $._traceBuffer = null;
  $.Primitives_mirrorFunctionCacheName = "$cachedFunction";
  $.Primitives_mirrorInvokeCacheName = "$cachedInvocation";
  $.Primitives_timerFrequency = null;
  $.Primitives_timerTicks = null;
  $.Closure_functionCounter = 0;
  $.BoundClosure_selfFieldNameCache = null;
  $.BoundClosure_receiverFieldNameCache = null;
  $._inTypeAssertion = false;
  $.deferredLoadHook = null;
  $.getTagFunction = null;
  $.alternateTagFunction = null;
  $.prototypeForTagFunction = null;
  $.dispatchRecordsForInstanceTags = null;
  $.interceptorsForUncacheableTags = null;
  $.initNativeDispatchFlag = null;
  $.JsMirrorSystem__librariesByName = null;
  $.JsMirrorSystem__hasInstalledDeferredLoadHook = false;
  $.classMirrors = null;
  $.counter = 0;
  $._BroadcastSubscription__STATE_EVENT_ID = 1;
  $._BroadcastSubscription__STATE_FIRING = 2;
  $._BroadcastSubscription__STATE_REMOVE_AFTER_FIRING = 4;
  $._BroadcastStreamController__STATE_INITIAL = 0;
  $._BroadcastStreamController__STATE_EVENT_ID = 1;
  $._BroadcastStreamController__STATE_FIRING = 2;
  $._BroadcastStreamController__STATE_CLOSED = 4;
  $._BroadcastStreamController__STATE_ADDSTREAM = 8;
  $._FutureListener_MASK_VALUE = 1;
  $._FutureListener_MASK_ERROR = 2;
  $._FutureListener_MASK_TEST_ERROR = 4;
  $._FutureListener_MASK_WHENCOMPLETE = 8;
  $._FutureListener_STATE_CHAIN = 0;
  $._FutureListener_STATE_THEN = 1;
  $._FutureListener_STATE_THEN_ONERROR = 3;
  $._FutureListener_STATE_CATCHERROR = 2;
  $._FutureListener_STATE_CATCHERROR_TEST = 6;
  $._FutureListener_STATE_WHENCOMPLETE = 8;
  $._Future__INCOMPLETE = 0;
  $._Future__PENDING_COMPLETE = 1;
  $._Future__CHAINED = 2;
  $._Future__VALUE = 4;
  $._Future__ERROR = 8;
  $._nextCallback = null;
  $._lastCallback = null;
  $._lastPriorityCallback = null;
  $._isInCallbackLoop = false;
  $._StreamController__STATE_INITIAL = 0;
  $._StreamController__STATE_SUBSCRIBED = 1;
  $._StreamController__STATE_CANCELED = 2;
  $._StreamController__STATE_SUBSCRIPTION_MASK = 3;
  $._StreamController__STATE_CLOSED = 4;
  $._StreamController__STATE_ADDSTREAM = 8;
  $._BufferingStreamSubscription__STATE_CANCEL_ON_ERROR = 1;
  $._BufferingStreamSubscription__STATE_CLOSED = 2;
  $._BufferingStreamSubscription__STATE_INPUT_PAUSED = 4;
  $._BufferingStreamSubscription__STATE_CANCELED = 8;
  $._BufferingStreamSubscription__STATE_WAIT_FOR_CANCEL = 16;
  $._BufferingStreamSubscription__STATE_IN_CALLBACK = 32;
  $._BufferingStreamSubscription__STATE_HAS_PENDING = 64;
  $._BufferingStreamSubscription__STATE_PAUSE_COUNT = 128;
  $._PendingEvents__STATE_UNSCHEDULED = 0;
  $._PendingEvents__STATE_SCHEDULED = 1;
  $._PendingEvents__STATE_CANCELED = 3;
  $._DoneStreamSubscription__DONE_SENT = 1;
  $._DoneStreamSubscription__SCHEDULED = 2;
  $._DoneStreamSubscription__PAUSED = 4;
  $.Zone_ROOT = C.C__RootZone;
  $.Zone__current = C.C__RootZone;
  $._RootZone__rootDelegate = null;
  $._ROOT_ZONE = C.C__RootZone;
  $.HasNextIterator__HAS_NEXT_AND_NEXT_IN_CURRENT = 0;
  $.HasNextIterator__NO_NEXT = 1;
  $.HasNextIterator__NOT_MOVED_YET = 2;
  $.ListQueue__INITIAL_CAPACITY = 8;
  $.ASCII = C.AsciiCodec_false;
  $._ASCII_MASK = 127;
  $.BASE64 = C.Base64Codec_Base64Encoder_false;
  $.BASE64URL = C.Base64Codec_Base64Encoder_true;
  $._paddingChar = 61;
  $._Base64Encoder__base64Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  $._Base64Encoder__base64urlAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
  $._Base64Encoder__valueShift = 2;
  $._Base64Encoder__countMask = 3;
  $._Base64Encoder__sixBitMask = 63;
  $._Base64Decoder__valueShift = 2;
  $._Base64Decoder__countMask = 3;
  $._Base64Decoder__invalid = -2;
  $._Base64Decoder__padding = -1;
  $._Base64Decoder___ = -2;
  $._Base64Decoder__p = -1;
  $._Base64Decoder__char_percent = 37;
  $._Base64Decoder__char_3 = 51;
  $._Base64Decoder__char_d = 100;
  $._ByteCallbackSink__INITIAL_BUFFER_SIZE = 1024;
  $.HTML_ESCAPE = C.HtmlEscape_gsm;
  $.HtmlEscapeMode_UNKNOWN = C.HtmlEscapeMode_p2v;
  $.HtmlEscapeMode_ATTRIBUTE = C.HtmlEscapeMode_0;
  $.HtmlEscapeMode_SQ_ATTRIBUTE = C.HtmlEscapeMode_00;
  $.HtmlEscapeMode_ELEMENT = C.HtmlEscapeMode_2oY;
  $.JSON = C.JsonCodec_null_null;
  $.JsonUtf8Encoder_DEFAULT_BUFFER_SIZE = 256;
  $._JsonStringifier_BACKSPACE = 8;
  $._JsonStringifier_TAB = 9;
  $._JsonStringifier_NEWLINE = 10;
  $._JsonStringifier_CARRIAGE_RETURN = 13;
  $._JsonStringifier_FORM_FEED = 12;
  $._JsonStringifier_QUOTE = 34;
  $._JsonStringifier_CHAR_0 = 48;
  $._JsonStringifier_BACKSLASH = 92;
  $._JsonStringifier_CHAR_b = 98;
  $._JsonStringifier_CHAR_f = 102;
  $._JsonStringifier_CHAR_n = 110;
  $._JsonStringifier_CHAR_r = 114;
  $._JsonStringifier_CHAR_t = 116;
  $._JsonStringifier_CHAR_u = 117;
  $.LATIN1 = C.Latin1Codec_false;
  $._LATIN1_MASK = 255;
  $._LF = 10;
  $._CR = 13;
  $._StringConversionSinkAsStringSinkAdapter__MIN_STRING_SIZE = 16;
  $.UNICODE_REPLACEMENT_CHARACTER_RUNE = 65533;
  $.UNICODE_BOM_CHARACTER_RUNE = 65279;
  $.UTF8 = C.Utf8Codec_false;
  $._Utf8Encoder__DEFAULT_BYTE_BUFFER_SIZE = 1024;
  $._ONE_BYTE_LIMIT = 127;
  $._TWO_BYTE_LIMIT = 2047;
  $._THREE_BYTE_LIMIT = 65535;
  $._FOUR_BYTE_LIMIT = 1114111;
  $._SURROGATE_MASK = 63488;
  $._SURROGATE_TAG_MASK = 64512;
  $._SURROGATE_VALUE_MASK = 1023;
  $._LEAD_SURROGATE_MIN = 55296;
  $._TAIL_SURROGATE_MIN = 56320;
  $._Utf8Decoder__LIMITS = C.List_127_2047_65535_1114111;
  $.Expando__EXPANDO_PROPERTY_NAME = "expando$values";
  $.Expando__keyCount = 0;
  $.deprecated = C.Deprecated_o8I;
  $.override = C.C__Override;
  $.proxy = C.C__Proxy;
  $.DateTime_MONDAY = 1;
  $.DateTime_TUESDAY = 2;
  $.DateTime_WEDNESDAY = 3;
  $.DateTime_THURSDAY = 4;
  $.DateTime_FRIDAY = 5;
  $.DateTime_SATURDAY = 6;
  $.DateTime_SUNDAY = 7;
  $.DateTime_DAYS_PER_WEEK = 7;
  $.DateTime_JANUARY = 1;
  $.DateTime_FEBRUARY = 2;
  $.DateTime_MARCH = 3;
  $.DateTime_APRIL = 4;
  $.DateTime_MAY = 5;
  $.DateTime_JUNE = 6;
  $.DateTime_JULY = 7;
  $.DateTime_AUGUST = 8;
  $.DateTime_SEPTEMBER = 9;
  $.DateTime_OCTOBER = 10;
  $.DateTime_NOVEMBER = 11;
  $.DateTime_DECEMBER = 12;
  $.DateTime_MONTHS_PER_YEAR = 12;
  $.DateTime__MAX_MILLISECONDS_SINCE_EPOCH = 864e13;
  $.double_NAN = 0 / 0;
  $.double_INFINITY = 1 / 0;
  $.double_NEGATIVE_INFINITY = -1 / 0;
  $.double_MIN_POSITIVE = 5e-324;
  $.double_MAX_FINITE = 17976931348623157e292;
  $.Duration_MICROSECONDS_PER_MILLISECOND = 1000;
  $.Duration_MILLISECONDS_PER_SECOND = 1000;
  $.Duration_SECONDS_PER_MINUTE = 60;
  $.Duration_MINUTES_PER_HOUR = 60;
  $.Duration_HOURS_PER_DAY = 24;
  $.Duration_MICROSECONDS_PER_SECOND = 1000000;
  $.Duration_MICROSECONDS_PER_MINUTE = 60000000;
  $.Duration_MICROSECONDS_PER_HOUR = 3600000000;
  $.Duration_MICROSECONDS_PER_DAY = 864e8;
  $.Duration_MILLISECONDS_PER_MINUTE = 60000;
  $.Duration_MILLISECONDS_PER_HOUR = 3600000;
  $.Duration_MILLISECONDS_PER_DAY = 86400000;
  $.Duration_SECONDS_PER_HOUR = 3600;
  $.Duration_SECONDS_PER_DAY = 86400;
  $.Duration_MINUTES_PER_DAY = 1440;
  $.Duration_ZERO = C.Duration_0;
  $.Stopwatch__frequency = null;
  $._SPACE = 32;
  $._PERCENT = 37;
  $._AMPERSAND = 38;
  $._PLUS = 43;
  $._DOT = 46;
  $._SLASH = 47;
  $._COLON = 58;
  $._EQUALS = 61;
  $._UPPER_CASE_A = 65;
  $._UPPER_CASE_Z = 90;
  $._LEFT_BRACKET = 91;
  $._BACKSLASH = 92;
  $._RIGHT_BRACKET = 93;
  $._LOWER_CASE_A = 97;
  $._LOWER_CASE_F = 102;
  $._LOWER_CASE_Z = 122;
  $._hexDigits = "0123456789ABCDEF";
  $._Uri__unreservedTable = C.List_nxB;
  $._Uri__unreserved2396Table = C.List_KIf;
  $._Uri__encodeFullTable = C.List_gnE;
  $._Uri__schemeTable = C.List_JYB;
  $._Uri__schemeLowerTable = C.List_6Pr;
  $._Uri__subDelimitersTable = C.List_axv;
  $._Uri__genDelimitersTable = C.List_2Vk;
  $._Uri__userinfoTable = C.List_gRj;
  $._Uri__regNameTable = C.List_qNA;
  $._Uri__pathCharTable = C.List_qg40;
  $._Uri__pathCharOrSlashTable = C.List_qg4;
  $._Uri__queryCharTable = C.List_CVk;
  $.UriData__noScheme = -1;
  $.UriData__tokenCharTable = C.List_qFt;
  $.UriData__uricTable = C.List_CVk;
  $.UriData__base64Table = C.List_JYB0;
  $._schemeEndIndex = 1;
  $._hostStartIndex = 2;
  $._portStartIndex = 3;
  $._pathStartIndex = 4;
  $._queryStartIndex = 5;
  $._fragmentStartIndex = 6;
  $._notSimpleIndex = 7;
  $._uriStart = 0;
  $._nonSimpleEndStates = 14;
  $._schemeStart = 20;
  $._clockValue = 0;
  $.ServiceExtensionResponse_kInvalidParams = -32602;
  $.ServiceExtensionResponse_kExtensionError = -32000;
  $.ServiceExtensionResponse_kExtensionErrorMax = -32000;
  $.ServiceExtensionResponse_kExtensionErrorMin = -32016;
  $.ServiceExtensionResponse_invalidParams = -32602;
  $.ServiceExtensionResponse_extensionError = -32000;
  $.ServiceExtensionResponse_extensionErrorMax = -32000;
  $.ServiceExtensionResponse_extensionErrorMin = -32016;
  $.UserTag_MAX_USER_TAGS = 64;
  $._isProduct = false;
  $._fastPathArguments = null;
  $._CopyingBytesBuilder__INIT_SIZE = 1024;
  $._SUCCESS_RESPONSE = 0;
  $._ILLEGAL_ARGUMENT_RESPONSE = 1;
  $._OSERROR_RESPONSE = 2;
  $._FILE_CLOSED_RESPONSE = 3;
  $._ERROR_RESPONSE_ERROR_TYPE = 0;
  $._OSERROR_RESPONSE_ERROR_CODE = 1;
  $._OSERROR_RESPONSE_MESSAGE = 2;
  $.OSError_noErrorCode = -1;
  $._CryptoUtils_PAD = 61;
  $._CryptoUtils_CR = 13;
  $._CryptoUtils_LF = 10;
  $._CryptoUtils_LINE_LENGTH = 76;
  $._CryptoUtils__encodeTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  $._CryptoUtils__encodeTableUrlSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
  $._CryptoUtils__decodeTable = C.List_q3m;
  $._MASK_8 = 255;
  $._MASK_32 = 4294967295;
  $._BITS_PER_BYTE = 8;
  $._BYTES_PER_WORD = 4;
  $._MD5__k = C.List_yzJ;
  $._MD5__r = C.List_kcl;
  $.ZLibOption_MIN_WINDOW_BITS = 8;
  $.ZLibOption_MAX_WINDOW_BITS = 15;
  $.ZLibOption_DEFAULT_WINDOW_BITS = 15;
  $.ZLibOption_MIN_LEVEL = -1;
  $.ZLibOption_MAX_LEVEL = 9;
  $.ZLibOption_DEFAULT_LEVEL = 6;
  $.ZLibOption_MIN_MEM_LEVEL = 1;
  $.ZLibOption_MAX_MEM_LEVEL = 9;
  $.ZLibOption_DEFAULT_MEM_LEVEL = 8;
  $.ZLibOption_STRATEGY_FILTERED = 1;
  $.ZLibOption_STRATEGY_HUFFMAN_ONLY = 2;
  $.ZLibOption_STRATEGY_RLE = 3;
  $.ZLibOption_STRATEGY_FIXED = 4;
  $.ZLibOption_STRATEGY_DEFAULT = 0;
  $.ZLIB = C.ZLibCodec_kqe;
  $.GZIP = C.GZipCodec_yXb;
  $._AsyncDirectoryLister_LIST_FILE = 0;
  $._AsyncDirectoryLister_LIST_DIRECTORY = 1;
  $._AsyncDirectoryLister_LIST_LINK = 2;
  $._AsyncDirectoryLister_LIST_ERROR = 3;
  $._AsyncDirectoryLister_LIST_DONE = 4;
  $._AsyncDirectoryLister_RESPONSE_TYPE = 0;
  $._AsyncDirectoryLister_RESPONSE_PATH = 1;
  $._AsyncDirectoryLister_RESPONSE_COMPLETE = 1;
  $._AsyncDirectoryLister_RESPONSE_ERROR = 2;
  $.FileMode_READ = C.FileMode_0;
  $.FileMode_WRITE = C.FileMode_1;
  $.FileMode_APPEND = C.FileMode_2;
  $.FileMode_WRITE_ONLY = C.FileMode_3;
  $.FileMode_WRITE_ONLY_APPEND = C.FileMode_4;
  $.READ = C.FileMode_0;
  $.WRITE = C.FileMode_1;
  $.APPEND = C.FileMode_2;
  $.WRITE_ONLY = C.FileMode_3;
  $.WRITE_ONLY_APPEND = C.FileMode_4;
  $.FileLock_values = C.List_uQj;
  $.FileLock_SHARED = C.FileLock_0;
  $.FileLock_EXCLUSIVE = C.FileLock_1;
  $.FileLock_BLOCKING_SHARED = C.FileLock_2;
  $.FileLock_BLOCKING_EXCLUSIVE = C.FileLock_3;
  $._BLOCK_SIZE = 65536;
  $._RandomAccessFile__connectedResourceHandler = false;
  $.FileSystemEntityType_FILE = C.FileSystemEntityType_0;
  $.FileSystemEntityType_DIRECTORY = C.FileSystemEntityType_1;
  $.FileSystemEntityType_LINK = C.FileSystemEntityType_2;
  $.FileSystemEntityType_NOT_FOUND = C.FileSystemEntityType_3;
  $.FileSystemEntityType__typeList = C.List_CpJ;
  $.FileStat__TYPE = 0;
  $.FileStat__CHANGED_TIME = 1;
  $.FileStat__MODIFIED_TIME = 2;
  $.FileStat__ACCESSED_TIME = 3;
  $.FileStat__MODE = 4;
  $.FileStat__SIZE = 5;
  $.FileStat__notFound = C.FileStat_8qt;
  $.FileSystemEvent_CREATE = 1;
  $.FileSystemEvent_MODIFY = 2;
  $.FileSystemEvent_DELETE = 4;
  $.FileSystemEvent_MOVE = 8;
  $.FileSystemEvent_ALL = 15;
  $.FileSystemEvent__MODIFY_ATTRIBUTES = 16;
  $.FileSystemEvent__DELETE_SELF = 32;
  $.FileSystemEvent__IS_DIR = 64;
  $.HttpStatus_CONTINUE = 100;
  $.HttpStatus_SWITCHING_PROTOCOLS = 101;
  $.HttpStatus_OK = 200;
  $.HttpStatus_CREATED = 201;
  $.HttpStatus_ACCEPTED = 202;
  $.HttpStatus_NON_AUTHORITATIVE_INFORMATION = 203;
  $.HttpStatus_NO_CONTENT = 204;
  $.HttpStatus_RESET_CONTENT = 205;
  $.HttpStatus_PARTIAL_CONTENT = 206;
  $.HttpStatus_MULTIPLE_CHOICES = 300;
  $.HttpStatus_MOVED_PERMANENTLY = 301;
  $.HttpStatus_FOUND = 302;
  $.HttpStatus_MOVED_TEMPORARILY = 302;
  $.HttpStatus_SEE_OTHER = 303;
  $.HttpStatus_NOT_MODIFIED = 304;
  $.HttpStatus_USE_PROXY = 305;
  $.HttpStatus_TEMPORARY_REDIRECT = 307;
  $.HttpStatus_BAD_REQUEST = 400;
  $.HttpStatus_UNAUTHORIZED = 401;
  $.HttpStatus_PAYMENT_REQUIRED = 402;
  $.HttpStatus_FORBIDDEN = 403;
  $.HttpStatus_NOT_FOUND = 404;
  $.HttpStatus_METHOD_NOT_ALLOWED = 405;
  $.HttpStatus_NOT_ACCEPTABLE = 406;
  $.HttpStatus_PROXY_AUTHENTICATION_REQUIRED = 407;
  $.HttpStatus_REQUEST_TIMEOUT = 408;
  $.HttpStatus_CONFLICT = 409;
  $.HttpStatus_GONE = 410;
  $.HttpStatus_LENGTH_REQUIRED = 411;
  $.HttpStatus_PRECONDITION_FAILED = 412;
  $.HttpStatus_REQUEST_ENTITY_TOO_LARGE = 413;
  $.HttpStatus_REQUEST_URI_TOO_LONG = 414;
  $.HttpStatus_UNSUPPORTED_MEDIA_TYPE = 415;
  $.HttpStatus_REQUESTED_RANGE_NOT_SATISFIABLE = 416;
  $.HttpStatus_EXPECTATION_FAILED = 417;
  $.HttpStatus_INTERNAL_SERVER_ERROR = 500;
  $.HttpStatus_NOT_IMPLEMENTED = 501;
  $.HttpStatus_BAD_GATEWAY = 502;
  $.HttpStatus_SERVICE_UNAVAILABLE = 503;
  $.HttpStatus_GATEWAY_TIMEOUT = 504;
  $.HttpStatus_HTTP_VERSION_NOT_SUPPORTED = 505;
  $.HttpStatus_NETWORK_CONNECT_TIMEOUT_ERROR = 599;
  $.HttpHeaders_ACCEPT = "accept";
  $.HttpHeaders_ACCEPT_CHARSET = "accept-charset";
  $.HttpHeaders_ACCEPT_ENCODING = "accept-encoding";
  $.HttpHeaders_ACCEPT_LANGUAGE = "accept-language";
  $.HttpHeaders_ACCEPT_RANGES = "accept-ranges";
  $.HttpHeaders_AGE = "age";
  $.HttpHeaders_ALLOW = "allow";
  $.HttpHeaders_AUTHORIZATION = "authorization";
  $.HttpHeaders_CACHE_CONTROL = "cache-control";
  $.HttpHeaders_CONNECTION = "connection";
  $.HttpHeaders_CONTENT_ENCODING = "content-encoding";
  $.HttpHeaders_CONTENT_LANGUAGE = "content-language";
  $.HttpHeaders_CONTENT_LENGTH = "content-length";
  $.HttpHeaders_CONTENT_LOCATION = "content-location";
  $.HttpHeaders_CONTENT_MD5 = "content-md5";
  $.HttpHeaders_CONTENT_RANGE = "content-range";
  $.HttpHeaders_CONTENT_TYPE = "content-type";
  $.HttpHeaders_DATE = "date";
  $.HttpHeaders_ETAG = "etag";
  $.HttpHeaders_EXPECT = "expect";
  $.HttpHeaders_EXPIRES = "expires";
  $.HttpHeaders_FROM = "from";
  $.HttpHeaders_HOST = "host";
  $.HttpHeaders_IF_MATCH = "if-match";
  $.HttpHeaders_IF_MODIFIED_SINCE = "if-modified-since";
  $.HttpHeaders_IF_NONE_MATCH = "if-none-match";
  $.HttpHeaders_IF_RANGE = "if-range";
  $.HttpHeaders_IF_UNMODIFIED_SINCE = "if-unmodified-since";
  $.HttpHeaders_LAST_MODIFIED = "last-modified";
  $.HttpHeaders_LOCATION = "location";
  $.HttpHeaders_MAX_FORWARDS = "max-forwards";
  $.HttpHeaders_PRAGMA = "pragma";
  $.HttpHeaders_PROXY_AUTHENTICATE = "proxy-authenticate";
  $.HttpHeaders_PROXY_AUTHORIZATION = "proxy-authorization";
  $.HttpHeaders_RANGE = "range";
  $.HttpHeaders_REFERER = "referer";
  $.HttpHeaders_RETRY_AFTER = "retry-after";
  $.HttpHeaders_SERVER = "server";
  $.HttpHeaders_TE = "te";
  $.HttpHeaders_TRAILER = "trailer";
  $.HttpHeaders_TRANSFER_ENCODING = "transfer-encoding";
  $.HttpHeaders_UPGRADE = "upgrade";
  $.HttpHeaders_USER_AGENT = "user-agent";
  $.HttpHeaders_VARY = "vary";
  $.HttpHeaders_VIA = "via";
  $.HttpHeaders_WARNING = "warning";
  $.HttpHeaders_WWW_AUTHENTICATE = "www-authenticate";
  $.HttpHeaders_COOKIE = "cookie";
  $.HttpHeaders_SET_COOKIE = "set-cookie";
  $.HttpHeaders_GENERAL_HEADERS = C.List_fld;
  $.HttpHeaders_ENTITY_HEADERS = C.List_MYA;
  $.HttpHeaders_RESPONSE_HEADERS = C.List_nfu;
  $.HttpHeaders_REQUEST_HEADERS = C.List_Rop;
  $.HttpClient_DEFAULT_HTTP_PORT = 80;
  $.HttpClient_DEFAULT_HTTPS_PORT = 443;
  $._OUTGOING_BUFFER_SIZE = 8192;
  $._HttpOutgoing__footerAndChunk0Length = C.List_E7y;
  $._HttpOutgoing__chunk0Length = C.List_yTu;
  $._HttpConnection__ACTIVE = 0;
  $._HttpConnection__IDLE = 1;
  $._HttpConnection__CLOSING = 2;
  $._HttpConnection__DETACHED = 3;
  $._ProxyConfiguration_PROXY_PREFIX = "PROXY ";
  $._ProxyConfiguration_DIRECT_PREFIX = "DIRECT";
  $._AuthenticationScheme_UNKNOWN = C._AuthenticationScheme_m1;
  $._AuthenticationScheme_BASIC = C._AuthenticationScheme_0;
  $._AuthenticationScheme_DIGEST = C._AuthenticationScheme_1;
  $._Const_HTTP = C.List_72_84_84_80;
  $._Const_HTTP1DOT = C.List_E7y0;
  $._Const_HTTP10 = C.List_2Vk1;
  $._Const_HTTP11 = C.List_2Vk0;
  $._Const_T = true;
  $._Const_F = false;
  $._Const_SEPARATOR_MAP = C.List_NUU;
  $._CharCode_HT = 9;
  $._CharCode_LF = 10;
  $._CharCode_CR = 13;
  $._CharCode_SP = 32;
  $._CharCode_AMPERSAND = 38;
  $._CharCode_COMMA = 44;
  $._CharCode_DASH = 45;
  $._CharCode_SLASH = 47;
  $._CharCode_ZERO = 48;
  $._CharCode_ONE = 49;
  $._CharCode_COLON = 58;
  $._CharCode_SEMI_COLON = 59;
  $._CharCode_EQUAL = 61;
  $._State_START = 0;
  $._State_METHOD_OR_RESPONSE_HTTP_VERSION = 1;
  $._State_RESPONSE_HTTP_VERSION = 2;
  $._State_REQUEST_LINE_METHOD = 3;
  $._State_REQUEST_LINE_URI = 4;
  $._State_REQUEST_LINE_HTTP_VERSION = 5;
  $._State_REQUEST_LINE_ENDING = 6;
  $._State_RESPONSE_LINE_STATUS_CODE = 7;
  $._State_RESPONSE_LINE_REASON_PHRASE = 8;
  $._State_RESPONSE_LINE_ENDING = 9;
  $._State_HEADER_START = 10;
  $._State_HEADER_FIELD = 11;
  $._State_HEADER_VALUE_START = 12;
  $._State_HEADER_VALUE = 13;
  $._State_HEADER_VALUE_FOLDING_OR_ENDING = 14;
  $._State_HEADER_VALUE_FOLD_OR_END = 15;
  $._State_HEADER_ENDING = 16;
  $._State_CHUNK_SIZE_STARTING_CR = 17;
  $._State_CHUNK_SIZE_STARTING_LF = 18;
  $._State_CHUNK_SIZE = 19;
  $._State_CHUNK_SIZE_EXTENSION = 20;
  $._State_CHUNK_SIZE_ENDING = 21;
  $._State_CHUNKED_BODY_DONE_CR = 22;
  $._State_CHUNKED_BODY_DONE_LF = 23;
  $._State_BODY = 24;
  $._State_CLOSED = 25;
  $._State_UPGRADED = 26;
  $._State_FAILURE = 27;
  $._State_FIRST_BODY_STATE = 17;
  $._HttpVersion_UNDETERMINED = 0;
  $._HttpVersion_HTTP10 = 1;
  $._HttpVersion_HTTP11 = 2;
  $._MessageType_UNDETERMINED = 0;
  $._MessageType_REQUEST = 1;
  $._MessageType_RESPONSE = 0;
  $._DART_SESSION_ID = "DARTSESSID";
  $._IOResourceInfo__count = 0;
  $._FileResourceInfo_TYPE = "_file";
  $._ProcessResourceInfo_TYPE = "_process";
  $._SocketResourceInfo_TCP_STRING = "TCP";
  $._SocketResourceInfo_UDP_STRING = "UDP";
  $._SocketResourceInfo_TYPE = "_socket";
  $._FILE_EXISTS = 0;
  $._FILE_CREATE = 1;
  $._FILE_DELETE = 2;
  $._FILE_RENAME = 3;
  $._FILE_COPY = 4;
  $._FILE_OPEN = 5;
  $._FILE_RESOLVE_SYMBOLIC_LINKS = 6;
  $._FILE_CLOSE = 7;
  $._FILE_POSITION = 8;
  $._FILE_SET_POSITION = 9;
  $._FILE_TRUNCATE = 10;
  $._FILE_LENGTH = 11;
  $._FILE_LENGTH_FROM_PATH = 12;
  $._FILE_LAST_ACCESSED = 13;
  $._FILE_SET_LAST_ACCESSED = 14;
  $._FILE_LAST_MODIFIED = 15;
  $._FILE_SET_LAST_MODIFIED = 16;
  $._FILE_FLUSH = 17;
  $._FILE_READ_BYTE = 18;
  $._FILE_WRITE_BYTE = 19;
  $._FILE_READ = 20;
  $._FILE_READ_INTO = 21;
  $._FILE_WRITE_FROM = 22;
  $._FILE_CREATE_LINK = 23;
  $._FILE_DELETE_LINK = 24;
  $._FILE_RENAME_LINK = 25;
  $._FILE_LINK_TARGET = 26;
  $._FILE_TYPE = 27;
  $._FILE_IDENTICAL = 28;
  $._FILE_STAT = 29;
  $._FILE_LOCK = 30;
  $._SOCKET_LOOKUP = 31;
  $._SOCKET_LIST_INTERFACES = 32;
  $._SOCKET_REVERSE_LOOKUP = 33;
  $._DIRECTORY_CREATE = 34;
  $._DIRECTORY_DELETE = 35;
  $._DIRECTORY_EXISTS = 36;
  $._DIRECTORY_CREATE_TEMP = 37;
  $._DIRECTORY_LIST_START = 38;
  $._DIRECTORY_LIST_NEXT = 39;
  $._DIRECTORY_LIST_STOP = 40;
  $._DIRECTORY_RENAME = 41;
  $._SSL_PROCESS_FILTER = 42;
  $._Platform__environmentCache = null;
  $._Platform_script = null;
  $.ProcessStartMode_values = C.List_w61;
  $.ProcessStartMode_NORMAL = C.ProcessStartMode_0;
  $.ProcessStartMode_DETACHED = C.ProcessStartMode_1;
  $.ProcessStartMode_DETACHED_WITH_STDIO = C.ProcessStartMode_2;
  $.ProcessSignal_SIGHUP = C.ProcessSignal_1_SIGHUP;
  $.ProcessSignal_SIGINT = C.ProcessSignal_2_SIGINT;
  $.ProcessSignal_SIGQUIT = C.ProcessSignal_3_SIGQUIT;
  $.ProcessSignal_SIGILL = C.ProcessSignal_4_SIGILL;
  $.ProcessSignal_SIGTRAP = C.ProcessSignal_5_SIGTRAP;
  $.ProcessSignal_SIGABRT = C.ProcessSignal_6_SIGABRT;
  $.ProcessSignal_SIGBUS = C.ProcessSignal_7_SIGBUS;
  $.ProcessSignal_SIGFPE = C.ProcessSignal_8_SIGFPE;
  $.ProcessSignal_SIGKILL = C.ProcessSignal_9_SIGKILL;
  $.ProcessSignal_SIGUSR1 = C.ProcessSignal_10_SIGUSR1;
  $.ProcessSignal_SIGSEGV = C.ProcessSignal_11_SIGSEGV;
  $.ProcessSignal_SIGUSR2 = C.ProcessSignal_12_SIGUSR2;
  $.ProcessSignal_SIGPIPE = C.ProcessSignal_13_SIGPIPE;
  $.ProcessSignal_SIGALRM = C.ProcessSignal_14_SIGALRM;
  $.ProcessSignal_SIGTERM = C.ProcessSignal_15_SIGTERM;
  $.ProcessSignal_SIGCHLD = C.ProcessSignal_17_SIGCHLD;
  $.ProcessSignal_SIGCONT = C.ProcessSignal_18_SIGCONT;
  $.ProcessSignal_SIGSTOP = C.ProcessSignal_19_SIGSTOP;
  $.ProcessSignal_SIGTSTP = C.ProcessSignal_20_SIGTSTP;
  $.ProcessSignal_SIGTTIN = C.ProcessSignal_21_SIGTTIN;
  $.ProcessSignal_SIGTTOU = C.ProcessSignal_22_SIGTTOU;
  $.ProcessSignal_SIGURG = C.ProcessSignal_23_SIGURG;
  $.ProcessSignal_SIGXCPU = C.ProcessSignal_24_SIGXCPU;
  $.ProcessSignal_SIGXFSZ = C.ProcessSignal_25_SIGXFSZ;
  $.ProcessSignal_SIGVTALRM = C.ProcessSignal_26_SIGVTALRM;
  $.ProcessSignal_SIGPROF = C.ProcessSignal_27_SIGPROF;
  $.ProcessSignal_SIGWINCH = C.ProcessSignal_28_SIGWINCH;
  $.ProcessSignal_SIGPOLL = C.ProcessSignal_29_SIGPOLL;
  $.ProcessSignal_SIGSYS = C.ProcessSignal_31_SIGSYS;
  $._nextServiceId = 1;
  $.InternetAddressType_IP_V4 = C.InternetAddressType_0;
  $.InternetAddressType_IP_V6 = C.InternetAddressType_1;
  $.InternetAddressType_ANY = C.InternetAddressType_m1;
  $.SocketDirection_RECEIVE = C.SocketDirection_0;
  $.SocketDirection_SEND = C.SocketDirection_1;
  $.SocketDirection_BOTH = C.SocketDirection_2;
  $.SocketOption_TCP_NODELAY = C.SocketOption_0;
  $.SocketOption__IP_MULTICAST_LOOP = C.SocketOption_1;
  $.SocketOption__IP_MULTICAST_HOPS = C.SocketOption_2;
  $.SocketOption__IP_MULTICAST_IF = C.SocketOption_3;
  $.SocketOption__IP_BROADCAST = C.SocketOption_4;
  $.RawSocketEvent_READ = C.RawSocketEvent_0;
  $.RawSocketEvent_WRITE = C.RawSocketEvent_1;
  $.RawSocketEvent_READ_CLOSED = C.RawSocketEvent_2;
  $.RawSocketEvent_CLOSED = C.RawSocketEvent_3;
  $._STDIO_HANDLE_TYPE_TERMINAL = 0;
  $._STDIO_HANDLE_TYPE_PIPE = 1;
  $._STDIO_HANDLE_TYPE_FILE = 2;
  $._STDIO_HANDLE_TYPE_SOCKET = 3;
  $._STDIO_HANDLE_TYPE_OTHER = 4;
  $.StdioType_TERMINAL = C.StdioType_terminal;
  $.StdioType_PIPE = C.StdioType_pipe;
  $.StdioType_FILE = C.StdioType_file;
  $.StdioType_OTHER = C.StdioType_other;
  $._stdin = null;
  $._stdout = null;
  $._stderr = null;
  $.SYSTEM_ENCODING = C.C_SystemEncoding;
  $.WebSocketStatus_NORMAL_CLOSURE = 1000;
  $.WebSocketStatus_GOING_AWAY = 1001;
  $.WebSocketStatus_PROTOCOL_ERROR = 1002;
  $.WebSocketStatus_UNSUPPORTED_DATA = 1003;
  $.WebSocketStatus_RESERVED_1004 = 1004;
  $.WebSocketStatus_NO_STATUS_RECEIVED = 1005;
  $.WebSocketStatus_ABNORMAL_CLOSURE = 1006;
  $.WebSocketStatus_INVALID_FRAME_PAYLOAD_DATA = 1007;
  $.WebSocketStatus_POLICY_VIOLATION = 1008;
  $.WebSocketStatus_MESSAGE_TOO_BIG = 1009;
  $.WebSocketStatus_MISSING_MANDATORY_EXTENSION = 1010;
  $.WebSocketStatus_INTERNAL_SERVER_ERROR = 1011;
  $.WebSocketStatus_RESERVED_1015 = 1015;
  $.CompressionOptions_DEFAULT = C.CompressionOptions_qty;
  $.CompressionOptions_OFF = C.CompressionOptions_qty0;
  $.WebSocket_CONNECTING = 0;
  $.WebSocket_OPEN = 1;
  $.WebSocket_CLOSING = 2;
  $.WebSocket_CLOSED = 3;
  $._webSocketGUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
  $._clientNoContextTakeover = "client_no_context_takeover";
  $._serverNoContextTakeover = "server_no_context_takeover";
  $._clientMaxWindowBits = "client_max_window_bits";
  $._serverMaxWindowBits = "server_max_window_bits";
  $._WebSocketMessageType_NONE = 0;
  $._WebSocketMessageType_TEXT = 1;
  $._WebSocketMessageType_BINARY = 2;
  $._WebSocketOpcode_CONTINUATION = 0;
  $._WebSocketOpcode_TEXT = 1;
  $._WebSocketOpcode_BINARY = 2;
  $._WebSocketOpcode_RESERVED_3 = 3;
  $._WebSocketOpcode_RESERVED_4 = 4;
  $._WebSocketOpcode_RESERVED_5 = 5;
  $._WebSocketOpcode_RESERVED_6 = 6;
  $._WebSocketOpcode_RESERVED_7 = 7;
  $._WebSocketOpcode_CLOSE = 8;
  $._WebSocketOpcode_PING = 9;
  $._WebSocketOpcode_PONG = 10;
  $._WebSocketOpcode_RESERVED_B = 11;
  $._WebSocketOpcode_RESERVED_C = 12;
  $._WebSocketOpcode_RESERVED_D = 13;
  $._WebSocketOpcode_RESERVED_E = 14;
  $._WebSocketOpcode_RESERVED_F = 15;
  $._WebSocketProtocolTransformer_START = 0;
  $._WebSocketProtocolTransformer_LEN_FIRST = 1;
  $._WebSocketProtocolTransformer_LEN_REST = 2;
  $._WebSocketProtocolTransformer_MASK = 3;
  $._WebSocketProtocolTransformer_PAYLOAD = 4;
  $._WebSocketProtocolTransformer_CLOSED = 5;
  $._WebSocketProtocolTransformer_FAILURE = 6;
  $._WebSocketProtocolTransformer_FIN = 128;
  $._WebSocketProtocolTransformer_RSV1 = 64;
  $._WebSocketProtocolTransformer_RSV2 = 32;
  $._WebSocketProtocolTransformer_RSV3 = 16;
  $._WebSocketProtocolTransformer_OPCODE = 15;
  $._WebSocketImpl_DEFAULT_WINDOW_BITS = 15;
  $._WebSocketImpl_PER_MESSAGE_DEFLATE = "permessage-deflate";
  $.Isolate_IMMEDIATE = 0;
  $.Isolate_BEFORE_NEXT_EVENT = 1;
  $.E = 2.718281828459045;
  $.LN10 = 2.302585092994046;
  $.LN2 = 0.6931471805599453;
  $.LOG2E = 1.4426950408889634;
  $.LOG10E = 0.4342944819032518;
  $.PI = 3.141592653589793;
  $.SQRT1_2 = 0.7071067811865476;
  $.SQRT2 = 1.4142135623730951;
  $.Endianness_BIG_ENDIAN = C.Endianness_false;
  $.Endianness_LITTLE_ENDIAN = C.Endianness_true;
  $.Int8List_BYTES_PER_ELEMENT = 1;
  $.Uint8List_BYTES_PER_ELEMENT = 1;
  $.Uint8ClampedList_BYTES_PER_ELEMENT = 1;
  $.Int16List_BYTES_PER_ELEMENT = 2;
  $.Uint16List_BYTES_PER_ELEMENT = 2;
  $.Int32List_BYTES_PER_ELEMENT = 4;
  $.Uint32List_BYTES_PER_ELEMENT = 4;
  $.Int64List_BYTES_PER_ELEMENT = 8;
  $.Uint64List_BYTES_PER_ELEMENT = 8;
  $.Float32List_BYTES_PER_ELEMENT = 4;
  $.Float64List_BYTES_PER_ELEMENT = 8;
  $.Float32x4List_BYTES_PER_ELEMENT = 16;
  $.Int32x4List_BYTES_PER_ELEMENT = 16;
  $.Float64x2List_BYTES_PER_ELEMENT = 16;
  $.Float32x4_XXXX = 0;
  $.Float32x4_XXXY = 64;
  $.Float32x4_XXXZ = 128;
  $.Float32x4_XXXW = 192;
  $.Float32x4_XXYX = 16;
  $.Float32x4_XXYY = 80;
  $.Float32x4_XXYZ = 144;
  $.Float32x4_XXYW = 208;
  $.Float32x4_XXZX = 32;
  $.Float32x4_XXZY = 96;
  $.Float32x4_XXZZ = 160;
  $.Float32x4_XXZW = 224;
  $.Float32x4_XXWX = 48;
  $.Float32x4_XXWY = 112;
  $.Float32x4_XXWZ = 176;
  $.Float32x4_XXWW = 240;
  $.Float32x4_XYXX = 4;
  $.Float32x4_XYXY = 68;
  $.Float32x4_XYXZ = 132;
  $.Float32x4_XYXW = 196;
  $.Float32x4_XYYX = 20;
  $.Float32x4_XYYY = 84;
  $.Float32x4_XYYZ = 148;
  $.Float32x4_XYYW = 212;
  $.Float32x4_XYZX = 36;
  $.Float32x4_XYZY = 100;
  $.Float32x4_XYZZ = 164;
  $.Float32x4_XYZW = 228;
  $.Float32x4_XYWX = 52;
  $.Float32x4_XYWY = 116;
  $.Float32x4_XYWZ = 180;
  $.Float32x4_XYWW = 244;
  $.Float32x4_XZXX = 8;
  $.Float32x4_XZXY = 72;
  $.Float32x4_XZXZ = 136;
  $.Float32x4_XZXW = 200;
  $.Float32x4_XZYX = 24;
  $.Float32x4_XZYY = 88;
  $.Float32x4_XZYZ = 152;
  $.Float32x4_XZYW = 216;
  $.Float32x4_XZZX = 40;
  $.Float32x4_XZZY = 104;
  $.Float32x4_XZZZ = 168;
  $.Float32x4_XZZW = 232;
  $.Float32x4_XZWX = 56;
  $.Float32x4_XZWY = 120;
  $.Float32x4_XZWZ = 184;
  $.Float32x4_XZWW = 248;
  $.Float32x4_XWXX = 12;
  $.Float32x4_XWXY = 76;
  $.Float32x4_XWXZ = 140;
  $.Float32x4_XWXW = 204;
  $.Float32x4_XWYX = 28;
  $.Float32x4_XWYY = 92;
  $.Float32x4_XWYZ = 156;
  $.Float32x4_XWYW = 220;
  $.Float32x4_XWZX = 44;
  $.Float32x4_XWZY = 108;
  $.Float32x4_XWZZ = 172;
  $.Float32x4_XWZW = 236;
  $.Float32x4_XWWX = 60;
  $.Float32x4_XWWY = 124;
  $.Float32x4_XWWZ = 188;
  $.Float32x4_XWWW = 252;
  $.Float32x4_YXXX = 1;
  $.Float32x4_YXXY = 65;
  $.Float32x4_YXXZ = 129;
  $.Float32x4_YXXW = 193;
  $.Float32x4_YXYX = 17;
  $.Float32x4_YXYY = 81;
  $.Float32x4_YXYZ = 145;
  $.Float32x4_YXYW = 209;
  $.Float32x4_YXZX = 33;
  $.Float32x4_YXZY = 97;
  $.Float32x4_YXZZ = 161;
  $.Float32x4_YXZW = 225;
  $.Float32x4_YXWX = 49;
  $.Float32x4_YXWY = 113;
  $.Float32x4_YXWZ = 177;
  $.Float32x4_YXWW = 241;
  $.Float32x4_YYXX = 5;
  $.Float32x4_YYXY = 69;
  $.Float32x4_YYXZ = 133;
  $.Float32x4_YYXW = 197;
  $.Float32x4_YYYX = 21;
  $.Float32x4_YYYY = 85;
  $.Float32x4_YYYZ = 149;
  $.Float32x4_YYYW = 213;
  $.Float32x4_YYZX = 37;
  $.Float32x4_YYZY = 101;
  $.Float32x4_YYZZ = 165;
  $.Float32x4_YYZW = 229;
  $.Float32x4_YYWX = 53;
  $.Float32x4_YYWY = 117;
  $.Float32x4_YYWZ = 181;
  $.Float32x4_YYWW = 245;
  $.Float32x4_YZXX = 9;
  $.Float32x4_YZXY = 73;
  $.Float32x4_YZXZ = 137;
  $.Float32x4_YZXW = 201;
  $.Float32x4_YZYX = 25;
  $.Float32x4_YZYY = 89;
  $.Float32x4_YZYZ = 153;
  $.Float32x4_YZYW = 217;
  $.Float32x4_YZZX = 41;
  $.Float32x4_YZZY = 105;
  $.Float32x4_YZZZ = 169;
  $.Float32x4_YZZW = 233;
  $.Float32x4_YZWX = 57;
  $.Float32x4_YZWY = 121;
  $.Float32x4_YZWZ = 185;
  $.Float32x4_YZWW = 249;
  $.Float32x4_YWXX = 13;
  $.Float32x4_YWXY = 77;
  $.Float32x4_YWXZ = 141;
  $.Float32x4_YWXW = 205;
  $.Float32x4_YWYX = 29;
  $.Float32x4_YWYY = 93;
  $.Float32x4_YWYZ = 157;
  $.Float32x4_YWYW = 221;
  $.Float32x4_YWZX = 45;
  $.Float32x4_YWZY = 109;
  $.Float32x4_YWZZ = 173;
  $.Float32x4_YWZW = 237;
  $.Float32x4_YWWX = 61;
  $.Float32x4_YWWY = 125;
  $.Float32x4_YWWZ = 189;
  $.Float32x4_YWWW = 253;
  $.Float32x4_ZXXX = 2;
  $.Float32x4_ZXXY = 66;
  $.Float32x4_ZXXZ = 130;
  $.Float32x4_ZXXW = 194;
  $.Float32x4_ZXYX = 18;
  $.Float32x4_ZXYY = 82;
  $.Float32x4_ZXYZ = 146;
  $.Float32x4_ZXYW = 210;
  $.Float32x4_ZXZX = 34;
  $.Float32x4_ZXZY = 98;
  $.Float32x4_ZXZZ = 162;
  $.Float32x4_ZXZW = 226;
  $.Float32x4_ZXWX = 50;
  $.Float32x4_ZXWY = 114;
  $.Float32x4_ZXWZ = 178;
  $.Float32x4_ZXWW = 242;
  $.Float32x4_ZYXX = 6;
  $.Float32x4_ZYXY = 70;
  $.Float32x4_ZYXZ = 134;
  $.Float32x4_ZYXW = 198;
  $.Float32x4_ZYYX = 22;
  $.Float32x4_ZYYY = 86;
  $.Float32x4_ZYYZ = 150;
  $.Float32x4_ZYYW = 214;
  $.Float32x4_ZYZX = 38;
  $.Float32x4_ZYZY = 102;
  $.Float32x4_ZYZZ = 166;
  $.Float32x4_ZYZW = 230;
  $.Float32x4_ZYWX = 54;
  $.Float32x4_ZYWY = 118;
  $.Float32x4_ZYWZ = 182;
  $.Float32x4_ZYWW = 246;
  $.Float32x4_ZZXX = 10;
  $.Float32x4_ZZXY = 74;
  $.Float32x4_ZZXZ = 138;
  $.Float32x4_ZZXW = 202;
  $.Float32x4_ZZYX = 26;
  $.Float32x4_ZZYY = 90;
  $.Float32x4_ZZYZ = 154;
  $.Float32x4_ZZYW = 218;
  $.Float32x4_ZZZX = 42;
  $.Float32x4_ZZZY = 106;
  $.Float32x4_ZZZZ = 170;
  $.Float32x4_ZZZW = 234;
  $.Float32x4_ZZWX = 58;
  $.Float32x4_ZZWY = 122;
  $.Float32x4_ZZWZ = 186;
  $.Float32x4_ZZWW = 250;
  $.Float32x4_ZWXX = 14;
  $.Float32x4_ZWXY = 78;
  $.Float32x4_ZWXZ = 142;
  $.Float32x4_ZWXW = 206;
  $.Float32x4_ZWYX = 30;
  $.Float32x4_ZWYY = 94;
  $.Float32x4_ZWYZ = 158;
  $.Float32x4_ZWYW = 222;
  $.Float32x4_ZWZX = 46;
  $.Float32x4_ZWZY = 110;
  $.Float32x4_ZWZZ = 174;
  $.Float32x4_ZWZW = 238;
  $.Float32x4_ZWWX = 62;
  $.Float32x4_ZWWY = 126;
  $.Float32x4_ZWWZ = 190;
  $.Float32x4_ZWWW = 254;
  $.Float32x4_WXXX = 3;
  $.Float32x4_WXXY = 67;
  $.Float32x4_WXXZ = 131;
  $.Float32x4_WXXW = 195;
  $.Float32x4_WXYX = 19;
  $.Float32x4_WXYY = 83;
  $.Float32x4_WXYZ = 147;
  $.Float32x4_WXYW = 211;
  $.Float32x4_WXZX = 35;
  $.Float32x4_WXZY = 99;
  $.Float32x4_WXZZ = 163;
  $.Float32x4_WXZW = 227;
  $.Float32x4_WXWX = 51;
  $.Float32x4_WXWY = 115;
  $.Float32x4_WXWZ = 179;
  $.Float32x4_WXWW = 243;
  $.Float32x4_WYXX = 7;
  $.Float32x4_WYXY = 71;
  $.Float32x4_WYXZ = 135;
  $.Float32x4_WYXW = 199;
  $.Float32x4_WYYX = 23;
  $.Float32x4_WYYY = 87;
  $.Float32x4_WYYZ = 151;
  $.Float32x4_WYYW = 215;
  $.Float32x4_WYZX = 39;
  $.Float32x4_WYZY = 103;
  $.Float32x4_WYZZ = 167;
  $.Float32x4_WYZW = 231;
  $.Float32x4_WYWX = 55;
  $.Float32x4_WYWY = 119;
  $.Float32x4_WYWZ = 183;
  $.Float32x4_WYWW = 247;
  $.Float32x4_WZXX = 11;
  $.Float32x4_WZXY = 75;
  $.Float32x4_WZXZ = 139;
  $.Float32x4_WZXW = 203;
  $.Float32x4_WZYX = 27;
  $.Float32x4_WZYY = 91;
  $.Float32x4_WZYZ = 155;
  $.Float32x4_WZYW = 219;
  $.Float32x4_WZZX = 43;
  $.Float32x4_WZZY = 107;
  $.Float32x4_WZZZ = 171;
  $.Float32x4_WZZW = 235;
  $.Float32x4_WZWX = 59;
  $.Float32x4_WZWY = 123;
  $.Float32x4_WZWZ = 187;
  $.Float32x4_WZWW = 251;
  $.Float32x4_WWXX = 15;
  $.Float32x4_WWXY = 79;
  $.Float32x4_WWXZ = 143;
  $.Float32x4_WWXW = 207;
  $.Float32x4_WWYX = 31;
  $.Float32x4_WWYY = 95;
  $.Float32x4_WWYZ = 159;
  $.Float32x4_WWYW = 223;
  $.Float32x4_WWZX = 47;
  $.Float32x4_WWZY = 111;
  $.Float32x4_WWZZ = 175;
  $.Float32x4_WWZW = 239;
  $.Float32x4_WWWX = 63;
  $.Float32x4_WWWY = 127;
  $.Float32x4_WWWZ = 191;
  $.Float32x4_WWWW = 255;
  $.Int32x4_XXXX = 0;
  $.Int32x4_XXXY = 64;
  $.Int32x4_XXXZ = 128;
  $.Int32x4_XXXW = 192;
  $.Int32x4_XXYX = 16;
  $.Int32x4_XXYY = 80;
  $.Int32x4_XXYZ = 144;
  $.Int32x4_XXYW = 208;
  $.Int32x4_XXZX = 32;
  $.Int32x4_XXZY = 96;
  $.Int32x4_XXZZ = 160;
  $.Int32x4_XXZW = 224;
  $.Int32x4_XXWX = 48;
  $.Int32x4_XXWY = 112;
  $.Int32x4_XXWZ = 176;
  $.Int32x4_XXWW = 240;
  $.Int32x4_XYXX = 4;
  $.Int32x4_XYXY = 68;
  $.Int32x4_XYXZ = 132;
  $.Int32x4_XYXW = 196;
  $.Int32x4_XYYX = 20;
  $.Int32x4_XYYY = 84;
  $.Int32x4_XYYZ = 148;
  $.Int32x4_XYYW = 212;
  $.Int32x4_XYZX = 36;
  $.Int32x4_XYZY = 100;
  $.Int32x4_XYZZ = 164;
  $.Int32x4_XYZW = 228;
  $.Int32x4_XYWX = 52;
  $.Int32x4_XYWY = 116;
  $.Int32x4_XYWZ = 180;
  $.Int32x4_XYWW = 244;
  $.Int32x4_XZXX = 8;
  $.Int32x4_XZXY = 72;
  $.Int32x4_XZXZ = 136;
  $.Int32x4_XZXW = 200;
  $.Int32x4_XZYX = 24;
  $.Int32x4_XZYY = 88;
  $.Int32x4_XZYZ = 152;
  $.Int32x4_XZYW = 216;
  $.Int32x4_XZZX = 40;
  $.Int32x4_XZZY = 104;
  $.Int32x4_XZZZ = 168;
  $.Int32x4_XZZW = 232;
  $.Int32x4_XZWX = 56;
  $.Int32x4_XZWY = 120;
  $.Int32x4_XZWZ = 184;
  $.Int32x4_XZWW = 248;
  $.Int32x4_XWXX = 12;
  $.Int32x4_XWXY = 76;
  $.Int32x4_XWXZ = 140;
  $.Int32x4_XWXW = 204;
  $.Int32x4_XWYX = 28;
  $.Int32x4_XWYY = 92;
  $.Int32x4_XWYZ = 156;
  $.Int32x4_XWYW = 220;
  $.Int32x4_XWZX = 44;
  $.Int32x4_XWZY = 108;
  $.Int32x4_XWZZ = 172;
  $.Int32x4_XWZW = 236;
  $.Int32x4_XWWX = 60;
  $.Int32x4_XWWY = 124;
  $.Int32x4_XWWZ = 188;
  $.Int32x4_XWWW = 252;
  $.Int32x4_YXXX = 1;
  $.Int32x4_YXXY = 65;
  $.Int32x4_YXXZ = 129;
  $.Int32x4_YXXW = 193;
  $.Int32x4_YXYX = 17;
  $.Int32x4_YXYY = 81;
  $.Int32x4_YXYZ = 145;
  $.Int32x4_YXYW = 209;
  $.Int32x4_YXZX = 33;
  $.Int32x4_YXZY = 97;
  $.Int32x4_YXZZ = 161;
  $.Int32x4_YXZW = 225;
  $.Int32x4_YXWX = 49;
  $.Int32x4_YXWY = 113;
  $.Int32x4_YXWZ = 177;
  $.Int32x4_YXWW = 241;
  $.Int32x4_YYXX = 5;
  $.Int32x4_YYXY = 69;
  $.Int32x4_YYXZ = 133;
  $.Int32x4_YYXW = 197;
  $.Int32x4_YYYX = 21;
  $.Int32x4_YYYY = 85;
  $.Int32x4_YYYZ = 149;
  $.Int32x4_YYYW = 213;
  $.Int32x4_YYZX = 37;
  $.Int32x4_YYZY = 101;
  $.Int32x4_YYZZ = 165;
  $.Int32x4_YYZW = 229;
  $.Int32x4_YYWX = 53;
  $.Int32x4_YYWY = 117;
  $.Int32x4_YYWZ = 181;
  $.Int32x4_YYWW = 245;
  $.Int32x4_YZXX = 9;
  $.Int32x4_YZXY = 73;
  $.Int32x4_YZXZ = 137;
  $.Int32x4_YZXW = 201;
  $.Int32x4_YZYX = 25;
  $.Int32x4_YZYY = 89;
  $.Int32x4_YZYZ = 153;
  $.Int32x4_YZYW = 217;
  $.Int32x4_YZZX = 41;
  $.Int32x4_YZZY = 105;
  $.Int32x4_YZZZ = 169;
  $.Int32x4_YZZW = 233;
  $.Int32x4_YZWX = 57;
  $.Int32x4_YZWY = 121;
  $.Int32x4_YZWZ = 185;
  $.Int32x4_YZWW = 249;
  $.Int32x4_YWXX = 13;
  $.Int32x4_YWXY = 77;
  $.Int32x4_YWXZ = 141;
  $.Int32x4_YWXW = 205;
  $.Int32x4_YWYX = 29;
  $.Int32x4_YWYY = 93;
  $.Int32x4_YWYZ = 157;
  $.Int32x4_YWYW = 221;
  $.Int32x4_YWZX = 45;
  $.Int32x4_YWZY = 109;
  $.Int32x4_YWZZ = 173;
  $.Int32x4_YWZW = 237;
  $.Int32x4_YWWX = 61;
  $.Int32x4_YWWY = 125;
  $.Int32x4_YWWZ = 189;
  $.Int32x4_YWWW = 253;
  $.Int32x4_ZXXX = 2;
  $.Int32x4_ZXXY = 66;
  $.Int32x4_ZXXZ = 130;
  $.Int32x4_ZXXW = 194;
  $.Int32x4_ZXYX = 18;
  $.Int32x4_ZXYY = 82;
  $.Int32x4_ZXYZ = 146;
  $.Int32x4_ZXYW = 210;
  $.Int32x4_ZXZX = 34;
  $.Int32x4_ZXZY = 98;
  $.Int32x4_ZXZZ = 162;
  $.Int32x4_ZXZW = 226;
  $.Int32x4_ZXWX = 50;
  $.Int32x4_ZXWY = 114;
  $.Int32x4_ZXWZ = 178;
  $.Int32x4_ZXWW = 242;
  $.Int32x4_ZYXX = 6;
  $.Int32x4_ZYXY = 70;
  $.Int32x4_ZYXZ = 134;
  $.Int32x4_ZYXW = 198;
  $.Int32x4_ZYYX = 22;
  $.Int32x4_ZYYY = 86;
  $.Int32x4_ZYYZ = 150;
  $.Int32x4_ZYYW = 214;
  $.Int32x4_ZYZX = 38;
  $.Int32x4_ZYZY = 102;
  $.Int32x4_ZYZZ = 166;
  $.Int32x4_ZYZW = 230;
  $.Int32x4_ZYWX = 54;
  $.Int32x4_ZYWY = 118;
  $.Int32x4_ZYWZ = 182;
  $.Int32x4_ZYWW = 246;
  $.Int32x4_ZZXX = 10;
  $.Int32x4_ZZXY = 74;
  $.Int32x4_ZZXZ = 138;
  $.Int32x4_ZZXW = 202;
  $.Int32x4_ZZYX = 26;
  $.Int32x4_ZZYY = 90;
  $.Int32x4_ZZYZ = 154;
  $.Int32x4_ZZYW = 218;
  $.Int32x4_ZZZX = 42;
  $.Int32x4_ZZZY = 106;
  $.Int32x4_ZZZZ = 170;
  $.Int32x4_ZZZW = 234;
  $.Int32x4_ZZWX = 58;
  $.Int32x4_ZZWY = 122;
  $.Int32x4_ZZWZ = 186;
  $.Int32x4_ZZWW = 250;
  $.Int32x4_ZWXX = 14;
  $.Int32x4_ZWXY = 78;
  $.Int32x4_ZWXZ = 142;
  $.Int32x4_ZWXW = 206;
  $.Int32x4_ZWYX = 30;
  $.Int32x4_ZWYY = 94;
  $.Int32x4_ZWYZ = 158;
  $.Int32x4_ZWYW = 222;
  $.Int32x4_ZWZX = 46;
  $.Int32x4_ZWZY = 110;
  $.Int32x4_ZWZZ = 174;
  $.Int32x4_ZWZW = 238;
  $.Int32x4_ZWWX = 62;
  $.Int32x4_ZWWY = 126;
  $.Int32x4_ZWWZ = 190;
  $.Int32x4_ZWWW = 254;
  $.Int32x4_WXXX = 3;
  $.Int32x4_WXXY = 67;
  $.Int32x4_WXXZ = 131;
  $.Int32x4_WXXW = 195;
  $.Int32x4_WXYX = 19;
  $.Int32x4_WXYY = 83;
  $.Int32x4_WXYZ = 147;
  $.Int32x4_WXYW = 211;
  $.Int32x4_WXZX = 35;
  $.Int32x4_WXZY = 99;
  $.Int32x4_WXZZ = 163;
  $.Int32x4_WXZW = 227;
  $.Int32x4_WXWX = 51;
  $.Int32x4_WXWY = 115;
  $.Int32x4_WXWZ = 179;
  $.Int32x4_WXWW = 243;
  $.Int32x4_WYXX = 7;
  $.Int32x4_WYXY = 71;
  $.Int32x4_WYXZ = 135;
  $.Int32x4_WYXW = 199;
  $.Int32x4_WYYX = 23;
  $.Int32x4_WYYY = 87;
  $.Int32x4_WYYZ = 151;
  $.Int32x4_WYYW = 215;
  $.Int32x4_WYZX = 39;
  $.Int32x4_WYZY = 103;
  $.Int32x4_WYZZ = 167;
  $.Int32x4_WYZW = 231;
  $.Int32x4_WYWX = 55;
  $.Int32x4_WYWY = 119;
  $.Int32x4_WYWZ = 183;
  $.Int32x4_WYWW = 247;
  $.Int32x4_WZXX = 11;
  $.Int32x4_WZXY = 75;
  $.Int32x4_WZXZ = 139;
  $.Int32x4_WZXW = 203;
  $.Int32x4_WZYX = 27;
  $.Int32x4_WZYY = 91;
  $.Int32x4_WZYZ = 155;
  $.Int32x4_WZYW = 219;
  $.Int32x4_WZZX = 43;
  $.Int32x4_WZZY = 107;
  $.Int32x4_WZZZ = 171;
  $.Int32x4_WZZW = 235;
  $.Int32x4_WZWX = 59;
  $.Int32x4_WZWY = 123;
  $.Int32x4_WZWZ = 187;
  $.Int32x4_WZWW = 251;
  $.Int32x4_WWXX = 15;
  $.Int32x4_WWXY = 79;
  $.Int32x4_WWXZ = 143;
  $.Int32x4_WWXW = 207;
  $.Int32x4_WWYX = 31;
  $.Int32x4_WWYY = 95;
  $.Int32x4_WWYZ = 159;
  $.Int32x4_WWYW = 223;
  $.Int32x4_WWZX = 47;
  $.Int32x4_WWZY = 111;
  $.Int32x4_WWZZ = 175;
  $.Int32x4_WWZW = 239;
  $.Int32x4_WWWX = 63;
  $.Int32x4_WWWY = 127;
  $.Int32x4_WWWZ = 191;
  $.Int32x4_WWWW = 255;
  $.OptionType_FLAG = C.OptionType_woc;
  $.OptionType_SINGLE = C.OptionType_F9d;
  $.OptionType_MULTIPLE = C.OptionType_Icb;
  $.Usage_NUM_COLUMNS = 3;
  $.argResults = null;
  $ = null;
  init.isHunkLoaded = function(hunkHash) {
    return !!$dart_deferred_initializers$[hunkHash];
  };
  init.deferredInitialized = new Object(null);
  init.isHunkInitialized = function(hunkHash) {
    return init.deferredInitialized[hunkHash];
  };
  init.initializeLoadedHunk = function(hunkHash) {
    $dart_deferred_initializers$[hunkHash]($globals$, $);
    init.deferredInitialized[hunkHash] = true;
  };
  init.deferredLibraryUris = {};
  init.deferredLibraryHashes = {};
  init.typeToInterceptorMap = [];
  (function(lazies) {
    for (var i = 0; i < lazies.length;) {
      var fieldName = lazies[i++];
      var getterName = lazies[i++];
      var lazyValue = lazies[i++];
      var staticName = lazies[i++];
      Isolate.$lazy(fieldName, getterName, lazyValue, staticName);
    }
  })(["DART_CLOSURE_PROPERTY_NAME", "$get$DART_CLOSURE_PROPERTY_NAME", function() {
    return H.getIsolateAffinityTag("_$dart_dartClosure");
  }, "DART_CLOSURE_PROPERTY_NAME", "JS_INTEROP_INTERCEPTOR_TAG", "$get$JS_INTEROP_INTERCEPTOR_TAG", function() {
    return H.getIsolateAffinityTag("_$dart_js");
  }, "JS_INTEROP_INTERCEPTOR_TAG", "constructorToInterceptor", "$get$constructorToInterceptor", function() {
    return typeof self.WeakMap == "undefined" ? new Map() : new WeakMap();
  }, "constructorToInterceptor", "Symbol_publicSymbolPattern", "$get$Symbol_publicSymbolPattern", function() {
    return P.RegExp_RegExp("^(?:(?:[\\-+*/%&|^]|\\[\\]=?|==|~/?|<[<=]?|>[>=]?|unary-)$|(?!(?:assert|break|c(?:a(?:se|tch)|lass|on(?:st|tinue))|d(?:efault|o)|e(?:lse|num|xtends)|f(?:alse|inal(?:ly)?|or)|i[fns]|n(?:ew|ull)|ret(?:hrow|urn)|s(?:uper|witch)|t(?:h(?:is|row)|r(?:ue|y))|v(?:ar|oid)|w(?:hile|ith))\\b(?!\\$))[a-zA-Z$][\\w$]*(?:=?$|[.](?!$)))+?$", true, false);
  }, "Symbol_publicSymbolPattern", "Symbol_symbolPattern", "$get$Symbol_symbolPattern", function() {
    return P.RegExp_RegExp("^(?:(?:[\\-+*/%&|^]|\\[\\]=?|==|~/?|<[<=]?|>[>=]?|unary-)$|(?!(?:assert|break|c(?:a(?:se|tch)|lass|on(?:st|tinue))|d(?:efault|o)|e(?:lse|num|xtends)|f(?:alse|inal(?:ly)?|or)|i[fns]|n(?:ew|ull)|ret(?:hrow|urn)|s(?:uper|witch)|t(?:h(?:is|row)|r(?:ue|y))|v(?:ar|oid)|w(?:hile|ith))\\b(?!\\$))[a-zA-Z$_][\\w$]*(?:=?$|[.](?!$)))+?$", true, false);
  }, "Symbol_symbolPattern", "IsolateNatives_thisScript", "$get$IsolateNatives_thisScript", function() {
    return H.IsolateNatives_computeThisScript();
  }, "IsolateNatives_thisScript", "IsolateNatives_workerIds", "$get$IsolateNatives_workerIds", function() {
    if (typeof WeakMap == "function")
      var t1 = new WeakMap();
    else {
      t1 = $.Expando__keyCount;
      $.Expando__keyCount = J.$add$ns(t1, 1);
      t1 = "expando$key$" + H.S(t1);
    }
    return new P.Expando(null, t1, [P.int]);
  }, "IsolateNatives_workerIds", "TypeErrorDecoder_noSuchMethodPattern", "$get$TypeErrorDecoder_noSuchMethodPattern", function() {
    return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({
      toString: function() {
        return "$receiver$";
      }
    }));
  }, "TypeErrorDecoder_noSuchMethodPattern", "TypeErrorDecoder_notClosurePattern", "$get$TypeErrorDecoder_notClosurePattern", function() {
    return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({$method$: null,
      toString: function() {
        return "$receiver$";
      }
    }));
  }, "TypeErrorDecoder_notClosurePattern", "TypeErrorDecoder_nullCallPattern", "$get$TypeErrorDecoder_nullCallPattern", function() {
    return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(null));
  }, "TypeErrorDecoder_nullCallPattern", "TypeErrorDecoder_nullLiteralCallPattern", "$get$TypeErrorDecoder_nullLiteralCallPattern", function() {
    return H.TypeErrorDecoder_extractPattern(function() {
      var $argumentsExpr$ = '$arguments$';
      try {
        null.$method$($argumentsExpr$);
      } catch (e) {
        return e.message;
      }
    }());
  }, "TypeErrorDecoder_nullLiteralCallPattern", "TypeErrorDecoder_undefinedCallPattern", "$get$TypeErrorDecoder_undefinedCallPattern", function() {
    return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(void 0));
  }, "TypeErrorDecoder_undefinedCallPattern", "TypeErrorDecoder_undefinedLiteralCallPattern", "$get$TypeErrorDecoder_undefinedLiteralCallPattern", function() {
    return H.TypeErrorDecoder_extractPattern(function() {
      var $argumentsExpr$ = '$arguments$';
      try {
        (void 0).$method$($argumentsExpr$);
      } catch (e) {
        return e.message;
      }
    }());
  }, "TypeErrorDecoder_undefinedLiteralCallPattern", "TypeErrorDecoder_nullPropertyPattern", "$get$TypeErrorDecoder_nullPropertyPattern", function() {
    return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(null));
  }, "TypeErrorDecoder_nullPropertyPattern", "TypeErrorDecoder_nullLiteralPropertyPattern", "$get$TypeErrorDecoder_nullLiteralPropertyPattern", function() {
    return H.TypeErrorDecoder_extractPattern(function() {
      try {
        null.$method$;
      } catch (e) {
        return e.message;
      }
    }());
  }, "TypeErrorDecoder_nullLiteralPropertyPattern", "TypeErrorDecoder_undefinedPropertyPattern", "$get$TypeErrorDecoder_undefinedPropertyPattern", function() {
    return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(void 0));
  }, "TypeErrorDecoder_undefinedPropertyPattern", "TypeErrorDecoder_undefinedLiteralPropertyPattern", "$get$TypeErrorDecoder_undefinedLiteralPropertyPattern", function() {
    return H.TypeErrorDecoder_extractPattern(function() {
      try {
        (void 0).$method$;
      } catch (e) {
        return e.message;
      }
    }());
  }, "TypeErrorDecoder_undefinedLiteralPropertyPattern", "_loadingLibraries", "$get$_loadingLibraries", function() {
    return P.LinkedHashMap_LinkedHashMap$_empty(P.String, [P.Future, P.Null]);
  }, "_loadingLibraries", "_loadedLibraries", "$get$_loadedLibraries", function() {
    return P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
  }, "_loadedLibraries", "JsMirrorSystem__dynamicType", "$get$JsMirrorSystem__dynamicType", function() {
    return H.JsTypeMirror$(C.Symbol_dynamic);
  }, "JsMirrorSystem__dynamicType", "JsMirrorSystem__voidType", "$get$JsMirrorSystem__voidType", function() {
    return H.JsTypeMirror$(C.Symbol_void);
  }, "JsMirrorSystem__voidType", "currentJsMirrorSystem", "$get$currentJsMirrorSystem", function() {
    return new H.JsMirrorSystem(null, new H.JsIsolateMirror(H._globalState().currentContext));
  }, "currentJsMirrorSystem", "mangledNames", "$get$mangledNames", function() {
    return new H._LazyMangledInstanceNamesMap(init.mangledNames);
  }, "mangledNames", "reflectiveNames", "$get$reflectiveNames", function() {
    return new H._LazyReflectiveNamesMap(init.mangledNames, true, 0, null);
  }, "reflectiveNames", "mangledGlobalNames", "$get$mangledGlobalNames", function() {
    return new H._LazyMangledNamesMap(init.mangledGlobalNames);
  }, "mangledGlobalNames", "reflectiveGlobalNames", "$get$reflectiveGlobalNames", function() {
    return new H._LazyReflectiveNamesMap(init.mangledGlobalNames, false, 0, null);
  }, "reflectiveGlobalNames", "NativeFloat32x4__list", "$get$NativeFloat32x4__list", function() {
    return H.NativeFloat32List_NativeFloat32List(4);
  }, "NativeFloat32x4__list", "NativeFloat32x4__uint32view", "$get$NativeFloat32x4__uint32view", function() {
    var t1 = $.$get$NativeFloat32x4__list().buffer;
    return (t1 && C.NativeByteBuffer_methods).asUint32List$0(t1);
  }, "NativeFloat32x4__uint32view", "NativeInt32x4__list", "$get$NativeInt32x4__list", function() {
    return H.NativeInt32List_NativeInt32List(4);
  }, "NativeInt32x4__list", "NativeFloat64x2__list", "$get$NativeFloat64x2__list", function() {
    return H.NativeFloat64List_NativeFloat64List(2);
  }, "NativeFloat64x2__list", "NativeFloat64x2__uint32View", "$get$NativeFloat64x2__uint32View", function() {
    var t1 = $.$get$NativeFloat64x2__list().buffer;
    return (t1 && C.NativeByteBuffer_methods).asUint32List$0(t1);
  }, "NativeFloat64x2__uint32View", "_AsyncRun__scheduleImmediateClosure", "$get$_AsyncRun__scheduleImmediateClosure", function() {
    return P._AsyncRun__initializeScheduleImmediate();
  }, "_AsyncRun__scheduleImmediateClosure", "Future__nullFuture", "$get$Future__nullFuture", function() {
    return P.Future_Future$value(null, null);
  }, "Future__nullFuture", "_DistinctStream__SENTINEL", "$get$_DistinctStream__SENTINEL", function() {
    return new P.Object();
  }, "_DistinctStream__SENTINEL", "_RootZone__rootMap", "$get$_RootZone__rootMap", function() {
    return P.HashMap_HashMap(null, null, null, null, null);
  }, "_RootZone__rootMap", "_toStringVisiting", "$get$_toStringVisiting", function() {
    return [];
  }, "_toStringVisiting", "_Base64Decoder__inverseAlphabet", "$get$_Base64Decoder__inverseAlphabet", function() {
    return H.NativeInt8List_NativeInt8List$fromList([-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -1, -2, -2, -2, -2, -2, 62, -2, 62, -2, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -2, -2, -2, -1, -2, -2, -2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -2, -2, -2, -2, 63, -2, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -2, -2, -2, -2, -2]);
  }, "_Base64Decoder__inverseAlphabet", "Encoding__nameToEncoding", "$get$Encoding__nameToEncoding", function() {
    return P.LinkedHashMap_LinkedHashMap$_literal(["iso_8859-1:1987", C.Latin1Codec_false, "iso-ir-100", C.Latin1Codec_false, "iso_8859-1", C.Latin1Codec_false, "iso-8859-1", C.Latin1Codec_false, "latin1", C.Latin1Codec_false, "l1", C.Latin1Codec_false, "ibm819", C.Latin1Codec_false, "cp819", C.Latin1Codec_false, "csisolatin1", C.Latin1Codec_false, "iso-ir-6", C.AsciiCodec_false, "ansi_x3.4-1968", C.AsciiCodec_false, "ansi_x3.4-1986", C.AsciiCodec_false, "iso_646.irv:1991", C.AsciiCodec_false, "iso646-us", C.AsciiCodec_false, "us-ascii", C.AsciiCodec_false, "us", C.AsciiCodec_false, "ibm367", C.AsciiCodec_false, "cp367", C.AsciiCodec_false, "csascii", C.AsciiCodec_false, "ascii", C.AsciiCodec_false, "csutf8", C.Utf8Codec_false, "utf-8", C.Utf8Codec_false], P.String, P.Encoding);
  }, "Encoding__nameToEncoding", "_Uri__needsNoEncoding", "$get$_Uri__needsNoEncoding", function() {
    return P.RegExp_RegExp("^[\\-\\.0-9A-Z_a-z~]*$", true, false);
  }, "_Uri__needsNoEncoding", "_hasErrorStackProperty", "$get$_hasErrorStackProperty", function() {
    return new Error().stack != void 0;
  }, "_hasErrorStackProperty", "_scannerTables", "$get$_scannerTables", function() {
    return P._createTables();
  }, "_scannerTables", "_extensions", "$get$_extensions", function() {
    return H.JsLinkedHashMap_JsLinkedHashMap$es6(P.String, {func: 1, ret: [P.Future, P.ServiceExtensionResponse], args: [P.String, [P.Map, P.String, P.String]]});
  }, "_extensions", "_FakeUserTag__instances", "$get$_FakeUserTag__instances", function() {
    return P.LinkedHashMap__makeEmpty();
  }, "_FakeUserTag__instances", "_FakeUserTag__defaultTag", "$get$_FakeUserTag__defaultTag", function() {
    return P._FakeUserTag__FakeUserTag("Default");
  }, "_FakeUserTag__defaultTag", "_currentTag", "$get$_currentTag", function() {
    return $.$get$_FakeUserTag__defaultTag();
  }, "_currentTag", "Metrics__metrics", "$get$Metrics__metrics", function() {
    return H.JsLinkedHashMap_JsLinkedHashMap$es6(P.String, P.Metric);
  }, "Metrics__metrics", "Timeline__stack", "$get$Timeline__stack", function() {
    return H.setRuntimeTypeInfo([], [P._SyncBlock]);
  }, "Timeline__stack", "Timeline__isolateId", "$get$Timeline__isolateId", function() {
    return 0;
  }, "Timeline__isolateId", "Timeline__isolateIdString", "$get$Timeline__isolateIdString", function() {
    return J.toString$0$($.$get$Timeline__isolateId());
  }, "Timeline__isolateIdString", "_CopyingBytesBuilder__emptyList", "$get$_CopyingBytesBuilder__emptyList", function() {
    return H.NativeUint8List_NativeUint8List(0);
  }, "_CopyingBytesBuilder__emptyList", "FileSystemEntity__absoluteWindowsPathPattern", "$get$FileSystemEntity__absoluteWindowsPathPattern", function() {
    return P.RegExp_RegExp("^(\\\\\\\\|[a-zA-Z]:[/\\\\])", true, false);
  }, "FileSystemEntity__absoluteWindowsPathPattern", "FileSystemEntity__parentRegExp", "$get$FileSystemEntity__parentRegExp", function() {
    return $.$get$Platform_isWindows() ? P.RegExp_RegExp("[^/\\\\][/\\\\]+[^/\\\\]", true, false) : P.RegExp_RegExp("[^/]/+[^/]", true, false);
  }, "FileSystemEntity__parentRegExp", "ContentType_TEXT", "$get$ContentType_TEXT", function() {
    return P.ContentType_ContentType("text", "plain", "utf-8", null);
  }, "ContentType_TEXT", "ContentType_HTML", "$get$ContentType_HTML", function() {
    return P.ContentType_ContentType("text", "html", "utf-8", null);
  }, "ContentType_HTML", "ContentType_JSON", "$get$ContentType_JSON", function() {
    return P.ContentType_ContentType("application", "json", "utf-8", null);
  }, "ContentType_JSON", "ContentType_BINARY", "$get$ContentType_BINARY", function() {
    return P.ContentType_ContentType("application", "octet-stream", null, null);
  }, "ContentType_BINARY", "_HttpClient__platformEnvironmentCache", "$get$_HttpClient__platformEnvironmentCache", function() {
    return P._Platform_environment();
  }, "_HttpClient__platformEnvironmentCache", "_HttpConnection__connections", "$get$_HttpConnection__connections", function() {
    return P.HashMap_HashMap(null, null, null, P.int, P._HttpConnection);
  }, "_HttpConnection__connections", "_HttpServer__servers", "$get$_HttpServer__servers", function() {
    return H.JsLinkedHashMap_JsLinkedHashMap$es6(P.int, P._HttpServer);
  }, "_HttpServer__servers", "_IOResourceInfo__sw", "$get$_IOResourceInfo__sw", function() {
    var t1 = P.Stopwatch$();
    t1.start$0();
    return t1;
  }, "_IOResourceInfo__sw", "_IOResourceInfo__startTime", "$get$_IOResourceInfo__startTime", function() {
    return P.DateTime$now().get$millisecondsSinceEpoch();
  }, "_IOResourceInfo__startTime", "_FileResourceInfo_openFiles", "$get$_FileResourceInfo_openFiles", function() {
    return H.JsLinkedHashMap_JsLinkedHashMap$es6(P.int, P._FileResourceInfo);
  }, "_FileResourceInfo_openFiles", "_ProcessResourceInfo_startedProcesses", "$get$_ProcessResourceInfo_startedProcesses", function() {
    return H.JsLinkedHashMap_JsLinkedHashMap$es6(P.int, P._ProcessResourceInfo);
  }, "_ProcessResourceInfo_startedProcesses", "_SocketResourceInfo_openSockets", "$get$_SocketResourceInfo_openSockets", function() {
    return H.JsLinkedHashMap_JsLinkedHashMap$es6(P.int, P._SocketResourceInfo);
  }, "_SocketResourceInfo_openSockets", "Platform__numberOfProcessors", "$get$Platform__numberOfProcessors", function() {
    return P._Platform_numberOfProcessors();
  }, "Platform__numberOfProcessors", "Platform__pathSeparator", "$get$Platform__pathSeparator", function() {
    return P._Platform_pathSeparator();
  }, "Platform__pathSeparator", "Platform__operatingSystem", "$get$Platform__operatingSystem", function() {
    return P._Platform_operatingSystem();
  }, "Platform__operatingSystem", "Platform__localHostname", "$get$Platform__localHostname", function() {
    return P._Platform_localHostname();
  }, "Platform__localHostname", "Platform__version", "$get$Platform__version", function() {
    return P._Platform_version();
  }, "Platform__version", "Platform_isLinux", "$get$Platform_isLinux", function() {
    $.$get$Platform__operatingSystem();
    return false;
  }, "Platform_isLinux", "Platform_isMacOS", "$get$Platform_isMacOS", function() {
    $.$get$Platform__operatingSystem();
    return false;
  }, "Platform_isMacOS", "Platform_isWindows", "$get$Platform_isWindows", function() {
    $.$get$Platform__operatingSystem();
    return false;
  }, "Platform_isWindows", "Platform_isAndroid", "$get$Platform_isAndroid", function() {
    $.$get$Platform__operatingSystem();
    return false;
  }, "Platform_isAndroid", "Platform_isIOS", "$get$Platform_isIOS", function() {
    $.$get$Platform__operatingSystem();
    return false;
  }, "Platform_isIOS", "Platform_isFuchsia", "$get$Platform_isFuchsia", function() {
    $.$get$Platform__operatingSystem();
    return false;
  }, "Platform_isFuchsia", "_Platform_executable", "$get$_Platform_executable", function() {
    return P._Platform__executable();
  }, "_Platform_executable", "_Platform_resolvedExecutable", "$get$_Platform_resolvedExecutable", function() {
    return P._Platform__resolvedExecutable();
  }, "_Platform_resolvedExecutable", "_Platform_packageRoot", "$get$_Platform_packageRoot", function() {
    return P._Platform__packageRoot();
  }, "_Platform_packageRoot", "_Platform_packageConfig", "$get$_Platform_packageConfig", function() {
    return P._Platform__packageConfig();
  }, "_Platform_packageConfig", "_WebSocketImpl__webSockets", "$get$_WebSocketImpl__webSockets", function() {
    return H.JsLinkedHashMap_JsLinkedHashMap$es6(P.int, P._WebSocketImpl);
  }, "_WebSocketImpl__webSockets", "_WebSocketImpl__httpClient", "$get$_WebSocketImpl__httpClient", function() {
    var t1, version;
    t1 = P.HashMap_HashMap(null, null, null, P.String, P._ConnectionTarget);
    version = $.$get$Platform__version();
    return new P._HttpClient(false, false, t1, [], [], null, null, null, P.io_HttpClient_findProxyFromEnvironment$closure(), C.Duration_15000000, null, null, true, "Dart/" + H.S(C.JSNull_methods.substring$2(version, 0, C.JSNull_methods.indexOf$2(version, ".", C.JSNull_methods.indexOf$1(version, ".").$add(0, 1)))) + " (dart:io)");
  }, "_WebSocketImpl__httpClient", "Isolate__currentIsolateCache", "$get$Isolate__currentIsolateCache", function() {
    var context = H._globalState().currentContext;
    return new P.Isolate(context.controlPort.get$sendPort(), context.pauseCapability, context.terminateCapability);
  }, "Isolate__currentIsolateCache", "Isolate__packageBase", "$get$Isolate__packageBase", function() {
    return P.Uri_base().resolve$1(self.defaultPackagesBase || "packages/");
  }, "Isolate__packageBase", "Random__secureRandom", "$get$Random__secureRandom", function() {
    return P._JSSecureRandom$();
  }, "Random__secureRandom", "Endianness_HOST_ENDIAN", "$get$Endianness_HOST_ENDIAN", function() {
    var t1 = H.NativeUint16List_NativeUint16List$fromList([1]).buffer;
    return (t1 && C.NativeByteBuffer_methods).asByteData$2(t1, 0, null).getInt8(0) === 1 ? C.Endianness_true : C.Endianness_false;
  }, "Endianness_HOST_ENDIAN", "Option__invalidChars", "$get$Option__invalidChars", function() {
    return P.RegExp_RegExp("[ \\t\\r\\n\"'\\\\/]", true, false);
  }, "Option__invalidChars", "_SOLO_OPT", "$get$_SOLO_OPT", function() {
    return P.RegExp_RegExp("^-([a-zA-Z0-9])$", true, false);
  }, "_SOLO_OPT", "_ABBR_OPT", "$get$_ABBR_OPT", function() {
    return P.RegExp_RegExp("^-([a-zA-Z0-9]+)(.*)$", true, false);
  }, "_ABBR_OPT", "_LONG_OPT", "$get$_LONG_OPT", function() {
    return P.RegExp_RegExp("^--([a-zA-Z\\-_0-9]+)(=(.*))?$", true, false);
  }, "_LONG_OPT", "shapeDef", "$get$shapeDef", function() {
    return ["circle 5", "rectangle 4 3", "square 2", "square me", "circle", "rectangle 4", "boo 2 4 5"];
  }, "shapeDef"]);
  Isolate = Isolate.$finishIsolateConstructor(Isolate);
  $ = new Isolate();
  init.metadata = [null, "value", "other", "start", false, "end", "key", 0, "error", "f", "path", "test", "stackTrace", "name", "index", "length", "_", "message", "response", "source", "onError", "data", "sink", "object", "cancelOnError", true, "port", "onData", "onDone", "host", "bytes", "element", "", "callback", "zone", "elements", "offsetInBytes", "stream", "x", "string", "uri", "buffer", "iterable", "count", "scheme", "_sink", "isLast", "e", "encoding", "s", "subscription", "recursive", "socket", "byteOffset", "request", "map", "v", "chunk", "input", "duration", "endian", "combine", "parent", "separator", C.Endianness_false, "type", "option", "orElse", "arg", "arguments", "mode", "action", "self", C.Utf8Codec_false, "namedArguments", "url", "context", "positionalArguments", "b", "target", "toEncodable", "address", "state", "fieldName", "charCode", "ifAbsent", "newPath", "a", "growable", "n", "arg2", "arg1", "msg", "result", "onListen", "onCancel", "o", "requestClientCertificate", "method", "connection", "raw", "isValidKey", "startIndex", "fd", "allowMalformed", "supportedProtocols", "text", "queryParameters", "osError", "followLinks", "event", "node", "windowBits", "compression", "requireClientCertificate", "function", "compare", "parameters", "invocation", "objects", "str", "v6Only", C.TypeVariable_Type_SplayTreeMap_4AN_K, "initialValue", "backlog", "list", "inputEvent", "i", "shared", "query", "dictionary", "info", "y", C.TypeVariable_Type__HandlerEventSink_u5Q_T, "onBadCertificate", "defaultValue", "level", "entry", "bufferSize", "width", 15, C.TypeVariable_C43, "proxy", "obj", "from", "code", "memberName", C.TypeVariable_iiT, "_socket", "byte", "runGuarded", "ref", "realm", "dispatch", "isMatch", "environment", "allowInvalid", "handleError", "file", "params", "errorCode", "line", "equals", "_stream", "handleDone", "indent", "values", "memLevel", C.TypeVariable_Type_SplayTreeSet_fjq_E, "strategy", "windows", C.TypeVariable_Type__DistinctStream_iDA_T, "mimeType", "m", "_value", "handleData", C.TypeVariable_Type__AsBroadcastStream_pV3_T, "keys", C.CompressionOptions_qty, "future", "codeUnits", "errorCallback", "protocol", "computation", "controller", C.FileMode_1, "each", "reference", "reviver", "enabled", "cr", "gzip", "convert", "microsecond", "isDirectory", 1, "month", "skipCount", "specification", "isUtc", "zoneValues", C.C_SystemEncoding, C.TypeVariable_Type__SimpleCallbackSink_qZk_T, C.TypeVariable_Type__FusedConverter_33h_T, -1, C.TypeVariable_Type__FusedConverter_33h_S, "futureValue", C.TypeVariable_Type__WhereStream_1p9_T, C.TypeVariable_Type__TakeWhileStream_CWV_T, "userInfo", C.TypeVariable_Type__SkipWhileStream_lyG_T, "username", C.TypeVariable_Type__LinkedListIterator_j0s_E, "pathSegments", C.TypeVariable_0, C.TypeVariable_Type__SplayTreeIterator_gg4_K, "fragment", "authority", "unencodedPath", "password", "offset", "resumeSignal", C.TypeVariable_Type__StreamController_wxj_T, "help", "hide", "allowed", "time", "urlSafe", "protocols", C.TypeVariable_Type_LinkedList_Mys_E, "pattern", "endIndex", C.TypeVariable_Type_ListQueue_c4R_E, C.TypeVariable_Type__MapStream_ynF_S, C.TypeVariable_Type__MapStream_ynF_T, "force", "incoming", "closing", "expected", C.TypeVariable_Type__GeneratorIterable_H1k_E, "constructorName", "decl", "mask", "flush", "z", "w", C.TypeVariable_Type__SplayTreeKeyIterable_mtF_K, C.TypeVariable_Type_SplayTreeMap_4AN_V, C.TypeVariable_Type_DoubleLinkedQueue_6La_E, C.TypeVariable_Type__MapBaseValueIterator_mtc_V, "onPause", "onResume", C.TypeVariable_Type_LinkedListEntry_Odg_E, "position", C.TypeVariable_Type_MutableRectangle_G79_T, "executable", "status", C.TypeVariable_etK, C.TypeVariable_xw8, C.TypeVariable_CF9, C.TypeVariable_7BT, C.TypeVariable_Type__StreamSinkTransformer_gUt_S, "bufferedData", C.TypeVariable_Type__StreamSinkTransformer_gUt_T, C.TypeVariable_Type__HandlerEventSink_u5Q_S, C.TypeVariable_Type__BoundSinkStream_rmX_S, C.TypeVariable_Type__BoundSinkStream_rmX_T, "credentials", "hashCode", C.TypeVariable_Type__ExpandStream_m9l_S, "isSecure", C.TypeVariable_Type__ExpandStream_m9l_T, "number", "tree", "k", "_incoming", "date", "component", C.TypeVariable_Type__ListQueueIterator_Ofa_E, "output", C.TypeVariable_2Y5, "_name", "_toEncodable", "addChunk", "size", C.TypeVariable_Type__StreamSinkImpl_UrA_T, "splitCommas", "allowedHelp", "year", "day", "hour", "minute", "second", "millisecond", "owner", "valueHelp", "sendPort", "max", "description", "negatable", "abbr", "c", C.TypeVariable_Type__GeneratedStreamImpl_jrB_T, C.TypeVariable_PTP, "eventSink", C.TypeVariable_Type__ControllerSubscription_S4n_T, "d", "webSocket", C.TypeVariable_Type__SplayTreeKeyIterator_6i1_K, C.TypeVariable_Type__SplayTreeValueIterable_F4j_V, "futures", "serverSide", C.TypeVariable_Type__SyncStreamController_kiv_T, "errorsAreFatal", C.TypeVariable_Type__SplayTreeNode_mCJ_K, "listeners", "timeout", C.TypeVariable_Type__DoubleLinkedQueueEntry_2Vu_E, C.TypeVariable_Type_DoubleLinkedQueueEntry_FGJ_E, C.TypeVariable_Type__MapBaseValueIterator_mtc_K, C.TypeVariable_Type_UnmodifiableMapView_C2I_K, C.TypeVariable_Type_UnmodifiableMapView_C2I_V, "rest", C.TypeVariable_Type__MapBaseValueIterable_4VA_V, "is_server", C.TypeVariable_Type_UnmodifiableMapBase_KU4_V, "requestedPort", "rawSocket", "handleUncaughtError", "run", "runUnary", "runBinary", "registerCallback", "registerUnaryCallback", "registerBinaryCallback", "scheduleMicrotask", "createTimer", "createPeriodicTimer", "print", "fork", "previous", "_map", C.TypeVariable_Type_Rectangle_o6V_T, "runInShell", "includeParentEnvironment", "workingDirectory", C.TypeVariable_Type_UnmodifiableListView_Gx6_E, "to", C.TypeVariable_Type__SplayTreeNodeIterator_0_K, "headerValue", "statusCode", "height", "id", C.TypeVariable_Type__Completer_T1l_T, "responsePort", "session", C.TypeVariable_4CA, "argumentError", "handler", C.TypeVariable_Type__FusedCodec_4kv_T, "args", "pointer", C.C_NoInline, "generator", C.TypeVariable_Type__FusedCodec_4kv_M, C.TypeVariable_Type_StreamSink_Y6h_S, "codeUnit", C.TypeVariable_Type__FusedCodec_4kv_S, C.TypeVariable_Type__InvertedCodec_SAd_S, C.TypeVariable_Type__InvertedCodec_SAd_T, "oldPath", "millis", "library", "path1", "upperLimit", "charCodes", "at", "resumeCapability", "category", "lowerLimit", "indexable", C.TypeVariable_Type__ControllerStream_iHe_T, "newLength", "argumentsAsJson", C.TypeVariable_oVw, C.TypeVariable_ahM, C.TypeVariable_Type__DelayedData_0mC_T, "_indent", "libraryName", "path2", "random", C.TypeVariable_Type__FusedConverter_33h_M, C.TypeVariable_Type__BroadcastSubscription_bl8_T, C.TypeVariable_00, 6, C.TypeVariable_Ecu, "_callback", "char", 8, C.TypeVariable_Type__SkipStream_6eq_T, "bits", C.TypeVariable_Type__AsyncStreamController_Ux9_T, "parameterSeparator", "valueSeparator", "preserveBackslash", "defaultsTo", "_subsetMask", "requested", "cookie", C.TypeVariable_Type__IterablePendingEvents_2jR_T, "content", C.TypeVariable_Type_UnmodifiableMapBase_KU4_K, C.TypeVariable_izR, "protocolVersion", "headers", "_httpClient", "outgoing", "queue", "_context", "symbol", C.TypeVariable_Type__HandleErrorStream_OpF_T, C.TypeVariable_Type__TakeStream_Yma_T, "val", "serverSocket", "top", C.TypeVariable_Type_Converter_JmU_S, "_serverSocket", "commands", C.TypeVariable_6mv, C.TypeVariable_Type__EventSinkWrapper_iL9_T, "results", "abbreviation", C.TypeVariable_Type_LinkedHashSet_j93_E, C.TypeVariable_Type_HashSet_cdS_E, "creds", "(", ")", "leftDelimiter", "rightDelimiter", "needle", "parameter", C.TypeVariable_Type_Converter_JmU_T, C.TypeVariable_Type_Set_mC8_E, "another", "location", C.TypeVariable_Type__EmptyStream_4QF_T, "initialCapacity", "argument", C.TypeVariable_Type__StreamIterator_AH7_T, C.TypeVariable_Type_ChunkedConverter_yzN_S, "startKey", "newValue", "reason", C.TypeVariable_Type_ChunkedConverter_yzN_T, C.TypeVariable_LdF, "add", "_httpServer", "left", "isolate", "fill", "field", "next", "removeMatching", "initialHeaders", C.TypeVariable_hD9, C.TypeVariable_zgG, C.TypeVariable_Type__DoneStreamSubscription_kvD_T, "tag", "onTimeout", "timeLimit", C.TypeVariable_OnH, C.TypeVariable_Type_ListBase_3Qc_E, "charset", C.TypeVariable_Type__StreamSinkWrapper_UQE_T, "asyncError", "subType", "primaryType", "process", "stack", C.TypeVariable_Type__UnmodifiableMapMixin_FuX_V, ";", C.TypeVariable_Type__UnmodifiableMapMixin_FuX_K, "signal", C.TypeVariable_86y, "alphabet", C.TypeVariable_mpT, "certificate", " ", "outputIndex", "uriHost", C.TypeVariable_Type__SyncCompleter_7QI_T, C.TypeVariable_Type_Point_Yua_T, "detachedRaw", "charTable", C.TypeVariable_Type_StreamView_yTL_T, "contentLength", "reflectee", "escapeLtGt", "escapeQuot", "escapeApos", "escapeSlash", "paused", C.TypeVariable_Type__HashSetBase_V0W_E, C.TypeVariable_MJa, C.TypeVariable_Type_MapView_6Vn_V, "events", C.TypeVariable_Type__BroadcastStream_e2q_T, C.TypeVariable_Type_ChunkedConversionSink_NCr_T, C.TypeVariable_Type_SetBase_2bH_E, C.TypeVariable_Type_HasNextIterator_wEV_E, "uriPort", C.TypeVariable_Type_SetMixin_WMS_E, C.TypeVariable_Type_HashMap_RoN_V, "stdoutEncoding", C.TypeVariable_Type_MapView_6Vn_K, "_transformer", "lines", "ch", "stderrEncoding", "_chunkedSink", "_stringSink", "pid", C.TypeVariable_Type_MapMixin_UNR_V, "_sinkMapper", "hash", C.TypeVariable_Type_MapMixin_UNR_K, C.TypeVariable_Type_MapBase_Olj_V, C.TypeVariable_Type_MapBase_Olj_K, C.TypeVariable_Type_EventSink_ar2_T, C.InternetAddressType_m1, "bufferLength", "clientNoContextTakeover", "encoded", C.TypeVariable_C5p, "command", C.TypeVariable_Dnt, "priority", "_source", "serverNoContextTakeover", C.TypeVariable_Type_BidirectionalIterator_46c_E, C.TypeVariable_Type__AsyncCompleter_Irt_T, "clientMaxWindowBits", C.TypeVariable_Type__Future_ifn_T, "endOrNull", "serverMaxWindowBits", C.TypeVariable_Type_JSArray_zDM_E, "expires", "_target", "padding", C.TypeVariable_Type__ForwardingStream_EK0_S, "conn", "_controller", C.FileLock_1, "tv", C.TypeVariable_Type__MapBaseValueIterable_4VA_K, C.TypeVariable_Type__ForwardingStream_EK0_T, "t", C.TypeVariable_Type__ZoneFunction_xw8_T, "sync", C.TypeVariable_Type__FutureListener_XVS_T, "_first", C.TypeVariable_Type_IterableBase_if4_E, C.TypeVariable_AlA, C.TypeVariable_Type__DoubleLink_7Yv_Link, "protocolSelector", "period", C.TypeVariable_3AX, "invalidValue", "minValue", "maxValue", C.TypeVariable_Type_HashMap_RoN_K, C.TypeVariable_Type__SplayTreeMapNode_jWj_V, "taskId", "_x", C.TypeVariable_Type__SplayTreeMapNode_jWj_K, "enable", C.TypeVariable_Type_List_naM_E, "metric", "_serverSide", C.TypeVariable_Type_LinkedHashMap_mTw_V, C.TypeVariable_Type__SplayTree_STv_K, "eventData", "eventKind", "sender", C.TypeVariable_Type_ListMixin_Ism_E, "payload", "onExit", C.TypeVariable_Type__SplayTreeValueIterable_F4j_K, "fillValue", "replacement", "column", C.TypeVariable_Type__SplayTreeValueIterator_F4j_V, C.TypeVariable_Type__StreamImplEvents_Q06_T, C.TypeVariable_Type_IterableMixin_cJC_E, C.TypeVariable_Type__SplayTreeValueIterator_F4j_K, "errorHandler", C.TypeVariable_Type__SplayTreeIterator_gg4_T, "_protocolSelector", "opcode", "fractionDigits", "allowTrailingOptions", "base64", "application/octet-stream", "percentEncoded", "contents", "radix", "encodedComponent", C.TypeVariable_Type__StreamImpl_7xV_T, C.TypeVariable_Type_StreamController_QWq_T, "prefix", "openedFile", "transition", "parser", "base", C.TypeVariable_TOW, "rawIndex", "factor", "matched", "segments", C.TypeVariable_Type_LinkedHashMap_mTw_K, "indices", "slashTerminated", "canonicalTable", C.FileMode_0, "hasAuthority", "sourceAddress", C.TypeVariable_Type_Queue_jXq_E, "_second", "key2", "allowScheme", "strictIPv6", "spaceToPlus", "pos", "plusToSpace", "_text", "_separatorIndices", "_uriCache", "charsetName", "firstSegment", "sourceUri", "_uri", "_schemeEnd", "_hostStart", "_portStart", "_pathStart", "_queryStart", "_fragmentStart", "_schemeCache", "_data", "fragmentStart", "queryStart", "quotient", "pathStart", "portStart", "hostStart", "schemeEnd", "ss", "segment", "equalsIndex", "_lineParser", "chars", "_fragment", "range", "_query", "when", "_port", "sequenceNumber", "_host", "errorDetail", "_userInfo", "_stackTrace", "stackTraceString", "caseSensitive", "label", "multiLine", "min", C.C__Growable, "variableName", "modifiedObject", "serverUri", "existingArgumentNames", "receiver", "className", "endName", "_taskId", "_start", "_startCpu", "phase", "startName", "_duration", "startCpu", "copy", "microseconds", "milliseconds", "addLineSeparator", "ignoreInvalidCharacters", "_chunkSizeInWords", "_digestSizeInWords", "_bigEndianWords", "seconds", "minutes", "hours", "days", "microsecondsSinceEpoch", "millisecondsSinceEpoch", "formattedString", "units", "nextCodeUnit", "_filter", "leadingSurrogate", "byteStream", "_allowMalformed", "tail", "_mode", "lead", "_path", "_position", "_end", "_file", "stringBuffer", "stringSink", "onClose", "_type", "changed", "modified", "accessed", "_bufferSize", 256, "cause", "contentChanged", "destination", "unsupportedObject", "_escape", C.HtmlEscapeMode_p2v, "custom", "codec", "converter", "outIndex", "expectedPadding", "paddingCount", "firstPadding", "sourceEnd", "sourceIndex", "_utf8Sink", "_allowInvalid", "e2", "e1", "currentNode", "lowerCase", "key1", "redirects", "comp", 80, "newElementCount", "defaultPortForScheme", "expectedModificationCount", "newContents", "retainMatching", "_transferLength", "updateFirst", "newEntry", "_httpConnection", "_httpRequest", "entries", "_tree", "defaultHeaders", "serverHeader", "_proxy", "_httpClientConnection", "_consume", "set", "sentinel", "_proxyTunnel", "_queue", "_iterator", "parts", "keyValuePairs", "otherZone", "_closeServer", "configuration", "_scheme", "outputSink", "flag", "wasInputPaused", "pendingEvents", "st", "_subscription", "_injectData", "_userOnData", "timer", "_requestParser", "streamTransformer", "_sessionManager", "streamConsumer", "listener", "sourceResult", "keepGoing", "theStackTrace", "_encoding", "theError", "sub", C.ProcessStartMode_0, "onResumeHandler", "onPauseHandler", "eventId", "zoneSpecification", "body", "_delegationTarget", "_handleDone", C.ProcessSignal_15_SIGTERM, "_handleError", "exitCode", "stdout", "stderr", "_signalNumber", "_handleData", "mapper", "_sharedState", "expand", "identifier", "transform", "onSuccess", "_socketSubscription", "_bufferedData", "defaultTransition", "userCode", "includeLoopback", "includeLinkLocal", "onCancelHandler", "reuseAddress", "_fd", "onListenHandler", "_onDone", "_pending", "varData", "notificationHandler", "transformer", "mapSink", "onComplete", C.Deprecated_R41, "onValue", "cleanUp", "maxWindowBits", "eagerError", "_deflate", "_s", "falseValue", "_compression", "trueValue", "flagW", "compressed", "deflate", "required", "shift", "dataIndex", "word", "flagZ", "exists", "block", "flagY", "flagX", "newW", "newZ", "newY", "newX", "fl", "typeArgument", "markClosed", "escapeDelimiters", "groups_", "chunkedTransferEncoding", "ifModifiedSince", "contentType", "builder", "group_", "g", "groups", "followLoops", "proxyAuth", "arg4", "credsAvailable", "p", "bufferOutput", "reasonPhrase", 302, "writeHeaders", "maxRedirects", "followRedirects", "arg3", "drainRequest", "setOutgoing", "numberOfArguments", "secureSocket", "closure", "newHandler", "errorMessage", "client", "times", "tunnel", "replace", "proxyConf", "prev", "onNonMatch", "onMatch", "precision", "collection", "val1", "val2", "transferLength", C.TypeVariable_Type__HttpOutboundMessage_Q0A_T, "secureConnection", C.TypeVariable_Type_FutureOr_Ozn_T, "dummy", "direction", "useSessionCache", "inputData", "getData", "outBytes", "retainNewlines", "sep", C.TypeVariable_Type__AddStreamState_ifH_T, "interval", C.TypeVariable_Type_StreamIterator_sgl_T, "controlPort", "pauseCapability", "terminateCapability", "packageUri", "entryPoint", C.TypeVariable_Type__RectangleBase_O5w_T, C.TypeVariable_Type__TypeTest_7QV_T, C.TypeVariable_Type__SplayTree_STv_Node, C.TypeVariable_Ck9, "checked", "packageRoot", "packageConfig", "automaticPackageResolution", "rawPort", "stackDescription", C.TypeVariable_2No, C.TypeVariable_Type_StreamTransformer_alc_T, C.TypeVariable_Type_StreamTransformer_alc_S, C.TypeVariable_Type_ChunkedConverter_yzN_T2, "exponent", "seed", C.TypeVariable_Type_ChunkedConverter_yzN_S2, C.TypeVariable_Type_Codec_1xO_T, C.TypeVariable_Type_Codec_1xO_S, C.TypeVariable_TTS, "typeArguments", "trimmedText", "isDocComment", "symbols", "targets", "metaTargets", "override", "_littleEndian", C.TypeVariable_wsa, "options", C.TypeVariable_Type_Sink_wrR_T, C.TypeVariable_Type_StreamConsumer_epf_S, C.TypeVariable_Type__PendingEvents_v74_T, C.TypeVariable_Type__DelayedEvent_kaS_T, C.TypeVariable_Type_StreamSubscription_GVy_T, C.TypeVariable_Type__EventSink_ciW_T, C.TypeVariable_Type__EventDispatch_yvL_T, C.TypeVariable_Type__FutureListener_XVS_S, C.TypeVariable_Type_Future_JO4_T, C.TypeVariable_Type_Completer_CNi_T, "allowMultiple", C.TypeVariable_Type_Stream_qXA_T, C.Deprecated_kXN, "parsed", C.TypeVariable_Type_Expando_lCi_T, C.TypeVariable_Type_Iterator_T5k_E, "_parser", "_parsed", C.TypeVariable_Type_Map_2Zi_V, "commandName", "grammar", "innermostCommand", "condition", C.TypeVariable_Type_Map_2Zi_K, "optionsAndSeparators", C.TypeVariable_Type_Comparable_Q43_T, "shapeDefinition", "_r", C.TypeVariable_Type_Iterable_K9t_E, "_y", "_filename", "persistentConnection"];
  init.types = [P.int, P.Object, H.Closure, {func: 1, args: [,]}, {func: 1}, {func: 1, ret: P.bool}, {func: 1, v: true}, {func: 1, ret: P.String}, P.bool, P.String, null, {func: 1, ret: P.int}, {func: 1, args: [,,]}, {func: 1, args: [P.String]}, [P.List, P.int], {func: 1, ret: P.bool, args: [P.Object]}, {func: 1, ret: P.int, args: [P.int]}, {func: 1, v: true, args: [P.int]}, {func: 1, ret: P.Future}, {func: 1, v: true, args: [P.String]}, {func: 1, ret: P.Type}, P.ProcessSignal, {func: 1, args: [P.int]}, P.double, {func: 1, ret: P.bool, args: [,]}, {func: 1, ret: P.String, args: [P.int]}, {func: 1, v: true, args: [[P.List, P.int]]}, {func: 1, v: true, args: [,]}, {func: 1, ret: P.String, args: [P.String]}, P.Function, {func: 1, ret: P.bool, args: [P.String]}, {func: 1, ret: P.int, args: [P.String]}, {func: 1, ret: P.bool, args: [P.int]}, {func: 1, args: [P.bool]}, P.Error, {func: 1, v: true, args: [P.bool]}, P.Uri, {func: 1, v: true, args: [{func: 1, v: true}]}, P.TypedData, P.ByteConversionSink, {func: 1, args: [P.String, P.String]}, P.Completer, [P.Stream, [P.List, P.int]], {func: 1, ret: P.Uri}, {func: 1, v: true, args: [[P.List, P.int], P.int, P.int, P.bool]}, {func: 1, ret: P.Symbol}, P.num, {func: 1, v: true, typedef: P.ControllerCallback}, {func: 1, v: true, args: [P.Object], opt: [P.StackTrace]}, {func: 1, v: true, args: [P.Object, P.StackTrace]}, P.List, P.Zone, {func: 1, ret: P.double}, {func: 1, ret: P.TypeMirror}, {func: 1, ret: P.bool, args: [P.TypeMirror]}, {func: 1, args: [,], typedef: P._ToEncodable}, {func: 1, ret: P.ClassMirror}, P.StringSink, {func: 1, ret: P.num, args: [P.num]}, {func: 1, ret: [P.List, P.InstanceMirror]}, {func: 1, v: true, args: [P.String,,]}, [P.List, P.String], [P.Stream, 549], {func: 1, ret: P.InstanceMirror, args: [P.Symbol, P.List], opt: [[P.Map, P.Symbol,,]]}, {func: 1, v: true, args: [P.Object]}, P.Duration, P._Future, 563, {func: 1, ret: P.InternetAddress}, {func: 1, ret: [P.List, P.int]}, {func: 1, ret: P.int, args: [P.int, P.int]}, {func: 1, v: true, args: [, P.StackTrace]}, {func: 1, ret: P.double, args: [P.num]}, P.StringConversionSink, P.IOException, P.DateTime, {func: 1, v: true, args: [P.int, P.int]}, {func: 1, args: [P.Invocation]}, P.IOSink, P.Encoding, {func: 1, args: [, P.StackTrace]}, {func: 1, v: true, args: [,], opt: [P.StackTrace]}, [P.Map, P.String, P.String], {func: 1, ret: P.Duration}, [P._BroadcastSubscription, 141], {func: 1, ret: P.DateTime}, P.Future, {func: 1, v: true, args: [P.String, P.int, P.int, P.bool]}, {func: 1, ret: [P.Map, P.Symbol, P.MethodMirror]}, P.Uint8List, {func: 1, v: true, typedef: P._DoneHandler}, P._DelayedEvent, {func: 1, ret: P.String, opt: [P.String]}, {func: 1, ret: [P.List, P.String]}, {func: 1, ret: [P.StreamSubscription, [P.List, P.int]], args: [{func: 1, v: true, args: [[P.List, P.int]]}], named: {cancelOnError: P.bool, onDone: {func: 1, v: true}, onError: P.Function}}, P.OSError, {func: 1, ret: [P.List, P.int], args: [P.int], opt: [P.int]}, {func: 1, ret: P.HttpConnectionInfo}, {func: 1, ret: P.Int32x4, args: [P.Float32x4]}, P.ByteConversionSinkBase, P.StringConversionSinkBase, {func: 1, typedef: P.ControllerCancelCallback}, P.Exception, P.StreamSubscription, {func: 1, ret: [P.Future, P.Socket]}, {func: 1, ret: [P.List, P.int], args: [P.int]}, {func: 1, ret: [P.Map, P.String, P.String]}, {func: 1, ret: P.Float32x4, args: [P.Float32x4]}, {func: 1, ret: P.InstanceMirror, args: [P.Symbol, P.Object]}, {func: 1, ret: P.Int32x4, args: [P.int]}, {func: 1, ret: P.Directory}, {func: 1, v: true, named: {recursive: P.bool}}, {func: 1, ret: P.InstanceMirror, args: [P.Symbol]}, {func: 1, ret: P.int, args: [P.int], opt: [P.Endianness]}, {func: 1, v: true, args: [P.int, P.int], opt: [P.Endianness]}, P.FileSystemEntity, {func: 1, ret: [P.Future, P.HttpClientRequest], args: [P.String, P.int, P.String]}, {func: 1, ret: [P.Future, P.HttpClientRequest], args: [P.Uri]}, {func: 1, ret: P.Float32x4}, {func: 1, ret: P.Float32x4, args: [P.double]}, 252, {func: 1, ret: P.Float64x2, args: [P.Float64x2]}, P.Map, {func: 1, ret: P.SourceLocation}, {func: 1, v: true, args: [147], typedef: [P._DataHandler, 147]}, {func: 1, ret: P.DeclarationMirror}, [P._PendingEvents, 147], P.Socket, P.Timer, {func: 1, ret: [P.Future, P.bool]}, {func: 1, ret: [P.List, P.TypeVariableMirror]}, {func: 1, ret: [P.List, P.TypeMirror]}, {func: 1, ret: [P.Map, P.Symbol, P.DeclarationMirror]}, P._Filter, {func: 1, v: true, opt: [P.Object]}, {func: 1, v: true, args: [P.Iterable], opt: [P.String]}, {func: 1, args: [P.Uri]}, [P.List, P.Cookie], P.SecurityContext, P._HttpHeaders, {func: 1, ret: [P.Map, P.String,,]}, {func: 1, ret: [P.List, P.int], args: [P.String]}, P._HttpClientCredentials, P.Mirror, P.HtmlEscapeMode, {func: 1, args: [P.EventSink]}, {func: 1, v: true, args: [P.DateTime]}, {func: 1, args: [P.String, P.int]}, {func: 1, args: [P.int, P.String]}, {func: 1, ret: P.String, args: [P.String, P.int, P.int]}, {func: 1, args: [P.Symbol,,]}, J.Interceptor, {func: 1, v: true, args: [[P.Iterable, P.Object]]}, [P.StreamConsumer, 285], P._HttpSession, {func: 1, ret: P.num}, [P.StreamController, 285], P.SocketOption, {func: 1, ret: P.String, args: [[P.List, P.int]]}, {func: 1, ret: P.ByteConversionSink, args: [[P.Sink, P.String]]}, {func: 1, ret: [P.Future, P.int]}, {func: 1, args: [P.Socket]}, {func: 1, v: true, args: [P.Duration]}, {func: 1, args: [,], opt: [P.StackTrace]}, {func: 1, v: true, args: [P.Function]}, {func: 1, v: true, args: [P._HttpClientConnection]}, P._Zone, {func: 1, opt: [P.String]}, {func: 1, ret: P.Int32x4, args: [P.Int32x4]}, {func: 1, ret: P.ByteBuffer}, {func: 1, args: [P.Object]}, {func: 1, ret: P.Timer, args: [P.Duration, {func: 1, v: true}]}, {func: 1, ret: [P.List, P.int], args: [P.String], opt: [P.int, P.int]}, {func: 1, ret: P.StringConversionSink, args: [[P.Sink, [P.List, P.int]]]}, {func: 1, v: true, args: [P.SendPort]}, [P.StreamSubscription, [P.List, P.int]], {func: 1, ret: P.Int32x4, args: [P.bool]}, {func: 1, v: true, args: [P.RandomAccessFile]}, {func: 1, ret: [P.List, P.ClassMirror]}, {func: 1, named: {allowInvalid: P.bool}}, {func: 1, ret: P.Float64x2}, {func: 1, args: [P.StringConversionSink]}, {func: 1, ret: P.Float64x2, args: [P.double]}, P.FileLock, [P._SplayTreeNode, 314], P._HttpIncoming, P.InternetAddress, {func: 1, args: [P.String, P.bool]}, {func: 1, v: true, args: [P.Uint8List, P.int, P.int]}, [P.Converter, [P.List, P.int], P.String], {func: 1, ret: P.bool, args: [P.ClassMirror]}, {func: 1, ret: [P.List, P.Cookie]}, [P.ChunkedConverter, P.String, [P.List, P.int], P.String, [P.List, P.int]], {func: 1, ret: [P.Future, P.ServiceExtensionResponse], args: [P.String, [P.Map, P.String, P.String]]}, [P.Converter, P.String, [P.List, P.int]], 254, {func: 1, ret: P.Match}, {func: 1, ret: P.bool, args: [P.Duration]}, {func: 1, ret: P.StackTrace}, {func: 1, ret: P.bool, args: [P.num]}, P.DeclarationMirror, {func: 1, v: true, args: [P._DelayedEvent]}, [P.Map, 514, 504], P.StdioType, {func: 1, ret: P.Timer, args: [P.Duration, {func: 1, v: true, args: [P.Timer]}]}, {func: 1, ret: [P.Future, P.HttpClientResponse]}, {func: 1, v: true, args: [P._Credentials]}, {func: 1, ret: P.Encoding}, 342, {func: 1, ret: P.Zone}, [P._AddStreamState, 141], P.InternetAddressType, {func: 1, ret: P.Future, args: [[P.Stream, [P.List, P.int]]]}, P.FileSystemEvent, {func: 1, ret: P.bool, args: [P.Map]}, {func: 1, v: true, args: [P.String, P.String]}, P._AsyncCallbackEntry, {func: 1, v: true, opt: [P.Future]}, {func: 1, v: true, args: [P.Uint8List, P.String, P.int]}, P.RawSocketEvent, {func: 1, ret: P.Iterable}, P.StackTrace, {func: 1, ret: P.int, args: [P.Object], opt: [P.int]}, [P.Stream, P.RawSocketEvent], {func: 1, v: true, args: [P.String], named: {arguments: P.Map}}, [P._SplayTreeNode, 215], P.BytesBuilder, [P.List, [P._SplayTreeNode, 215]], {func: 1, args: [P._HttpConnection]}, {func: 1, ret: P.Uint8List, args: [P.int]}, 318, [P._SplayTree, 215, [P._SplayTreeNode, 215]], [P.ChunkedConverter, [P.List, P.int], P.String, [P.List, P.int], P.String], {func: 1, ret: P.X509Certificate}, {func: 1, ret: P._AuthenticationScheme}, P.ZoneDelegate, P.StreamController, P.EventSink, [P._Future, 353], {func: 1, opt: [P.String, P.OSError]}, {func: 1, ret: [P.Future, P.ServiceExtensionResponse], args: [,,]}, {func: 1, ret: [P.Iterable, [P.Map, P.String, P.String]]}, {func: 1, ret: [P.Future, P.bool], args: [P.String]}, {func: 1, named: {dictionary: [P.List, P.int], gzip: P.bool, level: P.int, memLevel: P.int, raw: P.bool, strategy: P.int, windowBits: P.int}}, {func: 1, opt: [P.Object]}, {func: 1, args: [P.int], named: {isUtc: P.bool}}, {func: 1, ret: P.DateTime, args: [P.String]}, P._Base64Encoder, [P.Sink, P.String], {func: 1, args: [[P.Sink, [P.List, P.int]]]}, [P.Sink, [P.List, P.int]], {func: 1, args: [{func: 1, v: true, typedef: P.ControllerCallback}, {func: 1, v: true, typedef: P.ControllerCallback}, {func: 1, v: true, typedef: P.ControllerCallback}, {func: 1, typedef: P.ControllerCancelCallback}]}, {func: 1, args: [{func: 1, v: true}, {func: 1, v: true}]}, {func: 1, ret: P.String, args: [G.Option]}, P._JsonStringifier, {func: 1, v: true, args: [P.Uint8List, P.int, P.int], typedef: P._AddChunk}, P.StringBuffer, {func: 1, v: true, args: [P._HttpSession]}, [P.LinkedList, 252], [P.Map, P.String, [P.List, P.String]], P.RegExp, {func: 1, v: true, args: [P.Encoding]}, {func: 1, v: true, args: [P._HttpConnection]}, {func: 1, ret: P.bool, args: [P.X509Certificate]}, {func: 1, v: true, args: [P.String, P.Object]}, {func: 1, ret: [P.Future, P.RandomAccessFile], args: [P.int]}, {func: 1, ret: P.File, args: [P.String]}, {func: 1, v: true, args: [,,]}, {func: 1, ret: P.ByteConversionSink, args: [[P.Sink, [P.List, P.int]]]}, {func: 1, ret: [P.List, P.int], args: [[P.List, P.int]]}, [P.StreamConsumer, [P.List, P.int]], {func: 1, ret: P.UserTag}, {func: 1, ret: P.UriData}, {func: 1, ret: P.Uri, named: {fragment: P.String, host: P.String, path: P.String, pathSegments: [P.Iterable, P.String], port: P.int, query: P.String, queryParameters: [P.Map, P.String,,], scheme: P.String, userInfo: P.String}}, P.HttpClientCredentials, {func: 1, ret: P.bool, args: [P.DateTime]}, {func: 1, v: true, args: [[P.List, P.int], P.int, P.int]}, {func: 1, ret: P.ByteConversionSink, args: [P.bool]}, {func: 1, args: [[P.EventSink, P.String]]}, P._HttpClient, P._HttpOutgoing, {func: 1, ret: [P.List, P.String], args: [P.String]}, [P.DoubleLinkedQueue, 317], {func: 1, ret: P.String, args: [P.Object]}, {func: 1, ret: P.StringConversionSink, args: [[P.Sink, P.String]]}, {func: 1, v: true, args: [P.String, P.int]}, M.Shape, {func: 1, v: true, args: [P.Map]}, {func: 1, ret: P.Map}, P.ProcessStartMode, {func: 1, ret: P.ZoneDelegate}, {func: 1, v: true, args: [,], opt: [,]}, {func: 1, ret: P.Function}, P.SocketDirection, {func: 1, v: true, opt: [,]}, {func: 1, ret: P.MethodMirror}, {func: 1, ret: [P.List, P.ParameterMirror]}, P.CompressionOptions, P._WebSocketPerMessageDeflate, P.Capability, {func: 1, args: [P.Symbol, P.Mirror]}, {func: 1, args: [, P.String]}, {func: 1, ret: P.SendPort}, P.ObjectMirror, {func: 1, v: true, opt: [P.Random]}, P.TypeMirror, P.Endianness, {func: 1, v: true, args: [P.String, P.int, P.int]}, {func: 1, ret: P.HttpHeaders}, {func: 1, v: true, args: [{func: 1, v: true, typedef: P._AsyncCallback}]}, {func: 1, ret: P.Uri, args: [P.String]}, {func: 1, ret: P.Uri, args: [P.Uri]}, {func: 1, ret: P.String, named: {windows: P.bool}}, {func: 1, ret: [P.List, P.double], args: [P.int], opt: [P.int]}, {func: 1, v: true, args: [P.int, P.int, P.int]}, {func: 1, ret: P.String, named: {encoding: P.Encoding}}, {func: 1, ret: P.Uint8List, args: [,,]}, {func: 1, args: [P.String,,]}, {func: 1, args: [P.double]}, {func: 1, v: true, opt: [, P.StackTrace]}, {func: 1, args: [[P.List, P.int]]}, {func: 1, args: [[P.List, P.int], P.int]}, {func: 1, ret: P.ZLibEncoder}, {func: 1, ret: P.ZLibDecoder}, {func: 1, ret: P.Float32x4, args: [P.Float32x4, P.Float32x4]}, {func: 1, ret: [P.List, P.String], args: [[P.List, P.int]]}, {func: 1, ret: [P.Future, P.Directory], named: {recursive: P.bool}}, {func: 1, ret: P.Directory, args: [P.String]}, {func: 1, ret: [P.Iterator, P.Match]}, {func: 1, ret: H.JsTypeMirror}, {func: 1, ret: [P.Future, P.File], named: {recursive: P.bool}}, {func: 1, ret: [P.Future, P.File], args: [P.String]}, {func: 1, ret: [P.Future, P.DateTime]}, {func: 1, ret: P.Future, args: [P.DateTime]}, {func: 1, ret: [P.Future, [P.List, P.int]], args: [P.RandomAccessFile]}, {func: 1, ret: [P.Future, P.RandomAccessFile]}, {func: 1, ret: P.int, args: [[P.List, P.int]], opt: [P.int, P.int]}, {func: 1, args: [{func: 1, v: true}]}, {func: 1, ret: [P.Future, P.String]}, {func: 1, ret: P.LibraryMirror, args: [P.Symbol]}, {func: 1, args: [P.int,,]}, {func: 1, ret: P.Iterator}, {func: 1, args: [P.String, [P.List, P.String]]}, {func: 1, ret: P.LibraryMirror}, {func: 1, ret: P.HttpSession}, {func: 1, ret: {func: 1, v: true, typedef: P.ControllerCallback}}, {func: 1, ret: P._Future}, {func: 1, ret: P.Error}, {func: 1, ret: P._Credentials, args: [P._AuthenticationScheme]}, {func: 1, ret: P.Future, args: [P._AuthenticationScheme, P.String]}, {func: 1, v: true, args: [[P.List, P.int], {func: 1, v: true, args: [[P.List, P.int]]}]}, {func: 1, ret: [P.Future, P.Null]}, {func: 1, ret: P.bool, args: [P.Pattern], opt: [P.int]}, {func: 1, ret: P.String, args: [P.int], opt: [P.String]}, {func: 1, args: [P._ConnectionInfo]}, {func: 1, ret: P._HttpClientRequest, args: [P._ConnectionInfo]}, {func: 1, args: [P._HttpClientRequest]}, {func: 1, ret: [P.Future, P._ConnectionInfo], args: [,]}, {func: 1, args: [P._SiteCredentials,,]}, {func: 1, ret: P.Map, args: [P.bool]}, {func: 1, ret: P.HttpConnectionsInfo}, {func: 1, ret: [P.Map, P.String,,], args: [P.bool]}, {func: 1, ret: P.bool, args: [P.SocketOption, P.bool]}, {func: 1, v: true, args: [P._Future]}, {func: 1, v: true, args: [P.HttpClientRequest]}, {func: 1, v: true, args: [P._Credentials, P.HttpClientRequest]}, {func: 1, v: true, args: [P._ProxyCredentials, P.HttpClientRequest]}, {func: 1, args: [P.Map]}, {func: 1, ret: [P.Future, P.Link], args: [P.String]}, {func: 1, ret: P.Link, args: [P.String]}, {func: 1, args: [, P.String, P.String]}, {func: 1, ret: [P.Iterable, P.String]}, {func: 1, args: [P.RawSecureSocket]}, {func: 1, v: true, args: [[P.List, P.int], P.String]}, {func: 1, v: true, args: [P._FutureListener]}, {func: 1, args: [P.WebSocket]}, {func: 1, ret: [P.Future, P.WebSocket], args: [P.String]}, {func: 1, ret: P.Uint8List, args: [[P.List, P.int]]}, {func: 1, args: [[P.EventSink, [P.List, P.int]]]}, {func: 1, v: true, args: [P.Capability]}, {func: 1, ret: P.bool, args: [[P.Rectangle, P.num]]}, {func: 1, v: true, args: [P.int, P.String]}, {func: 1, ret: P.InstanceMirror, args: [P.Object]}, {func: 1, args: [,], opt: [,]}, V.ArgResults, {func: 1, args: [P._EventSink]}, {func: 1, v: true, args: [P.StreamSubscription, P._Future,, P.StackTrace]}, {func: 1, ret: P.AsyncError, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Object, P.StackTrace]}, {func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, v: true}]}, {func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, v: true, args: [P.Timer]}]}, {func: 1, v: true, args: [P.Zone, P.ZoneDelegate, P.Zone, P.String]}, {func: 1, ret: P.Zone, args: [P.Zone, P.ZoneDelegate, P.Zone, P.ZoneSpecification, P.Map]}, {func: 1, ret: P.String, args: [P.Iterable], opt: [P.String, P.String]}, {func: 1, ret: P.int, args: [,,]}, {func: 1, ret: P.bool, args: [P.Map, P.Object]}, {func: 1, ret: P.String, args: [P.Map]}, {func: 1, opt: [P.int]}, [P.LinkedListEntry, 212], {func: 1, args: [P.ByteConversionSink]}, {func: 1, args: [P.StringSink,,]}, {func: 1, args: [{func: 1, args: [,]}, P.int, {func: 1, v: true, args: [P.Uint8List, P.int, P.int], typedef: P._AddChunk}]}, {func: 1, args: [P.Timer]}, {func: 1, args: [[P.Sink, P.String]]}, {func: 1, named: {allowMalformed: P.bool}}, {func: 1, args: [P.int], opt: [P.int, P.int, P.int, P.int, P.int, P.int, P.int]}, {func: 1, ret: P.int, args: [P.Pattern], opt: [P.int]}, {func: 1, opt: [,]}, {func: 1, v: true, args: [P._EventDispatch]}, {func: 1, ret: P.Uri, args: [P.String, P.String], opt: [[P.Map, P.String, P.String]]}, {func: 1, ret: P.Uri, args: [P.String], named: {windows: P.bool}}, {func: 1, ret: P.String, args: [P.String], named: {encoding: P.Encoding}}, {func: 1, ret: P._Uri, args: [P.String, P.String], opt: [[P.Map, P.String, P.String]]}, {func: 1, ret: P.bool, args: [P.String, P.String]}, {func: 1, ret: P._Uri, args: [P.String], named: {windows: P.bool}}, {func: 1, ret: P.int, args: [P.String, P.int]}, {func: 1, ret: [P.Map, P.String, [P.List, P.String]]}, {func: 1, v: true, args: [P.Metric]}, {func: 1, args: [P.String, P.int, P.int]}, {func: 1, opt: [P.String, P.int]}, {func: 1, args: [P.Object, P.String], opt: [P.String]}, {func: 1, ret: P.Object, args: [P.Object]}, {func: 1, ret: P._HttpParser}, {func: 1, args: [P._FileResourceInfo]}, {func: 1, args: [P._ProcessResourceInfo]}, {func: 1, args: [P._SocketResourceInfo]}, {func: 1, ret: P.SecurityContext}, {func: 1, ret: P.Uint8List, args: [[P.List, P.String]]}, {func: 1, args: [[P.Stream, [P.List, P.int]]]}, {func: 1, args: [P.String], opt: [P.OSError]}, {func: 1, ret: P.Stdin}, {func: 1, ret: P.Stdout}, {func: 1, ret: P.bool, args: [P.HttpRequest]}, {func: 1, opt: [[P.List, P.int]]}, {func: 1, ret: [P.Future, P.Uri]}, {func: 1, ret: P.MirrorSystem}, {func: 1, args: [P.num]}, {func: 1, args: [[P.List, P.String]]}, {func: 1, ret: P.int, args: [P.num]}, J.JSIndexable, J.JSNumber, {func: 1, ret: P.Zone, named: {specification: P.ZoneSpecification, zoneValues: P.Map}}, {func: 1, ret: P.AsyncError, args: [P.Object, P.StackTrace]}, {func: 1, ret: H.JsLibraryMirror}, [P._StreamControllerLifecycle, 381], [P._BroadcastSubscription, 392], [P._StreamControllerLifecycle, 305], {func: 1, ret: P.InstanceMirror}, [P.Stream, 494], {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone,, P.StackTrace]}, {func: 1, ret: P.bool, args: [[P.Iterable, P.Object]]}, [P.Stream, 176], {func: 1, v: true, args: [[P.StreamSubscription, 176]], typedef: [P._BroadcastCallback, 176]}, {func: 1, ret: [P.Iterable, P.Match], args: [P.String], opt: [P.int]}, [P._ForwardingStream, 385, 384], [P.StreamSubscription, 385], {func: 1, ret: [P.EventSink, 261], args: [[P.EventSink, 263]], typedef: [P._SinkMapper, 261, 263]}, {func: 1, ret: P.bool, args: [P._SplayTreeMapNode]}, {func: 1, ret: P.TypeMirror, args: [P.int]}, {func: 1, v: true, args: [{func: 1, v: true, args: [,,]}]}, {func: 1, ret: P.String, args: [[P.List, P.int]], named: {allowInvalid: P.bool}}, [P.Map, P.String,,], [P._SplayTreeMapNode, 122, 247], {func: 1, ret: P.bool, args: [,], typedef: P._Predicate0}, {func: 1, ret: [P.Stream, [P.List, P.int]], args: [[P.Stream, P.String]]}, [P._SplayTreeNode, 168], {func: 1, ret: P.String, args: [[P.List, P.int]], opt: [P.int, P.int]}, {func: 1, ret: [P.Stream, P.String], args: [[P.Stream, [P.List, P.int]]]}, P._UnicodeSubsetEncoder, P._UnicodeSubsetDecoder, P.Sink, P._Base64EncoderSink, {func: 1, ret: P.Sink, args: [P.Sink]}, P.HtmlEscape, {func: 1, args: [,,], typedef: P._Reviver}, [P.ChunkedConversionSink, P.Object], [P.EventSink, P.String], P.ClosableStringSink, P._Utf8Decoder, P.Base64Codec, P.ArgumentError, P.Pattern, [P.List, P.Uint8List], P.Metric, P._HashBase, [P.Codec, [P.List, P.int], [P.List, P.int]], [P.Converter, [P.List, P.int], [P.List, P.int]], P._FilterSink, [P.StreamController, [P.List, P.int]], P.RandomAccessFile, P.File, {func: 1, v: true, args: [P.List]}, P.SendPort, {func: 1, ret: P.Match, args: [P.String], opt: [P.int]}, {func: 1, v: true, args: [P.num]}, P.ContentType, P.HeaderValue, {func: 1, ret: P.Float32x4, args: [P.int]}, [P.List, P.RedirectInfo], P.HttpHeaders, P.HttpResponse, P._HttpServer, P._HttpInboundMessage, {func: 1, ret: P.StreamSubscription, args: [{func: 1, v: true, args: [,]}], named: {cancelOnError: P.bool, onDone: {func: 1, v: true}, onError: P.Function}}, {func: 1, ret: P.ClosableStringSink}, P._HttpClientConnection, P._Proxy, {func: 1, v: true, args: [[P.List, P.int]], typedef: P._BytesConsumer}, P._HttpParser, [P.Set, P._HttpClientConnection], P.HttpClient, P._HttpSessionManager, [P.LinkedList, P._HttpConnection], {func: 1, ret: P.int, args: [P.String, P.int, P.int]}, P._Credentials, P._IOResourceInfo, P._ReadWriteResourceInfo, [P.Map, P.String, 535], {func: 1, ret: P.int, args: [, P.int]}, P.RawSocket, P.TlsException, {func: 1, ret: P.num, args: [P.int], opt: [P.Endianness]}, {func: 1, ret: P.DateTime, args: [P.Duration]}, {func: 1, ret: P.Duration, args: [P.Duration]}, P.StreamSink, P.Stream, [P.EventSink, [P.List, P.int]], P._WebSocketImpl, P.Stdout, 491, {func: 1, v: true, args: [P.int, P.num], opt: [P.Endianness]}, {func: 1, ret: P.List}, {func: 1, v: true, args: [P.String], opt: [,]}, [P.List, P.double], [P.Map, P.String, G.Option], [P.Map, P.String, N.ArgParser], N.ArgParser, 314, {func: 1, args: [P.UriData, P.String, P.String]}, {func: 1, ret: P.Stream}, {func: 1, ret: P.int, args: [P.FileLock]}, {func: 1, ret: P.bool, args: [[P.Point, P.num]]}, {func: 1, ret: N.ArgParser, args: [P.String], opt: [N.ArgParser]}, {func: 1, v: true, args: [P.String], named: {abbr: P.String, callback: {func: 1, v: true, args: [P.bool]}, defaultsTo: P.bool, help: P.String, hide: P.bool, negatable: P.bool}}, {func: 1, v: true, args: [P.String], named: {abbr: P.String, allowMultiple: P.bool, allowed: [P.List, P.String], allowedHelp: [P.Map, P.String, P.String], callback: {func: 1, v: true, args: [,]}, defaultsTo: P.String, help: P.String, hide: P.bool, splitCommas: P.bool, valueHelp: P.String}}, {func: 1, v: true, args: [P.String, P.String, P.String, P.String, [P.List, P.String], [P.Map, P.String, P.String],, {func: 1, v: true, args: [,]}, G.OptionType], named: {hide: P.bool, negatable: P.bool, splitCommas: P.bool}}, {func: 1, ret: V.ArgResults, args: [[P.List, P.String]]}, {func: 1, ret: G.Option, args: [P.String]}, {func: 1, ret: V.ArgResults}, {func: 1, v: true, args: [G.Option]}, {func: 1, ret: P.bool, args: [G.Parser]}, {func: 1, v: true, args: [P.bool, P.String]}, {func: 1, v: true, args: [P.Map, G.Option, P.String]}, {func: 1, v: true, args: [P.Map, G.Option, P.bool]}, {func: 1, v: true, args: [G.Option, P.String]}, {func: 1, ret: P._FutureListener, args: [P._FutureListener]}, {func: 1, ret: [P.Future, P.RandomAccessFile], opt: [P.FileLock, P.int, P.int]}, {func: 1, ret: M.Shape, args: [P.String]}, {func: 1, args: [H.TypeImpl]}, {func: 1, ret: P.String, args: [P.Match]}, {func: 1, ret: [P.Future, P.RandomAccessFile], opt: [P.int, P.int]}, {func: 1, args: [P.Function, P.Object, P.StackTrace]}, {func: 1, ret: P.Function, args: [P.Function, P.Zone]}, {func: 1, args: [{func: 1, v: true, typedef: P.ControllerCallback}, {func: 1, typedef: P.ControllerCancelCallback}]}, {func: 1, v: true, opt: [P.FileLock, P.int, P.int]}, {func: 1, args: [P.String], named: {uri: P.String}}, {func: 1, ret: P.Future, args: [{func: 1}]}, {func: 1, args: [P.String], opt: [P.Duration]}, {func: 1, v: true, args: [P._Future,,,]}, {func: 1, ret: [P.Future, P.String], opt: [P.String]}, {func: 1, v: true, args: [P.Future, P._Future]}, {func: 1, v: true, args: [P._Future, P._Future]}, {func: 1, v: true, args: [P._Future, P._FutureListener]}, {func: 1, args: [{func: 1, v: true, typedef: P._AsyncCallback}]}, {func: 1, v: true, opt: [P.int, P.int]}, {func: 1, ret: P._AsyncRun}, {func: 1, ret: [P.Future, P.bool], args: [P.Object]}, {func: 1, v: true, args: [{func: 1, typedef: P._NotificationHandler}]}, {func: 1, args: [P.StreamController]}, {func: 1, ret: P.Future, args: [P.int, P.List], named: {markClosed: P.bool}}, {func: 1, args: [{func: 1, v: true, typedef: P._DoneHandler}]}, {func: 1, args: [P._AsBroadcastStream]}, {func: 1, ret: [P.Future, P.Directory], opt: [P.String]}, {func: 1, ret: {func: 1, v: true, args: [, P.StackTrace], typedef: P._ErrorCallback}, args: [P.StreamSubscription, P._Future]}, {func: 1, v: true, args: [P.StreamSubscription, P._Future,,]}, {func: 1, v: true, args: [P._EventSink,,,]}, {func: 1, args: [P.Object, P.StackTrace]}, {func: 1, ret: P.ZoneSpecification, named: {createPeriodicTimer: {func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, v: true, args: [P.Timer]}], typedef: P.CreatePeriodicTimerHandler}, createTimer: {func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, v: true}], typedef: P.CreateTimerHandler}, errorCallback: {func: 1, ret: P.AsyncError, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Object, P.StackTrace], typedef: P.ErrorCallbackHandler}, fork: {func: 1, ret: P.Zone, args: [P.Zone, P.ZoneDelegate, P.Zone, P.ZoneSpecification, P.Map], typedef: P.ForkHandler}, handleUncaughtError: {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone,, P.StackTrace], typedef: P.HandleUncaughtErrorHandler}, print: {func: 1, v: true, args: [P.Zone, P.ZoneDelegate, P.Zone, P.String], typedef: P.PrintHandler}, registerBinaryCallback: {func: 1, ret: {func: 1, args: [,,], typedef: P.ZoneBinaryCallback}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,,]}], typedef: P.RegisterBinaryCallbackHandler}, registerCallback: {func: 1, ret: {func: 1, typedef: P.ZoneCallback}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1}], typedef: P.RegisterCallbackHandler}, registerUnaryCallback: {func: 1, ret: {func: 1, args: [,], typedef: P.ZoneUnaryCallback}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,]}], typedef: P.RegisterUnaryCallbackHandler}, run: {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1}], typedef: P.RunHandler}, runBinary: {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,,]},,,], typedef: P.RunBinaryHandler}, runUnary: {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,]},,], typedef: P.RunUnaryHandler}, scheduleMicrotask: {func: 1, v: true, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, v: true}], typedef: P.ScheduleMicrotaskHandler}}}, {func: 1, ret: P.ZoneSpecification, args: [P.ZoneSpecification], named: {createPeriodicTimer: {func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, v: true, args: [P.Timer]}], typedef: P.CreatePeriodicTimerHandler}, createTimer: {func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, v: true}], typedef: P.CreateTimerHandler}, errorCallback: {func: 1, ret: P.AsyncError, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Object, P.StackTrace], typedef: P.ErrorCallbackHandler}, fork: {func: 1, ret: P.Zone, args: [P.Zone, P.ZoneDelegate, P.Zone, P.ZoneSpecification, P.Map], typedef: P.ForkHandler}, handleUncaughtError: {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone,, P.StackTrace], typedef: P.HandleUncaughtErrorHandler}, print: {func: 1, v: true, args: [P.Zone, P.ZoneDelegate, P.Zone, P.String], typedef: P.PrintHandler}, registerBinaryCallback: {func: 1, ret: {func: 1, args: [,,], typedef: P.ZoneBinaryCallback}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,,]}], typedef: P.RegisterBinaryCallbackHandler}, registerCallback: {func: 1, ret: {func: 1, typedef: P.ZoneCallback}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1}], typedef: P.RegisterCallbackHandler}, registerUnaryCallback: {func: 1, ret: {func: 1, args: [,], typedef: P.ZoneUnaryCallback}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,]}], typedef: P.RegisterUnaryCallbackHandler}, run: {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1}], typedef: P.RunHandler}, runBinary: {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,,]},,,], typedef: P.RunBinaryHandler}, runUnary: {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,]},,], typedef: P.RunUnaryHandler}, scheduleMicrotask: {func: 1, v: true, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, v: true}], typedef: P.ScheduleMicrotaskHandler}}}, {func: 1, named: {createPeriodicTimer: {func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, v: true, args: [P.Timer]}], typedef: P.CreatePeriodicTimerHandler}, createTimer: {func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, v: true}], typedef: P.CreateTimerHandler}, errorCallback: {func: 1, ret: P.AsyncError, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Object, P.StackTrace], typedef: P.ErrorCallbackHandler}, fork: {func: 1, ret: P.Zone, args: [P.Zone, P.ZoneDelegate, P.Zone, P.ZoneSpecification, P.Map], typedef: P.ForkHandler}, handleUncaughtError: {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone,, P.StackTrace], typedef: P.HandleUncaughtErrorHandler}, print: {func: 1, v: true, args: [P.Zone, P.ZoneDelegate, P.Zone, P.String], typedef: P.PrintHandler}, registerBinaryCallback: {func: 1, ret: {func: 1, args: [,,], typedef: P.ZoneBinaryCallback}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,,]}], typedef: P.RegisterBinaryCallbackHandler}, registerCallback: {func: 1, ret: {func: 1, typedef: P.ZoneCallback}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1}], typedef: P.RegisterCallbackHandler}, registerUnaryCallback: {func: 1, ret: {func: 1, args: [,], typedef: P.ZoneUnaryCallback}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,]}], typedef: P.RegisterUnaryCallbackHandler}, run: {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1}], typedef: P.RunHandler}, runBinary: {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,,]},,,], typedef: P.RunBinaryHandler}, runUnary: {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,]},,], typedef: P.RunUnaryHandler}, scheduleMicrotask: {func: 1, v: true, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, v: true}], typedef: P.ScheduleMicrotaskHandler}}}, {func: 1, ret: P.Zone, args: [P.Zone]}, {func: 1, v: true, args: [P.Zone]}, {func: 1, ret: P.ZoneDelegate, args: [P._Zone]}, {func: 1, args: [P._Zone]}, {func: 1, args: [P._Zone, P.ZoneSpecification, P.Map]}, {func: 1, ret: [P.Future, P.FileStat]}, {func: 1, v: true, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1}]}, {func: 1, ret: P.FileStat}, {func: 1, ret: [P.Future, P.FileSystemEntity], named: {recursive: P.bool}}, {func: 1, ret: [P.Stream, P.FileSystemEvent], named: {events: P.int, recursive: P.bool}}, {func: 1, ret: P.Directory, opt: [P.String]}, {func: 1, ret: P.bool, args: [,,]}, {func: 1, ret: P.int, args: [,]}, {func: 1, ret: [P.Future, P.Directory], args: [P.String]}, {func: 1, v: true, args: [P.Iterable, P.List]}, {func: 1, ret: P.String, args: [P.List]}, {func: 1, v: true, args: [{func: 1, v: true, args: [P.String, [P.List, P.String]]}]}, {func: 1, ret: P.Maps}, {func: 1, ret: P.ContentType}, {func: 1, args: [P.Map,, {func: 1}]}, {func: 1, args: [P.Map, {func: 1, v: true, args: [,,]}]}, {func: 1, ret: P.Iterable, args: [P.Map]}, {func: 1, ret: P.int, args: [P.Map]}, {func: 1, v: true, args: [P.ContentType]}, {func: 1, v: true, args: [P.Map, P.Iterable, {func: 1, args: [,]}, {func: 1, args: [,]}]}, {func: 1, v: true, args: [P.Map, P.Iterable, P.Iterable]}, {func: 1, v: true, args: [P.BytesBuilder]}, {func: 1, ret: P.String, args: [P.Set]}, {func: 1, ret: P.Uri, args: [P._SimpleUri, P._SimpleUri]}, {func: 1, args: [P.int, P.ByteConversionSink]}, {func: 1, args: [P.bool, P.int]}, {func: 1, ret: [P.Stream, P.FileSystemEntity], named: {followLinks: P.bool, recursive: P.bool}}, {func: 1, args: [P.Sink]}, {func: 1, ret: P.int, args: [P.String, P.int, P.int, P.int, P.int, P.int]}, {func: 1, ret: P.int, args: [P.String, [P.List, P.int], P.int, P.int, P.bool, P.Uint8List, P.int, P.int]}, {func: 1, v: true, args: [P.String, P.Uint8List, P.int, P.int, P.int]}, {func: 1, ret: P._Base64EncoderSink}, {func: 1, args: [[P.Sink, P.String], P.bool]}, {func: 1, args: [P.ByteConversionSink, P.bool]}, {func: 1, ret: P._Base64Decoder}, {func: 1, ret: P.int, args: [P.String, P.int, P.int, P.Uint8List, P.int, P.int]}, {func: 1, ret: P.Uint8List, args: [P.String, P.int, P.int, P.int]}, {func: 1, ret: P.int, args: [P.String, P.int, P.int, P.int]}, {func: 1, ret: P.Runes}, {func: 1, ret: P.ByteConversionSink, args: [{func: 1, v: true, args: [[P.List, P.int]]}]}, {func: 1, ret: P.ByteConversionSinkBase}, {func: 1, args: [{func: 1, v: true, args: [[P.List, P.int]]}]}, {func: 1, ret: P.Encoding, args: [P.String]}, {func: 1, args: [P.String, P.bool, P.bool, P.bool, P.bool]}, {func: 1, named: {escapeApos: P.bool, escapeLtGt: P.bool, escapeQuot: P.bool, escapeSlash: P.bool, name: P.String}}, {func: 1, opt: [P.HtmlEscapeMode]}, {func: 1, args: [P.HtmlEscape, P.StringConversionSink]}, {func: 1, args: [,], named: {cause: null}}, {func: 1, named: {reviver: {func: 1, args: [,,]}, toEncodable: {func: 1, args: [,]}}}, {func: 1, args: [{func: 1, args: [,,]}]}, {func: 1, opt: [{func: 1, args: [,]}]}, {func: 1, args: [P.String], opt: [{func: 1, args: [,]}]}, {func: 1, opt: [P.String, {func: 1, args: [,]}, P.int]}, {func: 1, args: [P.StringConversionSink, {func: 1, args: [,], typedef: P._ToEncodable}, P.String]}, {func: 1, args: [P.ByteConversionSink, {func: 1, args: [,], typedef: P._ToEncodable}, [P.List, P.int], P.int]}, {func: 1, opt: [{func: 1, args: [,,]}]}, {func: 1, args: [P.String, {func: 1, args: [,,]}]}, {func: 1, args: [{func: 1, args: [,]}]}, {func: 1, ret: P._JsonPrettyPrintMixin}, {func: 1, v: true, args: [P.String, P.String, P.String, P.bool]}, {func: 1, ret: P.String, args: [, {func: 1, args: [,]}, P.String]}, {func: 1, v: true, args: [, P.StringSink, {func: 1, args: [,]}, P.String]}, {func: 1, args: [P.StringSink, {func: 1, args: [,]}, P.String]}, {func: 1, ret: [P.List, P.FileSystemEntity], named: {followLinks: P.bool, recursive: P.bool}}, {func: 1, v: true, args: [P.Object, [P.List, P.int], {func: 1, args: [,]}, P.int, {func: 1, v: true, args: [P.Uint8List, P.int, P.int]}]}, {func: 1, args: [{func: 1, args: [,]}, [P.List, P.int],, {func: 1, v: true, args: [P.Uint8List, P.int, P.int]}]}, {func: 1, ret: P._HttpHeaders}, {func: 1, ret: [P.Iterable, P.String], args: [P.String], opt: [P.int, P.int]}, {func: 1, ret: P.StringConversionSink, args: [{func: 1, v: true, args: [P.String]}]}, {func: 1, ret: P.StringConversionSink, args: [P.StringSink]}, {func: 1, ret: P.ClosableStringSink, args: [P.StringSink, {func: 1, v: true}]}, {func: 1, args: [P.StringSink, {func: 1, v: true, typedef: P._StringSinkCloseCallback}]}, {func: 1, ret: P.StringConversionSinkBase}, {func: 1, ret: P.StringConversionSinkMixin}, {func: 1, args: [P.StringSink]}, {func: 1, args: [{func: 1, v: true, args: [P.String], typedef: [P._ChunkedConversionCallback, P.String]}]}, {func: 1, ret: [P.Stream, P.FileSystemEntity]}, {func: 1, args: [P.Sink, P.StringSink, P.bool]}, {func: 1, args: [P.StringConversionSink, P.bool]}, {func: 1, args: [P.StringConversionSink, P.StringBuffer, P.bool]}, {func: 1, ret: P.Match, args: [P.String]}, {func: 1, ret: P.String, args: [P.bool, [P.List, P.int], P.int, P.int]}, {func: 1, args: [P.StringSink, P.bool]}, {func: 1, ret: [P.Map, P.String,,], args: [[P.Map, P.Symbol,,]]}, {func: 1, ret: P.Object, args: [P.String, P.Object]}, {func: 1, v: true, args: [P.String, P.Object, P.Object]}, {func: 1, ret: P.String, args: [P.List, P.int, P.int]}, {func: 1, ret: P.String, args: [H.NativeUint8List, P.int, P.int]}, {func: 1, ret: P.String, args: [[P.Iterable, P.int], P.int, P.int]}, {func: 1, ret: P.String, args: [P.String, P.Iterable, P.String]}, {func: 1, ret: P.String, args: [P.String, P.Object]}, {func: 1, ret: P.bool, args: [P.String], named: {defaultValue: P.bool}}, {func: 1, ret: P.int, args: [P.Comparable, P.Comparable]}, {func: 1, args: [H.JsLibraryMirror]}, {func: 1, ret: [P.List, P.RedirectInfo]}, {func: 1, ret: [P.List, P.LibraryDependencyMirror]}, {func: 1, args: [P.int, P.int, P.int, P.int, P.int, P.int, P.int, P.int, P.bool]}, {func: 1, ret: P.int, args: [P.int, P.int, P.int, P.int, P.int, P.int, P.int, P.int, P.bool]}, {func: 1, ret: P.double, args: [P.String], opt: [{func: 1, ret: P.double, args: [P.String]}]}, {func: 1, named: {days: P.int, hours: P.int, microseconds: P.int, milliseconds: P.int, minutes: P.int, seconds: P.int}}, [P.LinkedListEntry, 229], {func: 1, ret: P.TypeError}, {func: 1, ret: P.CastError}, {func: 1, ret: P.NullThrownError}, {func: 1, ret: [P.Future, P.HttpClientResponse], opt: [P.String, P.Uri, P.bool]}, {func: 1, args: [,], opt: [P.String,,]}, {func: 1, v: true, args: [P.StreamSubscription]}, {func: 1, args: [P.num], opt: [P.String, P.String]}, {func: 1, args: [P.num, P.int, P.int], opt: [P.String, P.String]}, {func: 1, ret: P.RangeError, args: [P.int,,], opt: [P.String, P.String, P.int]}, {func: 1, v: true, args: [P.int, P.int, P.int], opt: [P.String, P.String]}, {func: 1, v: true, args: [P.int,,], opt: [P.String, P.int, P.String]}, {func: 1, ret: P.int, args: [P.int, P.int, P.int], opt: [P.String, P.String, P.String]}, {func: 1, v: true, args: [P.int], opt: [P.String, P.String]}, {func: 1, args: [P.int,,], opt: [P.String, P.String, P.int]}, {func: 1, args: [P.Object, P.Symbol, P.List, [P.Map, P.Symbol,,]], opt: [P.List]}, {func: 1, ret: P.Exception, opt: [,]}, {func: 1, opt: [P.String,, P.int]}, {func: 1, args: [P.Function, P.List], opt: [[P.Map, P.Symbol,,]]}, {func: 1, ret: P.bool, args: [P.Object, P.Object]}, {func: 1, ret: P.int, args: [P.Object]}, {func: 1, ret: P.int, args: [P.String], named: {defaultValue: P.int}}, {func: 1, ret: P.int, args: [P.String], named: {onError: {func: 1, ret: P.int, args: [P.String]}, radix: P.int}}, {func: 1, ret: P.Invocation}, {func: 1, ret: P.Null}, {func: 1, ret: P.num, args: [P.String], opt: [{func: 1, ret: P.num, args: [P.String]}]}, {func: 1, ret: P.double, args: [P.String]}, {func: 1, ret: P.Pattern}, {func: 1, ret: P.RegExp, args: [P.String], named: {caseSensitive: P.bool, multiLine: P.bool}}, {func: 1, ret: P.StackTrace, args: [P.String]}, {func: 1, ret: P.String, args: [[P.Iterable, P.int]], opt: [P.int, P.int]}, {func: 1, ret: P.String, args: [P.String], named: {defaultValue: P.String}}, {func: 1, ret: P.String, args: [P.Pattern, P.String]}, {func: 1, ret: P.StringSink}, {func: 1, ret: P.Symbol, args: [P.String]}, {func: 1, ret: [P.Future, P.HttpClientResponse], args: [P.bool]}, {func: 1, ret: P._MD5}, {func: 1, ret: P.Uri, args: [P.String], named: {base64: P.bool, encoding: P.Encoding, mimeType: P.String, parameters: [P.Map, P.String, P.String]}}, {func: 1, ret: P.Uri, args: [[P.List, P.int]], named: {mimeType: null, parameters: [P.Map, P.String, P.String], percentEncoded: null}}, {func: 1, ret: P.Uri, args: [P.String], opt: [P.int, P.int]}, {func: 1, ret: [P.Future, P.File], args: [[P.Stream, [P.List, P.int]]]}, {func: 1, ret: [P.Map, P.String, P.String], args: [P.String], named: {encoding: P.Encoding}}, {func: 1, ret: [P.List, P.int], args: [P.String, P.int, P.int]}, {func: 1, args: [P.String, P.String, P.String, P.int, P.String, P.String, P.String]}, {func: 1, ret: P._Uri, args: [P.String, P.int, P.int, P.int, P.int, P.int, P.int, P.int, P.int, P.String]}, {func: 1, ret: P._Uri, named: {fragment: P.String, host: P.String, path: P.String, pathSegments: [P.Iterable, P.String], port: P.int, query: P.String, queryParameters: [P.Map, P.String,,], scheme: P.String, userInfo: P.String}}, {func: 1, ret: P.String, args: [P.Pattern, {func: 1, ret: P.String, args: [P.Match]}]}, {func: 1, ret: [P.Future, P.File]}, {func: 1, v: true, args: [P.String, P.int, P.String]}, {func: 1, ret: P.Uri, args: [P.String, P.String, P.String, [P.Map, P.String, P.String]]}, {func: 1, ret: P.String, args: [P.Pattern], named: {onMatch: {func: 1, ret: P.String, args: [P.Match]}, onNonMatch: {func: 1, ret: P.String, args: [P.String]}}}, {func: 1, args: [[P.List, P.String], P.bool]}, {func: 1, args: [[P.List, P.String], P.bool], opt: [P.int]}, {func: 1, args: [P.int, P.bool]}, {func: 1, ret: P._DelayedEvent}, {func: 1, ret: P.int, args: [P.int, P.String]}, {func: 1, ret: P.String, args: [P.String, P.int, P.int, P.bool]}, {func: 1, ret: P.String, args: [P.String, P.int, P.int, [P.Iterable, P.String], P.String, P.bool]}, {func: 1, ret: P.String, args: [P.String, P.String, P.bool]}, {func: 1, ret: P.String, args: [P.String, P.int, P.int, [P.Map, P.String,,]]}, {func: 1, ret: P.String, args: [P.String, P.int, P.bool]}, {func: 1, ret: P.String, args: [P.String, P.int, P.int, [P.List, P.int]]}, {func: 1, ret: P.String, args: [P.String, P.int, P.int, [P.List, P.int]], named: {escapeDelimiters: P.bool}}, {func: 1, ret: P.String, args: [P.String, P.bool]}, {func: 1, ret: P.String, args: [P.Uri]}, {func: 1, ret: P.Map, args: [P.String], named: {encoding: P.Encoding}}, {func: 1, ret: P.String, args: [[P.List, P.int], P.String, P.Encoding, P.bool]}, {func: 1, ret: P.Future, args: [P.Uri], named: {status: P.int}}, {func: 1, ret: P.String, args: [P.String, P.int, P.int, P.Encoding, P.bool]}, {func: 1, args: [P.String, [P.List, P.int], P.Uri]}, {func: 1, ret: P.UriData, args: [P.String], named: {base64: P.bool, encoding: P.Encoding, mimeType: P.String, parameters: [P.Map, P.String, P.String]}}, {func: 1, ret: P.UriData, args: [[P.List, P.int]], named: {mimeType: null, parameters: [P.Map, P.String, P.String], percentEncoded: null}}, {func: 1, ret: P.UriData, args: [P.Uri]}, {func: 1, v: true, args: [P.String, P.String, [P.Map, P.String, P.String], P.StringBuffer, P.List]}, {func: 1, ret: P.UriData, args: [P.String]}, {func: 1, ret: P.UriData, args: [P.String, P.int, P.Uri]}, {func: 1, v: true, args: [[P.List, P.int], [P.List, P.int], P.StringSink]}, {func: 1, ret: [P.List, P.Uint8List]}, {func: 1, ret: P.int, args: [P.String, P.int, P.int, P.int, [P.List, P.int]]}, {func: 1, args: [P.String, P.int, P.int, P.int, P.int, P.int, P.int, P.String]}, {func: 1, ret: [P.Future, P.Socket], named: {writeHeaders: P.bool}}, {func: 1, ret: P.bool, named: {message: P.String, when: P.bool}}, {func: 1, v: true, args: [P.String], named: {error: P.Object, level: P.int, name: P.String, sequenceNumber: P.int, stackTrace: P.StackTrace, time: P.DateTime, zone: P.Zone}}, {func: 1, v: true, args: [P.Future]}, {func: 1, v: true, args: [P.String, {func: 1, ret: [P.Future, P.ServiceExtensionResponse], args: [P.String, [P.Map, P.String, P.String]], typedef: P.ServiceExtensionHandler}]}, {func: 1, v: true, args: [P.String, P.Map]}, {func: 1, ret: {func: 1, ret: [P.Future, P.ServiceExtensionResponse], args: [P.String, [P.Map, P.String, P.String]], typedef: P.ServiceExtensionHandler}, args: [P.String]}, {func: 1, args: [P.String, {func: 1, ret: [P.Future, P.ServiceExtensionResponse], args: [P.String, [P.Map, P.String, P.String]], typedef: P.ServiceExtensionHandler}]}, {func: 1, ret: P.UserTag, args: [P.String]}, {func: 1, args: [P.String, P.String, P.double, P.double]}, {func: 1, ret: P.Metrics}, {func: 1, ret: P.String, args: [P.Pattern, P.String], opt: [P.int]}, {func: 1, ret: P.Service}, {func: 1, ret: [P.Future, P.ServiceProtocolInfo]}, {func: 1, ret: [P.Future, P.ServiceProtocolInfo], named: {enable: P.bool}}, {func: 1, ret: P.String, args: [P.Isolate]}, {func: 1, v: true, args: [P.SendPort, P.bool]}, {func: 1, ret: P.String, args: [P.SendPort]}, {func: 1, ret: P.Timeline}, {func: 1, args: [P.String, {func: 1, typedef: P.TimelineSyncFunction}], named: {arguments: P.Map}}, {func: 1, v: true, args: [P._HttpIncoming]}, {func: 1, v: true, args: [P.int, P.int, P.String, P.String, P.String, P.String]}, {func: 1, v: true, args: [P.int, P.int, P.String, P.String, P.String]}, {func: 1, v: true, args: [P.int, P.String, P.String, P.String]}, {func: 1, ret: P.BytesBuilder, named: {copy: P.bool}}, {func: 1, ret: P._BytesBuilder}, {func: 1, ret: P.IOException}, {func: 1, ret: P.Future, named: {drainRequest: P.bool, setOutgoing: P.bool}}, {func: 1, ret: P._BufferAndStart, args: [[P.List, P.int], P.int, P.int]}, {func: 1, ret: P._IOCrypto}, {func: 1, ret: P._CryptoUtils}, {func: 1, ret: P.String, args: [[P.List, P.int]], opt: [P.bool, P.bool]}, {func: 1, ret: [P.List, P.int], args: [P.String], opt: [P.bool]}, {func: 1, args: [P.int, P.int, P.bool]}, {func: 1, ret: P.ZLibOption}, {func: 1, ret: [P.Iterable, P.int]}, {func: 1, named: {dictionary: [P.List, P.int], raw: P.bool, windowBits: P.int}}, {func: 1, ret: P._BufferSink}, {func: 1, args: [P.ByteConversionSink, P.bool, P.int, P.int, P.int, P.int, [P.List, P.int], P.bool]}, {func: 1, args: [P.ByteConversionSink, P.int, [P.List, P.int], P.bool]}, {func: 1, args: [P.ByteConversionSink, P._Filter]}, {func: 1, ret: P._Filter}, {func: 1, ret: P._Filter, args: [P.bool, P.int, P.int, P.int, P.int, [P.List, P.int], P.bool]}, {func: 1, ret: P._Filter, args: [P.int, [P.List, P.int], P.bool]}, {func: 1, ret: P.Directory, args: [P.Uri]}, {func: 1, v: true, args: [[P.List, P.FileSystemEntity], P.String, P.bool, P.bool]}, {func: 1, ret: P._AsyncDirectoryListerOps, args: [P.int]}, {func: 1, args: [P.String, P.bool, P.bool]}, {func: 1, ret: P._EventHandler}, {func: 1, v: true, args: [P.Object, P.SendPort, P.int]}, {func: 1, ret: P.File, args: [P.Uri]}, {func: 1, ret: P.RandomAccessFile}, {func: 1, opt: [P.String, P.String, P.OSError]}, {func: 1, args: [P.File, P.FileMode]}, {func: 1, ret: P.RandomAccessFile, args: [P.int]}, {func: 1, args: [P.Object, P.String, P.String]}, {func: 1, ret: P._RandomAccessFileOps, args: [P.int]}, {func: 1, ret: P.FileSystemEntityType, args: [P.int]}, {func: 1, args: [P.DateTime, P.DateTime, P.DateTime, P.FileSystemEntityType, P.int, P.int]}, {func: 1, ret: P.FileStat, args: [P.String]}, {func: 1, ret: [P.Future, P.FileStat], args: [P.String]}, {func: 1, ret: P.FileSystemEntity}, {func: 1, ret: [P.Future, P.bool], args: [P.String, P.String]}, {func: 1, ret: [P.Future, P.FileSystemEntityType], args: [P.String], named: {followLinks: P.bool}}, {func: 1, ret: P.FileSystemEntityType, args: [P.String], named: {followLinks: P.bool}}, {func: 1, ret: P.String, opt: [P.int]}, {func: 1, ret: P.int, args: [P.String, P.bool]}, {func: 1, ret: [P.Future, P.int], args: [P.String, P.bool]}, {func: 1, ret: P.String, args: [P.Pattern, {func: 1, ret: P.String, args: [P.Match]}], opt: [P.int]}, {func: 1, args: [P.int, P.String, P.bool]}, {func: 1, args: [,, P.bool]}, {func: 1, args: [,, P.String]}, {func: 1, ret: P._FileSystemWatcher}, {func: 1, ret: [P.Stream, P.FileSystemEvent], args: [P.String, P.int, P.bool]}, {func: 1, ret: P.HttpStatus}, {func: 1, ret: [P.Future, P.HttpServer], args: [, P.int], named: {backlog: P.int, shared: P.bool, v6Only: P.bool}}, {func: 1, ret: [P.Future, P.HttpServer], args: [, P.int, P.SecurityContext], named: {backlog: P.int, requestClientCertificate: P.bool, shared: P.bool, v6Only: P.bool}}, {func: 1, ret: P.HttpServer, args: [P.ServerSocket]}, {func: 1, v: true, args: [[P.List, P.int], P.int]}, {func: 1, ret: P.HeaderValue, opt: [P.String, [P.Map, P.String, P.String]]}, {func: 1, ret: P.HeaderValue, args: [P.String], named: {parameterSeparator: P.String, preserveBackslash: P.bool, valueSeparator: P.String}}, {func: 1, ret: P.ContentType, args: [P.String, P.String], named: {charset: P.String, parameters: [P.Map, P.String, P.String]}}, {func: 1, ret: P.ContentType, args: [P.String]}, {func: 1, ret: P.Cookie, opt: [P.String, P.String]}, {func: 1, ret: P.Cookie, args: [P.String]}, {func: 1, ret: P.HttpRequest}, {func: 1, ret: P.HttpResponse}, {func: 1, ret: P.HttpClient, named: {context: P.SecurityContext}}, {func: 1, ret: P.String, args: [P.Uri], named: {environment: [P.Map, P.String, P.String]}}, {func: 1, ret: P.HttpClientRequest}, {func: 1, ret: P.HttpClientResponse}, {func: 1, ret: P.HttpClientCredentials}, {func: 1, ret: P.HttpClientBasicCredentials, args: [P.String, P.String]}, {func: 1, ret: P.HttpClientDigestCredentials, args: [P.String, P.String]}, {func: 1, ret: P.RedirectInfo}, {func: 1, ret: P.DetachedSocket}, {func: 1, args: [P.String], named: {uri: P.Uri}}, {func: 1, args: [P.String, [P.List, P.RedirectInfo]]}, {func: 1, ret: P.HttpDate}, {func: 1, ret: P.String, args: [P.DateTime]}, {func: 1, args: [P.String], named: {defaultPortForScheme: P.int, initialHeaders: P._HttpHeaders}}, {func: 1, opt: [P.String, [P.Map, P.String, P.String]]}, {func: 1, ret: P._HeaderValue, args: [P.String], named: {parameterSeparator: null, preserveBackslash: null, valueSeparator: null}}, {func: 1, args: [P.String, P.String, P.String, [P.Map, P.String, P.String]]}, {func: 1, ret: P._ContentType, args: [P.String]}, {func: 1, opt: [P.String, P.String]}, {func: 1, args: [P._HttpHeaders, P.int, [P.Stream, [P.List, P.int]]]}, {func: 1, args: [P._HttpIncoming]}, {func: 1, args: [P.HttpResponse, P._HttpIncoming, P._HttpServer, P._HttpConnection]}, {func: 1, args: [P._HttpIncoming, P._HttpClientRequest, P._HttpClient]}, {func: 1, args: [P.Uri, P.String, P._HttpOutgoing], named: {initialHeaders: P._HttpHeaders}}, {func: 1, args: [P.Uri, P.String, P._HttpOutgoing, P.HttpHeaders, P.String]}, {func: 1, args: [P._HttpOutgoing, P.Uri, P.String, P._Proxy, P._HttpClient, P._HttpClientConnection]}, {func: 1, args: [{func: 1, v: true, args: [[P.List, P.int]], typedef: P._BytesConsumer}]}, {func: 1, args: [P.String, P.Socket, P._HttpClient], opt: [P.bool, P.SecurityContext]}, {func: 1, args: [P.bool, P.String, P.int]}, {func: 1, args: [P._HttpClientConnection, P._Proxy]}, {func: 1, args: [P.String, P.String, P.int, P.bool, P.SecurityContext]}, {func: 1, args: [P.SecurityContext]}, {func: 1, ret: P.String, args: [P.Uri, [P.Map, P.String, P.String]]}, {func: 1, args: [, P._HttpServer]}, {func: 1, ret: [P.Future, P.HttpServer], args: [, P.int, P.int, P.bool, P.bool]}, {func: 1, ret: [P.Future, P.HttpServer], args: [, P.int, P.SecurityContext, P.int, P.bool, P.bool, P.bool]}, {func: 1, args: [, P.bool]}, {func: 1, args: [P.String, P.int, P.String, P.String]}, {func: 1, ret: P._HttpConnectionInfo}, {func: 1, ret: P._HttpConnectionInfo, args: [P.Socket]}, {func: 1, args: [P.Socket, [P.Stream, [P.List, P.int]]]}, {func: 1, ret: P._AuthenticationScheme, args: [P.String]}, {func: 1, args: [P._HttpClientCredentials, P.String]}, {func: 1, args: [P.Uri,, P._HttpClientCredentials]}, {func: 1, args: [P.String, P.int,, P._HttpClientCredentials]}, {func: 1, ret: P._HttpClientCredentials}, {func: 1, args: [P.int, P.String, P.Uri]}, {func: 1, ret: P._Const}, {func: 1, ret: P._CharCode}, {func: 1, ret: P._State}, {func: 1, ret: P._HttpVersion}, {func: 1, ret: P._MessageType}, {func: 1, args: [[P.StreamSubscription, [P.List, P.int]], [P.List, P.int], P.Function]}, {func: 1, args: [[P.StreamSubscription, [P.List, P.int]], [P.List, P.int]]}, {func: 1, ret: P.File}, {func: 1, args: [P._HttpSessionManager, P.String]}, {func: 1, ret: P._HttpClientRequest, args: [P.Uri, P.int, P.String, P._Proxy]}, {func: 1, ret: P.AsyncError, args: [P.Zone, P.Object, P.StackTrace]}, {func: 1, v: true, args: [P.Zone, {func: 1}]}, {func: 1, ret: [P.Future, P._HttpClientConnection], args: [P.String, P.int, P._Proxy, {func: 1, ret: P.bool, args: [P.X509Certificate]}]}, {func: 1, ret: P.Timer, args: [P.Zone, P.Duration, {func: 1, v: true}]}, {func: 1, ret: P._SHA1}, {func: 1, ret: P._IOService}, {func: 1, ret: P.Future, args: [P.int, P.List]}, {func: 1, ret: P.IOSink, args: [[P.StreamConsumer, [P.List, P.int]]], named: {encoding: P.Encoding}}, {func: 1, args: [[P.StreamConsumer, [P.List, P.int]], P.Encoding]}, {func: 1, ret: P.Link, args: [P.Uri]}, {func: 1, ret: P.Platform}, {func: 1, ret: P._Platform}, {func: 1, ret: P._ProcessUtils}, {func: 1, ret: P.int, args: [P.Process]}, {func: 1, ret: [P.Stream, P.ProcessSignal], args: [P.ProcessSignal]}, {func: 1, ret: P.Process}, {func: 1, ret: [P.Future, P.Process], args: [P.String, [P.List, P.String]], named: {environment: [P.Map, P.String, P.String], includeParentEnvironment: P.bool, mode: P.ProcessStartMode, runInShell: P.bool, workingDirectory: P.String}}, {func: 1, ret: [P.Future, P.ProcessResult], args: [P.String, [P.List, P.String]], named: {environment: [P.Map, P.String, P.String], includeParentEnvironment: P.bool, runInShell: P.bool, stderrEncoding: P.Encoding, stdoutEncoding: P.Encoding, workingDirectory: P.String}}, {func: 1, ret: P.ProcessResult, args: [P.String, [P.List, P.String]], named: {environment: [P.Map, P.String, P.String], includeParentEnvironment: P.bool, runInShell: P.bool, stderrEncoding: P.Encoding, stdoutEncoding: P.Encoding, workingDirectory: P.String}}, {func: 1, ret: P.bool, args: [P.int], opt: [P.ProcessSignal]}, {func: 1, args: [P.int, P.int,,,]}, {func: 1, args: [P.String], opt: [,]}, {func: 1, args: [P.String, [P.List, P.String]], opt: [P.String, P.int]}, {func: 1, args: [P.RawSecureServerSocket]}, {func: 1, ret: [P.Future, P.SecureServerSocket], args: [, P.int, P.SecurityContext], named: {backlog: P.int, requestClientCertificate: P.bool, requireClientCertificate: P.bool, shared: P.bool, supportedProtocols: [P.List, P.String], v6Only: P.bool}}, {func: 1, args: [P.RawServerSocket, P.SecurityContext, P.bool, P.bool, [P.List, P.String]]}, {func: 1, ret: [P.Future, P.RawSecureServerSocket], args: [, P.int, P.SecurityContext], named: {backlog: P.int, requestClientCertificate: P.bool, requireClientCertificate: P.bool, shared: P.bool, supportedProtocols: [P.List, P.String], v6Only: P.bool}}, {func: 1, ret: P.SecureSocket, args: [P.RawSecureSocket]}, {func: 1, ret: [P.Future, P.SecureSocket], args: [, P.int], named: {context: P.SecurityContext, onBadCertificate: {func: 1, ret: P.bool, args: [P.X509Certificate]}, supportedProtocols: [P.List, P.String]}}, {func: 1, ret: [P.Future, P.SecureSocket], args: [P.Socket], named: {context: P.SecurityContext, host: null, onBadCertificate: {func: 1, ret: P.bool, args: [P.X509Certificate]}}}, {func: 1, ret: [P.Future, P.SecureSocket], args: [P.Socket, P.SecurityContext], named: {bufferedData: [P.List, P.int], requestClientCertificate: P.bool, requireClientCertificate: P.bool, supportedProtocols: [P.List, P.String]}}, {func: 1, ret: P.RawSecureSocket}, {func: 1, ret: [P.Future, P.RawSecureSocket], args: [, P.int], named: {context: P.SecurityContext, onBadCertificate: {func: 1, ret: P.bool, args: [P.X509Certificate]}, supportedProtocols: [P.List, P.String]}}, {func: 1, ret: [P.Future, P.RawSecureSocket], args: [P.RawSocket], named: {context: P.SecurityContext, host: null, onBadCertificate: {func: 1, ret: P.bool, args: [P.X509Certificate]}, subscription: [P.StreamSubscription, P.RawSocketEvent], supportedProtocols: [P.List, P.String]}}, {func: 1, ret: [P.Future, P.RawSecureSocket], args: [P.RawSocket, P.SecurityContext], named: {bufferedData: [P.List, P.int], requestClientCertificate: P.bool, requireClientCertificate: P.bool, subscription: [P.StreamSubscription, P.RawSocketEvent], supportedProtocols: [P.List, P.String]}}, {func: 1, ret: [P.Future, P._RawSecureSocket], args: [, P.int], named: {bufferedData: [P.List, P.int], context: P.SecurityContext, is_server: P.bool, onBadCertificate: {func: 1, ret: P.bool, args: [P.X509Certificate]}, requestClientCertificate: P.bool, requireClientCertificate: P.bool, socket: P.RawSocket, subscription: [P.StreamSubscription, P.RawSocketEvent], supportedProtocols: [P.List, P.String]}}, {func: 1, args: [P.InternetAddress, P.int, P.bool, P.SecurityContext, P.RawSocket, [P.StreamSubscription, P.RawSocketEvent], [P.List, P.int], P.bool, P.bool, P.Function, [P.List, P.String]]}, {func: 1, v: true, args: [, P.int, P.bool, P.bool, P.bool, P.Function]}, {func: 1, ret: P._SecureFilter}, {func: 1, ret: P.Timer, args: [P.Zone, P.Duration, {func: 1, v: true, args: [P.Timer]}]}, {func: 1, args: [P.String, P.String, P.OSError]}, {func: 1, ret: [P.List, P.String], args: [P.Pattern]}, {func: 1, ret: P._HttpClientConnection}, {func: 1, ret: P._ServiceObject}, {func: 1, ret: P.InternetAddressType, args: [P.int]}, {func: 1, ret: P.InternetAddress, args: [P.String]}, {func: 1, ret: [P.Future, [P.List, P.InternetAddress]], args: [P.String], named: {type: P.InternetAddressType}}, {func: 1, ret: P.InternetAddress, args: [P.InternetAddress, P.String]}, {func: 1, ret: P.NetworkInterface}, {func: 1, ret: [P.Future, [P.List, P.NetworkInterface]], named: {includeLinkLocal: P.bool, includeLoopback: P.bool, type: P.InternetAddressType}}, {func: 1, ret: P.RawServerSocket}, {func: 1, ret: [P.Future, P.RawServerSocket], args: [, P.int], named: {backlog: P.int, shared: P.bool, v6Only: P.bool}}, {func: 1, ret: P.ServerSocket}, {func: 1, ret: [P.Future, P.ServerSocket], args: [, P.int], named: {backlog: P.int, shared: P.bool, v6Only: P.bool}}, {func: 1, ret: P.RawSocket}, {func: 1, ret: [P.Future, P.RawSocket], args: [, P.int], named: {sourceAddress: null}}, {func: 1, ret: P.Socket}, {func: 1, ret: [P.Future, P.Socket], args: [, P.int], named: {sourceAddress: null}}, {func: 1, args: [[P.List, P.int], P.InternetAddress, P.int]}, {func: 1, ret: P.RawDatagramSocket}, {func: 1, ret: [P.Future, P.RawDatagramSocket], args: [, P.int], named: {reuseAddress: P.bool}}, {func: 1, args: [P.String], named: {address: P.InternetAddress, osError: P.OSError, port: P.int}}, {func: 1, ret: P.String, args: [P.int, P.int, P.String]}, {func: 1, args: [P.IOSink, P.int]}, {func: 1, ret: [P.Future, P._ConnectionInfo], args: [P.String, P.int, P._Proxy, P._HttpClient]}, {func: 1, args: [P.IOSink]}, {func: 1, v: true, args: [P.StringSink]}, {func: 1, args: [{func: 1, ret: P.bool, args: [P.X509Certificate, P.String, P.int]}]}, {func: 1, ret: P.StdioType, args: [,]}, {func: 1, ret: P._StdIOUtils}, {func: 1, ret: P.int, args: [P.Socket]}, {func: 1, ret: P.WebSocketStatus}, {func: 1, named: {clientMaxWindowBits: P.int, clientNoContextTakeover: P.bool, enabled: P.bool, serverMaxWindowBits: P.int, serverNoContextTakeover: P.bool}}, {func: 1, ret: P.WebSocketTransformer, named: {compression: P.CompressionOptions, protocolSelector: {func: 1, args: [[P.List, P.String]]}}}, {func: 1, ret: [P.Future, P.WebSocket], args: [P.HttpRequest], named: {compression: P.CompressionOptions, protocolSelector: {func: 1, args: [[P.List, P.String]]}}}, {func: 1, ret: [P.Future, P.HttpClientRequest], args: [P.String, P.String, P.int, P.String]}, {func: 1, ret: [P.Future, P.WebSocket], args: [P.String], named: {compression: P.CompressionOptions, headers: [P.Map, P.String,,], protocols: [P.Iterable, P.String]}}, {func: 1, ret: P.WebSocket, args: [P.Socket], named: {compression: P.CompressionOptions, protocol: P.String, serverSide: P.bool}}, {func: 1, ret: P._WebSocketMessageType}, {func: 1, ret: P._WebSocketOpcode}, {func: 1, opt: [P.bool, P._WebSocketPerMessageDeflate]}, {func: 1, ret: [P.Future, P.HttpClientRequest], args: [P.String, P.Uri]}, {func: 1, args: [{func: 1, args: [[P.List, P.String]], typedef: P._ProtocolSelector}, P.CompressionOptions]}, {func: 1, ret: [P.Future, P.WebSocket], args: [P.HttpRequest, {func: 1, args: [[P.List, P.String]], typedef: P._ProtocolSelector}, P.CompressionOptions]}, {func: 1, ret: P._WebSocketPerMessageDeflate, args: [P.HttpRequest, P.HttpResponse, P.CompressionOptions]}, {func: 1, named: {clientMaxWindowBits: P.int, clientNoContextTakeover: P.bool, serverMaxWindowBits: P.int, serverNoContextTakeover: P.bool, serverSide: P.bool}}, {func: 1, args: [P._WebSocketImpl]}, {func: 1, ret: [P.Iterable, [P.List, P.int]], args: [P.int, [P.List, P.int], P.bool, P.bool]}, {func: 1, args: [P._WebSocketImpl, P.Socket]}, {func: 1, ret: [P.Future, P.WebSocket], args: [P.String, [P.Iterable, P.String], [P.Map, P.String,,]], named: {compression: P.CompressionOptions}}, {func: 1, ret: P._WebSocketPerMessageDeflate, args: [P.HttpClientResponse, P.CompressionOptions]}, {func: 1, args: [, P.String, P.CompressionOptions], opt: [P.bool, P._WebSocketPerMessageDeflate]}, {func: 1, ret: P.Capability}, {func: 1, args: [P.SendPort], named: {pauseCapability: P.Capability, terminateCapability: P.Capability}}, {func: 1, ret: P.Isolate}, {func: 1, ret: P.String, args: [P.int], opt: [P.int]}, {func: 1, ret: [P.Future, P.Uri], args: [P.Uri]}, {func: 1, ret: [P.Future, P.Isolate], args: [{func: 1, v: true, args: [,]},,], named: {errorsAreFatal: P.bool, onError: P.SendPort, onExit: P.SendPort, paused: P.bool}}, {func: 1, ret: [P.Future, P.Isolate], args: [P.Uri, [P.List, P.String],,], named: {automaticPackageResolution: P.bool, checked: P.bool, environment: [P.Map, P.String, P.String], errorsAreFatal: P.bool, onError: P.SendPort, onExit: P.SendPort, packageConfig: P.Uri, packageRoot: P.Uri, paused: P.bool}}, {func: 1, ret: P.ReceivePort}, {func: 1, ret: P.ReceivePort, args: [P.RawReceivePort]}, {func: 1, ret: P.RawReceivePort, opt: [{func: 1, v: true, args: [,]}]}, {func: 1, ret: P._JenkinsSmiHash}, {func: 1, ret: P.int, args: [,,,,]}, {func: 1, ret: P.double, args: [P.num, P.num]}, {func: 1, ret: P.num, args: [P.num, P.num]}, {func: 1, v: true, args: [P.Zone, P.String]}, {func: 1, ret: P.Random, opt: [P.int]}, {func: 1, ret: P.Random}, {func: 1, ret: [P.Map, P.Uri, P.LibraryMirror]}, {func: 1, ret: P.String, args: [P.Symbol]}, {func: 1, ret: P.Symbol, args: [P.String], opt: [P.LibraryMirror]}, {func: 1, ret: P.ClassMirror, args: [P.Type]}, {func: 1, ret: P.TypeMirror, args: [P.Type], opt: [[P.List, P.Type]]}, {func: 1, ret: P.Mirror}, {func: 1, ret: P.IsolateMirror}, {func: 1, ret: P.ObjectMirror}, {func: 1, ret: P.ClosureMirror}, {func: 1, ret: P.LibraryDependencyMirror}, {func: 1, ret: P.CombinatorMirror}, {func: 1, ret: P.FunctionTypeMirror}, {func: 1, ret: P.TypeVariableMirror}, {func: 1, ret: P.TypedefMirror}, {func: 1, ret: P.VariableMirror}, {func: 1, ret: P.ParameterMirror}, {func: 1, args: [P.String, P.String, P.bool]}, {func: 1, named: {metaTargets: null, override: null, symbols: null, targets: null}}, {func: 1, ret: P.NativeFieldWrapperClass1}, {func: 1, ret: P.NativeFieldWrapperClass2}, {func: 1, ret: P.NativeFieldWrapperClass3}, {func: 1, ret: P.NativeFieldWrapperClass4}, {func: 1, ret: P.TypedData}, {func: 1, ret: P.ByteData, args: [P.int]}, {func: 1, ret: P.ByteData, args: [P.ByteBuffer], opt: [P.int, P.int]}, {func: 1, ret: P.Int8List, args: [P.int]}, {func: 1, ret: P.Int8List, args: [[P.List, P.int]]}, {func: 1, ret: P.Int8List, args: [P.ByteBuffer], opt: [P.int, P.int]}, {func: 1, ret: P.Uint8List, args: [P.ByteBuffer], opt: [P.int, P.int]}, {func: 1, ret: P.Uint8ClampedList, args: [P.int]}, {func: 1, ret: P.Uint8ClampedList, args: [[P.List, P.int]]}, {func: 1, ret: P.Uint8ClampedList, args: [P.ByteBuffer], opt: [P.int, P.int]}, {func: 1, ret: P.Int16List, args: [P.int]}, {func: 1, ret: P.Int16List, args: [[P.List, P.int]]}, {func: 1, ret: P.Int16List, args: [P.ByteBuffer], opt: [P.int, P.int]}, {func: 1, ret: P.Uint16List, args: [P.int]}, {func: 1, ret: P.Uint16List, args: [[P.List, P.int]]}, {func: 1, ret: P.Uint16List, args: [P.ByteBuffer], opt: [P.int, P.int]}, {func: 1, ret: P.Int32List, args: [P.int]}, {func: 1, ret: P.Int32List, args: [[P.List, P.int]]}, {func: 1, ret: P.Int32List, args: [P.ByteBuffer], opt: [P.int, P.int]}, {func: 1, ret: P.Uint32List, args: [P.int]}, {func: 1, ret: P.Uint32List, args: [[P.List, P.int]]}, {func: 1, ret: P.Uint32List, args: [P.ByteBuffer], opt: [P.int, P.int]}, {func: 1, ret: P.Int64List, args: [P.int]}, {func: 1, ret: P.Int64List, args: [[P.List, P.int]]}, {func: 1, ret: P.Int64List, args: [P.ByteBuffer], opt: [P.int, P.int]}, {func: 1, ret: P.Uint64List, args: [P.int]}, {func: 1, ret: P.Uint64List, args: [[P.List, P.int]]}, {func: 1, ret: P.Uint64List, args: [P.ByteBuffer], opt: [P.int, P.int]}, {func: 1, ret: P.Float32List, args: [P.int]}, {func: 1, ret: P.Float32List, args: [[P.List, P.double]]}, {func: 1, ret: P.Float32List, args: [P.ByteBuffer], opt: [P.int, P.int]}, {func: 1, ret: P.Float64List, args: [P.int]}, {func: 1, ret: P.Float64List, args: [[P.List, P.double]]}, {func: 1, ret: P.Float64List, args: [P.ByteBuffer], opt: [P.int, P.int]}, {func: 1, ret: P.Float32x4List, args: [P.int]}, {func: 1, ret: P.Float32x4List, args: [[P.List, P.Float32x4]]}, {func: 1, ret: P.Float32x4List, args: [P.ByteBuffer], opt: [P.int, P.int]}, {func: 1, ret: P.Int32x4List, args: [P.int]}, {func: 1, ret: P.Int32x4List, args: [[P.List, P.Int32x4]]}, {func: 1, ret: P.Int32x4List, args: [P.ByteBuffer], opt: [P.int, P.int]}, {func: 1, ret: P.Float64x2List, args: [P.int]}, {func: 1, ret: P.Float64x2List, args: [[P.List, P.Float64x2]]}, {func: 1, ret: P.Float64x2List, args: [P.ByteBuffer], opt: [P.int, P.int]}, {func: 1, ret: P.Float32x4, args: [P.double, P.double, P.double, P.double]}, {func: 1, ret: P.Float32x4, args: [P.Int32x4]}, {func: 1, ret: P.Float32x4, args: [P.Float64x2]}, {func: 1, ret: P.Int32x4, args: [P.int, P.int, P.int, P.int]}, {func: 1, ret: P.Int32x4, args: [P.bool, P.bool, P.bool, P.bool]}, {func: 1, ret: P.Float64x2, args: [P.double, P.double]}, {func: 1, ret: P.Float64x2, args: [P.Float32x4]}, {func: 1, ret: N.ArgParser, named: {allowTrailingOptions: P.bool}}, {func: 1, args: [[P.Map, P.String, G.Option], [P.Map, P.String, N.ArgParser]], named: {allowTrailingOptions: P.bool}}, {func: 1, args: [P.String], opt: [[P.Iterable, P.String]]}, {func: 1, ret: V.ArgResults, args: [N.ArgParser, [P.Map, P.String,,], P.String, V.ArgResults, [P.List, P.String], [P.List, P.String]]}, {func: 1, args: [N.ArgParser, [P.Map, P.String,,], P.String, V.ArgResults, [P.List, P.String], [P.List, P.String]]}, {func: 1, ret: G.Option, args: [P.String, P.String, P.String, P.String, [P.List, P.String], [P.Map, P.String, P.String],, P.Function, G.OptionType], named: {hide: P.bool, negatable: P.bool, splitCommas: P.bool}}, {func: 1, args: [P.String, P.String, P.String, P.String, [P.List, P.String], [P.Map, P.String, P.String],, P.Function, G.OptionType], named: {hide: P.bool, negatable: P.bool, splitCommas: P.bool}}, {func: 1, args: [P.String, N.ArgParser, [P.List, P.String]], opt: [G.Parser, [P.List, P.String]]}, {func: 1, args: [P.List]}, {func: 1, ret: P.String, args: [P.String, P.int]}, {func: 1, ret: R.LineParser}, {func: 1, ret: R.ShapesMirror}, {func: 1, v: true, named: {force: P.bool}}, {func: 1, args: [P.num, P.num]}, {func: 1, ret: M.Shape}, {func: 1, args: [P.String, R.LineParser0]}, {func: 1, ret: R.LineParser0}, {func: 1, args: [{func: 1, ret: [P.Future, P.bool], args: [P.Uri, P.String, P.String]}]}, {func: 1, ret: P.Zone, args: [P.Zone, P.ZoneSpecification, P.Map]}, {func: 1, ret: P.bool, args: [P.Zone]}, {func: 1, v: true, args: [P.Uri, P.String, P.HttpClientCredentials]}, P.Null, {func: 1, args: [{func: 1, ret: [P.Future, P.bool], args: [P.String, P.int, P.String, P.String]}]}, [P.List, 545], {func: 1, v: true, args: [P.String, P.int, P.String, P.HttpClientCredentials]}, [P._SplayTreeNode, 580], {func: 1, args: [{func: 1, ret: P.String, args: [P.Uri]}]}, {func: 1, ret: [P.Future, P._HttpClientRequest], args: [P.String, P.Uri]}, {func: 1, ret: [P.Future, P._HttpClientRequest], args: [P.String, P.Uri, P._HttpClientRequest]}, H.TearOffClosure, {func: 1, ret: P._ConnectionTarget, args: [P.String, P.int, P.bool]}, [P._ControllerStream, 506], {func: 1, ret: [P.Future, P._ConnectionInfo], args: [P.String, P.int, P._ProxyConfiguration, P.bool]}, {func: 1, ret: P._SiteCredentials, args: [P.Uri], opt: [P._AuthenticationScheme]}, P._DoubleLink, {func: 1, ret: P._ProxyCredentials, args: [P._Proxy], opt: [P._AuthenticationScheme]}, {func: 1, ret: [P._ZoneFunction, {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1}], typedef: P.RunHandler}]}, {func: 1, ret: P.bool, args: [P.X509Certificate, P.String, P.int]}, {func: 1, ret: [P._ZoneFunction, {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,]},,], typedef: P.RunUnaryHandler}]}, [P._ControllerSubscription, 392], {func: 1, ret: [P._ZoneFunction, {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,,]},,,], typedef: P.RunBinaryHandler}]}, {func: 1, ret: [P._ZoneFunction, {func: 1, ret: {func: 1, typedef: P.ZoneCallback}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1}], typedef: P.RegisterCallbackHandler}]}, {func: 1, ret: [P._ZoneFunction, {func: 1, ret: {func: 1, args: [,], typedef: P.ZoneUnaryCallback}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,]}], typedef: P.RegisterUnaryCallbackHandler}]}, {func: 1, ret: [P._ZoneFunction, {func: 1, ret: {func: 1, args: [,,], typedef: P.ZoneBinaryCallback}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,,]}], typedef: P.RegisterBinaryCallbackHandler}]}, {func: 1, ret: [P._ZoneFunction, {func: 1, ret: P.AsyncError, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Object, P.StackTrace], typedef: P.ErrorCallbackHandler}]}, [P._EventDispatch, 141], [P._EventSink, 141], [P._StreamControllerLifecycle, 141], [P.StreamController, 141], [P._BroadcastStreamController, 393], [P.SynchronousStreamController, 393], [P._BroadcastStreamController, 503], [P._StreamImplEvents, 280], [P._SyncBroadcastStreamController, 280], [P._EventDispatch, 280], {func: 1, ret: [P._ZoneFunction, {func: 1, v: true, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, v: true}], typedef: P.ScheduleMicrotaskHandler}]}, {func: 1, ret: [P._ZoneFunction, {func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, v: true}], typedef: P.CreateTimerHandler}]}, {func: 1, ret: [P._ZoneFunction, {func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, v: true, args: [P.Timer]}], typedef: P.CreatePeriodicTimerHandler}]}, [P.Completer, 353], [P._Completer, 540], [P._Completer, 490], P._FutureListener, [P._Future, 559], {func: 1, ret: [P._ZoneFunction, {func: 1, v: true, args: [P.Zone, P.ZoneDelegate, P.Zone, P.String], typedef: P.PrintHandler}]}, [P.Future, 542], {func: 1, v: true, typedef: P._AsyncCallback}, {func: 1, ret: [P._ZoneFunction, {func: 1, ret: P.Zone, args: [P.Zone, P.ZoneDelegate, P.Zone, P.ZoneSpecification, P.Map], typedef: P.ForkHandler}]}, [P.Sink, 528], {func: 1, ret: [P.Future, P.RandomAccessFile], named: {mode: P.FileMode}}, [P.StreamConsumer, 365], [P.EventSink, 365], {func: 1, ret: [P._ZoneFunction, {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone,, P.StackTrace], typedef: P.HandleUncaughtErrorHandler}]}, [P.EventSink, 485], [P.StreamSink, 608], [P.StreamController, 614], [P._EventDispatch, 222], [P._EventSink, 222], [P._StreamControllerLifecycle, 222], [P.StreamController, 222], [P.SynchronousStreamController, 412], [P._StreamController, 412], [P._StreamController, 483], [P._StreamController, 401], [P._AsyncStreamControllerDispatch, 401], [P._StreamController, 312], [P._SyncStreamControllerDispatch, 312], [P._StreamImpl, 381], [P._BufferingStreamSubscription, 305], {func: 1, ret: P._Zone}, [P.StreamSink, 473], {func: 1, ret: P.ClassMirror, args: [P.int]}, [P._AddStreamState, 470], [P._EventDispatch, 147], [P._EventSink, 147], [P.StreamSubscription, 147], [P.Stream, 607], {func: 1, ret: [P._PendingEvents, 302], typedef: [P._EventGenerator, 302]}, [P._StreamImpl, 302], [P.Iterator, 409], [P._PendingEvents, 409], {func: 1, v: true, args: [P.int, P.int, [P.Iterable, P.int]], opt: [P.int]}, 386, [P._DelayedEvent, 386], {func: 1, ret: P.String, args: [P.String, P.String]}, [P._PendingEvents, 592], [P.StreamSubscription, 466], {func: 1, ret: P.Float64x2, args: [P.Float64x2, P.Float64x2]}, {func: 1, ret: P.RandomAccessFile, named: {mode: P.FileMode}}, [P._AsBroadcastStreamController, 176], [P.StreamSubscription, 176], P._AsBroadcastStream, [P.StreamSubscription, 454], [P.StreamIterator, 448], [P.Stream, 445], {func: 1, ret: [P.Stream, [P.List, P.int]], opt: [P.int, P.int]}, [P.Stream, 555], {func: 1, ret: [P.StreamSubscription, P.HttpRequest], args: [{func: 1, v: true, args: [P.HttpRequest]}], named: {cancelOnError: P.bool, onDone: {func: 1, v: true}, onError: P.Function}}, {func: 1, ret: P.Future, named: {force: P.bool}}, [P._BufferingStreamSubscription, 384], {func: 1, ret: P.bool, args: [207], typedef: [P._Predicate, 207]}, [P._ForwardingStream, 207, 207], {func: 1, ret: 234, args: [233], typedef: [P._Transformation, 233, 234]}, [P._ForwardingStream, 233, 234], {func: 1, ret: [P.Iterable, 271], args: [269], typedef: [P._Transformation, 269, [P.Iterable, 271]]}, [P._ForwardingStream, 269, 271], {func: 1, ret: P.bool, args: [,], typedef: P._ErrorTest}, [P._ForwardingStream, 420, 420], [P._ForwardingStream, 421, 421], [P._ForwardingStreamSubscription, 395, 395], {func: 1, ret: P.bool, args: [208], typedef: [P._Predicate, 208]}, [P._ForwardingStream, 208, 208], [P._ForwardingStream, 399, 399], {func: 1, ret: P.bool, args: [210], typedef: [P._Predicate, 210]}, [P._ForwardingStream, 210, 210], {func: 1, ret: P.bool, args: [171, 171], typedef: [P._Equality, 171]}, [P._ForwardingStream, 171, 171], P._EventSink, [P.EventSink, 429], [P.EventSink, 303], {func: 1, ret: null, args: [P.int]}, [P._BufferingStreamSubscription, 428], {func: 1, ret: {func: 1, ret: P.bool, args: [P.Object], typedef: P._FutureErrorTest}}, [P.StreamTransformer, 261, 263], {func: 1, ret: [P.EventSink, 265], args: [[P.EventSink, 266]], typedef: [P._SinkMapper, 265, 266]}, [P.Stream, 265], [P.Stream, 266], {func: 1, v: true, args: [264, [P.EventSink, 133]], typedef: [P._TransformDataHandler, 264, 133]}, {func: 1, v: true, args: [P.Object, P.StackTrace, [P.EventSink, 133]], typedef: [P._TransformErrorHandler, 133]}, {func: 1, v: true, args: [[P.EventSink, 133]], typedef: [P._TransformDoneHandler, 133]}, [P.EventSink, 133], [P.EventSink, 264], [P._StreamSinkTransformer, 464, 465], {func: 1, ret: [P.StreamSubscription, 260], args: [[P.Stream, 259], P.bool], typedef: [P._SubscriptionTransformer, 259, 260]}, [P.StreamTransformer, 259, 260], {func: 1, ret: [P.StreamSubscription, 258], args: [[P.Stream, 257], P.bool], typedef: [P._SubscriptionTransformer, 257, 258]}, [P.Stream, 257], [P.Stream, 258], {func: 1, v: true, args: [{func: 1, ret: P.bool, args: [,]}, P.bool]}, {func: 1, v: true, args: [P._HttpRequest]}, 557, {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone,, P.StackTrace], typedef: P.HandleUncaughtErrorHandler}, {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1}], typedef: P.RunHandler}, {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,]},,], typedef: P.RunUnaryHandler}, {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,,]},,,], typedef: P.RunBinaryHandler}, {func: 1, ret: {func: 1, typedef: P.ZoneCallback}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1}], typedef: P.RegisterCallbackHandler}, {func: 1, ret: {func: 1, args: [,], typedef: P.ZoneUnaryCallback}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,]}], typedef: P.RegisterUnaryCallbackHandler}, {func: 1, ret: {func: 1, args: [,,], typedef: P.ZoneBinaryCallback}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,,]}], typedef: P.RegisterBinaryCallbackHandler}, {func: 1, ret: P.AsyncError, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Object, P.StackTrace], typedef: P.ErrorCallbackHandler}, {func: 1, v: true, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, v: true}], typedef: P.ScheduleMicrotaskHandler}, {func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, v: true}], typedef: P.CreateTimerHandler}, {func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, v: true, args: [P.Timer]}], typedef: P.CreatePeriodicTimerHandler}, {func: 1, v: true, args: [P.Zone, P.ZoneDelegate, P.Zone, P.String], typedef: P.PrintHandler}, {func: 1, ret: P.Zone, args: [P.Zone, P.ZoneDelegate, P.Zone, P.ZoneSpecification, P.Map], typedef: P.ForkHandler}, P.ZoneSpecification, {func: 1, ret: P.InstanceMirror, args: [P.List], opt: [[P.Map, P.Symbol,,]]}, [P._ZoneFunction, {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1}], typedef: P.RunHandler}], [P._ZoneFunction, {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,]},,], typedef: P.RunUnaryHandler}], [P._ZoneFunction, {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,,]},,,], typedef: P.RunBinaryHandler}], [P._ZoneFunction, {func: 1, ret: {func: 1, typedef: P.ZoneCallback}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1}], typedef: P.RegisterCallbackHandler}], [P._ZoneFunction, {func: 1, ret: {func: 1, args: [,], typedef: P.ZoneUnaryCallback}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,]}], typedef: P.RegisterUnaryCallbackHandler}], [P._ZoneFunction, {func: 1, ret: {func: 1, args: [,,], typedef: P.ZoneBinaryCallback}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, args: [,,]}], typedef: P.RegisterBinaryCallbackHandler}], [P._ZoneFunction, {func: 1, ret: P.AsyncError, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Object, P.StackTrace], typedef: P.ErrorCallbackHandler}], [P._ZoneFunction, {func: 1, v: true, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, v: true}], typedef: P.ScheduleMicrotaskHandler}], [P._ZoneFunction, {func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, v: true}], typedef: P.CreateTimerHandler}], [P._ZoneFunction, {func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, v: true, args: [P.Timer]}], typedef: P.CreatePeriodicTimerHandler}], [P._ZoneFunction, {func: 1, v: true, args: [P.Zone, P.ZoneDelegate, P.Zone, P.String], typedef: P.PrintHandler}], [P._ZoneFunction, {func: 1, ret: P.Zone, args: [P.Zone, P.ZoneDelegate, P.Zone, P.ZoneSpecification, P.Map], typedef: P.ForkHandler}], [P._ZoneFunction, {func: 1, args: [P.Zone, P.ZoneDelegate, P.Zone,, P.StackTrace], typedef: P.HandleUncaughtErrorHandler}], {func: 1, ret: {func: 1, typedef: P._FutureAction}}, [P.Iterable, 346], [H.UnmodifiableListBase, 346], [P.Map, 570, 512], [P.SetBase, 502], [P.Set, 433], [P.Iterable, 593], [P.Iterable, 561], [P.Iterator, 509], [P.HashMap, 619, 579], [P.HashSet, 432], 229, [P.Iterable, 229], [P.LinkedList, 212], 212, [P.Iterator, 212], {func: 1, args: [, {func: 1}]}, {func: 1, ret: P._HttpSessionManager}, [P.Object_ListMixin, 471], [P.List, 584], [P.MapMixin, 527, 526], [P.Map, 525, 522], [P.MapBase, 411, 325], [P._UnmodifiableMapMixin, 411, 325], [P.Map, 554, 323], [H.EfficientLengthIterable, 323], [P.Iterator, 319], [P.Map, 319, 249], 249, [P.Iterator, 249], [P.Map, 481, 479], [P.MapView, 320, 321], [P._UnmodifiableMapMixin, 320, 321], [H.EfficientLengthIterable, 626], {func: 1, ret: P.IOSink, named: {encoding: P.Encoding, mode: P.FileMode}}, {func: 1, ret: P.AsciiEncoder}, [P._DoubleLink, [P.DoubleLinkedQueueEntry, 318]], {func: 1, ret: P.AsciiDecoder}, [P.DoubleLinkedQueueEntry, 317], [P._DoubleLinkedQueueEntry, 562], [P._DoubleLinkedQueueEntry, 566], [P._DoubleLinkedQueueSentinel, 248], [P.Iterable, 248], [P.Queue, 248], [P._DoubleLinkedQueueSentinel, 214], [P._DoubleLinkedQueueEntry, 214], 214, [P.Iterator, 214], [P.List, 232], [H.ListIterable, 232], [P.Queue, 232], [P.ListQueue, 278], 278, [P.Iterator, 278], [P.Set, 511], [P.SetMixin, 508], {func: 1, ret: [P.Future, [P.List, P.int]]}, {func: 1, ret: P.Uint8List, opt: [P.int, P.int]}, 571, [P._SplayTreeNode, 574], {func: 1, ret: P.bool, args: [P.AsyncError]}, {func: 1, ret: P.int, args: [122, 122], typedef: [P.Comparator, 122]}, {func: 1, args: [P.AsyncError]}, [P._SplayTree, 122, [P._SplayTreeMapNode, 122, 247]], [P.Map, 122, 247], {func: 1, ret: P.Int8List, opt: [P.int, P.int]}, {func: 1, ret: P.String, args: [[P.List, P.int], P.Encoding]}, {func: 1, ret: P.Uint8ClampedList, opt: [P.int, P.int]}, [P.Iterator, 596], [P._SplayTree, 246, [P._SplayTreeNode, 246]], [H.EfficientLengthIterable, 246], [P.SplayTreeMap, 587, 309], [H.EfficientLengthIterable, 309], [P._SplayTreeIterator, 308, 308], [P._SplayTreeIterator, 594, 591], [P._SplayTreeIterator, 348, [P._SplayTreeNode, 348]], {func: 1, ret: [P.Future, P.String], named: {encoding: P.Encoding}}, {func: 1, ret: P.int, args: [168, 168], typedef: [P.Comparator, 168]}, [P._SplayTree_IterableMixin_SetMixin, 168], {func: 1, ret: P.bool, args: [P.Uri, P._AuthenticationScheme]}, {func: 1, ret: P.String, args: [[P.List, P.int], P.int, P.int]}, {func: 1, ret: [P.Future, [P.List, P.String]], named: {encoding: P.Encoding}}, {func: 1, ret: P.Uint16List, opt: [P.int, P.int]}, {func: 1, ret: P.Int16List, opt: [P.int, P.int]}, {func: 1, ret: P.bool, args: [P._Proxy, P._AuthenticationScheme]}, {func: 1, ret: P.Uint32List, opt: [P.int, P.int]}, {func: 1, ret: P.Base64Encoder}, {func: 1, ret: P.Base64Decoder}, {func: 1, ret: P.String, args: [P.String], opt: [P.int, P.int]}, {func: 1, ret: [P.List, P.String], named: {encoding: P.Encoding}}, {func: 1, ret: P.Int32List, opt: [P.int, P.int]}, {func: 1, ret: [P.Future, P.File], args: [[P.List, P.int]], named: {flush: P.bool, mode: P.FileMode}}, P.Base64Encoder, [P.Codec, [P.List, P.int], P.String], {func: 1, ret: P.Uint64List, opt: [P.int, P.int]}, {func: 1, ret: P.Uint8List, args: [[P.List, P.int], P.int, P.int, P.bool]}, {func: 1, ret: P.Uint8List, args: [P.String, P.int, P.int]}, {func: 1, ret: P.String, args: [P._Credentials, P._HttpClientRequest]}, {func: 1, ret: P.Int64List, opt: [P.int, P.int]}, {func: 1, v: true, args: [[P.Iterable, P.int]]}, P._Base64Decoder, [P.ChunkedConversionSink, [P.List, P.int]], {func: 1, v: true, args: [[P.List, P.int]], typedef: [P._ChunkedConversionCallback, [P.List, P.int]]}, [P.Converter, 449, 453], [P.Sink, 507], {func: 1, v: true, args: [[P.List, 202]], typedef: [P._ChunkedConversionCallback, [P.List, 202]]}, [P.List, 202], [P.ChunkedConversionSink, 202], [P.EventSink, 533], [P.Sink, 356], [P.EventSink, 356], [P.Codec, 367, 364], [P.Codec, 364, 359], [P.Codec, 367, 359], [P.Codec, 368, 369], [P.Codec, 369, 368], [P.StreamTransformer, 425, 441], [P.Converter, 205, 391], [P.Converter, 391, 203], [P.Converter, 205, 203], [P.ChunkedConverter, 205, 203, 205, 203], [P.Map, P.String, P.Encoding], [P.Codec, P.String, [P.List, P.int]], {func: 1, v: true, args: [{func: 1, v: true, args: [[P.List, P.int]]}]}, [P.Converter, P.String, P.String], [P.ChunkedConverter, P.String, P.String, P.String, P.String], {func: 1, ret: [P.StreamSubscription, P._HttpIncoming], args: [{func: 1, v: true, args: [P._HttpIncoming]}], named: {cancelOnError: P.bool, onDone: {func: 1, v: true}, onError: P.Function}}, {func: 1, ret: P.Int32x4List, opt: [P.int, P.int]}, P.JsonUnsupportedObjectError, {func: 1, v: true, args: [[P.Stream, [P.List, P.int]]]}, {func: 1, ret: [P.Future, P.String], args: [[P.Stream, [P.List, P.int]]]}, [P.Codec, P.Object, P.String], [P.Converter, P.Object, P.String], [P.ChunkedConverter, P.Object, P.String, P.Object, P.String], [P.Converter, P.Object, [P.List, P.int]], [P.ChunkedConverter, P.Object, [P.List, P.int], P.Object, [P.List, P.int]], {func: 1, ret: P._HttpDetachedIncoming}, [P.Converter, P.String, P.Object], [P.ChunkedConverter, P.String, P.Object, P.String, P.Object], {func: 1, ret: P.Float32List, opt: [P.int, P.int]}, P._JsonStringStringifier__JsonPrettyPrintMixin, {func: 1, ret: P.Float64List, opt: [P.int, P.int]}, P._JsonUtf8Stringifier__JsonPrettyPrintMixin, P._Latin1DecoderSink, [P.Converter, P.String, [P.List, P.String]], [P.ChunkedConverter, P.String, [P.List, P.String], P.String, P.String], {func: 1, ret: P.bool, args: [[P.List, P.int], [P.List, P.int]]}, P._LineSplitterSink, [P.ChunkedConversionSink, P.String], {func: 1, v: true, typedef: P._StringSinkCloseCallback}, {func: 1, v: true, opt: [P.bool]}, {func: 1, args: [P.String], named: {reviver: {func: 1, args: [,,]}}}, P.StringConversionSinkMixin, {func: 1, v: true, args: [P.String], typedef: [P._ChunkedConversionCallback, P.String]}, P._StringSinkConversionSink, {func: 1, v: true, args: [[P.List, P.int]], named: {flush: P.bool, mode: P.FileMode}}, P._Utf8Encoder_StringConversionSinkMixin, P.Utf8Codec, P.Latin1Codec, P.JsonCodec, {func: 1, ret: P._HttpSession, args: [P.String]}, P.AsciiCodec, [P.Comparable, P.DateTime], [P.Comparable, P.Duration], P.AssertionError, {func: 1, ret: P._HttpSession}, P.RangeError, P.Symbol, [P.Map, P.Symbol,,], P.UnsupportedError, {func: 1, ret: 239, args: [P.int], typedef: [P._Generator, 239]}, [H.ListIterable, 239], [P.Iterator, 539], [H.EfficientLengthIterable, 576], [P.Comparable, P.num], {func: 1, ret: P.AsyncError}, [H.EfficientLengthIterable, 442], [P.Comparable, P.String], [P.Iterable, P.int], [P.BidirectionalIterator, P.int], {func: 1, ret: P.String, args: [P.Object], named: {toEncodable: {func: 1, args: [,]}}}, {func: 1, ret: P.JsonEncoder}, {func: 1, ret: P.JsonDecoder}, {func: 1, ret: P.Float32x4List, opt: [P.int, P.int]}, {func: 1, ret: [P.ChunkedConversionSink, P.Object], args: [[P.Sink, P.String]]}, P.UriData, P._Uri, {func: 1, v: true, args: [P.AsyncError]}, P.Deprecated, {func: 1, ret: P.Link}, [P.Map, P.String, P.Metric], [P.List, P._SyncBlock], [P.List, P._AsyncBlock], {func: 1, ret: [P.Stream, P.String], args: [[P.Stream, P.Object]]}, {func: 1, ret: [P.Future, P.Link], args: [P.String], named: {recursive: P.bool}}, {func: 1, v: true, args: [P.String], named: {recursive: P.bool}}, {func: 1, ret: [P.Future, P.File], args: [P.String], named: {encoding: P.Encoding, flush: P.bool, mode: P.FileMode}}, [P.ChunkedConverter, [P.List, P.int], [P.List, P.int], [P.List, P.int], [P.List, P.int]], {func: 1, ret: [P.List, P.int], args: [P.Object]}, {func: 1, ret: [P.Future, P.Link], named: {recursive: P.bool}}, {func: 1, ret: [P.ChunkedConversionSink, P.Object], args: [[P.Sink, [P.List, P.int]]]}, P.Directory, [P.StreamController, P.FileSystemEntity], P._AsyncDirectoryListerOps, {func: 1, ret: [P.Stream, [P.List, P.int]], args: [[P.Stream, P.Object]]}, {func: 1, ret: P.Float64x2List, opt: [P.int, P.int]}, [P.List, P.FileLock], {func: 1, ret: P.ByteData, opt: [P.int, P.int]}, {func: 1, ret: P.StringConversionSink, args: [[P.Sink, P.Object]]}, {func: 1, v: true, args: [P.String], named: {encoding: P.Encoding, flush: P.bool, mode: P.FileMode}}, {func: 1, ret: P.Float32x4, args: [P.Float32x4, P.int]}, {func: 1, ret: [P.Stream, P.Object], args: [[P.Stream, P.String]]}, {func: 1, ret: P.num, args: [,,]}, [P.Future, P.RandomAccessFile], {func: 1, ret: [P.Stream, P.ProcessSignal]}, {func: 1, ret: [P.StreamSubscription, P.SecureSocket], args: [{func: 1, v: true, args: [P.SecureSocket]}], named: {cancelOnError: P.bool, onDone: {func: 1, v: true}, onError: P.Function}}, P._FileResourceInfo, P._RandomAccessFileOps, {func: 1, ret: [P.Future, P.SecureServerSocket]}, P.FileSystemEntityType, {func: 1, ret: [P.StreamSubscription, P.RawSecureSocket], args: [{func: 1, v: true, args: [P.RawSecureSocket]}], named: {cancelOnError: P.bool, onDone: {func: 1, v: true}, onError: P.Function}}, [P.Stream, P.HttpRequest], {func: 1, ret: [P.Future, P.RawSecureServerSocket]}, {func: 1, v: true, args: [P.RawSocket]}, {func: 1, ret: [P.Future, [P.List, P.int]], args: [P.int]}, {func: 1, ret: P.Latin1Encoder}, {func: 1, ret: [P.StreamSubscription, P.RawSocketEvent], args: [{func: 1, v: true, args: [P.RawSocketEvent]}], named: {cancelOnError: P.bool, onDone: {func: 1, v: true}, onError: P.Function}}, P.HttpException, {func: 1, ret: [P.Future, P.RawSecureSocket]}, P._HeaderValue, P.Cookie, {func: 1, ret: P.Latin1Decoder}, {func: 1, v: true, args: [P.int, P.Float32x4]}, {func: 1, ret: P.Stream, args: [[P.Stream, P.String]]}, {func: 1, v: true, opt: [P.RawSocket]}, {func: 1, v: true, args: [P.SocketDirection]}, P._HttpConnection, {func: 1, ret: [P.List, P.Float32x4], args: [P.int], opt: [P.int]}, {func: 1, ret: [P.List, P.int], opt: [P.int]}, P.HttpRequest, {func: 1, v: true, args: [P.RawSocketEvent]}, P._HttpClientRequest, P.HttpClientResponse, {func: 1, v: true, args: [P.int, P.Int32x4]}, {func: 1, ret: [P.List, P.Int32x4], args: [P.int], opt: [P.int]}, {func: 1, v: true, named: {requestClientCertificate: P.bool, requireClientCertificate: P.bool, useSessionCache: P.bool}}, P._IOSinkImpl, P._HttpRequest, {func: 1, ret: P.String, args: [[P.List, P.int]], named: {allowMalformed: P.bool}}, [P._HttpOutboundMessage, P.HttpResponse], {func: 1, ret: [P.Future, P._FilterStatus]}, [P.Completer, P.HttpClientResponse], {func: 1, ret: P.int, args: [[P.List, P.int], P.int, P.int]}, [P.Future, P.HttpClientResponse], [P._HttpOutboundMessage, P.HttpClientResponse], P.HttpClientRequest, {func: 1, ret: P.int, args: [{func: 1, ret: [P.List, P.int], args: [P.int]}]}, [P.Completer, P.Socket], {func: 1, ret: P.Float64x2, args: [P.int]}, P._HttpOutboundMessage, {func: 1, ret: P.Utf8Decoder}, {func: 1, ret: P.bool, args: [P.RawSocket]}, [P.Completer, P._HttpIncoming], [P.Future, P.Socket], {func: 1, ret: [P.Future, P.int], args: [[P.List, P.int]], opt: [P.int, P.int]}, P.Queue, [P.Map, P.String, P._ConnectionTarget], [P.List, P._Credentials], [P.List, P._ProxyCredentials], {func: 1, ret: P.bool, args: [P.X509Certificate, P.String, P.int], typedef: P.BadCertificateCallback}, {func: 1, ret: P.String, args: [P.bool]}, [P.Map, P.int, P._HttpConnection], P.LinkedListEntry__ServiceObject, {func: 1, ret: P.String, named: {encoding: P.Encoding, retainNewlines: P.bool}}, {func: 1, ret: P.IOSink}, [P.StreamController, P.HttpRequest], [P.Map, P.int, P._HttpServer], P.Stream__ServiceObject, P.HttpServer, [P.List, P._Proxy], {func: 1, ret: P.bool, args: [P.int, P.int]}, P.HttpConnectionInfo, {func: 1, ret: [P.Map, P.Symbol,,]}, {func: 1, ret: [P.Converter, P.String, [P.List, P.int]]}, P.HttpClientBasicCredentials, P.HttpClientDigestCredentials, P.RedirectInfo, {func: 1, v: true, opt: [[P.List, P.int], P.int]}, [P.StreamController, P._HttpIncoming], [P.Stream, P._HttpIncoming], P.HttpSession, [P.Map, P.String, P._HttpSession], P.Stopwatch, {func: 1, ret: [P.Converter, [P.List, P.int], P.String]}, [P.Map, P.int, P._FileResourceInfo], {func: 1, ret: P._CompressionMaxWindowBits, args: [P.HeaderValue]}, [P.Map, P.int, P._ProcessResourceInfo], [P.Map, P.int, P._SocketResourceInfo], [P.StreamSink, [P.List, P.int]], [P.StreamSink, 285], [P._StreamSinkImpl, [P.List, P.int]], P.Link, {func: 1, ret: P.String, args: [P.HeaderValue, P.int]}, {func: 1, v: true, args: [P.int, P.Float64x2]}, [P.List, P.ProcessStartMode], {func: 1, ret: P._CompressionMaxWindowBits, opt: [P.HeaderValue]}, P.RawSecureServerSocket, [P.Stream, P.SecureSocket], P.RawServerSocket, [P.StreamController, P.RawSecureSocket], [P.StreamSubscription, P.RawSocket], [P.Stream, P.RawSecureSocket], {func: 1, ret: P.Stream, args: [[P.Stream, [P.List, P.int]]]}, [P.Completer, P._RawSecureSocket], [P.StreamController, P.RawSocketEvent], {func: 1, ret: [P.List, P.Float64x2], args: [P.int], opt: [P.int]}, [P.StreamSubscription, P.RawSocketEvent], [P.Completer, P.RawSecureSocket], P._FilterStatus, P._SecureFilter, P.RawSecureSocket, {func: 1, v: true, args: [P.int, P.int, P.Uint8List]}, {func: 1, ret: P.int, args: [P.DateTime]}, [P.Stream, P.RawSocket], [P.Stream, P.Socket], {func: 1, ret: [P.Stream, P.WebSocket], args: [[P.Stream, P.HttpRequest]]}, {func: 1, ret: P.Int32x4, args: [P.Int32x4, P.int]}, {func: 1, ret: P.Duration, args: [P.DateTime]}, P.NetworkInterface, P._StdStream, P._StdSink, [P.LinkedListEntry, 252], {func: 1, ret: [P.Future, P.RandomAccessFile], args: [[P.List, P.int]], opt: [P.int, P.int]}, [P.StreamTransformer, P.HttpRequest, P.WebSocket], {func: 1, v: true, args: [[P.List, P.int]], opt: [P.int, P.int]}, {func: 1, ret: [P.Stream, [P.List, P.int]], args: [P.Stream]}, {func: 1, ret: P.Duration, args: [P.num]}, [P.StreamTransformer, [P.List, P.int],,], {func: 1, v: true, args: [P.int, [P.List, P.int]]}, [P.StreamController, P.WebSocket], {func: 1, args: [[P.List, P.String]], typedef: P._ProtocolSelector}, P.WebSocketTransformer, {func: 1, ret: [P.Future, P.RandomAccessFile], args: [P.String], named: {encoding: P.Encoding}}, [P.StreamTransformer,, [P.List, P.int]], P.StreamConsumer, P._WebSocketConsumer, [P.Map, P.int, P._WebSocketImpl], P.Stream__ServiceObject0, P.WebSocket, P.SystemEncoding, {func: 1, ret: P.bool, opt: [, P.StackTrace]}, P.Stdin, P.GZipCodec, P.ZLibCodec, {func: 1, ret: P.Duration, args: [P.int]}, {func: 1, ret: P.Future, args: [,]}, {func: 1, ret: P.Future, args: [P.Stream]}, [P._RectangleBase, 342], {func: 1, ret: P.int, args: [P.Duration]}, [P._RectangleBase, 254], [P.Rectangle, 254], {func: 1, ret: P.Future, opt: [P.int, P.String]}, {func: 1, ret: P.RuneIterator}, P.InstanceMirror, {func: 1, v: true, opt: [P.int]}, {func: 1, v: true, opt: [P.int, P.String]}, P.ClassMirror, P.VariableMirror, {func: 1, ret: P.num, args: [P.int]}, {func: 1, v: true, args: [P.int, P.num]}, {func: 1, ret: P.Capability, opt: [P.Capability]}, [P.List, P.Float32x4], [P.List, P.Int32x4], [P.List, P.Float64x2], {func: 1, v: true, args: [P.String], named: {encoding: P.Encoding}}, {func: 1, v: true, args: [P.SendPort], named: {response: P.Object}}, P.FormatException, {func: 1, ret: P._FutureListener}, {func: 1, v: true, named: {priority: P.int}}, {func: 1, v: true, args: [P.SendPort], named: {priority: P.int, response: P.Object}}, G.OptionType, G.Parser, R.LineParser, {func: 1, v: true, args: [P.int, P.int, [P.Iterable, P.double]], opt: [P.int]}, R.LineParser0, {func: 1, ret: null, args: [,]}, {func: 1, ret: P.bool, args: [,]}, {func: 1, ret: [P.Iterable,,], args: [,]}, {func: 1, v: true, args: [P.int,,]}, {func: 1, args: [,]}, {func: 1, ret: [P._PendingEvents,,]}, {func: 1, v: true, args: [,]}, {func: 1, v: true, args: [[P.StreamSubscription,,]]}, {func: 1, ret: P.bool, args: [,]}, {func: 1, ret: null, args: [,]}, {func: 1, ret: P.bool, args: [,,]}, {func: 1, ret: [P.EventSink,,], args: [[P.EventSink,,]]}, {func: 1, v: true, args: [, [P.EventSink,,]]}, {func: 1, v: true, args: [P.Object, P.StackTrace, [P.EventSink,,]]}, {func: 1, v: true, args: [[P.EventSink,,]]}, {func: 1, ret: [P.StreamSubscription,,], args: [[P.Stream,,], P.bool]}, {func: 1, ret: null}, {func: 1, ret: null, args: [,]}, {func: 1, ret: null, args: [,,]}, {func: 1, ret: null, args: [P.Zone, P.ZoneDelegate, P.Zone,, P.StackTrace]}, {func: 1, ret: null, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: null}]}, {func: 1, ret: null, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: null, args: [,]},,]}, {func: 1, ret: null, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: null, args: [,,]},,,]}, {func: 1, ret: {func: 1, ret: null, typedef: [P.ZoneCallback,,]}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: null}]}, {func: 1, ret: {func: 1, ret: null, args: [,], typedef: [P.ZoneUnaryCallback,,,]}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: null, args: [,]}]}, {func: 1, ret: {func: 1, ret: null, args: [,,], typedef: [P.ZoneBinaryCallback,,,,]}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: null, args: [,,]}]}, {func: 1, v: true, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, v: true}]}, {func: 1, ret: P.bool, args: [,,]}, {func: 1, ret: P.int, args: [,]}, {func: 1, ret: P.bool, args: [,]}, {func: 1, v: true, args: [,]}, {func: 1, ret: P.int, args: [,,]}, [P.StreamSubscription, 303], {func: 1, ret: P.Utf8Encoder}];
  function convertToFastObject(properties) {
    function MyClass() {
    }
    MyClass.prototype = properties;
    new MyClass();
    return properties;
  }
  function convertToSlowObject(properties) {
    properties.__MAGIC_SLOW_PROPERTY = 1;
    delete properties.__MAGIC_SLOW_PROPERTY;
    return properties;
  }
  A = convertToFastObject(A);
  B = convertToFastObject(B);
  C = convertToFastObject(C);
  D = convertToFastObject(D);
  E = convertToFastObject(E);
  F = convertToFastObject(F);
  G = convertToFastObject(G);
  H = convertToFastObject(H);
  J = convertToFastObject(J);
  K = convertToFastObject(K);
  L = convertToFastObject(L);
  M = convertToFastObject(M);
  N = convertToFastObject(N);
  O = convertToFastObject(O);
  P = convertToFastObject(P);
  Q = convertToFastObject(Q);
  R = convertToFastObject(R);
  S = convertToFastObject(S);
  T = convertToFastObject(T);
  U = convertToFastObject(U);
  V = convertToFastObject(V);
  W = convertToFastObject(W);
  X = convertToFastObject(X);
  Y = convertToFastObject(Y);
  Z = convertToFastObject(Z);
  function init() {
    Isolate.$isolateProperties = Object.create(null);
    init.allClasses = map();
    init.getTypeFromName = function(name) {
      return init.allClasses[name];
    };
    init.interceptorsByTag = map();
    init.leafTags = map();
    init.finishedClasses = map();
    Isolate.$lazy = function(fieldName, getterName, lazyValue, staticName, prototype) {
      if (!init.lazies)
        init.lazies = Object.create(null);
      init.lazies[fieldName] = getterName;
      prototype = prototype || Isolate.$isolateProperties;
      var sentinelUndefined = {};
      var sentinelInProgress = {};
      prototype[fieldName] = sentinelUndefined;
      prototype[getterName] = function() {
        var result = this[fieldName];
        if (result == sentinelInProgress)
          H.throwCyclicInit(staticName || fieldName);
        try {
          if (result === sentinelUndefined) {
            this[fieldName] = sentinelInProgress;
            try {
              result = this[fieldName] = lazyValue();
            } finally {
              if (result === sentinelUndefined)
                this[fieldName] = null;
            }
          }
          return result;
        } finally {
          this[getterName] = function() {
            return this[fieldName];
          };
        }
      };
    };
    Isolate.$finishIsolateConstructor = function(oldIsolate) {
      var isolateProperties = oldIsolate.$isolateProperties;
      function Isolate() {
        var staticNames = Object.keys(isolateProperties);
        for (var i = 0; i < staticNames.length; i++) {
          var staticName = staticNames[i];
          this[staticName] = isolateProperties[staticName];
        }
        var lazies = init.lazies;
        var lazyInitializers = lazies ? Object.keys(lazies) : [];
        for (var i = 0; i < lazyInitializers.length; i++)
          this[lazies[lazyInitializers[i]]] = null;
        function ForceEfficientMap() {
        }
        ForceEfficientMap.prototype = this;
        new ForceEfficientMap();
        for (var i = 0; i < lazyInitializers.length; i++) {
          var lazyInitName = lazies[lazyInitializers[i]];
          this[lazyInitName] = isolateProperties[lazyInitName];
        }
      }
      Isolate.prototype = oldIsolate.prototype;
      Isolate.prototype.constructor = Isolate;
      Isolate.$isolateProperties = isolateProperties;
      Isolate.makeConstantList = oldIsolate.makeConstantList;
      Isolate.functionThatReturnsNull = oldIsolate.functionThatReturnsNull;
      return Isolate;
    };
  }
  !function() {
    var intern = function(s) {
      var o = {};
      o[s] = 1;
      return Object.keys(convertToFastObject(o))[0];
    };
    init.getIsolateTag = function(name) {
      return intern("___dart_" + name + init.isolateTag);
    };
    var tableProperty = "___dart_isolate_tags_";
    var usedProperties = Object[tableProperty] || (Object[tableProperty] = Object.create(null));
    var rootProperty = "_ZxYxX";
    for (var i = 0;; i++) {
      var property = intern(rootProperty + "_" + i + "_");
      if (!(property in usedProperties)) {
        usedProperties[property] = 1;
        init.isolateTag = property;
        break;
      }
    }
    init.dispatchPropertyName = init.getIsolateTag("dispatch_record");
  }();
  // BEGIN invoke [main].
  (function(callback) {
    if (typeof document === "undefined") {
      callback(null);
      return;
    }
    if (typeof document.currentScript != 'undefined') {
      callback(document.currentScript);
      return;
    }
    var scripts = document.scripts;
    function onLoad(event) {
      for (var i = 0; i < scripts.length; ++i)
        scripts[i].removeEventListener("load", onLoad, false);
      callback(event.target);
    }
    for (var i = 0; i < scripts.length; ++i)
      scripts[i].addEventListener("load", onLoad, false);
  })(function(currentScript) {
    init.currentScript = currentScript;
    if (typeof dartMainRunner === "function")
      dartMainRunner(function(a) {
        H.startRootIsolate(F.main__main$closure(), a);
      }, []);
    else
      (function(a) {
        H.startRootIsolate(F.main__main$closure(), a);
      })([]);
  });
  // END invoke [main].
})();

//# sourceMappingURL=out.js.map
